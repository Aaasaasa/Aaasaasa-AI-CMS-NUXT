/**
 * Client
 */

import * as runtime from './runtime/library.js'
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>

/**
 * Model as_actionscheduler_actions
 *
 */
export type as_actionscheduler_actions =
  $Result.DefaultSelection<Prisma.$as_actionscheduler_actionsPayload>
/**
 * Model as_actionscheduler_claims
 *
 */
export type as_actionscheduler_claims =
  $Result.DefaultSelection<Prisma.$as_actionscheduler_claimsPayload>
/**
 * Model as_actionscheduler_groups
 *
 */
export type as_actionscheduler_groups =
  $Result.DefaultSelection<Prisma.$as_actionscheduler_groupsPayload>
/**
 * Model as_actionscheduler_logs
 *
 */
export type as_actionscheduler_logs =
  $Result.DefaultSelection<Prisma.$as_actionscheduler_logsPayload>
/**
 * Model as_awb_critical_css
 *
 */
export type as_awb_critical_css = $Result.DefaultSelection<Prisma.$as_awb_critical_cssPayload>
/**
 * Model as_cli_cookie_scan
 *
 */
export type as_cli_cookie_scan = $Result.DefaultSelection<Prisma.$as_cli_cookie_scanPayload>
/**
 * Model as_cli_cookie_scan_categories
 *
 */
export type as_cli_cookie_scan_categories =
  $Result.DefaultSelection<Prisma.$as_cli_cookie_scan_categoriesPayload>
/**
 * Model as_cli_cookie_scan_cookies
 *
 */
export type as_cli_cookie_scan_cookies =
  $Result.DefaultSelection<Prisma.$as_cli_cookie_scan_cookiesPayload>
/**
 * Model as_cli_cookie_scan_url
 *
 */
export type as_cli_cookie_scan_url = $Result.DefaultSelection<Prisma.$as_cli_cookie_scan_urlPayload>
/**
 * Model as_cli_scripts
 *
 */
export type as_cli_scripts = $Result.DefaultSelection<Prisma.$as_cli_scriptsPayload>
/**
 * Model as_commentmeta
 *
 */
export type as_commentmeta = $Result.DefaultSelection<Prisma.$as_commentmetaPayload>
/**
 * Model as_comments
 *
 */
export type as_comments = $Result.DefaultSelection<Prisma.$as_commentsPayload>
/**
 * Model as_fusion_form_entries
 *
 */
export type as_fusion_form_entries = $Result.DefaultSelection<Prisma.$as_fusion_form_entriesPayload>
/**
 * Model as_fusion_form_fields
 *
 */
export type as_fusion_form_fields = $Result.DefaultSelection<Prisma.$as_fusion_form_fieldsPayload>
/**
 * Model as_fusion_form_submissions
 *
 */
export type as_fusion_form_submissions =
  $Result.DefaultSelection<Prisma.$as_fusion_form_submissionsPayload>
/**
 * Model as_fusion_forms
 *
 */
export type as_fusion_forms = $Result.DefaultSelection<Prisma.$as_fusion_formsPayload>
/**
 * Model as_layerslider
 *
 */
export type as_layerslider = $Result.DefaultSelection<Prisma.$as_layersliderPayload>
/**
 * Model as_layerslider_revisions
 *
 */
export type as_layerslider_revisions =
  $Result.DefaultSelection<Prisma.$as_layerslider_revisionsPayload>
/**
 * Model as_links
 *
 */
export type as_links = $Result.DefaultSelection<Prisma.$as_linksPayload>
/**
 * Model as_loginizer_logs
 *
 */
export type as_loginizer_logs = $Result.DefaultSelection<Prisma.$as_loginizer_logsPayload>
/**
 * Model as_options
 *
 */
export type as_options = $Result.DefaultSelection<Prisma.$as_optionsPayload>
/**
 * Model as_postmeta
 *
 */
export type as_postmeta = $Result.DefaultSelection<Prisma.$as_postmetaPayload>
/**
 * Model as_posts
 *
 */
export type as_posts = $Result.DefaultSelection<Prisma.$as_postsPayload>
/**
 * Model as_term_relationships
 *
 */
export type as_term_relationships = $Result.DefaultSelection<Prisma.$as_term_relationshipsPayload>
/**
 * Model as_term_taxonomy
 *
 */
export type as_term_taxonomy = $Result.DefaultSelection<Prisma.$as_term_taxonomyPayload>
/**
 * Model as_termmeta
 *
 */
export type as_termmeta = $Result.DefaultSelection<Prisma.$as_termmetaPayload>
/**
 * Model as_terms
 *
 */
export type as_terms = $Result.DefaultSelection<Prisma.$as_termsPayload>
/**
 * Model as_tm_taskmeta
 *
 */
export type as_tm_taskmeta = $Result.DefaultSelection<Prisma.$as_tm_taskmetaPayload>
/**
 * Model as_tm_tasks
 *
 */
export type as_tm_tasks = $Result.DefaultSelection<Prisma.$as_tm_tasksPayload>
/**
 * Model as_usermeta
 *
 */
export type as_usermeta = $Result.DefaultSelection<Prisma.$as_usermetaPayload>
/**
 * Model as_users
 *
 */
export type as_users = $Result.DefaultSelection<Prisma.$as_usersPayload>
/**
 * Model as_wpo_404_detector
 *
 */
export type as_wpo_404_detector = $Result.DefaultSelection<Prisma.$as_wpo_404_detectorPayload>
/**
 * Model as_yoast_indexable
 *
 */
export type as_yoast_indexable = $Result.DefaultSelection<Prisma.$as_yoast_indexablePayload>
/**
 * Model as_yoast_indexable_hierarchy
 *
 */
export type as_yoast_indexable_hierarchy =
  $Result.DefaultSelection<Prisma.$as_yoast_indexable_hierarchyPayload>
/**
 * Model as_yoast_migrations
 *
 */
export type as_yoast_migrations = $Result.DefaultSelection<Prisma.$as_yoast_migrationsPayload>
/**
 * Model as_yoast_primary_term
 *
 */
export type as_yoast_primary_term = $Result.DefaultSelection<Prisma.$as_yoast_primary_termPayload>
/**
 * Model as_yoast_seo_links
 *
 */
export type as_yoast_seo_links = $Result.DefaultSelection<Prisma.$as_yoast_seo_linksPayload>
/**
 * Model as_yoast_seo_meta
 *
 */
export type as_yoast_seo_meta = $Result.DefaultSelection<Prisma.$as_yoast_seo_metaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more As_actionscheduler_actions
 * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more As_actionscheduler_actions
   * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>)
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  ): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs
      }
    >
  >

  /**
   * `prisma.as_actionscheduler_actions`: Exposes CRUD operations for the **as_actionscheduler_actions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_actionscheduler_actions
   * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findMany()
   * ```
   */
  get as_actionscheduler_actions(): Prisma.as_actionscheduler_actionsDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.as_actionscheduler_claims`: Exposes CRUD operations for the **as_actionscheduler_claims** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_actionscheduler_claims
   * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findMany()
   * ```
   */
  get as_actionscheduler_claims(): Prisma.as_actionscheduler_claimsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_actionscheduler_groups`: Exposes CRUD operations for the **as_actionscheduler_groups** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_actionscheduler_groups
   * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findMany()
   * ```
   */
  get as_actionscheduler_groups(): Prisma.as_actionscheduler_groupsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_actionscheduler_logs`: Exposes CRUD operations for the **as_actionscheduler_logs** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_actionscheduler_logs
   * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findMany()
   * ```
   */
  get as_actionscheduler_logs(): Prisma.as_actionscheduler_logsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_awb_critical_css`: Exposes CRUD operations for the **as_awb_critical_css** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_awb_critical_csses
   * const as_awb_critical_csses = await prisma.as_awb_critical_css.findMany()
   * ```
   */
  get as_awb_critical_css(): Prisma.as_awb_critical_cssDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_cli_cookie_scan`: Exposes CRUD operations for the **as_cli_cookie_scan** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_cli_cookie_scans
   * const as_cli_cookie_scans = await prisma.as_cli_cookie_scan.findMany()
   * ```
   */
  get as_cli_cookie_scan(): Prisma.as_cli_cookie_scanDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_cli_cookie_scan_categories`: Exposes CRUD operations for the **as_cli_cookie_scan_categories** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_cli_cookie_scan_categories
   * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findMany()
   * ```
   */
  get as_cli_cookie_scan_categories(): Prisma.as_cli_cookie_scan_categoriesDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.as_cli_cookie_scan_cookies`: Exposes CRUD operations for the **as_cli_cookie_scan_cookies** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_cli_cookie_scan_cookies
   * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findMany()
   * ```
   */
  get as_cli_cookie_scan_cookies(): Prisma.as_cli_cookie_scan_cookiesDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.as_cli_cookie_scan_url`: Exposes CRUD operations for the **as_cli_cookie_scan_url** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_cli_cookie_scan_urls
   * const as_cli_cookie_scan_urls = await prisma.as_cli_cookie_scan_url.findMany()
   * ```
   */
  get as_cli_cookie_scan_url(): Prisma.as_cli_cookie_scan_urlDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_cli_scripts`: Exposes CRUD operations for the **as_cli_scripts** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_cli_scripts
   * const as_cli_scripts = await prisma.as_cli_scripts.findMany()
   * ```
   */
  get as_cli_scripts(): Prisma.as_cli_scriptsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_commentmeta`: Exposes CRUD operations for the **as_commentmeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_commentmetas
   * const as_commentmetas = await prisma.as_commentmeta.findMany()
   * ```
   */
  get as_commentmeta(): Prisma.as_commentmetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_comments`: Exposes CRUD operations for the **as_comments** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_comments
   * const as_comments = await prisma.as_comments.findMany()
   * ```
   */
  get as_comments(): Prisma.as_commentsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_fusion_form_entries`: Exposes CRUD operations for the **as_fusion_form_entries** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_fusion_form_entries
   * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findMany()
   * ```
   */
  get as_fusion_form_entries(): Prisma.as_fusion_form_entriesDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_fusion_form_fields`: Exposes CRUD operations for the **as_fusion_form_fields** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_fusion_form_fields
   * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findMany()
   * ```
   */
  get as_fusion_form_fields(): Prisma.as_fusion_form_fieldsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_fusion_form_submissions`: Exposes CRUD operations for the **as_fusion_form_submissions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_fusion_form_submissions
   * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findMany()
   * ```
   */
  get as_fusion_form_submissions(): Prisma.as_fusion_form_submissionsDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.as_fusion_forms`: Exposes CRUD operations for the **as_fusion_forms** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_fusion_forms
   * const as_fusion_forms = await prisma.as_fusion_forms.findMany()
   * ```
   */
  get as_fusion_forms(): Prisma.as_fusion_formsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_layerslider`: Exposes CRUD operations for the **as_layerslider** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_layersliders
   * const as_layersliders = await prisma.as_layerslider.findMany()
   * ```
   */
  get as_layerslider(): Prisma.as_layersliderDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_layerslider_revisions`: Exposes CRUD operations for the **as_layerslider_revisions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_layerslider_revisions
   * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findMany()
   * ```
   */
  get as_layerslider_revisions(): Prisma.as_layerslider_revisionsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_links`: Exposes CRUD operations for the **as_links** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_links
   * const as_links = await prisma.as_links.findMany()
   * ```
   */
  get as_links(): Prisma.as_linksDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_loginizer_logs`: Exposes CRUD operations for the **as_loginizer_logs** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_loginizer_logs
   * const as_loginizer_logs = await prisma.as_loginizer_logs.findMany()
   * ```
   */
  get as_loginizer_logs(): Prisma.as_loginizer_logsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_options`: Exposes CRUD operations for the **as_options** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_options
   * const as_options = await prisma.as_options.findMany()
   * ```
   */
  get as_options(): Prisma.as_optionsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_postmeta`: Exposes CRUD operations for the **as_postmeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_postmetas
   * const as_postmetas = await prisma.as_postmeta.findMany()
   * ```
   */
  get as_postmeta(): Prisma.as_postmetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_posts`: Exposes CRUD operations for the **as_posts** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_posts
   * const as_posts = await prisma.as_posts.findMany()
   * ```
   */
  get as_posts(): Prisma.as_postsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_term_relationships`: Exposes CRUD operations for the **as_term_relationships** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_term_relationships
   * const as_term_relationships = await prisma.as_term_relationships.findMany()
   * ```
   */
  get as_term_relationships(): Prisma.as_term_relationshipsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_term_taxonomy`: Exposes CRUD operations for the **as_term_taxonomy** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_term_taxonomies
   * const as_term_taxonomies = await prisma.as_term_taxonomy.findMany()
   * ```
   */
  get as_term_taxonomy(): Prisma.as_term_taxonomyDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_termmeta`: Exposes CRUD operations for the **as_termmeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_termmetas
   * const as_termmetas = await prisma.as_termmeta.findMany()
   * ```
   */
  get as_termmeta(): Prisma.as_termmetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_terms`: Exposes CRUD operations for the **as_terms** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_terms
   * const as_terms = await prisma.as_terms.findMany()
   * ```
   */
  get as_terms(): Prisma.as_termsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_tm_taskmeta`: Exposes CRUD operations for the **as_tm_taskmeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_tm_taskmetas
   * const as_tm_taskmetas = await prisma.as_tm_taskmeta.findMany()
   * ```
   */
  get as_tm_taskmeta(): Prisma.as_tm_taskmetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_tm_tasks`: Exposes CRUD operations for the **as_tm_tasks** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_tm_tasks
   * const as_tm_tasks = await prisma.as_tm_tasks.findMany()
   * ```
   */
  get as_tm_tasks(): Prisma.as_tm_tasksDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_usermeta`: Exposes CRUD operations for the **as_usermeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_usermetas
   * const as_usermetas = await prisma.as_usermeta.findMany()
   * ```
   */
  get as_usermeta(): Prisma.as_usermetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_users`: Exposes CRUD operations for the **as_users** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_users
   * const as_users = await prisma.as_users.findMany()
   * ```
   */
  get as_users(): Prisma.as_usersDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_wpo_404_detector`: Exposes CRUD operations for the **as_wpo_404_detector** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_wpo_404_detectors
   * const as_wpo_404_detectors = await prisma.as_wpo_404_detector.findMany()
   * ```
   */
  get as_wpo_404_detector(): Prisma.as_wpo_404_detectorDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_yoast_indexable`: Exposes CRUD operations for the **as_yoast_indexable** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_indexables
   * const as_yoast_indexables = await prisma.as_yoast_indexable.findMany()
   * ```
   */
  get as_yoast_indexable(): Prisma.as_yoast_indexableDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_yoast_indexable_hierarchy`: Exposes CRUD operations for the **as_yoast_indexable_hierarchy** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_indexable_hierarchies
   * const as_yoast_indexable_hierarchies = await prisma.as_yoast_indexable_hierarchy.findMany()
   * ```
   */
  get as_yoast_indexable_hierarchy(): Prisma.as_yoast_indexable_hierarchyDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.as_yoast_migrations`: Exposes CRUD operations for the **as_yoast_migrations** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_migrations
   * const as_yoast_migrations = await prisma.as_yoast_migrations.findMany()
   * ```
   */
  get as_yoast_migrations(): Prisma.as_yoast_migrationsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_yoast_primary_term`: Exposes CRUD operations for the **as_yoast_primary_term** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_primary_terms
   * const as_yoast_primary_terms = await prisma.as_yoast_primary_term.findMany()
   * ```
   */
  get as_yoast_primary_term(): Prisma.as_yoast_primary_termDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_yoast_seo_links`: Exposes CRUD operations for the **as_yoast_seo_links** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_seo_links
   * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findMany()
   * ```
   */
  get as_yoast_seo_links(): Prisma.as_yoast_seo_linksDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.as_yoast_seo_meta`: Exposes CRUD operations for the **as_yoast_seo_meta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more As_yoast_seo_metas
   * const as_yoast_seo_metas = await prisma.as_yoast_seo_meta.findMany()
   * ```
   */
  get as_yoast_seo_meta(): Prisma.as_yoast_seo_metaDelegate<ExtArgs, ClientOptions>
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }

  export type Enumerable<T> = T | Array<T>

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  }

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends bigint
            ? False
            : T extends object
              ? True
              : False

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" */
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
  } & {}

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>
      }
    >
  >

  type Key = string | number | symbol
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never
  type AtStrict<O extends object, K extends Key> = O[K & keyof O]
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>
    0: AtLoose<O, K>
  }[strict]

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K]
      } & {}

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K]
  } & {}

  type _Record<K extends keyof any, T> = {
    [P in K]: T
  }

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>
  /** End Helper Types for "Merge" */

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B

  export const type: unique symbol

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never
      }
    : never

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>

  export const ModelName: {
    as_actionscheduler_actions: 'as_actionscheduler_actions'
    as_actionscheduler_claims: 'as_actionscheduler_claims'
    as_actionscheduler_groups: 'as_actionscheduler_groups'
    as_actionscheduler_logs: 'as_actionscheduler_logs'
    as_awb_critical_css: 'as_awb_critical_css'
    as_cli_cookie_scan: 'as_cli_cookie_scan'
    as_cli_cookie_scan_categories: 'as_cli_cookie_scan_categories'
    as_cli_cookie_scan_cookies: 'as_cli_cookie_scan_cookies'
    as_cli_cookie_scan_url: 'as_cli_cookie_scan_url'
    as_cli_scripts: 'as_cli_scripts'
    as_commentmeta: 'as_commentmeta'
    as_comments: 'as_comments'
    as_fusion_form_entries: 'as_fusion_form_entries'
    as_fusion_form_fields: 'as_fusion_form_fields'
    as_fusion_form_submissions: 'as_fusion_form_submissions'
    as_fusion_forms: 'as_fusion_forms'
    as_layerslider: 'as_layerslider'
    as_layerslider_revisions: 'as_layerslider_revisions'
    as_links: 'as_links'
    as_loginizer_logs: 'as_loginizer_logs'
    as_options: 'as_options'
    as_postmeta: 'as_postmeta'
    as_posts: 'as_posts'
    as_term_relationships: 'as_term_relationships'
    as_term_taxonomy: 'as_term_taxonomy'
    as_termmeta: 'as_termmeta'
    as_terms: 'as_terms'
    as_tm_taskmeta: 'as_tm_taskmeta'
    as_tm_tasks: 'as_tm_tasks'
    as_usermeta: 'as_usermeta'
    as_users: 'as_users'
    as_wpo_404_detector: 'as_wpo_404_detector'
    as_yoast_indexable: 'as_yoast_indexable'
    as_yoast_indexable_hierarchy: 'as_yoast_indexable_hierarchy'
    as_yoast_migrations: 'as_yoast_migrations'
    as_yoast_primary_term: 'as_yoast_primary_term'
    as_yoast_seo_links: 'as_yoast_seo_links'
    as_yoast_seo_meta: 'as_yoast_seo_meta'
  }

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]

  export type Datasources = {
    mysql?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps:
        | 'as_actionscheduler_actions'
        | 'as_actionscheduler_claims'
        | 'as_actionscheduler_groups'
        | 'as_actionscheduler_logs'
        | 'as_awb_critical_css'
        | 'as_cli_cookie_scan'
        | 'as_cli_cookie_scan_categories'
        | 'as_cli_cookie_scan_cookies'
        | 'as_cli_cookie_scan_url'
        | 'as_cli_scripts'
        | 'as_commentmeta'
        | 'as_comments'
        | 'as_fusion_form_entries'
        | 'as_fusion_form_fields'
        | 'as_fusion_form_submissions'
        | 'as_fusion_forms'
        | 'as_layerslider'
        | 'as_layerslider_revisions'
        | 'as_links'
        | 'as_loginizer_logs'
        | 'as_options'
        | 'as_postmeta'
        | 'as_posts'
        | 'as_term_relationships'
        | 'as_term_taxonomy'
        | 'as_termmeta'
        | 'as_terms'
        | 'as_tm_taskmeta'
        | 'as_tm_tasks'
        | 'as_usermeta'
        | 'as_users'
        | 'as_wpo_404_detector'
        | 'as_yoast_indexable'
        | 'as_yoast_indexable_hierarchy'
        | 'as_yoast_migrations'
        | 'as_yoast_primary_term'
        | 'as_yoast_seo_links'
        | 'as_yoast_seo_meta'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      as_actionscheduler_actions: {
        payload: Prisma.$as_actionscheduler_actionsPayload<ExtArgs>
        fields: Prisma.as_actionscheduler_actionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_actionscheduler_actionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_actionscheduler_actionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          findFirst: {
            args: Prisma.as_actionscheduler_actionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_actionscheduler_actionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          findMany: {
            args: Prisma.as_actionscheduler_actionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>[]
          }
          create: {
            args: Prisma.as_actionscheduler_actionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          createMany: {
            args: Prisma.as_actionscheduler_actionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_actionscheduler_actionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          update: {
            args: Prisma.as_actionscheduler_actionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          deleteMany: {
            args: Prisma.as_actionscheduler_actionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_actionscheduler_actionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_actionscheduler_actionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_actionsPayload>
          }
          aggregate: {
            args: Prisma.As_actionscheduler_actionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_actionscheduler_actions>
          }
          groupBy: {
            args: Prisma.as_actionscheduler_actionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_actionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_actionscheduler_actionsCountArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_actionsCountAggregateOutputType> | number
          }
        }
      }
      as_actionscheduler_claims: {
        payload: Prisma.$as_actionscheduler_claimsPayload<ExtArgs>
        fields: Prisma.as_actionscheduler_claimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_actionscheduler_claimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_actionscheduler_claimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          findFirst: {
            args: Prisma.as_actionscheduler_claimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_actionscheduler_claimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          findMany: {
            args: Prisma.as_actionscheduler_claimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>[]
          }
          create: {
            args: Prisma.as_actionscheduler_claimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          createMany: {
            args: Prisma.as_actionscheduler_claimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_actionscheduler_claimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          update: {
            args: Prisma.as_actionscheduler_claimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          deleteMany: {
            args: Prisma.as_actionscheduler_claimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_actionscheduler_claimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_actionscheduler_claimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_claimsPayload>
          }
          aggregate: {
            args: Prisma.As_actionscheduler_claimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_actionscheduler_claims>
          }
          groupBy: {
            args: Prisma.as_actionscheduler_claimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_claimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_actionscheduler_claimsCountArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_claimsCountAggregateOutputType> | number
          }
        }
      }
      as_actionscheduler_groups: {
        payload: Prisma.$as_actionscheduler_groupsPayload<ExtArgs>
        fields: Prisma.as_actionscheduler_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_actionscheduler_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_actionscheduler_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          findFirst: {
            args: Prisma.as_actionscheduler_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_actionscheduler_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          findMany: {
            args: Prisma.as_actionscheduler_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>[]
          }
          create: {
            args: Prisma.as_actionscheduler_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          createMany: {
            args: Prisma.as_actionscheduler_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_actionscheduler_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          update: {
            args: Prisma.as_actionscheduler_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          deleteMany: {
            args: Prisma.as_actionscheduler_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_actionscheduler_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_actionscheduler_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_groupsPayload>
          }
          aggregate: {
            args: Prisma.As_actionscheduler_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_actionscheduler_groups>
          }
          groupBy: {
            args: Prisma.as_actionscheduler_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_actionscheduler_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_groupsCountAggregateOutputType> | number
          }
        }
      }
      as_actionscheduler_logs: {
        payload: Prisma.$as_actionscheduler_logsPayload<ExtArgs>
        fields: Prisma.as_actionscheduler_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_actionscheduler_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_actionscheduler_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          findFirst: {
            args: Prisma.as_actionscheduler_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_actionscheduler_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          findMany: {
            args: Prisma.as_actionscheduler_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>[]
          }
          create: {
            args: Prisma.as_actionscheduler_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          createMany: {
            args: Prisma.as_actionscheduler_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_actionscheduler_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          update: {
            args: Prisma.as_actionscheduler_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          deleteMany: {
            args: Prisma.as_actionscheduler_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_actionscheduler_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_actionscheduler_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_actionscheduler_logsPayload>
          }
          aggregate: {
            args: Prisma.As_actionscheduler_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_actionscheduler_logs>
          }
          groupBy: {
            args: Prisma.as_actionscheduler_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_actionscheduler_logsCountArgs<ExtArgs>
            result: $Utils.Optional<As_actionscheduler_logsCountAggregateOutputType> | number
          }
        }
      }
      as_awb_critical_css: {
        payload: Prisma.$as_awb_critical_cssPayload<ExtArgs>
        fields: Prisma.as_awb_critical_cssFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_awb_critical_cssFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_awb_critical_cssFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          findFirst: {
            args: Prisma.as_awb_critical_cssFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_awb_critical_cssFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          findMany: {
            args: Prisma.as_awb_critical_cssFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>[]
          }
          create: {
            args: Prisma.as_awb_critical_cssCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          createMany: {
            args: Prisma.as_awb_critical_cssCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_awb_critical_cssDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          update: {
            args: Prisma.as_awb_critical_cssUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          deleteMany: {
            args: Prisma.as_awb_critical_cssDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_awb_critical_cssUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_awb_critical_cssUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_awb_critical_cssPayload>
          }
          aggregate: {
            args: Prisma.As_awb_critical_cssAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_awb_critical_css>
          }
          groupBy: {
            args: Prisma.as_awb_critical_cssGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_awb_critical_cssGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_awb_critical_cssCountArgs<ExtArgs>
            result: $Utils.Optional<As_awb_critical_cssCountAggregateOutputType> | number
          }
        }
      }
      as_cli_cookie_scan: {
        payload: Prisma.$as_cli_cookie_scanPayload<ExtArgs>
        fields: Prisma.as_cli_cookie_scanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_cli_cookie_scanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_cli_cookie_scanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          findFirst: {
            args: Prisma.as_cli_cookie_scanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_cli_cookie_scanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          findMany: {
            args: Prisma.as_cli_cookie_scanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>[]
          }
          create: {
            args: Prisma.as_cli_cookie_scanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          createMany: {
            args: Prisma.as_cli_cookie_scanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_cli_cookie_scanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          update: {
            args: Prisma.as_cli_cookie_scanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          deleteMany: {
            args: Prisma.as_cli_cookie_scanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_cli_cookie_scanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_cli_cookie_scanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scanPayload>
          }
          aggregate: {
            args: Prisma.As_cli_cookie_scanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_cli_cookie_scan>
          }
          groupBy: {
            args: Prisma.as_cli_cookie_scanGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scanGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_cli_cookie_scanCountArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scanCountAggregateOutputType> | number
          }
        }
      }
      as_cli_cookie_scan_categories: {
        payload: Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>
        fields: Prisma.as_cli_cookie_scan_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_cli_cookie_scan_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_cli_cookie_scan_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          findFirst: {
            args: Prisma.as_cli_cookie_scan_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_cli_cookie_scan_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          findMany: {
            args: Prisma.as_cli_cookie_scan_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>[]
          }
          create: {
            args: Prisma.as_cli_cookie_scan_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          createMany: {
            args: Prisma.as_cli_cookie_scan_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_cli_cookie_scan_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          update: {
            args: Prisma.as_cli_cookie_scan_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.as_cli_cookie_scan_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_cli_cookie_scan_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_cli_cookie_scan_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_categoriesPayload>
          }
          aggregate: {
            args: Prisma.As_cli_cookie_scan_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_cli_cookie_scan_categories>
          }
          groupBy: {
            args: Prisma.as_cli_cookie_scan_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_cli_cookie_scan_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_categoriesCountAggregateOutputType> | number
          }
        }
      }
      as_cli_cookie_scan_cookies: {
        payload: Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>
        fields: Prisma.as_cli_cookie_scan_cookiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_cli_cookie_scan_cookiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_cli_cookie_scan_cookiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          findFirst: {
            args: Prisma.as_cli_cookie_scan_cookiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_cli_cookie_scan_cookiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          findMany: {
            args: Prisma.as_cli_cookie_scan_cookiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>[]
          }
          create: {
            args: Prisma.as_cli_cookie_scan_cookiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          createMany: {
            args: Prisma.as_cli_cookie_scan_cookiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_cli_cookie_scan_cookiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          update: {
            args: Prisma.as_cli_cookie_scan_cookiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          deleteMany: {
            args: Prisma.as_cli_cookie_scan_cookiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_cli_cookie_scan_cookiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_cli_cookie_scan_cookiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_cookiesPayload>
          }
          aggregate: {
            args: Prisma.As_cli_cookie_scan_cookiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_cli_cookie_scan_cookies>
          }
          groupBy: {
            args: Prisma.as_cli_cookie_scan_cookiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_cookiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_cli_cookie_scan_cookiesCountArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_cookiesCountAggregateOutputType> | number
          }
        }
      }
      as_cli_cookie_scan_url: {
        payload: Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>
        fields: Prisma.as_cli_cookie_scan_urlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_cli_cookie_scan_urlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_cli_cookie_scan_urlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          findFirst: {
            args: Prisma.as_cli_cookie_scan_urlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_cli_cookie_scan_urlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          findMany: {
            args: Prisma.as_cli_cookie_scan_urlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>[]
          }
          create: {
            args: Prisma.as_cli_cookie_scan_urlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          createMany: {
            args: Prisma.as_cli_cookie_scan_urlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_cli_cookie_scan_urlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          update: {
            args: Prisma.as_cli_cookie_scan_urlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          deleteMany: {
            args: Prisma.as_cli_cookie_scan_urlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_cli_cookie_scan_urlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_cli_cookie_scan_urlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_cookie_scan_urlPayload>
          }
          aggregate: {
            args: Prisma.As_cli_cookie_scan_urlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_cli_cookie_scan_url>
          }
          groupBy: {
            args: Prisma.as_cli_cookie_scan_urlGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_urlGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_cli_cookie_scan_urlCountArgs<ExtArgs>
            result: $Utils.Optional<As_cli_cookie_scan_urlCountAggregateOutputType> | number
          }
        }
      }
      as_cli_scripts: {
        payload: Prisma.$as_cli_scriptsPayload<ExtArgs>
        fields: Prisma.as_cli_scriptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_cli_scriptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_cli_scriptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          findFirst: {
            args: Prisma.as_cli_scriptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_cli_scriptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          findMany: {
            args: Prisma.as_cli_scriptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>[]
          }
          create: {
            args: Prisma.as_cli_scriptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          createMany: {
            args: Prisma.as_cli_scriptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_cli_scriptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          update: {
            args: Prisma.as_cli_scriptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          deleteMany: {
            args: Prisma.as_cli_scriptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_cli_scriptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_cli_scriptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_cli_scriptsPayload>
          }
          aggregate: {
            args: Prisma.As_cli_scriptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_cli_scripts>
          }
          groupBy: {
            args: Prisma.as_cli_scriptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_cli_scriptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_cli_scriptsCountArgs<ExtArgs>
            result: $Utils.Optional<As_cli_scriptsCountAggregateOutputType> | number
          }
        }
      }
      as_commentmeta: {
        payload: Prisma.$as_commentmetaPayload<ExtArgs>
        fields: Prisma.as_commentmetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_commentmetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_commentmetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          findFirst: {
            args: Prisma.as_commentmetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_commentmetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          findMany: {
            args: Prisma.as_commentmetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>[]
          }
          create: {
            args: Prisma.as_commentmetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          createMany: {
            args: Prisma.as_commentmetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_commentmetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          update: {
            args: Prisma.as_commentmetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          deleteMany: {
            args: Prisma.as_commentmetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_commentmetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_commentmetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentmetaPayload>
          }
          aggregate: {
            args: Prisma.As_commentmetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_commentmeta>
          }
          groupBy: {
            args: Prisma.as_commentmetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_commentmetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_commentmetaCountArgs<ExtArgs>
            result: $Utils.Optional<As_commentmetaCountAggregateOutputType> | number
          }
        }
      }
      as_comments: {
        payload: Prisma.$as_commentsPayload<ExtArgs>
        fields: Prisma.as_commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          findFirst: {
            args: Prisma.as_commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          findMany: {
            args: Prisma.as_commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>[]
          }
          create: {
            args: Prisma.as_commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          createMany: {
            args: Prisma.as_commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          update: {
            args: Prisma.as_commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          deleteMany: {
            args: Prisma.as_commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_commentsPayload>
          }
          aggregate: {
            args: Prisma.As_commentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_comments>
          }
          groupBy: {
            args: Prisma.as_commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_commentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_commentsCountArgs<ExtArgs>
            result: $Utils.Optional<As_commentsCountAggregateOutputType> | number
          }
        }
      }
      as_fusion_form_entries: {
        payload: Prisma.$as_fusion_form_entriesPayload<ExtArgs>
        fields: Prisma.as_fusion_form_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_fusion_form_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_fusion_form_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          findFirst: {
            args: Prisma.as_fusion_form_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_fusion_form_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          findMany: {
            args: Prisma.as_fusion_form_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>[]
          }
          create: {
            args: Prisma.as_fusion_form_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          createMany: {
            args: Prisma.as_fusion_form_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_fusion_form_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          update: {
            args: Prisma.as_fusion_form_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          deleteMany: {
            args: Prisma.as_fusion_form_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_fusion_form_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_fusion_form_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_entriesPayload>
          }
          aggregate: {
            args: Prisma.As_fusion_form_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_fusion_form_entries>
          }
          groupBy: {
            args: Prisma.as_fusion_form_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_fusion_form_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_entriesCountAggregateOutputType> | number
          }
        }
      }
      as_fusion_form_fields: {
        payload: Prisma.$as_fusion_form_fieldsPayload<ExtArgs>
        fields: Prisma.as_fusion_form_fieldsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_fusion_form_fieldsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_fusion_form_fieldsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          findFirst: {
            args: Prisma.as_fusion_form_fieldsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_fusion_form_fieldsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          findMany: {
            args: Prisma.as_fusion_form_fieldsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>[]
          }
          create: {
            args: Prisma.as_fusion_form_fieldsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          createMany: {
            args: Prisma.as_fusion_form_fieldsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_fusion_form_fieldsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          update: {
            args: Prisma.as_fusion_form_fieldsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          deleteMany: {
            args: Prisma.as_fusion_form_fieldsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_fusion_form_fieldsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_fusion_form_fieldsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_fieldsPayload>
          }
          aggregate: {
            args: Prisma.As_fusion_form_fieldsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_fusion_form_fields>
          }
          groupBy: {
            args: Prisma.as_fusion_form_fieldsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_fieldsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_fusion_form_fieldsCountArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_fieldsCountAggregateOutputType> | number
          }
        }
      }
      as_fusion_form_submissions: {
        payload: Prisma.$as_fusion_form_submissionsPayload<ExtArgs>
        fields: Prisma.as_fusion_form_submissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_fusion_form_submissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_fusion_form_submissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          findFirst: {
            args: Prisma.as_fusion_form_submissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_fusion_form_submissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          findMany: {
            args: Prisma.as_fusion_form_submissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>[]
          }
          create: {
            args: Prisma.as_fusion_form_submissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          createMany: {
            args: Prisma.as_fusion_form_submissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_fusion_form_submissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          update: {
            args: Prisma.as_fusion_form_submissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          deleteMany: {
            args: Prisma.as_fusion_form_submissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_fusion_form_submissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_fusion_form_submissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_form_submissionsPayload>
          }
          aggregate: {
            args: Prisma.As_fusion_form_submissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_fusion_form_submissions>
          }
          groupBy: {
            args: Prisma.as_fusion_form_submissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_submissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_fusion_form_submissionsCountArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_form_submissionsCountAggregateOutputType> | number
          }
        }
      }
      as_fusion_forms: {
        payload: Prisma.$as_fusion_formsPayload<ExtArgs>
        fields: Prisma.as_fusion_formsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_fusion_formsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_fusion_formsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          findFirst: {
            args: Prisma.as_fusion_formsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_fusion_formsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          findMany: {
            args: Prisma.as_fusion_formsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>[]
          }
          create: {
            args: Prisma.as_fusion_formsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          createMany: {
            args: Prisma.as_fusion_formsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_fusion_formsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          update: {
            args: Prisma.as_fusion_formsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          deleteMany: {
            args: Prisma.as_fusion_formsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_fusion_formsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_fusion_formsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_fusion_formsPayload>
          }
          aggregate: {
            args: Prisma.As_fusion_formsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_fusion_forms>
          }
          groupBy: {
            args: Prisma.as_fusion_formsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_formsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_fusion_formsCountArgs<ExtArgs>
            result: $Utils.Optional<As_fusion_formsCountAggregateOutputType> | number
          }
        }
      }
      as_layerslider: {
        payload: Prisma.$as_layersliderPayload<ExtArgs>
        fields: Prisma.as_layersliderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_layersliderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_layersliderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          findFirst: {
            args: Prisma.as_layersliderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_layersliderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          findMany: {
            args: Prisma.as_layersliderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>[]
          }
          create: {
            args: Prisma.as_layersliderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          createMany: {
            args: Prisma.as_layersliderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_layersliderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          update: {
            args: Prisma.as_layersliderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          deleteMany: {
            args: Prisma.as_layersliderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_layersliderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_layersliderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layersliderPayload>
          }
          aggregate: {
            args: Prisma.As_layersliderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_layerslider>
          }
          groupBy: {
            args: Prisma.as_layersliderGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_layersliderGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_layersliderCountArgs<ExtArgs>
            result: $Utils.Optional<As_layersliderCountAggregateOutputType> | number
          }
        }
      }
      as_layerslider_revisions: {
        payload: Prisma.$as_layerslider_revisionsPayload<ExtArgs>
        fields: Prisma.as_layerslider_revisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_layerslider_revisionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_layerslider_revisionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          findFirst: {
            args: Prisma.as_layerslider_revisionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_layerslider_revisionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          findMany: {
            args: Prisma.as_layerslider_revisionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>[]
          }
          create: {
            args: Prisma.as_layerslider_revisionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          createMany: {
            args: Prisma.as_layerslider_revisionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_layerslider_revisionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          update: {
            args: Prisma.as_layerslider_revisionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          deleteMany: {
            args: Prisma.as_layerslider_revisionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_layerslider_revisionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_layerslider_revisionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_layerslider_revisionsPayload>
          }
          aggregate: {
            args: Prisma.As_layerslider_revisionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_layerslider_revisions>
          }
          groupBy: {
            args: Prisma.as_layerslider_revisionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_layerslider_revisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_layerslider_revisionsCountArgs<ExtArgs>
            result: $Utils.Optional<As_layerslider_revisionsCountAggregateOutputType> | number
          }
        }
      }
      as_links: {
        payload: Prisma.$as_linksPayload<ExtArgs>
        fields: Prisma.as_linksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_linksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_linksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          findFirst: {
            args: Prisma.as_linksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_linksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          findMany: {
            args: Prisma.as_linksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>[]
          }
          create: {
            args: Prisma.as_linksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          createMany: {
            args: Prisma.as_linksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_linksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          update: {
            args: Prisma.as_linksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          deleteMany: {
            args: Prisma.as_linksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_linksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_linksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_linksPayload>
          }
          aggregate: {
            args: Prisma.As_linksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_links>
          }
          groupBy: {
            args: Prisma.as_linksGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_linksGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_linksCountArgs<ExtArgs>
            result: $Utils.Optional<As_linksCountAggregateOutputType> | number
          }
        }
      }
      as_loginizer_logs: {
        payload: Prisma.$as_loginizer_logsPayload<ExtArgs>
        fields: Prisma.as_loginizer_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_loginizer_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_loginizer_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          findFirst: {
            args: Prisma.as_loginizer_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_loginizer_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          findMany: {
            args: Prisma.as_loginizer_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>[]
          }
          create: {
            args: Prisma.as_loginizer_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          createMany: {
            args: Prisma.as_loginizer_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_loginizer_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          update: {
            args: Prisma.as_loginizer_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          deleteMany: {
            args: Prisma.as_loginizer_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_loginizer_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_loginizer_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_loginizer_logsPayload>
          }
          aggregate: {
            args: Prisma.As_loginizer_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_loginizer_logs>
          }
          groupBy: {
            args: Prisma.as_loginizer_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_loginizer_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_loginizer_logsCountArgs<ExtArgs>
            result: $Utils.Optional<As_loginizer_logsCountAggregateOutputType> | number
          }
        }
      }
      as_options: {
        payload: Prisma.$as_optionsPayload<ExtArgs>
        fields: Prisma.as_optionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_optionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_optionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          findFirst: {
            args: Prisma.as_optionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_optionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          findMany: {
            args: Prisma.as_optionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>[]
          }
          create: {
            args: Prisma.as_optionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          createMany: {
            args: Prisma.as_optionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_optionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          update: {
            args: Prisma.as_optionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          deleteMany: {
            args: Prisma.as_optionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_optionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_optionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_optionsPayload>
          }
          aggregate: {
            args: Prisma.As_optionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_options>
          }
          groupBy: {
            args: Prisma.as_optionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_optionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_optionsCountArgs<ExtArgs>
            result: $Utils.Optional<As_optionsCountAggregateOutputType> | number
          }
        }
      }
      as_postmeta: {
        payload: Prisma.$as_postmetaPayload<ExtArgs>
        fields: Prisma.as_postmetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_postmetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_postmetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          findFirst: {
            args: Prisma.as_postmetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_postmetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          findMany: {
            args: Prisma.as_postmetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>[]
          }
          create: {
            args: Prisma.as_postmetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          createMany: {
            args: Prisma.as_postmetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_postmetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          update: {
            args: Prisma.as_postmetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          deleteMany: {
            args: Prisma.as_postmetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_postmetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_postmetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postmetaPayload>
          }
          aggregate: {
            args: Prisma.As_postmetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_postmeta>
          }
          groupBy: {
            args: Prisma.as_postmetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_postmetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_postmetaCountArgs<ExtArgs>
            result: $Utils.Optional<As_postmetaCountAggregateOutputType> | number
          }
        }
      }
      as_posts: {
        payload: Prisma.$as_postsPayload<ExtArgs>
        fields: Prisma.as_postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          findFirst: {
            args: Prisma.as_postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          findMany: {
            args: Prisma.as_postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>[]
          }
          create: {
            args: Prisma.as_postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          createMany: {
            args: Prisma.as_postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          update: {
            args: Prisma.as_postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          deleteMany: {
            args: Prisma.as_postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_postsPayload>
          }
          aggregate: {
            args: Prisma.As_postsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_posts>
          }
          groupBy: {
            args: Prisma.as_postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_postsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_postsCountArgs<ExtArgs>
            result: $Utils.Optional<As_postsCountAggregateOutputType> | number
          }
        }
      }
      as_term_relationships: {
        payload: Prisma.$as_term_relationshipsPayload<ExtArgs>
        fields: Prisma.as_term_relationshipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_term_relationshipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_term_relationshipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          findFirst: {
            args: Prisma.as_term_relationshipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_term_relationshipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          findMany: {
            args: Prisma.as_term_relationshipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>[]
          }
          create: {
            args: Prisma.as_term_relationshipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          createMany: {
            args: Prisma.as_term_relationshipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_term_relationshipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          update: {
            args: Prisma.as_term_relationshipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          deleteMany: {
            args: Prisma.as_term_relationshipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_term_relationshipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_term_relationshipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_relationshipsPayload>
          }
          aggregate: {
            args: Prisma.As_term_relationshipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_term_relationships>
          }
          groupBy: {
            args: Prisma.as_term_relationshipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_term_relationshipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_term_relationshipsCountArgs<ExtArgs>
            result: $Utils.Optional<As_term_relationshipsCountAggregateOutputType> | number
          }
        }
      }
      as_term_taxonomy: {
        payload: Prisma.$as_term_taxonomyPayload<ExtArgs>
        fields: Prisma.as_term_taxonomyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_term_taxonomyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_term_taxonomyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          findFirst: {
            args: Prisma.as_term_taxonomyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_term_taxonomyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          findMany: {
            args: Prisma.as_term_taxonomyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>[]
          }
          create: {
            args: Prisma.as_term_taxonomyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          createMany: {
            args: Prisma.as_term_taxonomyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_term_taxonomyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          update: {
            args: Prisma.as_term_taxonomyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          deleteMany: {
            args: Prisma.as_term_taxonomyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_term_taxonomyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_term_taxonomyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_term_taxonomyPayload>
          }
          aggregate: {
            args: Prisma.As_term_taxonomyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_term_taxonomy>
          }
          groupBy: {
            args: Prisma.as_term_taxonomyGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_term_taxonomyGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_term_taxonomyCountArgs<ExtArgs>
            result: $Utils.Optional<As_term_taxonomyCountAggregateOutputType> | number
          }
        }
      }
      as_termmeta: {
        payload: Prisma.$as_termmetaPayload<ExtArgs>
        fields: Prisma.as_termmetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_termmetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_termmetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          findFirst: {
            args: Prisma.as_termmetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_termmetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          findMany: {
            args: Prisma.as_termmetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>[]
          }
          create: {
            args: Prisma.as_termmetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          createMany: {
            args: Prisma.as_termmetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_termmetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          update: {
            args: Prisma.as_termmetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          deleteMany: {
            args: Prisma.as_termmetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_termmetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_termmetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termmetaPayload>
          }
          aggregate: {
            args: Prisma.As_termmetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_termmeta>
          }
          groupBy: {
            args: Prisma.as_termmetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_termmetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_termmetaCountArgs<ExtArgs>
            result: $Utils.Optional<As_termmetaCountAggregateOutputType> | number
          }
        }
      }
      as_terms: {
        payload: Prisma.$as_termsPayload<ExtArgs>
        fields: Prisma.as_termsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_termsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_termsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          findFirst: {
            args: Prisma.as_termsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_termsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          findMany: {
            args: Prisma.as_termsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>[]
          }
          create: {
            args: Prisma.as_termsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          createMany: {
            args: Prisma.as_termsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_termsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          update: {
            args: Prisma.as_termsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          deleteMany: {
            args: Prisma.as_termsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_termsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_termsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_termsPayload>
          }
          aggregate: {
            args: Prisma.As_termsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_terms>
          }
          groupBy: {
            args: Prisma.as_termsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_termsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_termsCountArgs<ExtArgs>
            result: $Utils.Optional<As_termsCountAggregateOutputType> | number
          }
        }
      }
      as_tm_taskmeta: {
        payload: Prisma.$as_tm_taskmetaPayload<ExtArgs>
        fields: Prisma.as_tm_taskmetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_tm_taskmetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_tm_taskmetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          findFirst: {
            args: Prisma.as_tm_taskmetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_tm_taskmetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          findMany: {
            args: Prisma.as_tm_taskmetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>[]
          }
          create: {
            args: Prisma.as_tm_taskmetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          createMany: {
            args: Prisma.as_tm_taskmetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_tm_taskmetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          update: {
            args: Prisma.as_tm_taskmetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          deleteMany: {
            args: Prisma.as_tm_taskmetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_tm_taskmetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_tm_taskmetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_taskmetaPayload>
          }
          aggregate: {
            args: Prisma.As_tm_taskmetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_tm_taskmeta>
          }
          groupBy: {
            args: Prisma.as_tm_taskmetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_tm_taskmetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_tm_taskmetaCountArgs<ExtArgs>
            result: $Utils.Optional<As_tm_taskmetaCountAggregateOutputType> | number
          }
        }
      }
      as_tm_tasks: {
        payload: Prisma.$as_tm_tasksPayload<ExtArgs>
        fields: Prisma.as_tm_tasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_tm_tasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_tm_tasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          findFirst: {
            args: Prisma.as_tm_tasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_tm_tasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          findMany: {
            args: Prisma.as_tm_tasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>[]
          }
          create: {
            args: Prisma.as_tm_tasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          createMany: {
            args: Prisma.as_tm_tasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_tm_tasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          update: {
            args: Prisma.as_tm_tasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          deleteMany: {
            args: Prisma.as_tm_tasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_tm_tasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_tm_tasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_tm_tasksPayload>
          }
          aggregate: {
            args: Prisma.As_tm_tasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_tm_tasks>
          }
          groupBy: {
            args: Prisma.as_tm_tasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_tm_tasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_tm_tasksCountArgs<ExtArgs>
            result: $Utils.Optional<As_tm_tasksCountAggregateOutputType> | number
          }
        }
      }
      as_usermeta: {
        payload: Prisma.$as_usermetaPayload<ExtArgs>
        fields: Prisma.as_usermetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_usermetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_usermetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          findFirst: {
            args: Prisma.as_usermetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_usermetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          findMany: {
            args: Prisma.as_usermetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>[]
          }
          create: {
            args: Prisma.as_usermetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          createMany: {
            args: Prisma.as_usermetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_usermetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          update: {
            args: Prisma.as_usermetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          deleteMany: {
            args: Prisma.as_usermetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_usermetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_usermetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usermetaPayload>
          }
          aggregate: {
            args: Prisma.As_usermetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_usermeta>
          }
          groupBy: {
            args: Prisma.as_usermetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_usermetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_usermetaCountArgs<ExtArgs>
            result: $Utils.Optional<As_usermetaCountAggregateOutputType> | number
          }
        }
      }
      as_users: {
        payload: Prisma.$as_usersPayload<ExtArgs>
        fields: Prisma.as_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          findFirst: {
            args: Prisma.as_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          findMany: {
            args: Prisma.as_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>[]
          }
          create: {
            args: Prisma.as_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          createMany: {
            args: Prisma.as_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          update: {
            args: Prisma.as_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          deleteMany: {
            args: Prisma.as_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_usersPayload>
          }
          aggregate: {
            args: Prisma.As_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_users>
          }
          groupBy: {
            args: Prisma.as_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_usersCountArgs<ExtArgs>
            result: $Utils.Optional<As_usersCountAggregateOutputType> | number
          }
        }
      }
      as_wpo_404_detector: {
        payload: Prisma.$as_wpo_404_detectorPayload<ExtArgs>
        fields: Prisma.as_wpo_404_detectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_wpo_404_detectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_wpo_404_detectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          findFirst: {
            args: Prisma.as_wpo_404_detectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_wpo_404_detectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          findMany: {
            args: Prisma.as_wpo_404_detectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>[]
          }
          create: {
            args: Prisma.as_wpo_404_detectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          createMany: {
            args: Prisma.as_wpo_404_detectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_wpo_404_detectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          update: {
            args: Prisma.as_wpo_404_detectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          deleteMany: {
            args: Prisma.as_wpo_404_detectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_wpo_404_detectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_wpo_404_detectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_wpo_404_detectorPayload>
          }
          aggregate: {
            args: Prisma.As_wpo_404_detectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_wpo_404_detector>
          }
          groupBy: {
            args: Prisma.as_wpo_404_detectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_wpo_404_detectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_wpo_404_detectorCountArgs<ExtArgs>
            result: $Utils.Optional<As_wpo_404_detectorCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_indexable: {
        payload: Prisma.$as_yoast_indexablePayload<ExtArgs>
        fields: Prisma.as_yoast_indexableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_indexableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_indexableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          findFirst: {
            args: Prisma.as_yoast_indexableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_indexableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          findMany: {
            args: Prisma.as_yoast_indexableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>[]
          }
          create: {
            args: Prisma.as_yoast_indexableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          createMany: {
            args: Prisma.as_yoast_indexableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_indexableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          update: {
            args: Prisma.as_yoast_indexableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_indexableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_indexableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_indexableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexablePayload>
          }
          aggregate: {
            args: Prisma.As_yoast_indexableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_indexable>
          }
          groupBy: {
            args: Prisma.as_yoast_indexableGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_indexableGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_indexableCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_indexableCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_indexable_hierarchy: {
        payload: Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>
        fields: Prisma.as_yoast_indexable_hierarchyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_indexable_hierarchyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_indexable_hierarchyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          findFirst: {
            args: Prisma.as_yoast_indexable_hierarchyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_indexable_hierarchyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          findMany: {
            args: Prisma.as_yoast_indexable_hierarchyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>[]
          }
          create: {
            args: Prisma.as_yoast_indexable_hierarchyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          createMany: {
            args: Prisma.as_yoast_indexable_hierarchyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_indexable_hierarchyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          update: {
            args: Prisma.as_yoast_indexable_hierarchyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_indexable_hierarchyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_indexable_hierarchyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_indexable_hierarchyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_indexable_hierarchyPayload>
          }
          aggregate: {
            args: Prisma.As_yoast_indexable_hierarchyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_indexable_hierarchy>
          }
          groupBy: {
            args: Prisma.as_yoast_indexable_hierarchyGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_indexable_hierarchyGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_indexable_hierarchyCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_indexable_hierarchyCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_migrations: {
        payload: Prisma.$as_yoast_migrationsPayload<ExtArgs>
        fields: Prisma.as_yoast_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          findFirst: {
            args: Prisma.as_yoast_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          findMany: {
            args: Prisma.as_yoast_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>[]
          }
          create: {
            args: Prisma.as_yoast_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          createMany: {
            args: Prisma.as_yoast_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          update: {
            args: Prisma.as_yoast_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_migrationsPayload>
          }
          aggregate: {
            args: Prisma.As_yoast_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_migrations>
          }
          groupBy: {
            args: Prisma.as_yoast_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_migrationsCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_primary_term: {
        payload: Prisma.$as_yoast_primary_termPayload<ExtArgs>
        fields: Prisma.as_yoast_primary_termFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_primary_termFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_primary_termFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          findFirst: {
            args: Prisma.as_yoast_primary_termFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_primary_termFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          findMany: {
            args: Prisma.as_yoast_primary_termFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>[]
          }
          create: {
            args: Prisma.as_yoast_primary_termCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          createMany: {
            args: Prisma.as_yoast_primary_termCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_primary_termDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          update: {
            args: Prisma.as_yoast_primary_termUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_primary_termDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_primary_termUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_primary_termUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_primary_termPayload>
          }
          aggregate: {
            args: Prisma.As_yoast_primary_termAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_primary_term>
          }
          groupBy: {
            args: Prisma.as_yoast_primary_termGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_primary_termGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_primary_termCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_primary_termCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_seo_links: {
        payload: Prisma.$as_yoast_seo_linksPayload<ExtArgs>
        fields: Prisma.as_yoast_seo_linksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_seo_linksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_seo_linksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          findFirst: {
            args: Prisma.as_yoast_seo_linksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_seo_linksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          findMany: {
            args: Prisma.as_yoast_seo_linksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>[]
          }
          create: {
            args: Prisma.as_yoast_seo_linksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          createMany: {
            args: Prisma.as_yoast_seo_linksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_seo_linksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          update: {
            args: Prisma.as_yoast_seo_linksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_seo_linksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_seo_linksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_seo_linksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_linksPayload>
          }
          aggregate: {
            args: Prisma.As_yoast_seo_linksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_seo_links>
          }
          groupBy: {
            args: Prisma.as_yoast_seo_linksGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_seo_linksGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_seo_linksCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_seo_linksCountAggregateOutputType> | number
          }
        }
      }
      as_yoast_seo_meta: {
        payload: Prisma.$as_yoast_seo_metaPayload<ExtArgs>
        fields: Prisma.as_yoast_seo_metaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.as_yoast_seo_metaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.as_yoast_seo_metaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          findFirst: {
            args: Prisma.as_yoast_seo_metaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.as_yoast_seo_metaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          findMany: {
            args: Prisma.as_yoast_seo_metaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>[]
          }
          create: {
            args: Prisma.as_yoast_seo_metaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          createMany: {
            args: Prisma.as_yoast_seo_metaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.as_yoast_seo_metaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          update: {
            args: Prisma.as_yoast_seo_metaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          deleteMany: {
            args: Prisma.as_yoast_seo_metaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.as_yoast_seo_metaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.as_yoast_seo_metaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$as_yoast_seo_metaPayload>
          }
          aggregate: {
            args: Prisma.As_yoast_seo_metaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAs_yoast_seo_meta>
          }
          groupBy: {
            args: Prisma.as_yoast_seo_metaGroupByArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_seo_metaGroupByOutputType>[]
          }
          count: {
            args: Prisma.as_yoast_seo_metaCountArgs<ExtArgs>
            result: $Utils.Optional<As_yoast_seo_metaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    as_actionscheduler_actions?: as_actionscheduler_actionsOmit
    as_actionscheduler_claims?: as_actionscheduler_claimsOmit
    as_actionscheduler_groups?: as_actionscheduler_groupsOmit
    as_actionscheduler_logs?: as_actionscheduler_logsOmit
    as_awb_critical_css?: as_awb_critical_cssOmit
    as_cli_cookie_scan?: as_cli_cookie_scanOmit
    as_cli_cookie_scan_categories?: as_cli_cookie_scan_categoriesOmit
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesOmit
    as_cli_cookie_scan_url?: as_cli_cookie_scan_urlOmit
    as_cli_scripts?: as_cli_scriptsOmit
    as_commentmeta?: as_commentmetaOmit
    as_comments?: as_commentsOmit
    as_fusion_form_entries?: as_fusion_form_entriesOmit
    as_fusion_form_fields?: as_fusion_form_fieldsOmit
    as_fusion_form_submissions?: as_fusion_form_submissionsOmit
    as_fusion_forms?: as_fusion_formsOmit
    as_layerslider?: as_layersliderOmit
    as_layerslider_revisions?: as_layerslider_revisionsOmit
    as_links?: as_linksOmit
    as_loginizer_logs?: as_loginizer_logsOmit
    as_options?: as_optionsOmit
    as_postmeta?: as_postmetaOmit
    as_posts?: as_postsOmit
    as_term_relationships?: as_term_relationshipsOmit
    as_term_taxonomy?: as_term_taxonomyOmit
    as_termmeta?: as_termmetaOmit
    as_terms?: as_termsOmit
    as_tm_taskmeta?: as_tm_taskmetaOmit
    as_tm_tasks?: as_tm_tasksOmit
    as_usermeta?: as_usermetaOmit
    as_users?: as_usersOmit
    as_wpo_404_detector?: as_wpo_404_detectorOmit
    as_yoast_indexable?: as_yoast_indexableOmit
    as_yoast_indexable_hierarchy?: as_yoast_indexable_hierarchyOmit
    as_yoast_migrations?: as_yoast_migrationsOmit
    as_yoast_primary_term?: as_yoast_primary_termOmit
    as_yoast_seo_links?: as_yoast_seo_linksOmit
    as_yoast_seo_meta?: as_yoast_seo_metaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */

  /**
   * Count Type As_cli_cookie_scan_categoriesCountOutputType
   */

  export type As_cli_cookie_scan_categoriesCountOutputType = {
    as_cli_cookie_scan_cookies: number
  }

  export type As_cli_cookie_scan_categoriesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    as_cli_cookie_scan_cookies?:
      | boolean
      | As_cli_cookie_scan_categoriesCountOutputTypeCountAs_cli_cookie_scan_cookiesArgs
  }

  // Custom InputTypes
  /**
   * As_cli_cookie_scan_categoriesCountOutputType without action
   */
  export type As_cli_cookie_scan_categoriesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the As_cli_cookie_scan_categoriesCountOutputType
     */
    select?: As_cli_cookie_scan_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * As_cli_cookie_scan_categoriesCountOutputType without action
   */
  export type As_cli_cookie_scan_categoriesCountOutputTypeCountAs_cli_cookie_scan_cookiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_cookie_scan_cookiesWhereInput
  }

  /**
   * Models
   */

  /**
   * Model as_actionscheduler_actions
   */

  export type AggregateAs_actionscheduler_actions = {
    _count: As_actionscheduler_actionsCountAggregateOutputType | null
    _avg: As_actionscheduler_actionsAvgAggregateOutputType | null
    _sum: As_actionscheduler_actionsSumAggregateOutputType | null
    _min: As_actionscheduler_actionsMinAggregateOutputType | null
    _max: As_actionscheduler_actionsMaxAggregateOutputType | null
  }

  export type As_actionscheduler_actionsAvgAggregateOutputType = {
    action_id: number | null
    group_id: number | null
    attempts: number | null
    claim_id: number | null
    priority: number | null
  }

  export type As_actionscheduler_actionsSumAggregateOutputType = {
    action_id: bigint | null
    group_id: bigint | null
    attempts: number | null
    claim_id: bigint | null
    priority: number | null
  }

  export type As_actionscheduler_actionsMinAggregateOutputType = {
    action_id: bigint | null
    hook: string | null
    status: string | null
    scheduled_date_gmt: Date | null
    scheduled_date_local: Date | null
    args: string | null
    schedule: string | null
    group_id: bigint | null
    attempts: number | null
    last_attempt_gmt: Date | null
    last_attempt_local: Date | null
    claim_id: bigint | null
    extended_args: string | null
    priority: number | null
  }

  export type As_actionscheduler_actionsMaxAggregateOutputType = {
    action_id: bigint | null
    hook: string | null
    status: string | null
    scheduled_date_gmt: Date | null
    scheduled_date_local: Date | null
    args: string | null
    schedule: string | null
    group_id: bigint | null
    attempts: number | null
    last_attempt_gmt: Date | null
    last_attempt_local: Date | null
    claim_id: bigint | null
    extended_args: string | null
    priority: number | null
  }

  export type As_actionscheduler_actionsCountAggregateOutputType = {
    action_id: number
    hook: number
    status: number
    scheduled_date_gmt: number
    scheduled_date_local: number
    args: number
    schedule: number
    group_id: number
    attempts: number
    last_attempt_gmt: number
    last_attempt_local: number
    claim_id: number
    extended_args: number
    priority: number
    _all: number
  }

  export type As_actionscheduler_actionsAvgAggregateInputType = {
    action_id?: true
    group_id?: true
    attempts?: true
    claim_id?: true
    priority?: true
  }

  export type As_actionscheduler_actionsSumAggregateInputType = {
    action_id?: true
    group_id?: true
    attempts?: true
    claim_id?: true
    priority?: true
  }

  export type As_actionscheduler_actionsMinAggregateInputType = {
    action_id?: true
    hook?: true
    status?: true
    scheduled_date_gmt?: true
    scheduled_date_local?: true
    args?: true
    schedule?: true
    group_id?: true
    attempts?: true
    last_attempt_gmt?: true
    last_attempt_local?: true
    claim_id?: true
    extended_args?: true
    priority?: true
  }

  export type As_actionscheduler_actionsMaxAggregateInputType = {
    action_id?: true
    hook?: true
    status?: true
    scheduled_date_gmt?: true
    scheduled_date_local?: true
    args?: true
    schedule?: true
    group_id?: true
    attempts?: true
    last_attempt_gmt?: true
    last_attempt_local?: true
    claim_id?: true
    extended_args?: true
    priority?: true
  }

  export type As_actionscheduler_actionsCountAggregateInputType = {
    action_id?: true
    hook?: true
    status?: true
    scheduled_date_gmt?: true
    scheduled_date_local?: true
    args?: true
    schedule?: true
    group_id?: true
    attempts?: true
    last_attempt_gmt?: true
    last_attempt_local?: true
    claim_id?: true
    extended_args?: true
    priority?: true
    _all?: true
  }

  export type As_actionscheduler_actionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_actions to aggregate.
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_actions to fetch.
     */
    orderBy?:
      | as_actionscheduler_actionsOrderByWithRelationInput
      | as_actionscheduler_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_actionscheduler_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_actionscheduler_actions
     */
    _count?: true | As_actionscheduler_actionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_actionscheduler_actionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_actionscheduler_actionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_actionscheduler_actionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_actionscheduler_actionsMaxAggregateInputType
  }

  export type GetAs_actionscheduler_actionsAggregateType<
    T extends As_actionscheduler_actionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_actionscheduler_actions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_actionscheduler_actions[P]>
      : GetScalarType<T[P], AggregateAs_actionscheduler_actions[P]>
  }

  export type as_actionscheduler_actionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_actionscheduler_actionsWhereInput
    orderBy?:
      | as_actionscheduler_actionsOrderByWithAggregationInput
      | as_actionscheduler_actionsOrderByWithAggregationInput[]
    by: As_actionscheduler_actionsScalarFieldEnum[] | As_actionscheduler_actionsScalarFieldEnum
    having?: as_actionscheduler_actionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_actionscheduler_actionsCountAggregateInputType | true
    _avg?: As_actionscheduler_actionsAvgAggregateInputType
    _sum?: As_actionscheduler_actionsSumAggregateInputType
    _min?: As_actionscheduler_actionsMinAggregateInputType
    _max?: As_actionscheduler_actionsMaxAggregateInputType
  }

  export type As_actionscheduler_actionsGroupByOutputType = {
    action_id: bigint
    hook: string
    status: string
    scheduled_date_gmt: Date | null
    scheduled_date_local: Date | null
    args: string | null
    schedule: string | null
    group_id: bigint
    attempts: number
    last_attempt_gmt: Date | null
    last_attempt_local: Date | null
    claim_id: bigint
    extended_args: string | null
    priority: number
    _count: As_actionscheduler_actionsCountAggregateOutputType | null
    _avg: As_actionscheduler_actionsAvgAggregateOutputType | null
    _sum: As_actionscheduler_actionsSumAggregateOutputType | null
    _min: As_actionscheduler_actionsMinAggregateOutputType | null
    _max: As_actionscheduler_actionsMaxAggregateOutputType | null
  }

  type GetAs_actionscheduler_actionsGroupByPayload<
    T extends as_actionscheduler_actionsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_actionscheduler_actionsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_actionscheduler_actionsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_actionscheduler_actionsGroupByOutputType[P]>
          : GetScalarType<T[P], As_actionscheduler_actionsGroupByOutputType[P]>
      }
    >
  >

  export type as_actionscheduler_actionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      action_id?: boolean
      hook?: boolean
      status?: boolean
      scheduled_date_gmt?: boolean
      scheduled_date_local?: boolean
      args?: boolean
      schedule?: boolean
      group_id?: boolean
      attempts?: boolean
      last_attempt_gmt?: boolean
      last_attempt_local?: boolean
      claim_id?: boolean
      extended_args?: boolean
      priority?: boolean
    },
    ExtArgs['result']['as_actionscheduler_actions']
  >

  export type as_actionscheduler_actionsSelectScalar = {
    action_id?: boolean
    hook?: boolean
    status?: boolean
    scheduled_date_gmt?: boolean
    scheduled_date_local?: boolean
    args?: boolean
    schedule?: boolean
    group_id?: boolean
    attempts?: boolean
    last_attempt_gmt?: boolean
    last_attempt_local?: boolean
    claim_id?: boolean
    extended_args?: boolean
    priority?: boolean
  }

  export type as_actionscheduler_actionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'action_id'
    | 'hook'
    | 'status'
    | 'scheduled_date_gmt'
    | 'scheduled_date_local'
    | 'args'
    | 'schedule'
    | 'group_id'
    | 'attempts'
    | 'last_attempt_gmt'
    | 'last_attempt_local'
    | 'claim_id'
    | 'extended_args'
    | 'priority',
    ExtArgs['result']['as_actionscheduler_actions']
  >

  export type $as_actionscheduler_actionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_actionscheduler_actions'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        action_id: bigint
        hook: string
        status: string
        scheduled_date_gmt: Date | null
        scheduled_date_local: Date | null
        args: string | null
        schedule: string | null
        group_id: bigint
        attempts: number
        last_attempt_gmt: Date | null
        last_attempt_local: Date | null
        claim_id: bigint
        extended_args: string | null
        priority: number
      },
      ExtArgs['result']['as_actionscheduler_actions']
    >
    composites: {}
  }

  type as_actionscheduler_actionsGetPayload<
    S extends boolean | null | undefined | as_actionscheduler_actionsDefaultArgs
  > = $Result.GetResult<Prisma.$as_actionscheduler_actionsPayload, S>

  type as_actionscheduler_actionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_actionscheduler_actionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_actionscheduler_actionsCountAggregateInputType | true
  }

  export interface as_actionscheduler_actionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_actionscheduler_actions']
      meta: { name: 'as_actionscheduler_actions' }
    }
    /**
     * Find zero or one As_actionscheduler_actions that matches the filter.
     * @param {as_actionscheduler_actionsFindUniqueArgs} args - Arguments to find a As_actionscheduler_actions
     * @example
     * // Get one As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_actionscheduler_actionsFindUniqueArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_actionscheduler_actions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_actionscheduler_actionsFindUniqueOrThrowArgs} args - Arguments to find a As_actionscheduler_actions
     * @example
     * // Get one As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_actionscheduler_actionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsFindFirstArgs} args - Arguments to find a As_actionscheduler_actions
     * @example
     * // Get one As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_actionscheduler_actionsFindFirstArgs>(
      args?: SelectSubset<T, as_actionscheduler_actionsFindFirstArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_actions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsFindFirstOrThrowArgs} args - Arguments to find a As_actionscheduler_actions
     * @example
     * // Get one As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_actionscheduler_actionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_actionscheduler_actionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_actionscheduler_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findMany()
     *
     * // Get first 10 As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.findMany({ take: 10 })
     *
     * // Only select the `action_id`
     * const as_actionscheduler_actionsWithAction_idOnly = await prisma.as_actionscheduler_actions.findMany({ select: { action_id: true } })
     *
     */
    findMany<T extends as_actionscheduler_actionsFindManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_actionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsCreateArgs} args - Arguments to create a As_actionscheduler_actions.
     * @example
     * // Create one As_actionscheduler_actions
     * const As_actionscheduler_actions = await prisma.as_actionscheduler_actions.create({
     *   data: {
     *     // ... data to create a As_actionscheduler_actions
     *   }
     * })
     *
     */
    create<T extends as_actionscheduler_actionsCreateArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsCreateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsCreateManyArgs} args - Arguments to create many As_actionscheduler_actions.
     * @example
     * // Create many As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_actionscheduler_actionsCreateManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_actionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsDeleteArgs} args - Arguments to delete one As_actionscheduler_actions.
     * @example
     * // Delete one As_actionscheduler_actions
     * const As_actionscheduler_actions = await prisma.as_actionscheduler_actions.delete({
     *   where: {
     *     // ... filter to delete one As_actionscheduler_actions
     *   }
     * })
     *
     */
    delete<T extends as_actionscheduler_actionsDeleteArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsDeleteArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsUpdateArgs} args - Arguments to update one As_actionscheduler_actions.
     * @example
     * // Update one As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_actionscheduler_actionsUpdateArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsUpdateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsDeleteManyArgs} args - Arguments to filter As_actionscheduler_actions to delete.
     * @example
     * // Delete a few As_actionscheduler_actions
     * const { count } = await prisma.as_actionscheduler_actions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_actionscheduler_actionsDeleteManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_actionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_actionscheduler_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_actionscheduler_actionsUpdateManyArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_actionscheduler_actions.
     * @param {as_actionscheduler_actionsUpsertArgs} args - Arguments to update or create a As_actionscheduler_actions.
     * @example
     * // Update or create a As_actionscheduler_actions
     * const as_actionscheduler_actions = await prisma.as_actionscheduler_actions.upsert({
     *   create: {
     *     // ... data to create a As_actionscheduler_actions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_actionscheduler_actions we want to update
     *   }
     * })
     */
    upsert<T extends as_actionscheduler_actionsUpsertArgs>(
      args: SelectSubset<T, as_actionscheduler_actionsUpsertArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_actionsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_actionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_actionscheduler_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsCountArgs} args - Arguments to filter As_actionscheduler_actions to count.
     * @example
     * // Count the number of As_actionscheduler_actions
     * const count = await prisma.as_actionscheduler_actions.count({
     *   where: {
     *     // ... the filter for the As_actionscheduler_actions we want to count
     *   }
     * })
     */
    count<T extends as_actionscheduler_actionsCountArgs>(
      args?: Subset<T, as_actionscheduler_actionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_actionscheduler_actionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_actionscheduler_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_actionscheduler_actionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_actionscheduler_actionsAggregateArgs>(
      args: Subset<T, As_actionscheduler_actionsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_actionscheduler_actionsAggregateType<T>>

    /**
     * Group by As_actionscheduler_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_actionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_actionscheduler_actionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_actionscheduler_actionsGroupByArgs['orderBy'] }
        : { orderBy?: as_actionscheduler_actionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_actionscheduler_actionsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_actionscheduler_actionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_actionscheduler_actions model
     */
    readonly fields: as_actionscheduler_actionsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_actionscheduler_actions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_actionscheduler_actionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_actionscheduler_actions model
   */
  interface as_actionscheduler_actionsFieldRefs {
    readonly action_id: FieldRef<'as_actionscheduler_actions', 'BigInt'>
    readonly hook: FieldRef<'as_actionscheduler_actions', 'String'>
    readonly status: FieldRef<'as_actionscheduler_actions', 'String'>
    readonly scheduled_date_gmt: FieldRef<'as_actionscheduler_actions', 'DateTime'>
    readonly scheduled_date_local: FieldRef<'as_actionscheduler_actions', 'DateTime'>
    readonly args: FieldRef<'as_actionscheduler_actions', 'String'>
    readonly schedule: FieldRef<'as_actionscheduler_actions', 'String'>
    readonly group_id: FieldRef<'as_actionscheduler_actions', 'BigInt'>
    readonly attempts: FieldRef<'as_actionscheduler_actions', 'Int'>
    readonly last_attempt_gmt: FieldRef<'as_actionscheduler_actions', 'DateTime'>
    readonly last_attempt_local: FieldRef<'as_actionscheduler_actions', 'DateTime'>
    readonly claim_id: FieldRef<'as_actionscheduler_actions', 'BigInt'>
    readonly extended_args: FieldRef<'as_actionscheduler_actions', 'String'>
    readonly priority: FieldRef<'as_actionscheduler_actions', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_actionscheduler_actions findUnique
   */
  export type as_actionscheduler_actionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_actions to fetch.
     */
    where: as_actionscheduler_actionsWhereUniqueInput
  }

  /**
   * as_actionscheduler_actions findUniqueOrThrow
   */
  export type as_actionscheduler_actionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_actions to fetch.
     */
    where: as_actionscheduler_actionsWhereUniqueInput
  }

  /**
   * as_actionscheduler_actions findFirst
   */
  export type as_actionscheduler_actionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_actions to fetch.
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_actions to fetch.
     */
    orderBy?:
      | as_actionscheduler_actionsOrderByWithRelationInput
      | as_actionscheduler_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_actions.
     */
    cursor?: as_actionscheduler_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_actions.
     */
    distinct?:
      | As_actionscheduler_actionsScalarFieldEnum
      | As_actionscheduler_actionsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_actions findFirstOrThrow
   */
  export type as_actionscheduler_actionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_actions to fetch.
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_actions to fetch.
     */
    orderBy?:
      | as_actionscheduler_actionsOrderByWithRelationInput
      | as_actionscheduler_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_actions.
     */
    cursor?: as_actionscheduler_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_actions.
     */
    distinct?:
      | As_actionscheduler_actionsScalarFieldEnum
      | As_actionscheduler_actionsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_actions findMany
   */
  export type as_actionscheduler_actionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_actions to fetch.
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_actions to fetch.
     */
    orderBy?:
      | as_actionscheduler_actionsOrderByWithRelationInput
      | as_actionscheduler_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_actionscheduler_actions.
     */
    cursor?: as_actionscheduler_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_actions.
     */
    skip?: number
    distinct?:
      | As_actionscheduler_actionsScalarFieldEnum
      | As_actionscheduler_actionsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_actions create
   */
  export type as_actionscheduler_actionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_actionscheduler_actions.
     */
    data: XOR<as_actionscheduler_actionsCreateInput, as_actionscheduler_actionsUncheckedCreateInput>
  }

  /**
   * as_actionscheduler_actions createMany
   */
  export type as_actionscheduler_actionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_actionscheduler_actions.
     */
    data: as_actionscheduler_actionsCreateManyInput | as_actionscheduler_actionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_actionscheduler_actions update
   */
  export type as_actionscheduler_actionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_actionscheduler_actions.
     */
    data: XOR<as_actionscheduler_actionsUpdateInput, as_actionscheduler_actionsUncheckedUpdateInput>
    /**
     * Choose, which as_actionscheduler_actions to update.
     */
    where: as_actionscheduler_actionsWhereUniqueInput
  }

  /**
   * as_actionscheduler_actions updateMany
   */
  export type as_actionscheduler_actionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_actionscheduler_actions.
     */
    data: XOR<
      as_actionscheduler_actionsUpdateManyMutationInput,
      as_actionscheduler_actionsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_actionscheduler_actions to update
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * Limit how many as_actionscheduler_actions to update.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_actions upsert
   */
  export type as_actionscheduler_actionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_actionscheduler_actions to update in case it exists.
     */
    where: as_actionscheduler_actionsWhereUniqueInput
    /**
     * In case the as_actionscheduler_actions found by the `where` argument doesn't exist, create a new as_actionscheduler_actions with this data.
     */
    create: XOR<
      as_actionscheduler_actionsCreateInput,
      as_actionscheduler_actionsUncheckedCreateInput
    >
    /**
     * In case the as_actionscheduler_actions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      as_actionscheduler_actionsUpdateInput,
      as_actionscheduler_actionsUncheckedUpdateInput
    >
  }

  /**
   * as_actionscheduler_actions delete
   */
  export type as_actionscheduler_actionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
    /**
     * Filter which as_actionscheduler_actions to delete.
     */
    where: as_actionscheduler_actionsWhereUniqueInput
  }

  /**
   * as_actionscheduler_actions deleteMany
   */
  export type as_actionscheduler_actionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_actions to delete
     */
    where?: as_actionscheduler_actionsWhereInput
    /**
     * Limit how many as_actionscheduler_actions to delete.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_actions without action
   */
  export type as_actionscheduler_actionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_actions
     */
    select?: as_actionscheduler_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_actions
     */
    omit?: as_actionscheduler_actionsOmit<ExtArgs> | null
  }

  /**
   * Model as_actionscheduler_claims
   */

  export type AggregateAs_actionscheduler_claims = {
    _count: As_actionscheduler_claimsCountAggregateOutputType | null
    _avg: As_actionscheduler_claimsAvgAggregateOutputType | null
    _sum: As_actionscheduler_claimsSumAggregateOutputType | null
    _min: As_actionscheduler_claimsMinAggregateOutputType | null
    _max: As_actionscheduler_claimsMaxAggregateOutputType | null
  }

  export type As_actionscheduler_claimsAvgAggregateOutputType = {
    claim_id: number | null
  }

  export type As_actionscheduler_claimsSumAggregateOutputType = {
    claim_id: bigint | null
  }

  export type As_actionscheduler_claimsMinAggregateOutputType = {
    claim_id: bigint | null
    date_created_gmt: Date | null
  }

  export type As_actionscheduler_claimsMaxAggregateOutputType = {
    claim_id: bigint | null
    date_created_gmt: Date | null
  }

  export type As_actionscheduler_claimsCountAggregateOutputType = {
    claim_id: number
    date_created_gmt: number
    _all: number
  }

  export type As_actionscheduler_claimsAvgAggregateInputType = {
    claim_id?: true
  }

  export type As_actionscheduler_claimsSumAggregateInputType = {
    claim_id?: true
  }

  export type As_actionscheduler_claimsMinAggregateInputType = {
    claim_id?: true
    date_created_gmt?: true
  }

  export type As_actionscheduler_claimsMaxAggregateInputType = {
    claim_id?: true
    date_created_gmt?: true
  }

  export type As_actionscheduler_claimsCountAggregateInputType = {
    claim_id?: true
    date_created_gmt?: true
    _all?: true
  }

  export type As_actionscheduler_claimsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_claims to aggregate.
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_claims to fetch.
     */
    orderBy?:
      | as_actionscheduler_claimsOrderByWithRelationInput
      | as_actionscheduler_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_actionscheduler_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_actionscheduler_claims
     */
    _count?: true | As_actionscheduler_claimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_actionscheduler_claimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_actionscheduler_claimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_actionscheduler_claimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_actionscheduler_claimsMaxAggregateInputType
  }

  export type GetAs_actionscheduler_claimsAggregateType<
    T extends As_actionscheduler_claimsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_actionscheduler_claims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_actionscheduler_claims[P]>
      : GetScalarType<T[P], AggregateAs_actionscheduler_claims[P]>
  }

  export type as_actionscheduler_claimsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_actionscheduler_claimsWhereInput
    orderBy?:
      | as_actionscheduler_claimsOrderByWithAggregationInput
      | as_actionscheduler_claimsOrderByWithAggregationInput[]
    by: As_actionscheduler_claimsScalarFieldEnum[] | As_actionscheduler_claimsScalarFieldEnum
    having?: as_actionscheduler_claimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_actionscheduler_claimsCountAggregateInputType | true
    _avg?: As_actionscheduler_claimsAvgAggregateInputType
    _sum?: As_actionscheduler_claimsSumAggregateInputType
    _min?: As_actionscheduler_claimsMinAggregateInputType
    _max?: As_actionscheduler_claimsMaxAggregateInputType
  }

  export type As_actionscheduler_claimsGroupByOutputType = {
    claim_id: bigint
    date_created_gmt: Date | null
    _count: As_actionscheduler_claimsCountAggregateOutputType | null
    _avg: As_actionscheduler_claimsAvgAggregateOutputType | null
    _sum: As_actionscheduler_claimsSumAggregateOutputType | null
    _min: As_actionscheduler_claimsMinAggregateOutputType | null
    _max: As_actionscheduler_claimsMaxAggregateOutputType | null
  }

  type GetAs_actionscheduler_claimsGroupByPayload<T extends as_actionscheduler_claimsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_actionscheduler_claimsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_actionscheduler_claimsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_actionscheduler_claimsGroupByOutputType[P]>
            : GetScalarType<T[P], As_actionscheduler_claimsGroupByOutputType[P]>
        }
      >
    >

  export type as_actionscheduler_claimsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      claim_id?: boolean
      date_created_gmt?: boolean
    },
    ExtArgs['result']['as_actionscheduler_claims']
  >

  export type as_actionscheduler_claimsSelectScalar = {
    claim_id?: boolean
    date_created_gmt?: boolean
  }

  export type as_actionscheduler_claimsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'claim_id' | 'date_created_gmt',
    ExtArgs['result']['as_actionscheduler_claims']
  >

  export type $as_actionscheduler_claimsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_actionscheduler_claims'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        claim_id: bigint
        date_created_gmt: Date | null
      },
      ExtArgs['result']['as_actionscheduler_claims']
    >
    composites: {}
  }

  type as_actionscheduler_claimsGetPayload<
    S extends boolean | null | undefined | as_actionscheduler_claimsDefaultArgs
  > = $Result.GetResult<Prisma.$as_actionscheduler_claimsPayload, S>

  type as_actionscheduler_claimsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_actionscheduler_claimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_actionscheduler_claimsCountAggregateInputType | true
  }

  export interface as_actionscheduler_claimsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_actionscheduler_claims']
      meta: { name: 'as_actionscheduler_claims' }
    }
    /**
     * Find zero or one As_actionscheduler_claims that matches the filter.
     * @param {as_actionscheduler_claimsFindUniqueArgs} args - Arguments to find a As_actionscheduler_claims
     * @example
     * // Get one As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_actionscheduler_claimsFindUniqueArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_actionscheduler_claims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_actionscheduler_claimsFindUniqueOrThrowArgs} args - Arguments to find a As_actionscheduler_claims
     * @example
     * // Get one As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_actionscheduler_claimsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsFindFirstArgs} args - Arguments to find a As_actionscheduler_claims
     * @example
     * // Get one As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_actionscheduler_claimsFindFirstArgs>(
      args?: SelectSubset<T, as_actionscheduler_claimsFindFirstArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_claims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsFindFirstOrThrowArgs} args - Arguments to find a As_actionscheduler_claims
     * @example
     * // Get one As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_actionscheduler_claimsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_actionscheduler_claimsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_actionscheduler_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findMany()
     *
     * // Get first 10 As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.findMany({ take: 10 })
     *
     * // Only select the `claim_id`
     * const as_actionscheduler_claimsWithClaim_idOnly = await prisma.as_actionscheduler_claims.findMany({ select: { claim_id: true } })
     *
     */
    findMany<T extends as_actionscheduler_claimsFindManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_claimsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsCreateArgs} args - Arguments to create a As_actionscheduler_claims.
     * @example
     * // Create one As_actionscheduler_claims
     * const As_actionscheduler_claims = await prisma.as_actionscheduler_claims.create({
     *   data: {
     *     // ... data to create a As_actionscheduler_claims
     *   }
     * })
     *
     */
    create<T extends as_actionscheduler_claimsCreateArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsCreateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsCreateManyArgs} args - Arguments to create many As_actionscheduler_claims.
     * @example
     * // Create many As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_actionscheduler_claimsCreateManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_claimsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsDeleteArgs} args - Arguments to delete one As_actionscheduler_claims.
     * @example
     * // Delete one As_actionscheduler_claims
     * const As_actionscheduler_claims = await prisma.as_actionscheduler_claims.delete({
     *   where: {
     *     // ... filter to delete one As_actionscheduler_claims
     *   }
     * })
     *
     */
    delete<T extends as_actionscheduler_claimsDeleteArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsDeleteArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsUpdateArgs} args - Arguments to update one As_actionscheduler_claims.
     * @example
     * // Update one As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_actionscheduler_claimsUpdateArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsUpdateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsDeleteManyArgs} args - Arguments to filter As_actionscheduler_claims to delete.
     * @example
     * // Delete a few As_actionscheduler_claims
     * const { count } = await prisma.as_actionscheduler_claims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_actionscheduler_claimsDeleteManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_claimsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_actionscheduler_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_actionscheduler_claimsUpdateManyArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_actionscheduler_claims.
     * @param {as_actionscheduler_claimsUpsertArgs} args - Arguments to update or create a As_actionscheduler_claims.
     * @example
     * // Update or create a As_actionscheduler_claims
     * const as_actionscheduler_claims = await prisma.as_actionscheduler_claims.upsert({
     *   create: {
     *     // ... data to create a As_actionscheduler_claims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_actionscheduler_claims we want to update
     *   }
     * })
     */
    upsert<T extends as_actionscheduler_claimsUpsertArgs>(
      args: SelectSubset<T, as_actionscheduler_claimsUpsertArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_claimsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_claimsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_actionscheduler_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsCountArgs} args - Arguments to filter As_actionscheduler_claims to count.
     * @example
     * // Count the number of As_actionscheduler_claims
     * const count = await prisma.as_actionscheduler_claims.count({
     *   where: {
     *     // ... the filter for the As_actionscheduler_claims we want to count
     *   }
     * })
     */
    count<T extends as_actionscheduler_claimsCountArgs>(
      args?: Subset<T, as_actionscheduler_claimsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_actionscheduler_claimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_actionscheduler_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_actionscheduler_claimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_actionscheduler_claimsAggregateArgs>(
      args: Subset<T, As_actionscheduler_claimsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_actionscheduler_claimsAggregateType<T>>

    /**
     * Group by As_actionscheduler_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_claimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_actionscheduler_claimsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_actionscheduler_claimsGroupByArgs['orderBy'] }
        : { orderBy?: as_actionscheduler_claimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_actionscheduler_claimsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_actionscheduler_claimsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_actionscheduler_claims model
     */
    readonly fields: as_actionscheduler_claimsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_actionscheduler_claims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_actionscheduler_claimsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_actionscheduler_claims model
   */
  interface as_actionscheduler_claimsFieldRefs {
    readonly claim_id: FieldRef<'as_actionscheduler_claims', 'BigInt'>
    readonly date_created_gmt: FieldRef<'as_actionscheduler_claims', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * as_actionscheduler_claims findUnique
   */
  export type as_actionscheduler_claimsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_claims to fetch.
     */
    where: as_actionscheduler_claimsWhereUniqueInput
  }

  /**
   * as_actionscheduler_claims findUniqueOrThrow
   */
  export type as_actionscheduler_claimsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_claims to fetch.
     */
    where: as_actionscheduler_claimsWhereUniqueInput
  }

  /**
   * as_actionscheduler_claims findFirst
   */
  export type as_actionscheduler_claimsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_claims to fetch.
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_claims to fetch.
     */
    orderBy?:
      | as_actionscheduler_claimsOrderByWithRelationInput
      | as_actionscheduler_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_claims.
     */
    cursor?: as_actionscheduler_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_claims.
     */
    distinct?: As_actionscheduler_claimsScalarFieldEnum | As_actionscheduler_claimsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_claims findFirstOrThrow
   */
  export type as_actionscheduler_claimsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_claims to fetch.
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_claims to fetch.
     */
    orderBy?:
      | as_actionscheduler_claimsOrderByWithRelationInput
      | as_actionscheduler_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_claims.
     */
    cursor?: as_actionscheduler_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_claims.
     */
    distinct?: As_actionscheduler_claimsScalarFieldEnum | As_actionscheduler_claimsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_claims findMany
   */
  export type as_actionscheduler_claimsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_claims to fetch.
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_claims to fetch.
     */
    orderBy?:
      | as_actionscheduler_claimsOrderByWithRelationInput
      | as_actionscheduler_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_actionscheduler_claims.
     */
    cursor?: as_actionscheduler_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_claims.
     */
    skip?: number
    distinct?: As_actionscheduler_claimsScalarFieldEnum | As_actionscheduler_claimsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_claims create
   */
  export type as_actionscheduler_claimsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_actionscheduler_claims.
     */
    data?: XOR<as_actionscheduler_claimsCreateInput, as_actionscheduler_claimsUncheckedCreateInput>
  }

  /**
   * as_actionscheduler_claims createMany
   */
  export type as_actionscheduler_claimsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_actionscheduler_claims.
     */
    data: as_actionscheduler_claimsCreateManyInput | as_actionscheduler_claimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_actionscheduler_claims update
   */
  export type as_actionscheduler_claimsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_actionscheduler_claims.
     */
    data: XOR<as_actionscheduler_claimsUpdateInput, as_actionscheduler_claimsUncheckedUpdateInput>
    /**
     * Choose, which as_actionscheduler_claims to update.
     */
    where: as_actionscheduler_claimsWhereUniqueInput
  }

  /**
   * as_actionscheduler_claims updateMany
   */
  export type as_actionscheduler_claimsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_actionscheduler_claims.
     */
    data: XOR<
      as_actionscheduler_claimsUpdateManyMutationInput,
      as_actionscheduler_claimsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_actionscheduler_claims to update
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * Limit how many as_actionscheduler_claims to update.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_claims upsert
   */
  export type as_actionscheduler_claimsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_actionscheduler_claims to update in case it exists.
     */
    where: as_actionscheduler_claimsWhereUniqueInput
    /**
     * In case the as_actionscheduler_claims found by the `where` argument doesn't exist, create a new as_actionscheduler_claims with this data.
     */
    create: XOR<as_actionscheduler_claimsCreateInput, as_actionscheduler_claimsUncheckedCreateInput>
    /**
     * In case the as_actionscheduler_claims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_actionscheduler_claimsUpdateInput, as_actionscheduler_claimsUncheckedUpdateInput>
  }

  /**
   * as_actionscheduler_claims delete
   */
  export type as_actionscheduler_claimsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
    /**
     * Filter which as_actionscheduler_claims to delete.
     */
    where: as_actionscheduler_claimsWhereUniqueInput
  }

  /**
   * as_actionscheduler_claims deleteMany
   */
  export type as_actionscheduler_claimsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_claims to delete
     */
    where?: as_actionscheduler_claimsWhereInput
    /**
     * Limit how many as_actionscheduler_claims to delete.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_claims without action
   */
  export type as_actionscheduler_claimsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_claims
     */
    select?: as_actionscheduler_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_claims
     */
    omit?: as_actionscheduler_claimsOmit<ExtArgs> | null
  }

  /**
   * Model as_actionscheduler_groups
   */

  export type AggregateAs_actionscheduler_groups = {
    _count: As_actionscheduler_groupsCountAggregateOutputType | null
    _avg: As_actionscheduler_groupsAvgAggregateOutputType | null
    _sum: As_actionscheduler_groupsSumAggregateOutputType | null
    _min: As_actionscheduler_groupsMinAggregateOutputType | null
    _max: As_actionscheduler_groupsMaxAggregateOutputType | null
  }

  export type As_actionscheduler_groupsAvgAggregateOutputType = {
    group_id: number | null
  }

  export type As_actionscheduler_groupsSumAggregateOutputType = {
    group_id: bigint | null
  }

  export type As_actionscheduler_groupsMinAggregateOutputType = {
    group_id: bigint | null
    slug: string | null
  }

  export type As_actionscheduler_groupsMaxAggregateOutputType = {
    group_id: bigint | null
    slug: string | null
  }

  export type As_actionscheduler_groupsCountAggregateOutputType = {
    group_id: number
    slug: number
    _all: number
  }

  export type As_actionscheduler_groupsAvgAggregateInputType = {
    group_id?: true
  }

  export type As_actionscheduler_groupsSumAggregateInputType = {
    group_id?: true
  }

  export type As_actionscheduler_groupsMinAggregateInputType = {
    group_id?: true
    slug?: true
  }

  export type As_actionscheduler_groupsMaxAggregateInputType = {
    group_id?: true
    slug?: true
  }

  export type As_actionscheduler_groupsCountAggregateInputType = {
    group_id?: true
    slug?: true
    _all?: true
  }

  export type As_actionscheduler_groupsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_groups to aggregate.
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_groups to fetch.
     */
    orderBy?:
      | as_actionscheduler_groupsOrderByWithRelationInput
      | as_actionscheduler_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_actionscheduler_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_actionscheduler_groups
     */
    _count?: true | As_actionscheduler_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_actionscheduler_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_actionscheduler_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_actionscheduler_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_actionscheduler_groupsMaxAggregateInputType
  }

  export type GetAs_actionscheduler_groupsAggregateType<
    T extends As_actionscheduler_groupsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_actionscheduler_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_actionscheduler_groups[P]>
      : GetScalarType<T[P], AggregateAs_actionscheduler_groups[P]>
  }

  export type as_actionscheduler_groupsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_actionscheduler_groupsWhereInput
    orderBy?:
      | as_actionscheduler_groupsOrderByWithAggregationInput
      | as_actionscheduler_groupsOrderByWithAggregationInput[]
    by: As_actionscheduler_groupsScalarFieldEnum[] | As_actionscheduler_groupsScalarFieldEnum
    having?: as_actionscheduler_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_actionscheduler_groupsCountAggregateInputType | true
    _avg?: As_actionscheduler_groupsAvgAggregateInputType
    _sum?: As_actionscheduler_groupsSumAggregateInputType
    _min?: As_actionscheduler_groupsMinAggregateInputType
    _max?: As_actionscheduler_groupsMaxAggregateInputType
  }

  export type As_actionscheduler_groupsGroupByOutputType = {
    group_id: bigint
    slug: string
    _count: As_actionscheduler_groupsCountAggregateOutputType | null
    _avg: As_actionscheduler_groupsAvgAggregateOutputType | null
    _sum: As_actionscheduler_groupsSumAggregateOutputType | null
    _min: As_actionscheduler_groupsMinAggregateOutputType | null
    _max: As_actionscheduler_groupsMaxAggregateOutputType | null
  }

  type GetAs_actionscheduler_groupsGroupByPayload<T extends as_actionscheduler_groupsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_actionscheduler_groupsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_actionscheduler_groupsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_actionscheduler_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], As_actionscheduler_groupsGroupByOutputType[P]>
        }
      >
    >

  export type as_actionscheduler_groupsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      group_id?: boolean
      slug?: boolean
    },
    ExtArgs['result']['as_actionscheduler_groups']
  >

  export type as_actionscheduler_groupsSelectScalar = {
    group_id?: boolean
    slug?: boolean
  }

  export type as_actionscheduler_groupsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<'group_id' | 'slug', ExtArgs['result']['as_actionscheduler_groups']>

  export type $as_actionscheduler_groupsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_actionscheduler_groups'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        group_id: bigint
        slug: string
      },
      ExtArgs['result']['as_actionscheduler_groups']
    >
    composites: {}
  }

  type as_actionscheduler_groupsGetPayload<
    S extends boolean | null | undefined | as_actionscheduler_groupsDefaultArgs
  > = $Result.GetResult<Prisma.$as_actionscheduler_groupsPayload, S>

  type as_actionscheduler_groupsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_actionscheduler_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_actionscheduler_groupsCountAggregateInputType | true
  }

  export interface as_actionscheduler_groupsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_actionscheduler_groups']
      meta: { name: 'as_actionscheduler_groups' }
    }
    /**
     * Find zero or one As_actionscheduler_groups that matches the filter.
     * @param {as_actionscheduler_groupsFindUniqueArgs} args - Arguments to find a As_actionscheduler_groups
     * @example
     * // Get one As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_actionscheduler_groupsFindUniqueArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_actionscheduler_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_actionscheduler_groupsFindUniqueOrThrowArgs} args - Arguments to find a As_actionscheduler_groups
     * @example
     * // Get one As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_actionscheduler_groupsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsFindFirstArgs} args - Arguments to find a As_actionscheduler_groups
     * @example
     * // Get one As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_actionscheduler_groupsFindFirstArgs>(
      args?: SelectSubset<T, as_actionscheduler_groupsFindFirstArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsFindFirstOrThrowArgs} args - Arguments to find a As_actionscheduler_groups
     * @example
     * // Get one As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_actionscheduler_groupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_actionscheduler_groupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_actionscheduler_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findMany()
     *
     * // Get first 10 As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.findMany({ take: 10 })
     *
     * // Only select the `group_id`
     * const as_actionscheduler_groupsWithGroup_idOnly = await prisma.as_actionscheduler_groups.findMany({ select: { group_id: true } })
     *
     */
    findMany<T extends as_actionscheduler_groupsFindManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_groupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsCreateArgs} args - Arguments to create a As_actionscheduler_groups.
     * @example
     * // Create one As_actionscheduler_groups
     * const As_actionscheduler_groups = await prisma.as_actionscheduler_groups.create({
     *   data: {
     *     // ... data to create a As_actionscheduler_groups
     *   }
     * })
     *
     */
    create<T extends as_actionscheduler_groupsCreateArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsCreateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsCreateManyArgs} args - Arguments to create many As_actionscheduler_groups.
     * @example
     * // Create many As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_actionscheduler_groupsCreateManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_groupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsDeleteArgs} args - Arguments to delete one As_actionscheduler_groups.
     * @example
     * // Delete one As_actionscheduler_groups
     * const As_actionscheduler_groups = await prisma.as_actionscheduler_groups.delete({
     *   where: {
     *     // ... filter to delete one As_actionscheduler_groups
     *   }
     * })
     *
     */
    delete<T extends as_actionscheduler_groupsDeleteArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsDeleteArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsUpdateArgs} args - Arguments to update one As_actionscheduler_groups.
     * @example
     * // Update one As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_actionscheduler_groupsUpdateArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsUpdateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsDeleteManyArgs} args - Arguments to filter As_actionscheduler_groups to delete.
     * @example
     * // Delete a few As_actionscheduler_groups
     * const { count } = await prisma.as_actionscheduler_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_actionscheduler_groupsDeleteManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_groupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_actionscheduler_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_actionscheduler_groupsUpdateManyArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_actionscheduler_groups.
     * @param {as_actionscheduler_groupsUpsertArgs} args - Arguments to update or create a As_actionscheduler_groups.
     * @example
     * // Update or create a As_actionscheduler_groups
     * const as_actionscheduler_groups = await prisma.as_actionscheduler_groups.upsert({
     *   create: {
     *     // ... data to create a As_actionscheduler_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_actionscheduler_groups we want to update
     *   }
     * })
     */
    upsert<T extends as_actionscheduler_groupsUpsertArgs>(
      args: SelectSubset<T, as_actionscheduler_groupsUpsertArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_groupsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_groupsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_actionscheduler_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsCountArgs} args - Arguments to filter As_actionscheduler_groups to count.
     * @example
     * // Count the number of As_actionscheduler_groups
     * const count = await prisma.as_actionscheduler_groups.count({
     *   where: {
     *     // ... the filter for the As_actionscheduler_groups we want to count
     *   }
     * })
     */
    count<T extends as_actionscheduler_groupsCountArgs>(
      args?: Subset<T, as_actionscheduler_groupsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_actionscheduler_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_actionscheduler_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_actionscheduler_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_actionscheduler_groupsAggregateArgs>(
      args: Subset<T, As_actionscheduler_groupsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_actionscheduler_groupsAggregateType<T>>

    /**
     * Group by As_actionscheduler_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_actionscheduler_groupsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_actionscheduler_groupsGroupByArgs['orderBy'] }
        : { orderBy?: as_actionscheduler_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_actionscheduler_groupsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_actionscheduler_groupsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_actionscheduler_groups model
     */
    readonly fields: as_actionscheduler_groupsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_actionscheduler_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_actionscheduler_groupsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_actionscheduler_groups model
   */
  interface as_actionscheduler_groupsFieldRefs {
    readonly group_id: FieldRef<'as_actionscheduler_groups', 'BigInt'>
    readonly slug: FieldRef<'as_actionscheduler_groups', 'String'>
  }

  // Custom InputTypes
  /**
   * as_actionscheduler_groups findUnique
   */
  export type as_actionscheduler_groupsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_groups to fetch.
     */
    where: as_actionscheduler_groupsWhereUniqueInput
  }

  /**
   * as_actionscheduler_groups findUniqueOrThrow
   */
  export type as_actionscheduler_groupsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_groups to fetch.
     */
    where: as_actionscheduler_groupsWhereUniqueInput
  }

  /**
   * as_actionscheduler_groups findFirst
   */
  export type as_actionscheduler_groupsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_groups to fetch.
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_groups to fetch.
     */
    orderBy?:
      | as_actionscheduler_groupsOrderByWithRelationInput
      | as_actionscheduler_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_groups.
     */
    cursor?: as_actionscheduler_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_groups.
     */
    distinct?: As_actionscheduler_groupsScalarFieldEnum | As_actionscheduler_groupsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_groups findFirstOrThrow
   */
  export type as_actionscheduler_groupsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_groups to fetch.
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_groups to fetch.
     */
    orderBy?:
      | as_actionscheduler_groupsOrderByWithRelationInput
      | as_actionscheduler_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_groups.
     */
    cursor?: as_actionscheduler_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_groups.
     */
    distinct?: As_actionscheduler_groupsScalarFieldEnum | As_actionscheduler_groupsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_groups findMany
   */
  export type as_actionscheduler_groupsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_groups to fetch.
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_groups to fetch.
     */
    orderBy?:
      | as_actionscheduler_groupsOrderByWithRelationInput
      | as_actionscheduler_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_actionscheduler_groups.
     */
    cursor?: as_actionscheduler_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_groups.
     */
    skip?: number
    distinct?: As_actionscheduler_groupsScalarFieldEnum | As_actionscheduler_groupsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_groups create
   */
  export type as_actionscheduler_groupsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_actionscheduler_groups.
     */
    data: XOR<as_actionscheduler_groupsCreateInput, as_actionscheduler_groupsUncheckedCreateInput>
  }

  /**
   * as_actionscheduler_groups createMany
   */
  export type as_actionscheduler_groupsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_actionscheduler_groups.
     */
    data: as_actionscheduler_groupsCreateManyInput | as_actionscheduler_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_actionscheduler_groups update
   */
  export type as_actionscheduler_groupsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_actionscheduler_groups.
     */
    data: XOR<as_actionscheduler_groupsUpdateInput, as_actionscheduler_groupsUncheckedUpdateInput>
    /**
     * Choose, which as_actionscheduler_groups to update.
     */
    where: as_actionscheduler_groupsWhereUniqueInput
  }

  /**
   * as_actionscheduler_groups updateMany
   */
  export type as_actionscheduler_groupsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_actionscheduler_groups.
     */
    data: XOR<
      as_actionscheduler_groupsUpdateManyMutationInput,
      as_actionscheduler_groupsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_actionscheduler_groups to update
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * Limit how many as_actionscheduler_groups to update.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_groups upsert
   */
  export type as_actionscheduler_groupsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_actionscheduler_groups to update in case it exists.
     */
    where: as_actionscheduler_groupsWhereUniqueInput
    /**
     * In case the as_actionscheduler_groups found by the `where` argument doesn't exist, create a new as_actionscheduler_groups with this data.
     */
    create: XOR<as_actionscheduler_groupsCreateInput, as_actionscheduler_groupsUncheckedCreateInput>
    /**
     * In case the as_actionscheduler_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_actionscheduler_groupsUpdateInput, as_actionscheduler_groupsUncheckedUpdateInput>
  }

  /**
   * as_actionscheduler_groups delete
   */
  export type as_actionscheduler_groupsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
    /**
     * Filter which as_actionscheduler_groups to delete.
     */
    where: as_actionscheduler_groupsWhereUniqueInput
  }

  /**
   * as_actionscheduler_groups deleteMany
   */
  export type as_actionscheduler_groupsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_groups to delete
     */
    where?: as_actionscheduler_groupsWhereInput
    /**
     * Limit how many as_actionscheduler_groups to delete.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_groups without action
   */
  export type as_actionscheduler_groupsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_groups
     */
    select?: as_actionscheduler_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_groups
     */
    omit?: as_actionscheduler_groupsOmit<ExtArgs> | null
  }

  /**
   * Model as_actionscheduler_logs
   */

  export type AggregateAs_actionscheduler_logs = {
    _count: As_actionscheduler_logsCountAggregateOutputType | null
    _avg: As_actionscheduler_logsAvgAggregateOutputType | null
    _sum: As_actionscheduler_logsSumAggregateOutputType | null
    _min: As_actionscheduler_logsMinAggregateOutputType | null
    _max: As_actionscheduler_logsMaxAggregateOutputType | null
  }

  export type As_actionscheduler_logsAvgAggregateOutputType = {
    log_id: number | null
    action_id: number | null
  }

  export type As_actionscheduler_logsSumAggregateOutputType = {
    log_id: bigint | null
    action_id: bigint | null
  }

  export type As_actionscheduler_logsMinAggregateOutputType = {
    log_id: bigint | null
    action_id: bigint | null
    message: string | null
    log_date_gmt: Date | null
    log_date_local: Date | null
  }

  export type As_actionscheduler_logsMaxAggregateOutputType = {
    log_id: bigint | null
    action_id: bigint | null
    message: string | null
    log_date_gmt: Date | null
    log_date_local: Date | null
  }

  export type As_actionscheduler_logsCountAggregateOutputType = {
    log_id: number
    action_id: number
    message: number
    log_date_gmt: number
    log_date_local: number
    _all: number
  }

  export type As_actionscheduler_logsAvgAggregateInputType = {
    log_id?: true
    action_id?: true
  }

  export type As_actionscheduler_logsSumAggregateInputType = {
    log_id?: true
    action_id?: true
  }

  export type As_actionscheduler_logsMinAggregateInputType = {
    log_id?: true
    action_id?: true
    message?: true
    log_date_gmt?: true
    log_date_local?: true
  }

  export type As_actionscheduler_logsMaxAggregateInputType = {
    log_id?: true
    action_id?: true
    message?: true
    log_date_gmt?: true
    log_date_local?: true
  }

  export type As_actionscheduler_logsCountAggregateInputType = {
    log_id?: true
    action_id?: true
    message?: true
    log_date_gmt?: true
    log_date_local?: true
    _all?: true
  }

  export type As_actionscheduler_logsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_logs to aggregate.
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_logs to fetch.
     */
    orderBy?:
      | as_actionscheduler_logsOrderByWithRelationInput
      | as_actionscheduler_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_actionscheduler_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_actionscheduler_logs
     */
    _count?: true | As_actionscheduler_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_actionscheduler_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_actionscheduler_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_actionscheduler_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_actionscheduler_logsMaxAggregateInputType
  }

  export type GetAs_actionscheduler_logsAggregateType<
    T extends As_actionscheduler_logsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_actionscheduler_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_actionscheduler_logs[P]>
      : GetScalarType<T[P], AggregateAs_actionscheduler_logs[P]>
  }

  export type as_actionscheduler_logsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_actionscheduler_logsWhereInput
    orderBy?:
      | as_actionscheduler_logsOrderByWithAggregationInput
      | as_actionscheduler_logsOrderByWithAggregationInput[]
    by: As_actionscheduler_logsScalarFieldEnum[] | As_actionscheduler_logsScalarFieldEnum
    having?: as_actionscheduler_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_actionscheduler_logsCountAggregateInputType | true
    _avg?: As_actionscheduler_logsAvgAggregateInputType
    _sum?: As_actionscheduler_logsSumAggregateInputType
    _min?: As_actionscheduler_logsMinAggregateInputType
    _max?: As_actionscheduler_logsMaxAggregateInputType
  }

  export type As_actionscheduler_logsGroupByOutputType = {
    log_id: bigint
    action_id: bigint
    message: string
    log_date_gmt: Date | null
    log_date_local: Date | null
    _count: As_actionscheduler_logsCountAggregateOutputType | null
    _avg: As_actionscheduler_logsAvgAggregateOutputType | null
    _sum: As_actionscheduler_logsSumAggregateOutputType | null
    _min: As_actionscheduler_logsMinAggregateOutputType | null
    _max: As_actionscheduler_logsMaxAggregateOutputType | null
  }

  type GetAs_actionscheduler_logsGroupByPayload<T extends as_actionscheduler_logsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_actionscheduler_logsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_actionscheduler_logsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_actionscheduler_logsGroupByOutputType[P]>
            : GetScalarType<T[P], As_actionscheduler_logsGroupByOutputType[P]>
        }
      >
    >

  export type as_actionscheduler_logsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      log_id?: boolean
      action_id?: boolean
      message?: boolean
      log_date_gmt?: boolean
      log_date_local?: boolean
    },
    ExtArgs['result']['as_actionscheduler_logs']
  >

  export type as_actionscheduler_logsSelectScalar = {
    log_id?: boolean
    action_id?: boolean
    message?: boolean
    log_date_gmt?: boolean
    log_date_local?: boolean
  }

  export type as_actionscheduler_logsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'log_id' | 'action_id' | 'message' | 'log_date_gmt' | 'log_date_local',
    ExtArgs['result']['as_actionscheduler_logs']
  >

  export type $as_actionscheduler_logsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_actionscheduler_logs'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        log_id: bigint
        action_id: bigint
        message: string
        log_date_gmt: Date | null
        log_date_local: Date | null
      },
      ExtArgs['result']['as_actionscheduler_logs']
    >
    composites: {}
  }

  type as_actionscheduler_logsGetPayload<
    S extends boolean | null | undefined | as_actionscheduler_logsDefaultArgs
  > = $Result.GetResult<Prisma.$as_actionscheduler_logsPayload, S>

  type as_actionscheduler_logsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_actionscheduler_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_actionscheduler_logsCountAggregateInputType | true
  }

  export interface as_actionscheduler_logsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_actionscheduler_logs']
      meta: { name: 'as_actionscheduler_logs' }
    }
    /**
     * Find zero or one As_actionscheduler_logs that matches the filter.
     * @param {as_actionscheduler_logsFindUniqueArgs} args - Arguments to find a As_actionscheduler_logs
     * @example
     * // Get one As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_actionscheduler_logsFindUniqueArgs>(
      args: SelectSubset<T, as_actionscheduler_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_actionscheduler_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_actionscheduler_logsFindUniqueOrThrowArgs} args - Arguments to find a As_actionscheduler_logs
     * @example
     * // Get one As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_actionscheduler_logsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_actionscheduler_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsFindFirstArgs} args - Arguments to find a As_actionscheduler_logs
     * @example
     * // Get one As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_actionscheduler_logsFindFirstArgs>(
      args?: SelectSubset<T, as_actionscheduler_logsFindFirstArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_actionscheduler_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsFindFirstOrThrowArgs} args - Arguments to find a As_actionscheduler_logs
     * @example
     * // Get one As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_actionscheduler_logsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_actionscheduler_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_actionscheduler_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findMany()
     *
     * // Get first 10 As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.findMany({ take: 10 })
     *
     * // Only select the `log_id`
     * const as_actionscheduler_logsWithLog_idOnly = await prisma.as_actionscheduler_logs.findMany({ select: { log_id: true } })
     *
     */
    findMany<T extends as_actionscheduler_logsFindManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_actionscheduler_logs.
     * @param {as_actionscheduler_logsCreateArgs} args - Arguments to create a As_actionscheduler_logs.
     * @example
     * // Create one As_actionscheduler_logs
     * const As_actionscheduler_logs = await prisma.as_actionscheduler_logs.create({
     *   data: {
     *     // ... data to create a As_actionscheduler_logs
     *   }
     * })
     *
     */
    create<T extends as_actionscheduler_logsCreateArgs>(
      args: SelectSubset<T, as_actionscheduler_logsCreateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_actionscheduler_logs.
     * @param {as_actionscheduler_logsCreateManyArgs} args - Arguments to create many As_actionscheduler_logs.
     * @example
     * // Create many As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_actionscheduler_logsCreateManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_actionscheduler_logs.
     * @param {as_actionscheduler_logsDeleteArgs} args - Arguments to delete one As_actionscheduler_logs.
     * @example
     * // Delete one As_actionscheduler_logs
     * const As_actionscheduler_logs = await prisma.as_actionscheduler_logs.delete({
     *   where: {
     *     // ... filter to delete one As_actionscheduler_logs
     *   }
     * })
     *
     */
    delete<T extends as_actionscheduler_logsDeleteArgs>(
      args: SelectSubset<T, as_actionscheduler_logsDeleteArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_actionscheduler_logs.
     * @param {as_actionscheduler_logsUpdateArgs} args - Arguments to update one As_actionscheduler_logs.
     * @example
     * // Update one As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_actionscheduler_logsUpdateArgs>(
      args: SelectSubset<T, as_actionscheduler_logsUpdateArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_actionscheduler_logs.
     * @param {as_actionscheduler_logsDeleteManyArgs} args - Arguments to filter As_actionscheduler_logs to delete.
     * @example
     * // Delete a few As_actionscheduler_logs
     * const { count } = await prisma.as_actionscheduler_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_actionscheduler_logsDeleteManyArgs>(
      args?: SelectSubset<T, as_actionscheduler_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_actionscheduler_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_actionscheduler_logsUpdateManyArgs>(
      args: SelectSubset<T, as_actionscheduler_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_actionscheduler_logs.
     * @param {as_actionscheduler_logsUpsertArgs} args - Arguments to update or create a As_actionscheduler_logs.
     * @example
     * // Update or create a As_actionscheduler_logs
     * const as_actionscheduler_logs = await prisma.as_actionscheduler_logs.upsert({
     *   create: {
     *     // ... data to create a As_actionscheduler_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_actionscheduler_logs we want to update
     *   }
     * })
     */
    upsert<T extends as_actionscheduler_logsUpsertArgs>(
      args: SelectSubset<T, as_actionscheduler_logsUpsertArgs<ExtArgs>>
    ): Prisma__as_actionscheduler_logsClient<
      $Result.GetResult<
        Prisma.$as_actionscheduler_logsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_actionscheduler_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsCountArgs} args - Arguments to filter As_actionscheduler_logs to count.
     * @example
     * // Count the number of As_actionscheduler_logs
     * const count = await prisma.as_actionscheduler_logs.count({
     *   where: {
     *     // ... the filter for the As_actionscheduler_logs we want to count
     *   }
     * })
     */
    count<T extends as_actionscheduler_logsCountArgs>(
      args?: Subset<T, as_actionscheduler_logsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_actionscheduler_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_actionscheduler_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_actionscheduler_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_actionscheduler_logsAggregateArgs>(
      args: Subset<T, As_actionscheduler_logsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_actionscheduler_logsAggregateType<T>>

    /**
     * Group by As_actionscheduler_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_actionscheduler_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_actionscheduler_logsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_actionscheduler_logsGroupByArgs['orderBy'] }
        : { orderBy?: as_actionscheduler_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_actionscheduler_logsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_actionscheduler_logsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_actionscheduler_logs model
     */
    readonly fields: as_actionscheduler_logsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_actionscheduler_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_actionscheduler_logsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_actionscheduler_logs model
   */
  interface as_actionscheduler_logsFieldRefs {
    readonly log_id: FieldRef<'as_actionscheduler_logs', 'BigInt'>
    readonly action_id: FieldRef<'as_actionscheduler_logs', 'BigInt'>
    readonly message: FieldRef<'as_actionscheduler_logs', 'String'>
    readonly log_date_gmt: FieldRef<'as_actionscheduler_logs', 'DateTime'>
    readonly log_date_local: FieldRef<'as_actionscheduler_logs', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * as_actionscheduler_logs findUnique
   */
  export type as_actionscheduler_logsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_logs to fetch.
     */
    where: as_actionscheduler_logsWhereUniqueInput
  }

  /**
   * as_actionscheduler_logs findUniqueOrThrow
   */
  export type as_actionscheduler_logsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_logs to fetch.
     */
    where: as_actionscheduler_logsWhereUniqueInput
  }

  /**
   * as_actionscheduler_logs findFirst
   */
  export type as_actionscheduler_logsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_logs to fetch.
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_logs to fetch.
     */
    orderBy?:
      | as_actionscheduler_logsOrderByWithRelationInput
      | as_actionscheduler_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_logs.
     */
    cursor?: as_actionscheduler_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_logs.
     */
    distinct?: As_actionscheduler_logsScalarFieldEnum | As_actionscheduler_logsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_logs findFirstOrThrow
   */
  export type as_actionscheduler_logsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_logs to fetch.
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_logs to fetch.
     */
    orderBy?:
      | as_actionscheduler_logsOrderByWithRelationInput
      | as_actionscheduler_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_actionscheduler_logs.
     */
    cursor?: as_actionscheduler_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_actionscheduler_logs.
     */
    distinct?: As_actionscheduler_logsScalarFieldEnum | As_actionscheduler_logsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_logs findMany
   */
  export type as_actionscheduler_logsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_actionscheduler_logs to fetch.
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_actionscheduler_logs to fetch.
     */
    orderBy?:
      | as_actionscheduler_logsOrderByWithRelationInput
      | as_actionscheduler_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_actionscheduler_logs.
     */
    cursor?: as_actionscheduler_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_actionscheduler_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_actionscheduler_logs.
     */
    skip?: number
    distinct?: As_actionscheduler_logsScalarFieldEnum | As_actionscheduler_logsScalarFieldEnum[]
  }

  /**
   * as_actionscheduler_logs create
   */
  export type as_actionscheduler_logsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_actionscheduler_logs.
     */
    data: XOR<as_actionscheduler_logsCreateInput, as_actionscheduler_logsUncheckedCreateInput>
  }

  /**
   * as_actionscheduler_logs createMany
   */
  export type as_actionscheduler_logsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_actionscheduler_logs.
     */
    data: as_actionscheduler_logsCreateManyInput | as_actionscheduler_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_actionscheduler_logs update
   */
  export type as_actionscheduler_logsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_actionscheduler_logs.
     */
    data: XOR<as_actionscheduler_logsUpdateInput, as_actionscheduler_logsUncheckedUpdateInput>
    /**
     * Choose, which as_actionscheduler_logs to update.
     */
    where: as_actionscheduler_logsWhereUniqueInput
  }

  /**
   * as_actionscheduler_logs updateMany
   */
  export type as_actionscheduler_logsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_actionscheduler_logs.
     */
    data: XOR<
      as_actionscheduler_logsUpdateManyMutationInput,
      as_actionscheduler_logsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_actionscheduler_logs to update
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * Limit how many as_actionscheduler_logs to update.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_logs upsert
   */
  export type as_actionscheduler_logsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_actionscheduler_logs to update in case it exists.
     */
    where: as_actionscheduler_logsWhereUniqueInput
    /**
     * In case the as_actionscheduler_logs found by the `where` argument doesn't exist, create a new as_actionscheduler_logs with this data.
     */
    create: XOR<as_actionscheduler_logsCreateInput, as_actionscheduler_logsUncheckedCreateInput>
    /**
     * In case the as_actionscheduler_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_actionscheduler_logsUpdateInput, as_actionscheduler_logsUncheckedUpdateInput>
  }

  /**
   * as_actionscheduler_logs delete
   */
  export type as_actionscheduler_logsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
    /**
     * Filter which as_actionscheduler_logs to delete.
     */
    where: as_actionscheduler_logsWhereUniqueInput
  }

  /**
   * as_actionscheduler_logs deleteMany
   */
  export type as_actionscheduler_logsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_actionscheduler_logs to delete
     */
    where?: as_actionscheduler_logsWhereInput
    /**
     * Limit how many as_actionscheduler_logs to delete.
     */
    limit?: number
  }

  /**
   * as_actionscheduler_logs without action
   */
  export type as_actionscheduler_logsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_actionscheduler_logs
     */
    select?: as_actionscheduler_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_actionscheduler_logs
     */
    omit?: as_actionscheduler_logsOmit<ExtArgs> | null
  }

  /**
   * Model as_awb_critical_css
   */

  export type AggregateAs_awb_critical_css = {
    _count: As_awb_critical_cssCountAggregateOutputType | null
    _avg: As_awb_critical_cssAvgAggregateOutputType | null
    _sum: As_awb_critical_cssSumAggregateOutputType | null
    _min: As_awb_critical_cssMinAggregateOutputType | null
    _max: As_awb_critical_cssMaxAggregateOutputType | null
  }

  export type As_awb_critical_cssAvgAggregateOutputType = {
    id: number | null
  }

  export type As_awb_critical_cssSumAggregateOutputType = {
    id: bigint | null
  }

  export type As_awb_critical_cssMinAggregateOutputType = {
    id: bigint | null
    css_key: string | null
    mobile_css: string | null
    desktop_css: string | null
    mobile_preloads: string | null
    desktop_preloads: string | null
    updated_at: string | null
  }

  export type As_awb_critical_cssMaxAggregateOutputType = {
    id: bigint | null
    css_key: string | null
    mobile_css: string | null
    desktop_css: string | null
    mobile_preloads: string | null
    desktop_preloads: string | null
    updated_at: string | null
  }

  export type As_awb_critical_cssCountAggregateOutputType = {
    id: number
    css_key: number
    mobile_css: number
    desktop_css: number
    mobile_preloads: number
    desktop_preloads: number
    updated_at: number
    _all: number
  }

  export type As_awb_critical_cssAvgAggregateInputType = {
    id?: true
  }

  export type As_awb_critical_cssSumAggregateInputType = {
    id?: true
  }

  export type As_awb_critical_cssMinAggregateInputType = {
    id?: true
    css_key?: true
    mobile_css?: true
    desktop_css?: true
    mobile_preloads?: true
    desktop_preloads?: true
    updated_at?: true
  }

  export type As_awb_critical_cssMaxAggregateInputType = {
    id?: true
    css_key?: true
    mobile_css?: true
    desktop_css?: true
    mobile_preloads?: true
    desktop_preloads?: true
    updated_at?: true
  }

  export type As_awb_critical_cssCountAggregateInputType = {
    id?: true
    css_key?: true
    mobile_css?: true
    desktop_css?: true
    mobile_preloads?: true
    desktop_preloads?: true
    updated_at?: true
    _all?: true
  }

  export type As_awb_critical_cssAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_awb_critical_css to aggregate.
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_awb_critical_csses to fetch.
     */
    orderBy?:
      | as_awb_critical_cssOrderByWithRelationInput
      | as_awb_critical_cssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_awb_critical_cssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_awb_critical_csses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_awb_critical_csses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_awb_critical_csses
     */
    _count?: true | As_awb_critical_cssCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_awb_critical_cssAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_awb_critical_cssSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_awb_critical_cssMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_awb_critical_cssMaxAggregateInputType
  }

  export type GetAs_awb_critical_cssAggregateType<T extends As_awb_critical_cssAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_awb_critical_css]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_awb_critical_css[P]>
      : GetScalarType<T[P], AggregateAs_awb_critical_css[P]>
  }

  export type as_awb_critical_cssGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_awb_critical_cssWhereInput
    orderBy?:
      | as_awb_critical_cssOrderByWithAggregationInput
      | as_awb_critical_cssOrderByWithAggregationInput[]
    by: As_awb_critical_cssScalarFieldEnum[] | As_awb_critical_cssScalarFieldEnum
    having?: as_awb_critical_cssScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_awb_critical_cssCountAggregateInputType | true
    _avg?: As_awb_critical_cssAvgAggregateInputType
    _sum?: As_awb_critical_cssSumAggregateInputType
    _min?: As_awb_critical_cssMinAggregateInputType
    _max?: As_awb_critical_cssMaxAggregateInputType
  }

  export type As_awb_critical_cssGroupByOutputType = {
    id: bigint
    css_key: string
    mobile_css: string
    desktop_css: string
    mobile_preloads: string
    desktop_preloads: string
    updated_at: string
    _count: As_awb_critical_cssCountAggregateOutputType | null
    _avg: As_awb_critical_cssAvgAggregateOutputType | null
    _sum: As_awb_critical_cssSumAggregateOutputType | null
    _min: As_awb_critical_cssMinAggregateOutputType | null
    _max: As_awb_critical_cssMaxAggregateOutputType | null
  }

  type GetAs_awb_critical_cssGroupByPayload<T extends as_awb_critical_cssGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_awb_critical_cssGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_awb_critical_cssGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_awb_critical_cssGroupByOutputType[P]>
            : GetScalarType<T[P], As_awb_critical_cssGroupByOutputType[P]>
        }
      >
    >

  export type as_awb_critical_cssSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      css_key?: boolean
      mobile_css?: boolean
      desktop_css?: boolean
      mobile_preloads?: boolean
      desktop_preloads?: boolean
      updated_at?: boolean
    },
    ExtArgs['result']['as_awb_critical_css']
  >

  export type as_awb_critical_cssSelectScalar = {
    id?: boolean
    css_key?: boolean
    mobile_css?: boolean
    desktop_css?: boolean
    mobile_preloads?: boolean
    desktop_preloads?: boolean
    updated_at?: boolean
  }

  export type as_awb_critical_cssOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'css_key'
    | 'mobile_css'
    | 'desktop_css'
    | 'mobile_preloads'
    | 'desktop_preloads'
    | 'updated_at',
    ExtArgs['result']['as_awb_critical_css']
  >

  export type $as_awb_critical_cssPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_awb_critical_css'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        css_key: string
        mobile_css: string
        desktop_css: string
        mobile_preloads: string
        desktop_preloads: string
        updated_at: string
      },
      ExtArgs['result']['as_awb_critical_css']
    >
    composites: {}
  }

  type as_awb_critical_cssGetPayload<
    S extends boolean | null | undefined | as_awb_critical_cssDefaultArgs
  > = $Result.GetResult<Prisma.$as_awb_critical_cssPayload, S>

  type as_awb_critical_cssCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_awb_critical_cssFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_awb_critical_cssCountAggregateInputType | true
  }

  export interface as_awb_critical_cssDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_awb_critical_css']
      meta: { name: 'as_awb_critical_css' }
    }
    /**
     * Find zero or one As_awb_critical_css that matches the filter.
     * @param {as_awb_critical_cssFindUniqueArgs} args - Arguments to find a As_awb_critical_css
     * @example
     * // Get one As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_awb_critical_cssFindUniqueArgs>(
      args: SelectSubset<T, as_awb_critical_cssFindUniqueArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_awb_critical_css that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_awb_critical_cssFindUniqueOrThrowArgs} args - Arguments to find a As_awb_critical_css
     * @example
     * // Get one As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_awb_critical_cssFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_awb_critical_cssFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_awb_critical_css that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssFindFirstArgs} args - Arguments to find a As_awb_critical_css
     * @example
     * // Get one As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_awb_critical_cssFindFirstArgs>(
      args?: SelectSubset<T, as_awb_critical_cssFindFirstArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_awb_critical_css that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssFindFirstOrThrowArgs} args - Arguments to find a As_awb_critical_css
     * @example
     * // Get one As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_awb_critical_cssFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_awb_critical_cssFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_awb_critical_csses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_awb_critical_csses
     * const as_awb_critical_csses = await prisma.as_awb_critical_css.findMany()
     *
     * // Get first 10 As_awb_critical_csses
     * const as_awb_critical_csses = await prisma.as_awb_critical_css.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_awb_critical_cssWithIdOnly = await prisma.as_awb_critical_css.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_awb_critical_cssFindManyArgs>(
      args?: SelectSubset<T, as_awb_critical_cssFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_awb_critical_css.
     * @param {as_awb_critical_cssCreateArgs} args - Arguments to create a As_awb_critical_css.
     * @example
     * // Create one As_awb_critical_css
     * const As_awb_critical_css = await prisma.as_awb_critical_css.create({
     *   data: {
     *     // ... data to create a As_awb_critical_css
     *   }
     * })
     *
     */
    create<T extends as_awb_critical_cssCreateArgs>(
      args: SelectSubset<T, as_awb_critical_cssCreateArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_awb_critical_csses.
     * @param {as_awb_critical_cssCreateManyArgs} args - Arguments to create many As_awb_critical_csses.
     * @example
     * // Create many As_awb_critical_csses
     * const as_awb_critical_css = await prisma.as_awb_critical_css.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_awb_critical_cssCreateManyArgs>(
      args?: SelectSubset<T, as_awb_critical_cssCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_awb_critical_css.
     * @param {as_awb_critical_cssDeleteArgs} args - Arguments to delete one As_awb_critical_css.
     * @example
     * // Delete one As_awb_critical_css
     * const As_awb_critical_css = await prisma.as_awb_critical_css.delete({
     *   where: {
     *     // ... filter to delete one As_awb_critical_css
     *   }
     * })
     *
     */
    delete<T extends as_awb_critical_cssDeleteArgs>(
      args: SelectSubset<T, as_awb_critical_cssDeleteArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_awb_critical_css.
     * @param {as_awb_critical_cssUpdateArgs} args - Arguments to update one As_awb_critical_css.
     * @example
     * // Update one As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_awb_critical_cssUpdateArgs>(
      args: SelectSubset<T, as_awb_critical_cssUpdateArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_awb_critical_csses.
     * @param {as_awb_critical_cssDeleteManyArgs} args - Arguments to filter As_awb_critical_csses to delete.
     * @example
     * // Delete a few As_awb_critical_csses
     * const { count } = await prisma.as_awb_critical_css.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_awb_critical_cssDeleteManyArgs>(
      args?: SelectSubset<T, as_awb_critical_cssDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_awb_critical_csses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_awb_critical_csses
     * const as_awb_critical_css = await prisma.as_awb_critical_css.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_awb_critical_cssUpdateManyArgs>(
      args: SelectSubset<T, as_awb_critical_cssUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_awb_critical_css.
     * @param {as_awb_critical_cssUpsertArgs} args - Arguments to update or create a As_awb_critical_css.
     * @example
     * // Update or create a As_awb_critical_css
     * const as_awb_critical_css = await prisma.as_awb_critical_css.upsert({
     *   create: {
     *     // ... data to create a As_awb_critical_css
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_awb_critical_css we want to update
     *   }
     * })
     */
    upsert<T extends as_awb_critical_cssUpsertArgs>(
      args: SelectSubset<T, as_awb_critical_cssUpsertArgs<ExtArgs>>
    ): Prisma__as_awb_critical_cssClient<
      $Result.GetResult<
        Prisma.$as_awb_critical_cssPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_awb_critical_csses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssCountArgs} args - Arguments to filter As_awb_critical_csses to count.
     * @example
     * // Count the number of As_awb_critical_csses
     * const count = await prisma.as_awb_critical_css.count({
     *   where: {
     *     // ... the filter for the As_awb_critical_csses we want to count
     *   }
     * })
     */
    count<T extends as_awb_critical_cssCountArgs>(
      args?: Subset<T, as_awb_critical_cssCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_awb_critical_cssCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_awb_critical_css.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_awb_critical_cssAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_awb_critical_cssAggregateArgs>(
      args: Subset<T, As_awb_critical_cssAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_awb_critical_cssAggregateType<T>>

    /**
     * Group by As_awb_critical_css.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_awb_critical_cssGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_awb_critical_cssGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_awb_critical_cssGroupByArgs['orderBy'] }
        : { orderBy?: as_awb_critical_cssGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_awb_critical_cssGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_awb_critical_cssGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_awb_critical_css model
     */
    readonly fields: as_awb_critical_cssFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_awb_critical_css.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_awb_critical_cssClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_awb_critical_css model
   */
  interface as_awb_critical_cssFieldRefs {
    readonly id: FieldRef<'as_awb_critical_css', 'BigInt'>
    readonly css_key: FieldRef<'as_awb_critical_css', 'String'>
    readonly mobile_css: FieldRef<'as_awb_critical_css', 'String'>
    readonly desktop_css: FieldRef<'as_awb_critical_css', 'String'>
    readonly mobile_preloads: FieldRef<'as_awb_critical_css', 'String'>
    readonly desktop_preloads: FieldRef<'as_awb_critical_css', 'String'>
    readonly updated_at: FieldRef<'as_awb_critical_css', 'String'>
  }

  // Custom InputTypes
  /**
   * as_awb_critical_css findUnique
   */
  export type as_awb_critical_cssFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter, which as_awb_critical_css to fetch.
     */
    where: as_awb_critical_cssWhereUniqueInput
  }

  /**
   * as_awb_critical_css findUniqueOrThrow
   */
  export type as_awb_critical_cssFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter, which as_awb_critical_css to fetch.
     */
    where: as_awb_critical_cssWhereUniqueInput
  }

  /**
   * as_awb_critical_css findFirst
   */
  export type as_awb_critical_cssFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter, which as_awb_critical_css to fetch.
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_awb_critical_csses to fetch.
     */
    orderBy?:
      | as_awb_critical_cssOrderByWithRelationInput
      | as_awb_critical_cssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_awb_critical_csses.
     */
    cursor?: as_awb_critical_cssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_awb_critical_csses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_awb_critical_csses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_awb_critical_csses.
     */
    distinct?: As_awb_critical_cssScalarFieldEnum | As_awb_critical_cssScalarFieldEnum[]
  }

  /**
   * as_awb_critical_css findFirstOrThrow
   */
  export type as_awb_critical_cssFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter, which as_awb_critical_css to fetch.
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_awb_critical_csses to fetch.
     */
    orderBy?:
      | as_awb_critical_cssOrderByWithRelationInput
      | as_awb_critical_cssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_awb_critical_csses.
     */
    cursor?: as_awb_critical_cssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_awb_critical_csses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_awb_critical_csses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_awb_critical_csses.
     */
    distinct?: As_awb_critical_cssScalarFieldEnum | As_awb_critical_cssScalarFieldEnum[]
  }

  /**
   * as_awb_critical_css findMany
   */
  export type as_awb_critical_cssFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter, which as_awb_critical_csses to fetch.
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_awb_critical_csses to fetch.
     */
    orderBy?:
      | as_awb_critical_cssOrderByWithRelationInput
      | as_awb_critical_cssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_awb_critical_csses.
     */
    cursor?: as_awb_critical_cssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_awb_critical_csses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_awb_critical_csses.
     */
    skip?: number
    distinct?: As_awb_critical_cssScalarFieldEnum | As_awb_critical_cssScalarFieldEnum[]
  }

  /**
   * as_awb_critical_css create
   */
  export type as_awb_critical_cssCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * The data needed to create a as_awb_critical_css.
     */
    data: XOR<as_awb_critical_cssCreateInput, as_awb_critical_cssUncheckedCreateInput>
  }

  /**
   * as_awb_critical_css createMany
   */
  export type as_awb_critical_cssCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_awb_critical_csses.
     */
    data: as_awb_critical_cssCreateManyInput | as_awb_critical_cssCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_awb_critical_css update
   */
  export type as_awb_critical_cssUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * The data needed to update a as_awb_critical_css.
     */
    data: XOR<as_awb_critical_cssUpdateInput, as_awb_critical_cssUncheckedUpdateInput>
    /**
     * Choose, which as_awb_critical_css to update.
     */
    where: as_awb_critical_cssWhereUniqueInput
  }

  /**
   * as_awb_critical_css updateMany
   */
  export type as_awb_critical_cssUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_awb_critical_csses.
     */
    data: XOR<
      as_awb_critical_cssUpdateManyMutationInput,
      as_awb_critical_cssUncheckedUpdateManyInput
    >
    /**
     * Filter which as_awb_critical_csses to update
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * Limit how many as_awb_critical_csses to update.
     */
    limit?: number
  }

  /**
   * as_awb_critical_css upsert
   */
  export type as_awb_critical_cssUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * The filter to search for the as_awb_critical_css to update in case it exists.
     */
    where: as_awb_critical_cssWhereUniqueInput
    /**
     * In case the as_awb_critical_css found by the `where` argument doesn't exist, create a new as_awb_critical_css with this data.
     */
    create: XOR<as_awb_critical_cssCreateInput, as_awb_critical_cssUncheckedCreateInput>
    /**
     * In case the as_awb_critical_css was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_awb_critical_cssUpdateInput, as_awb_critical_cssUncheckedUpdateInput>
  }

  /**
   * as_awb_critical_css delete
   */
  export type as_awb_critical_cssDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
    /**
     * Filter which as_awb_critical_css to delete.
     */
    where: as_awb_critical_cssWhereUniqueInput
  }

  /**
   * as_awb_critical_css deleteMany
   */
  export type as_awb_critical_cssDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_awb_critical_csses to delete
     */
    where?: as_awb_critical_cssWhereInput
    /**
     * Limit how many as_awb_critical_csses to delete.
     */
    limit?: number
  }

  /**
   * as_awb_critical_css without action
   */
  export type as_awb_critical_cssDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_awb_critical_css
     */
    select?: as_awb_critical_cssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_awb_critical_css
     */
    omit?: as_awb_critical_cssOmit<ExtArgs> | null
  }

  /**
   * Model as_cli_cookie_scan
   */

  export type AggregateAs_cli_cookie_scan = {
    _count: As_cli_cookie_scanCountAggregateOutputType | null
    _avg: As_cli_cookie_scanAvgAggregateOutputType | null
    _sum: As_cli_cookie_scanSumAggregateOutputType | null
    _min: As_cli_cookie_scanMinAggregateOutputType | null
    _max: As_cli_cookie_scanMaxAggregateOutputType | null
  }

  export type As_cli_cookie_scanAvgAggregateOutputType = {
    id_cli_cookie_scan: number | null
    status: number | null
    created_at: number | null
    total_url: number | null
    total_cookies: number | null
    current_offset: number | null
  }

  export type As_cli_cookie_scanSumAggregateOutputType = {
    id_cli_cookie_scan: number | null
    status: number | null
    created_at: number | null
    total_url: number | null
    total_cookies: number | null
    current_offset: number | null
  }

  export type As_cli_cookie_scanMinAggregateOutputType = {
    id_cli_cookie_scan: number | null
    status: number | null
    created_at: number | null
    total_url: number | null
    total_cookies: number | null
    current_action: string | null
    current_offset: number | null
  }

  export type As_cli_cookie_scanMaxAggregateOutputType = {
    id_cli_cookie_scan: number | null
    status: number | null
    created_at: number | null
    total_url: number | null
    total_cookies: number | null
    current_action: string | null
    current_offset: number | null
  }

  export type As_cli_cookie_scanCountAggregateOutputType = {
    id_cli_cookie_scan: number
    status: number
    created_at: number
    total_url: number
    total_cookies: number
    current_action: number
    current_offset: number
    _all: number
  }

  export type As_cli_cookie_scanAvgAggregateInputType = {
    id_cli_cookie_scan?: true
    status?: true
    created_at?: true
    total_url?: true
    total_cookies?: true
    current_offset?: true
  }

  export type As_cli_cookie_scanSumAggregateInputType = {
    id_cli_cookie_scan?: true
    status?: true
    created_at?: true
    total_url?: true
    total_cookies?: true
    current_offset?: true
  }

  export type As_cli_cookie_scanMinAggregateInputType = {
    id_cli_cookie_scan?: true
    status?: true
    created_at?: true
    total_url?: true
    total_cookies?: true
    current_action?: true
    current_offset?: true
  }

  export type As_cli_cookie_scanMaxAggregateInputType = {
    id_cli_cookie_scan?: true
    status?: true
    created_at?: true
    total_url?: true
    total_cookies?: true
    current_action?: true
    current_offset?: true
  }

  export type As_cli_cookie_scanCountAggregateInputType = {
    id_cli_cookie_scan?: true
    status?: true
    created_at?: true
    total_url?: true
    total_cookies?: true
    current_action?: true
    current_offset?: true
    _all?: true
  }

  export type As_cli_cookie_scanAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan to aggregate.
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scans to fetch.
     */
    orderBy?:
      | as_cli_cookie_scanOrderByWithRelationInput
      | as_cli_cookie_scanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_cli_cookie_scanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_cli_cookie_scans
     */
    _count?: true | As_cli_cookie_scanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_cli_cookie_scanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_cli_cookie_scanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_cli_cookie_scanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_cli_cookie_scanMaxAggregateInputType
  }

  export type GetAs_cli_cookie_scanAggregateType<T extends As_cli_cookie_scanAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_cli_cookie_scan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_cli_cookie_scan[P]>
      : GetScalarType<T[P], AggregateAs_cli_cookie_scan[P]>
  }

  export type as_cli_cookie_scanGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_cookie_scanWhereInput
    orderBy?:
      | as_cli_cookie_scanOrderByWithAggregationInput
      | as_cli_cookie_scanOrderByWithAggregationInput[]
    by: As_cli_cookie_scanScalarFieldEnum[] | As_cli_cookie_scanScalarFieldEnum
    having?: as_cli_cookie_scanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_cli_cookie_scanCountAggregateInputType | true
    _avg?: As_cli_cookie_scanAvgAggregateInputType
    _sum?: As_cli_cookie_scanSumAggregateInputType
    _min?: As_cli_cookie_scanMinAggregateInputType
    _max?: As_cli_cookie_scanMaxAggregateInputType
  }

  export type As_cli_cookie_scanGroupByOutputType = {
    id_cli_cookie_scan: number
    status: number
    created_at: number
    total_url: number
    total_cookies: number
    current_action: string
    current_offset: number
    _count: As_cli_cookie_scanCountAggregateOutputType | null
    _avg: As_cli_cookie_scanAvgAggregateOutputType | null
    _sum: As_cli_cookie_scanSumAggregateOutputType | null
    _min: As_cli_cookie_scanMinAggregateOutputType | null
    _max: As_cli_cookie_scanMaxAggregateOutputType | null
  }

  type GetAs_cli_cookie_scanGroupByPayload<T extends as_cli_cookie_scanGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_cli_cookie_scanGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_cli_cookie_scanGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_cli_cookie_scanGroupByOutputType[P]>
            : GetScalarType<T[P], As_cli_cookie_scanGroupByOutputType[P]>
        }
      >
    >

  export type as_cli_cookie_scanSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id_cli_cookie_scan?: boolean
      status?: boolean
      created_at?: boolean
      total_url?: boolean
      total_cookies?: boolean
      current_action?: boolean
      current_offset?: boolean
    },
    ExtArgs['result']['as_cli_cookie_scan']
  >

  export type as_cli_cookie_scanSelectScalar = {
    id_cli_cookie_scan?: boolean
    status?: boolean
    created_at?: boolean
    total_url?: boolean
    total_cookies?: boolean
    current_action?: boolean
    current_offset?: boolean
  }

  export type as_cli_cookie_scanOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id_cli_cookie_scan'
    | 'status'
    | 'created_at'
    | 'total_url'
    | 'total_cookies'
    | 'current_action'
    | 'current_offset',
    ExtArgs['result']['as_cli_cookie_scan']
  >

  export type $as_cli_cookie_scanPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_cli_cookie_scan'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id_cli_cookie_scan: number
        status: number
        created_at: number
        total_url: number
        total_cookies: number
        current_action: string
        current_offset: number
      },
      ExtArgs['result']['as_cli_cookie_scan']
    >
    composites: {}
  }

  type as_cli_cookie_scanGetPayload<
    S extends boolean | null | undefined | as_cli_cookie_scanDefaultArgs
  > = $Result.GetResult<Prisma.$as_cli_cookie_scanPayload, S>

  type as_cli_cookie_scanCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_cli_cookie_scanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_cli_cookie_scanCountAggregateInputType | true
  }

  export interface as_cli_cookie_scanDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_cli_cookie_scan']
      meta: { name: 'as_cli_cookie_scan' }
    }
    /**
     * Find zero or one As_cli_cookie_scan that matches the filter.
     * @param {as_cli_cookie_scanFindUniqueArgs} args - Arguments to find a As_cli_cookie_scan
     * @example
     * // Get one As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_cli_cookie_scanFindUniqueArgs>(
      args: SelectSubset<T, as_cli_cookie_scanFindUniqueArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scanPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_cli_cookie_scan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_cli_cookie_scanFindUniqueOrThrowArgs} args - Arguments to find a As_cli_cookie_scan
     * @example
     * // Get one As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_cli_cookie_scanFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_cli_cookie_scanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scanPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanFindFirstArgs} args - Arguments to find a As_cli_cookie_scan
     * @example
     * // Get one As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_cli_cookie_scanFindFirstArgs>(
      args?: SelectSubset<T, as_cli_cookie_scanFindFirstArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scanPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanFindFirstOrThrowArgs} args - Arguments to find a As_cli_cookie_scan
     * @example
     * // Get one As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_cli_cookie_scanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_cli_cookie_scanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scanPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_cli_cookie_scans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_cli_cookie_scans
     * const as_cli_cookie_scans = await prisma.as_cli_cookie_scan.findMany()
     *
     * // Get first 10 As_cli_cookie_scans
     * const as_cli_cookie_scans = await prisma.as_cli_cookie_scan.findMany({ take: 10 })
     *
     * // Only select the `id_cli_cookie_scan`
     * const as_cli_cookie_scanWithId_cli_cookie_scanOnly = await prisma.as_cli_cookie_scan.findMany({ select: { id_cli_cookie_scan: true } })
     *
     */
    findMany<T extends as_cli_cookie_scanFindManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scanPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_cli_cookie_scan.
     * @param {as_cli_cookie_scanCreateArgs} args - Arguments to create a As_cli_cookie_scan.
     * @example
     * // Create one As_cli_cookie_scan
     * const As_cli_cookie_scan = await prisma.as_cli_cookie_scan.create({
     *   data: {
     *     // ... data to create a As_cli_cookie_scan
     *   }
     * })
     *
     */
    create<T extends as_cli_cookie_scanCreateArgs>(
      args: SelectSubset<T, as_cli_cookie_scanCreateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<Prisma.$as_cli_cookie_scanPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_cli_cookie_scans.
     * @param {as_cli_cookie_scanCreateManyArgs} args - Arguments to create many As_cli_cookie_scans.
     * @example
     * // Create many As_cli_cookie_scans
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_cli_cookie_scanCreateManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_cli_cookie_scan.
     * @param {as_cli_cookie_scanDeleteArgs} args - Arguments to delete one As_cli_cookie_scan.
     * @example
     * // Delete one As_cli_cookie_scan
     * const As_cli_cookie_scan = await prisma.as_cli_cookie_scan.delete({
     *   where: {
     *     // ... filter to delete one As_cli_cookie_scan
     *   }
     * })
     *
     */
    delete<T extends as_cli_cookie_scanDeleteArgs>(
      args: SelectSubset<T, as_cli_cookie_scanDeleteArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<Prisma.$as_cli_cookie_scanPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_cli_cookie_scan.
     * @param {as_cli_cookie_scanUpdateArgs} args - Arguments to update one As_cli_cookie_scan.
     * @example
     * // Update one As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_cli_cookie_scanUpdateArgs>(
      args: SelectSubset<T, as_cli_cookie_scanUpdateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<Prisma.$as_cli_cookie_scanPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_cli_cookie_scans.
     * @param {as_cli_cookie_scanDeleteManyArgs} args - Arguments to filter As_cli_cookie_scans to delete.
     * @example
     * // Delete a few As_cli_cookie_scans
     * const { count } = await prisma.as_cli_cookie_scan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_cli_cookie_scanDeleteManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_cli_cookie_scans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_cli_cookie_scans
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_cli_cookie_scanUpdateManyArgs>(
      args: SelectSubset<T, as_cli_cookie_scanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_cli_cookie_scan.
     * @param {as_cli_cookie_scanUpsertArgs} args - Arguments to update or create a As_cli_cookie_scan.
     * @example
     * // Update or create a As_cli_cookie_scan
     * const as_cli_cookie_scan = await prisma.as_cli_cookie_scan.upsert({
     *   create: {
     *     // ... data to create a As_cli_cookie_scan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan we want to update
     *   }
     * })
     */
    upsert<T extends as_cli_cookie_scanUpsertArgs>(
      args: SelectSubset<T, as_cli_cookie_scanUpsertArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scanClient<
      $Result.GetResult<Prisma.$as_cli_cookie_scanPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_cli_cookie_scans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanCountArgs} args - Arguments to filter As_cli_cookie_scans to count.
     * @example
     * // Count the number of As_cli_cookie_scans
     * const count = await prisma.as_cli_cookie_scan.count({
     *   where: {
     *     // ... the filter for the As_cli_cookie_scans we want to count
     *   }
     * })
     */
    count<T extends as_cli_cookie_scanCountArgs>(
      args?: Subset<T, as_cli_cookie_scanCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_cli_cookie_scanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_cli_cookie_scan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_cli_cookie_scanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_cli_cookie_scanAggregateArgs>(
      args: Subset<T, As_cli_cookie_scanAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_cli_cookie_scanAggregateType<T>>

    /**
     * Group by As_cli_cookie_scan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_cli_cookie_scanGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_cli_cookie_scanGroupByArgs['orderBy'] }
        : { orderBy?: as_cli_cookie_scanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_cli_cookie_scanGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_cli_cookie_scanGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_cli_cookie_scan model
     */
    readonly fields: as_cli_cookie_scanFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_cli_cookie_scan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_cli_cookie_scanClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_cli_cookie_scan model
   */
  interface as_cli_cookie_scanFieldRefs {
    readonly id_cli_cookie_scan: FieldRef<'as_cli_cookie_scan', 'Int'>
    readonly status: FieldRef<'as_cli_cookie_scan', 'Int'>
    readonly created_at: FieldRef<'as_cli_cookie_scan', 'Int'>
    readonly total_url: FieldRef<'as_cli_cookie_scan', 'Int'>
    readonly total_cookies: FieldRef<'as_cli_cookie_scan', 'Int'>
    readonly current_action: FieldRef<'as_cli_cookie_scan', 'String'>
    readonly current_offset: FieldRef<'as_cli_cookie_scan', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_cli_cookie_scan findUnique
   */
  export type as_cli_cookie_scanFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan to fetch.
     */
    where: as_cli_cookie_scanWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan findUniqueOrThrow
   */
  export type as_cli_cookie_scanFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan to fetch.
     */
    where: as_cli_cookie_scanWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan findFirst
   */
  export type as_cli_cookie_scanFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan to fetch.
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scans to fetch.
     */
    orderBy?:
      | as_cli_cookie_scanOrderByWithRelationInput
      | as_cli_cookie_scanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scans.
     */
    cursor?: as_cli_cookie_scanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scans.
     */
    distinct?: As_cli_cookie_scanScalarFieldEnum | As_cli_cookie_scanScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan findFirstOrThrow
   */
  export type as_cli_cookie_scanFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan to fetch.
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scans to fetch.
     */
    orderBy?:
      | as_cli_cookie_scanOrderByWithRelationInput
      | as_cli_cookie_scanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scans.
     */
    cursor?: as_cli_cookie_scanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scans.
     */
    distinct?: As_cli_cookie_scanScalarFieldEnum | As_cli_cookie_scanScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan findMany
   */
  export type as_cli_cookie_scanFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scans to fetch.
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scans to fetch.
     */
    orderBy?:
      | as_cli_cookie_scanOrderByWithRelationInput
      | as_cli_cookie_scanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_cli_cookie_scans.
     */
    cursor?: as_cli_cookie_scanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scans.
     */
    skip?: number
    distinct?: As_cli_cookie_scanScalarFieldEnum | As_cli_cookie_scanScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan create
   */
  export type as_cli_cookie_scanCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * The data needed to create a as_cli_cookie_scan.
     */
    data: XOR<as_cli_cookie_scanCreateInput, as_cli_cookie_scanUncheckedCreateInput>
  }

  /**
   * as_cli_cookie_scan createMany
   */
  export type as_cli_cookie_scanCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_cli_cookie_scans.
     */
    data: as_cli_cookie_scanCreateManyInput | as_cli_cookie_scanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_cli_cookie_scan update
   */
  export type as_cli_cookie_scanUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * The data needed to update a as_cli_cookie_scan.
     */
    data: XOR<as_cli_cookie_scanUpdateInput, as_cli_cookie_scanUncheckedUpdateInput>
    /**
     * Choose, which as_cli_cookie_scan to update.
     */
    where: as_cli_cookie_scanWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan updateMany
   */
  export type as_cli_cookie_scanUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_cli_cookie_scans.
     */
    data: XOR<as_cli_cookie_scanUpdateManyMutationInput, as_cli_cookie_scanUncheckedUpdateManyInput>
    /**
     * Filter which as_cli_cookie_scans to update
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * Limit how many as_cli_cookie_scans to update.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan upsert
   */
  export type as_cli_cookie_scanUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * The filter to search for the as_cli_cookie_scan to update in case it exists.
     */
    where: as_cli_cookie_scanWhereUniqueInput
    /**
     * In case the as_cli_cookie_scan found by the `where` argument doesn't exist, create a new as_cli_cookie_scan with this data.
     */
    create: XOR<as_cli_cookie_scanCreateInput, as_cli_cookie_scanUncheckedCreateInput>
    /**
     * In case the as_cli_cookie_scan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_cli_cookie_scanUpdateInput, as_cli_cookie_scanUncheckedUpdateInput>
  }

  /**
   * as_cli_cookie_scan delete
   */
  export type as_cli_cookie_scanDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
    /**
     * Filter which as_cli_cookie_scan to delete.
     */
    where: as_cli_cookie_scanWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan deleteMany
   */
  export type as_cli_cookie_scanDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scans to delete
     */
    where?: as_cli_cookie_scanWhereInput
    /**
     * Limit how many as_cli_cookie_scans to delete.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan without action
   */
  export type as_cli_cookie_scanDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan
     */
    select?: as_cli_cookie_scanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan
     */
    omit?: as_cli_cookie_scanOmit<ExtArgs> | null
  }

  /**
   * Model as_cli_cookie_scan_categories
   */

  export type AggregateAs_cli_cookie_scan_categories = {
    _count: As_cli_cookie_scan_categoriesCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_categoriesAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_categoriesSumAggregateOutputType | null
    _min: As_cli_cookie_scan_categoriesMinAggregateOutputType | null
    _max: As_cli_cookie_scan_categoriesMaxAggregateOutputType | null
  }

  export type As_cli_cookie_scan_categoriesAvgAggregateOutputType = {
    id_cli_cookie_category: number | null
  }

  export type As_cli_cookie_scan_categoriesSumAggregateOutputType = {
    id_cli_cookie_category: number | null
  }

  export type As_cli_cookie_scan_categoriesMinAggregateOutputType = {
    id_cli_cookie_category: number | null
    cli_cookie_category_name: string | null
    cli_cookie_category_description: string | null
  }

  export type As_cli_cookie_scan_categoriesMaxAggregateOutputType = {
    id_cli_cookie_category: number | null
    cli_cookie_category_name: string | null
    cli_cookie_category_description: string | null
  }

  export type As_cli_cookie_scan_categoriesCountAggregateOutputType = {
    id_cli_cookie_category: number
    cli_cookie_category_name: number
    cli_cookie_category_description: number
    _all: number
  }

  export type As_cli_cookie_scan_categoriesAvgAggregateInputType = {
    id_cli_cookie_category?: true
  }

  export type As_cli_cookie_scan_categoriesSumAggregateInputType = {
    id_cli_cookie_category?: true
  }

  export type As_cli_cookie_scan_categoriesMinAggregateInputType = {
    id_cli_cookie_category?: true
    cli_cookie_category_name?: true
    cli_cookie_category_description?: true
  }

  export type As_cli_cookie_scan_categoriesMaxAggregateInputType = {
    id_cli_cookie_category?: true
    cli_cookie_category_name?: true
    cli_cookie_category_description?: true
  }

  export type As_cli_cookie_scan_categoriesCountAggregateInputType = {
    id_cli_cookie_category?: true
    cli_cookie_category_name?: true
    cli_cookie_category_description?: true
    _all?: true
  }

  export type As_cli_cookie_scan_categoriesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_categories to aggregate.
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_categories to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_cli_cookie_scan_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_cli_cookie_scan_categories
     */
    _count?: true | As_cli_cookie_scan_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_cli_cookie_scan_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_cli_cookie_scan_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_cli_cookie_scan_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_cli_cookie_scan_categoriesMaxAggregateInputType
  }

  export type GetAs_cli_cookie_scan_categoriesAggregateType<
    T extends As_cli_cookie_scan_categoriesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_cli_cookie_scan_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_cli_cookie_scan_categories[P]>
      : GetScalarType<T[P], AggregateAs_cli_cookie_scan_categories[P]>
  }

  export type as_cli_cookie_scan_categoriesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_cookie_scan_categoriesWhereInput
    orderBy?:
      | as_cli_cookie_scan_categoriesOrderByWithAggregationInput
      | as_cli_cookie_scan_categoriesOrderByWithAggregationInput[]
    by:
      | As_cli_cookie_scan_categoriesScalarFieldEnum[]
      | As_cli_cookie_scan_categoriesScalarFieldEnum
    having?: as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_cli_cookie_scan_categoriesCountAggregateInputType | true
    _avg?: As_cli_cookie_scan_categoriesAvgAggregateInputType
    _sum?: As_cli_cookie_scan_categoriesSumAggregateInputType
    _min?: As_cli_cookie_scan_categoriesMinAggregateInputType
    _max?: As_cli_cookie_scan_categoriesMaxAggregateInputType
  }

  export type As_cli_cookie_scan_categoriesGroupByOutputType = {
    id_cli_cookie_category: number
    cli_cookie_category_name: string
    cli_cookie_category_description: string | null
    _count: As_cli_cookie_scan_categoriesCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_categoriesAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_categoriesSumAggregateOutputType | null
    _min: As_cli_cookie_scan_categoriesMinAggregateOutputType | null
    _max: As_cli_cookie_scan_categoriesMaxAggregateOutputType | null
  }

  type GetAs_cli_cookie_scan_categoriesGroupByPayload<
    T extends as_cli_cookie_scan_categoriesGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_cli_cookie_scan_categoriesGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_cli_cookie_scan_categoriesGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_cli_cookie_scan_categoriesGroupByOutputType[P]>
          : GetScalarType<T[P], As_cli_cookie_scan_categoriesGroupByOutputType[P]>
      }
    >
  >

  export type as_cli_cookie_scan_categoriesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id_cli_cookie_category?: boolean
      cli_cookie_category_name?: boolean
      cli_cookie_category_description?: boolean
      as_cli_cookie_scan_cookies?:
        | boolean
        | as_cli_cookie_scan_categories$as_cli_cookie_scan_cookiesArgs<ExtArgs>
      _count?: boolean | As_cli_cookie_scan_categoriesCountOutputTypeDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['as_cli_cookie_scan_categories']
  >

  export type as_cli_cookie_scan_categoriesSelectScalar = {
    id_cli_cookie_category?: boolean
    cli_cookie_category_name?: boolean
    cli_cookie_category_description?: boolean
  }

  export type as_cli_cookie_scan_categoriesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id_cli_cookie_category' | 'cli_cookie_category_name' | 'cli_cookie_category_description',
    ExtArgs['result']['as_cli_cookie_scan_categories']
  >
  export type as_cli_cookie_scan_categoriesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    as_cli_cookie_scan_cookies?:
      | boolean
      | as_cli_cookie_scan_categories$as_cli_cookie_scan_cookiesArgs<ExtArgs>
    _count?: boolean | As_cli_cookie_scan_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $as_cli_cookie_scan_categoriesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_cli_cookie_scan_categories'
    objects: {
      as_cli_cookie_scan_cookies: Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id_cli_cookie_category: number
        cli_cookie_category_name: string
        cli_cookie_category_description: string | null
      },
      ExtArgs['result']['as_cli_cookie_scan_categories']
    >
    composites: {}
  }

  type as_cli_cookie_scan_categoriesGetPayload<
    S extends boolean | null | undefined | as_cli_cookie_scan_categoriesDefaultArgs
  > = $Result.GetResult<Prisma.$as_cli_cookie_scan_categoriesPayload, S>

  type as_cli_cookie_scan_categoriesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<
    as_cli_cookie_scan_categoriesFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: As_cli_cookie_scan_categoriesCountAggregateInputType | true
  }

  export interface as_cli_cookie_scan_categoriesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_cli_cookie_scan_categories']
      meta: { name: 'as_cli_cookie_scan_categories' }
    }
    /**
     * Find zero or one As_cli_cookie_scan_categories that matches the filter.
     * @param {as_cli_cookie_scan_categoriesFindUniqueArgs} args - Arguments to find a As_cli_cookie_scan_categories
     * @example
     * // Get one As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_cli_cookie_scan_categoriesFindUniqueArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_cli_cookie_scan_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_cli_cookie_scan_categoriesFindUniqueOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_categories
     * @example
     * // Get one As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_cli_cookie_scan_categoriesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesFindFirstArgs} args - Arguments to find a As_cli_cookie_scan_categories
     * @example
     * // Get one As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_cli_cookie_scan_categoriesFindFirstArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_categoriesFindFirstArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesFindFirstOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_categories
     * @example
     * // Get one As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_cli_cookie_scan_categoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_categoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_cli_cookie_scan_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findMany()
     *
     * // Get first 10 As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.findMany({ take: 10 })
     *
     * // Only select the `id_cli_cookie_category`
     * const as_cli_cookie_scan_categoriesWithId_cli_cookie_categoryOnly = await prisma.as_cli_cookie_scan_categories.findMany({ select: { id_cli_cookie_category: true } })
     *
     */
    findMany<T extends as_cli_cookie_scan_categoriesFindManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_categoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesCreateArgs} args - Arguments to create a As_cli_cookie_scan_categories.
     * @example
     * // Create one As_cli_cookie_scan_categories
     * const As_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.create({
     *   data: {
     *     // ... data to create a As_cli_cookie_scan_categories
     *   }
     * })
     *
     */
    create<T extends as_cli_cookie_scan_categoriesCreateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesCreateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesCreateManyArgs} args - Arguments to create many As_cli_cookie_scan_categories.
     * @example
     * // Create many As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_cli_cookie_scan_categoriesCreateManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_categoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesDeleteArgs} args - Arguments to delete one As_cli_cookie_scan_categories.
     * @example
     * // Delete one As_cli_cookie_scan_categories
     * const As_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.delete({
     *   where: {
     *     // ... filter to delete one As_cli_cookie_scan_categories
     *   }
     * })
     *
     */
    delete<T extends as_cli_cookie_scan_categoriesDeleteArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesDeleteArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesUpdateArgs} args - Arguments to update one As_cli_cookie_scan_categories.
     * @example
     * // Update one As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_cli_cookie_scan_categoriesUpdateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesUpdateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesDeleteManyArgs} args - Arguments to filter As_cli_cookie_scan_categories to delete.
     * @example
     * // Delete a few As_cli_cookie_scan_categories
     * const { count } = await prisma.as_cli_cookie_scan_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_cli_cookie_scan_categoriesDeleteManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_categoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_cli_cookie_scan_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_cli_cookie_scan_categoriesUpdateManyArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_cli_cookie_scan_categories.
     * @param {as_cli_cookie_scan_categoriesUpsertArgs} args - Arguments to update or create a As_cli_cookie_scan_categories.
     * @example
     * // Update or create a As_cli_cookie_scan_categories
     * const as_cli_cookie_scan_categories = await prisma.as_cli_cookie_scan_categories.upsert({
     *   create: {
     *     // ... data to create a As_cli_cookie_scan_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_categories we want to update
     *   }
     * })
     */
    upsert<T extends as_cli_cookie_scan_categoriesUpsertArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_categoriesUpsertArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_cli_cookie_scan_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesCountArgs} args - Arguments to filter As_cli_cookie_scan_categories to count.
     * @example
     * // Count the number of As_cli_cookie_scan_categories
     * const count = await prisma.as_cli_cookie_scan_categories.count({
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_categories we want to count
     *   }
     * })
     */
    count<T extends as_cli_cookie_scan_categoriesCountArgs>(
      args?: Subset<T, as_cli_cookie_scan_categoriesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_cli_cookie_scan_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_cli_cookie_scan_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_cli_cookie_scan_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_cli_cookie_scan_categoriesAggregateArgs>(
      args: Subset<T, As_cli_cookie_scan_categoriesAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_cli_cookie_scan_categoriesAggregateType<T>>

    /**
     * Group by As_cli_cookie_scan_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_cli_cookie_scan_categoriesGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_cli_cookie_scan_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: as_cli_cookie_scan_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_cli_cookie_scan_categoriesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAs_cli_cookie_scan_categoriesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_cli_cookie_scan_categories model
     */
    readonly fields: as_cli_cookie_scan_categoriesFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_cli_cookie_scan_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_cli_cookie_scan_categoriesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    as_cli_cookie_scan_cookies<
      T extends as_cli_cookie_scan_categories$as_cli_cookie_scan_cookiesArgs<ExtArgs> = {}
    >(
      args?: Subset<T, as_cli_cookie_scan_categories$as_cli_cookie_scan_cookiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_cli_cookie_scan_categories model
   */
  interface as_cli_cookie_scan_categoriesFieldRefs {
    readonly id_cli_cookie_category: FieldRef<'as_cli_cookie_scan_categories', 'Int'>
    readonly cli_cookie_category_name: FieldRef<'as_cli_cookie_scan_categories', 'String'>
    readonly cli_cookie_category_description: FieldRef<'as_cli_cookie_scan_categories', 'String'>
  }

  // Custom InputTypes
  /**
   * as_cli_cookie_scan_categories findUnique
   */
  export type as_cli_cookie_scan_categoriesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_categories to fetch.
     */
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_categories findUniqueOrThrow
   */
  export type as_cli_cookie_scan_categoriesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_categories to fetch.
     */
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_categories findFirst
   */
  export type as_cli_cookie_scan_categoriesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_categories to fetch.
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_categories to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_categories.
     */
    cursor?: as_cli_cookie_scan_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_categories.
     */
    distinct?:
      | As_cli_cookie_scan_categoriesScalarFieldEnum
      | As_cli_cookie_scan_categoriesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_categories findFirstOrThrow
   */
  export type as_cli_cookie_scan_categoriesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_categories to fetch.
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_categories to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_categories.
     */
    cursor?: as_cli_cookie_scan_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_categories.
     */
    distinct?:
      | As_cli_cookie_scan_categoriesScalarFieldEnum
      | As_cli_cookie_scan_categoriesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_categories findMany
   */
  export type as_cli_cookie_scan_categoriesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_categories to fetch.
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_categories to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput
      | as_cli_cookie_scan_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_cli_cookie_scan_categories.
     */
    cursor?: as_cli_cookie_scan_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_categories.
     */
    skip?: number
    distinct?:
      | As_cli_cookie_scan_categoriesScalarFieldEnum
      | As_cli_cookie_scan_categoriesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_categories create
   */
  export type as_cli_cookie_scan_categoriesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a as_cli_cookie_scan_categories.
     */
    data: XOR<
      as_cli_cookie_scan_categoriesCreateInput,
      as_cli_cookie_scan_categoriesUncheckedCreateInput
    >
  }

  /**
   * as_cli_cookie_scan_categories createMany
   */
  export type as_cli_cookie_scan_categoriesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_cli_cookie_scan_categories.
     */
    data:
      | as_cli_cookie_scan_categoriesCreateManyInput
      | as_cli_cookie_scan_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_cli_cookie_scan_categories update
   */
  export type as_cli_cookie_scan_categoriesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a as_cli_cookie_scan_categories.
     */
    data: XOR<
      as_cli_cookie_scan_categoriesUpdateInput,
      as_cli_cookie_scan_categoriesUncheckedUpdateInput
    >
    /**
     * Choose, which as_cli_cookie_scan_categories to update.
     */
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_categories updateMany
   */
  export type as_cli_cookie_scan_categoriesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_cli_cookie_scan_categories.
     */
    data: XOR<
      as_cli_cookie_scan_categoriesUpdateManyMutationInput,
      as_cli_cookie_scan_categoriesUncheckedUpdateManyInput
    >
    /**
     * Filter which as_cli_cookie_scan_categories to update
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * Limit how many as_cli_cookie_scan_categories to update.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_categories upsert
   */
  export type as_cli_cookie_scan_categoriesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the as_cli_cookie_scan_categories to update in case it exists.
     */
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
    /**
     * In case the as_cli_cookie_scan_categories found by the `where` argument doesn't exist, create a new as_cli_cookie_scan_categories with this data.
     */
    create: XOR<
      as_cli_cookie_scan_categoriesCreateInput,
      as_cli_cookie_scan_categoriesUncheckedCreateInput
    >
    /**
     * In case the as_cli_cookie_scan_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      as_cli_cookie_scan_categoriesUpdateInput,
      as_cli_cookie_scan_categoriesUncheckedUpdateInput
    >
  }

  /**
   * as_cli_cookie_scan_categories delete
   */
  export type as_cli_cookie_scan_categoriesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
    /**
     * Filter which as_cli_cookie_scan_categories to delete.
     */
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_categories deleteMany
   */
  export type as_cli_cookie_scan_categoriesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_categories to delete
     */
    where?: as_cli_cookie_scan_categoriesWhereInput
    /**
     * Limit how many as_cli_cookie_scan_categories to delete.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_categories.as_cli_cookie_scan_cookies
   */
  export type as_cli_cookie_scan_categories$as_cli_cookie_scan_cookiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    where?: as_cli_cookie_scan_cookiesWhereInput
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput[]
    cursor?: as_cli_cookie_scan_cookiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?:
      | As_cli_cookie_scan_cookiesScalarFieldEnum
      | As_cli_cookie_scan_cookiesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_categories without action
   */
  export type as_cli_cookie_scan_categoriesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_categories
     */
    select?: as_cli_cookie_scan_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_categories
     */
    omit?: as_cli_cookie_scan_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_categoriesInclude<ExtArgs> | null
  }

  /**
   * Model as_cli_cookie_scan_cookies
   */

  export type AggregateAs_cli_cookie_scan_cookies = {
    _count: As_cli_cookie_scan_cookiesCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_cookiesAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_cookiesSumAggregateOutputType | null
    _min: As_cli_cookie_scan_cookiesMinAggregateOutputType | null
    _max: As_cli_cookie_scan_cookiesMaxAggregateOutputType | null
  }

  export type As_cli_cookie_scan_cookiesAvgAggregateOutputType = {
    id_cli_cookie_scan_cookies: number | null
    id_cli_cookie_scan: number | null
    id_cli_cookie_scan_url: number | null
    category_id: number | null
  }

  export type As_cli_cookie_scan_cookiesSumAggregateOutputType = {
    id_cli_cookie_scan_cookies: number | null
    id_cli_cookie_scan: number | null
    id_cli_cookie_scan_url: number | null
    category_id: number | null
  }

  export type As_cli_cookie_scan_cookiesMinAggregateOutputType = {
    id_cli_cookie_scan_cookies: number | null
    id_cli_cookie_scan: number | null
    id_cli_cookie_scan_url: number | null
    cookie_id: string | null
    expiry: string | null
    type: string | null
    category: string | null
    category_id: number | null
    description: string | null
  }

  export type As_cli_cookie_scan_cookiesMaxAggregateOutputType = {
    id_cli_cookie_scan_cookies: number | null
    id_cli_cookie_scan: number | null
    id_cli_cookie_scan_url: number | null
    cookie_id: string | null
    expiry: string | null
    type: string | null
    category: string | null
    category_id: number | null
    description: string | null
  }

  export type As_cli_cookie_scan_cookiesCountAggregateOutputType = {
    id_cli_cookie_scan_cookies: number
    id_cli_cookie_scan: number
    id_cli_cookie_scan_url: number
    cookie_id: number
    expiry: number
    type: number
    category: number
    category_id: number
    description: number
    _all: number
  }

  export type As_cli_cookie_scan_cookiesAvgAggregateInputType = {
    id_cli_cookie_scan_cookies?: true
    id_cli_cookie_scan?: true
    id_cli_cookie_scan_url?: true
    category_id?: true
  }

  export type As_cli_cookie_scan_cookiesSumAggregateInputType = {
    id_cli_cookie_scan_cookies?: true
    id_cli_cookie_scan?: true
    id_cli_cookie_scan_url?: true
    category_id?: true
  }

  export type As_cli_cookie_scan_cookiesMinAggregateInputType = {
    id_cli_cookie_scan_cookies?: true
    id_cli_cookie_scan?: true
    id_cli_cookie_scan_url?: true
    cookie_id?: true
    expiry?: true
    type?: true
    category?: true
    category_id?: true
    description?: true
  }

  export type As_cli_cookie_scan_cookiesMaxAggregateInputType = {
    id_cli_cookie_scan_cookies?: true
    id_cli_cookie_scan?: true
    id_cli_cookie_scan_url?: true
    cookie_id?: true
    expiry?: true
    type?: true
    category?: true
    category_id?: true
    description?: true
  }

  export type As_cli_cookie_scan_cookiesCountAggregateInputType = {
    id_cli_cookie_scan_cookies?: true
    id_cli_cookie_scan?: true
    id_cli_cookie_scan_url?: true
    cookie_id?: true
    expiry?: true
    type?: true
    category?: true
    category_id?: true
    description?: true
    _all?: true
  }

  export type As_cli_cookie_scan_cookiesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_cookies to aggregate.
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_cookies to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_cli_cookie_scan_cookiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_cli_cookie_scan_cookies
     */
    _count?: true | As_cli_cookie_scan_cookiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_cli_cookie_scan_cookiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_cli_cookie_scan_cookiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_cli_cookie_scan_cookiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_cli_cookie_scan_cookiesMaxAggregateInputType
  }

  export type GetAs_cli_cookie_scan_cookiesAggregateType<
    T extends As_cli_cookie_scan_cookiesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_cli_cookie_scan_cookies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_cli_cookie_scan_cookies[P]>
      : GetScalarType<T[P], AggregateAs_cli_cookie_scan_cookies[P]>
  }

  export type as_cli_cookie_scan_cookiesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_cookie_scan_cookiesWhereInput
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithAggregationInput
      | as_cli_cookie_scan_cookiesOrderByWithAggregationInput[]
    by: As_cli_cookie_scan_cookiesScalarFieldEnum[] | As_cli_cookie_scan_cookiesScalarFieldEnum
    having?: as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_cli_cookie_scan_cookiesCountAggregateInputType | true
    _avg?: As_cli_cookie_scan_cookiesAvgAggregateInputType
    _sum?: As_cli_cookie_scan_cookiesSumAggregateInputType
    _min?: As_cli_cookie_scan_cookiesMinAggregateInputType
    _max?: As_cli_cookie_scan_cookiesMaxAggregateInputType
  }

  export type As_cli_cookie_scan_cookiesGroupByOutputType = {
    id_cli_cookie_scan_cookies: number
    id_cli_cookie_scan: number
    id_cli_cookie_scan_url: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    category_id: number
    description: string | null
    _count: As_cli_cookie_scan_cookiesCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_cookiesAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_cookiesSumAggregateOutputType | null
    _min: As_cli_cookie_scan_cookiesMinAggregateOutputType | null
    _max: As_cli_cookie_scan_cookiesMaxAggregateOutputType | null
  }

  type GetAs_cli_cookie_scan_cookiesGroupByPayload<
    T extends as_cli_cookie_scan_cookiesGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_cli_cookie_scan_cookiesGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_cli_cookie_scan_cookiesGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_cli_cookie_scan_cookiesGroupByOutputType[P]>
          : GetScalarType<T[P], As_cli_cookie_scan_cookiesGroupByOutputType[P]>
      }
    >
  >

  export type as_cli_cookie_scan_cookiesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id_cli_cookie_scan_cookies?: boolean
      id_cli_cookie_scan?: boolean
      id_cli_cookie_scan_url?: boolean
      cookie_id?: boolean
      expiry?: boolean
      type?: boolean
      category?: boolean
      category_id?: boolean
      description?: boolean
      as_cli_cookie_scan_categories?: boolean | as_cli_cookie_scan_categoriesDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['as_cli_cookie_scan_cookies']
  >

  export type as_cli_cookie_scan_cookiesSelectScalar = {
    id_cli_cookie_scan_cookies?: boolean
    id_cli_cookie_scan?: boolean
    id_cli_cookie_scan_url?: boolean
    cookie_id?: boolean
    expiry?: boolean
    type?: boolean
    category?: boolean
    category_id?: boolean
    description?: boolean
  }

  export type as_cli_cookie_scan_cookiesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id_cli_cookie_scan_cookies'
    | 'id_cli_cookie_scan'
    | 'id_cli_cookie_scan_url'
    | 'cookie_id'
    | 'expiry'
    | 'type'
    | 'category'
    | 'category_id'
    | 'description',
    ExtArgs['result']['as_cli_cookie_scan_cookies']
  >
  export type as_cli_cookie_scan_cookiesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    as_cli_cookie_scan_categories?: boolean | as_cli_cookie_scan_categoriesDefaultArgs<ExtArgs>
  }

  export type $as_cli_cookie_scan_cookiesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_cli_cookie_scan_cookies'
    objects: {
      as_cli_cookie_scan_categories: Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id_cli_cookie_scan_cookies: number
        id_cli_cookie_scan: number
        id_cli_cookie_scan_url: number
        cookie_id: string
        expiry: string
        type: string
        category: string
        category_id: number
        description: string | null
      },
      ExtArgs['result']['as_cli_cookie_scan_cookies']
    >
    composites: {}
  }

  type as_cli_cookie_scan_cookiesGetPayload<
    S extends boolean | null | undefined | as_cli_cookie_scan_cookiesDefaultArgs
  > = $Result.GetResult<Prisma.$as_cli_cookie_scan_cookiesPayload, S>

  type as_cli_cookie_scan_cookiesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_cli_cookie_scan_cookiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_cli_cookie_scan_cookiesCountAggregateInputType | true
  }

  export interface as_cli_cookie_scan_cookiesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_cli_cookie_scan_cookies']
      meta: { name: 'as_cli_cookie_scan_cookies' }
    }
    /**
     * Find zero or one As_cli_cookie_scan_cookies that matches the filter.
     * @param {as_cli_cookie_scan_cookiesFindUniqueArgs} args - Arguments to find a As_cli_cookie_scan_cookies
     * @example
     * // Get one As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_cli_cookie_scan_cookiesFindUniqueArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesFindUniqueArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_cli_cookie_scan_cookies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_cli_cookie_scan_cookiesFindUniqueOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_cookies
     * @example
     * // Get one As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_cli_cookie_scan_cookiesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_cookies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesFindFirstArgs} args - Arguments to find a As_cli_cookie_scan_cookies
     * @example
     * // Get one As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_cli_cookie_scan_cookiesFindFirstArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_cookiesFindFirstArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_cookies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesFindFirstOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_cookies
     * @example
     * // Get one As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_cli_cookie_scan_cookiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_cookiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_cli_cookie_scan_cookies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findMany()
     *
     * // Get first 10 As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.findMany({ take: 10 })
     *
     * // Only select the `id_cli_cookie_scan_cookies`
     * const as_cli_cookie_scan_cookiesWithId_cli_cookie_scan_cookiesOnly = await prisma.as_cli_cookie_scan_cookies.findMany({ select: { id_cli_cookie_scan_cookies: true } })
     *
     */
    findMany<T extends as_cli_cookie_scan_cookiesFindManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_cookiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesCreateArgs} args - Arguments to create a As_cli_cookie_scan_cookies.
     * @example
     * // Create one As_cli_cookie_scan_cookies
     * const As_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.create({
     *   data: {
     *     // ... data to create a As_cli_cookie_scan_cookies
     *   }
     * })
     *
     */
    create<T extends as_cli_cookie_scan_cookiesCreateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesCreateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesCreateManyArgs} args - Arguments to create many As_cli_cookie_scan_cookies.
     * @example
     * // Create many As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_cli_cookie_scan_cookiesCreateManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_cookiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesDeleteArgs} args - Arguments to delete one As_cli_cookie_scan_cookies.
     * @example
     * // Delete one As_cli_cookie_scan_cookies
     * const As_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.delete({
     *   where: {
     *     // ... filter to delete one As_cli_cookie_scan_cookies
     *   }
     * })
     *
     */
    delete<T extends as_cli_cookie_scan_cookiesDeleteArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesDeleteArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesUpdateArgs} args - Arguments to update one As_cli_cookie_scan_cookies.
     * @example
     * // Update one As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_cli_cookie_scan_cookiesUpdateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesUpdateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesDeleteManyArgs} args - Arguments to filter As_cli_cookie_scan_cookies to delete.
     * @example
     * // Delete a few As_cli_cookie_scan_cookies
     * const { count } = await prisma.as_cli_cookie_scan_cookies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_cli_cookie_scan_cookiesDeleteManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_cookiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_cli_cookie_scan_cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_cli_cookie_scan_cookiesUpdateManyArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_cli_cookie_scan_cookies.
     * @param {as_cli_cookie_scan_cookiesUpsertArgs} args - Arguments to update or create a As_cli_cookie_scan_cookies.
     * @example
     * // Update or create a As_cli_cookie_scan_cookies
     * const as_cli_cookie_scan_cookies = await prisma.as_cli_cookie_scan_cookies.upsert({
     *   create: {
     *     // ... data to create a As_cli_cookie_scan_cookies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_cookies we want to update
     *   }
     * })
     */
    upsert<T extends as_cli_cookie_scan_cookiesUpsertArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_cookiesUpsertArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_cookiesClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_cookiesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_cli_cookie_scan_cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesCountArgs} args - Arguments to filter As_cli_cookie_scan_cookies to count.
     * @example
     * // Count the number of As_cli_cookie_scan_cookies
     * const count = await prisma.as_cli_cookie_scan_cookies.count({
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_cookies we want to count
     *   }
     * })
     */
    count<T extends as_cli_cookie_scan_cookiesCountArgs>(
      args?: Subset<T, as_cli_cookie_scan_cookiesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_cli_cookie_scan_cookiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_cli_cookie_scan_cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_cli_cookie_scan_cookiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_cli_cookie_scan_cookiesAggregateArgs>(
      args: Subset<T, As_cli_cookie_scan_cookiesAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_cli_cookie_scan_cookiesAggregateType<T>>

    /**
     * Group by As_cli_cookie_scan_cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_cookiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_cli_cookie_scan_cookiesGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_cli_cookie_scan_cookiesGroupByArgs['orderBy'] }
        : { orderBy?: as_cli_cookie_scan_cookiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_cli_cookie_scan_cookiesGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_cli_cookie_scan_cookiesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_cli_cookie_scan_cookies model
     */
    readonly fields: as_cli_cookie_scan_cookiesFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_cli_cookie_scan_cookies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_cli_cookie_scan_cookiesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    as_cli_cookie_scan_categories<T extends as_cli_cookie_scan_categoriesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, as_cli_cookie_scan_categoriesDefaultArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_categoriesClient<
      | $Result.GetResult<
          Prisma.$as_cli_cookie_scan_categoriesPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_cli_cookie_scan_cookies model
   */
  interface as_cli_cookie_scan_cookiesFieldRefs {
    readonly id_cli_cookie_scan_cookies: FieldRef<'as_cli_cookie_scan_cookies', 'Int'>
    readonly id_cli_cookie_scan: FieldRef<'as_cli_cookie_scan_cookies', 'Int'>
    readonly id_cli_cookie_scan_url: FieldRef<'as_cli_cookie_scan_cookies', 'Int'>
    readonly cookie_id: FieldRef<'as_cli_cookie_scan_cookies', 'String'>
    readonly expiry: FieldRef<'as_cli_cookie_scan_cookies', 'String'>
    readonly type: FieldRef<'as_cli_cookie_scan_cookies', 'String'>
    readonly category: FieldRef<'as_cli_cookie_scan_cookies', 'String'>
    readonly category_id: FieldRef<'as_cli_cookie_scan_cookies', 'Int'>
    readonly description: FieldRef<'as_cli_cookie_scan_cookies', 'String'>
  }

  // Custom InputTypes
  /**
   * as_cli_cookie_scan_cookies findUnique
   */
  export type as_cli_cookie_scan_cookiesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_cookies to fetch.
     */
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_cookies findUniqueOrThrow
   */
  export type as_cli_cookie_scan_cookiesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_cookies to fetch.
     */
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_cookies findFirst
   */
  export type as_cli_cookie_scan_cookiesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_cookies to fetch.
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_cookies to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_cookies.
     */
    cursor?: as_cli_cookie_scan_cookiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_cookies.
     */
    distinct?:
      | As_cli_cookie_scan_cookiesScalarFieldEnum
      | As_cli_cookie_scan_cookiesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_cookies findFirstOrThrow
   */
  export type as_cli_cookie_scan_cookiesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_cookies to fetch.
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_cookies to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_cookies.
     */
    cursor?: as_cli_cookie_scan_cookiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_cookies.
     */
    distinct?:
      | As_cli_cookie_scan_cookiesScalarFieldEnum
      | As_cli_cookie_scan_cookiesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_cookies findMany
   */
  export type as_cli_cookie_scan_cookiesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_cookies to fetch.
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_cookies to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput
      | as_cli_cookie_scan_cookiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_cli_cookie_scan_cookies.
     */
    cursor?: as_cli_cookie_scan_cookiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_cookies.
     */
    skip?: number
    distinct?:
      | As_cli_cookie_scan_cookiesScalarFieldEnum
      | As_cli_cookie_scan_cookiesScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_cookies create
   */
  export type as_cli_cookie_scan_cookiesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * The data needed to create a as_cli_cookie_scan_cookies.
     */
    data: XOR<as_cli_cookie_scan_cookiesCreateInput, as_cli_cookie_scan_cookiesUncheckedCreateInput>
  }

  /**
   * as_cli_cookie_scan_cookies createMany
   */
  export type as_cli_cookie_scan_cookiesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_cli_cookie_scan_cookies.
     */
    data: as_cli_cookie_scan_cookiesCreateManyInput | as_cli_cookie_scan_cookiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_cli_cookie_scan_cookies update
   */
  export type as_cli_cookie_scan_cookiesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * The data needed to update a as_cli_cookie_scan_cookies.
     */
    data: XOR<as_cli_cookie_scan_cookiesUpdateInput, as_cli_cookie_scan_cookiesUncheckedUpdateInput>
    /**
     * Choose, which as_cli_cookie_scan_cookies to update.
     */
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_cookies updateMany
   */
  export type as_cli_cookie_scan_cookiesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_cli_cookie_scan_cookies.
     */
    data: XOR<
      as_cli_cookie_scan_cookiesUpdateManyMutationInput,
      as_cli_cookie_scan_cookiesUncheckedUpdateManyInput
    >
    /**
     * Filter which as_cli_cookie_scan_cookies to update
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * Limit how many as_cli_cookie_scan_cookies to update.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_cookies upsert
   */
  export type as_cli_cookie_scan_cookiesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * The filter to search for the as_cli_cookie_scan_cookies to update in case it exists.
     */
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
    /**
     * In case the as_cli_cookie_scan_cookies found by the `where` argument doesn't exist, create a new as_cli_cookie_scan_cookies with this data.
     */
    create: XOR<
      as_cli_cookie_scan_cookiesCreateInput,
      as_cli_cookie_scan_cookiesUncheckedCreateInput
    >
    /**
     * In case the as_cli_cookie_scan_cookies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      as_cli_cookie_scan_cookiesUpdateInput,
      as_cli_cookie_scan_cookiesUncheckedUpdateInput
    >
  }

  /**
   * as_cli_cookie_scan_cookies delete
   */
  export type as_cli_cookie_scan_cookiesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
    /**
     * Filter which as_cli_cookie_scan_cookies to delete.
     */
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_cookies deleteMany
   */
  export type as_cli_cookie_scan_cookiesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_cookies to delete
     */
    where?: as_cli_cookie_scan_cookiesWhereInput
    /**
     * Limit how many as_cli_cookie_scan_cookies to delete.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_cookies without action
   */
  export type as_cli_cookie_scan_cookiesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_cookies
     */
    select?: as_cli_cookie_scan_cookiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_cookies
     */
    omit?: as_cli_cookie_scan_cookiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: as_cli_cookie_scan_cookiesInclude<ExtArgs> | null
  }

  /**
   * Model as_cli_cookie_scan_url
   */

  export type AggregateAs_cli_cookie_scan_url = {
    _count: As_cli_cookie_scan_urlCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_urlAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_urlSumAggregateOutputType | null
    _min: As_cli_cookie_scan_urlMinAggregateOutputType | null
    _max: As_cli_cookie_scan_urlMaxAggregateOutputType | null
  }

  export type As_cli_cookie_scan_urlAvgAggregateOutputType = {
    id_cli_cookie_scan_url: number | null
    id_cli_cookie_scan: number | null
    scanned: number | null
    total_cookies: number | null
  }

  export type As_cli_cookie_scan_urlSumAggregateOutputType = {
    id_cli_cookie_scan_url: number | null
    id_cli_cookie_scan: number | null
    scanned: number | null
    total_cookies: number | null
  }

  export type As_cli_cookie_scan_urlMinAggregateOutputType = {
    id_cli_cookie_scan_url: number | null
    id_cli_cookie_scan: number | null
    url: string | null
    scanned: number | null
    total_cookies: number | null
  }

  export type As_cli_cookie_scan_urlMaxAggregateOutputType = {
    id_cli_cookie_scan_url: number | null
    id_cli_cookie_scan: number | null
    url: string | null
    scanned: number | null
    total_cookies: number | null
  }

  export type As_cli_cookie_scan_urlCountAggregateOutputType = {
    id_cli_cookie_scan_url: number
    id_cli_cookie_scan: number
    url: number
    scanned: number
    total_cookies: number
    _all: number
  }

  export type As_cli_cookie_scan_urlAvgAggregateInputType = {
    id_cli_cookie_scan_url?: true
    id_cli_cookie_scan?: true
    scanned?: true
    total_cookies?: true
  }

  export type As_cli_cookie_scan_urlSumAggregateInputType = {
    id_cli_cookie_scan_url?: true
    id_cli_cookie_scan?: true
    scanned?: true
    total_cookies?: true
  }

  export type As_cli_cookie_scan_urlMinAggregateInputType = {
    id_cli_cookie_scan_url?: true
    id_cli_cookie_scan?: true
    url?: true
    scanned?: true
    total_cookies?: true
  }

  export type As_cli_cookie_scan_urlMaxAggregateInputType = {
    id_cli_cookie_scan_url?: true
    id_cli_cookie_scan?: true
    url?: true
    scanned?: true
    total_cookies?: true
  }

  export type As_cli_cookie_scan_urlCountAggregateInputType = {
    id_cli_cookie_scan_url?: true
    id_cli_cookie_scan?: true
    url?: true
    scanned?: true
    total_cookies?: true
    _all?: true
  }

  export type As_cli_cookie_scan_urlAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_url to aggregate.
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_urls to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_urlOrderByWithRelationInput
      | as_cli_cookie_scan_urlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_cli_cookie_scan_urlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_urls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_urls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_cli_cookie_scan_urls
     */
    _count?: true | As_cli_cookie_scan_urlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_cli_cookie_scan_urlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_cli_cookie_scan_urlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_cli_cookie_scan_urlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_cli_cookie_scan_urlMaxAggregateInputType
  }

  export type GetAs_cli_cookie_scan_urlAggregateType<
    T extends As_cli_cookie_scan_urlAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_cli_cookie_scan_url]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_cli_cookie_scan_url[P]>
      : GetScalarType<T[P], AggregateAs_cli_cookie_scan_url[P]>
  }

  export type as_cli_cookie_scan_urlGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_cookie_scan_urlWhereInput
    orderBy?:
      | as_cli_cookie_scan_urlOrderByWithAggregationInput
      | as_cli_cookie_scan_urlOrderByWithAggregationInput[]
    by: As_cli_cookie_scan_urlScalarFieldEnum[] | As_cli_cookie_scan_urlScalarFieldEnum
    having?: as_cli_cookie_scan_urlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_cli_cookie_scan_urlCountAggregateInputType | true
    _avg?: As_cli_cookie_scan_urlAvgAggregateInputType
    _sum?: As_cli_cookie_scan_urlSumAggregateInputType
    _min?: As_cli_cookie_scan_urlMinAggregateInputType
    _max?: As_cli_cookie_scan_urlMaxAggregateInputType
  }

  export type As_cli_cookie_scan_urlGroupByOutputType = {
    id_cli_cookie_scan_url: number
    id_cli_cookie_scan: number
    url: string
    scanned: number
    total_cookies: number
    _count: As_cli_cookie_scan_urlCountAggregateOutputType | null
    _avg: As_cli_cookie_scan_urlAvgAggregateOutputType | null
    _sum: As_cli_cookie_scan_urlSumAggregateOutputType | null
    _min: As_cli_cookie_scan_urlMinAggregateOutputType | null
    _max: As_cli_cookie_scan_urlMaxAggregateOutputType | null
  }

  type GetAs_cli_cookie_scan_urlGroupByPayload<T extends as_cli_cookie_scan_urlGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_cli_cookie_scan_urlGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_cli_cookie_scan_urlGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_cli_cookie_scan_urlGroupByOutputType[P]>
            : GetScalarType<T[P], As_cli_cookie_scan_urlGroupByOutputType[P]>
        }
      >
    >

  export type as_cli_cookie_scan_urlSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id_cli_cookie_scan_url?: boolean
      id_cli_cookie_scan?: boolean
      url?: boolean
      scanned?: boolean
      total_cookies?: boolean
    },
    ExtArgs['result']['as_cli_cookie_scan_url']
  >

  export type as_cli_cookie_scan_urlSelectScalar = {
    id_cli_cookie_scan_url?: boolean
    id_cli_cookie_scan?: boolean
    url?: boolean
    scanned?: boolean
    total_cookies?: boolean
  }

  export type as_cli_cookie_scan_urlOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id_cli_cookie_scan_url' | 'id_cli_cookie_scan' | 'url' | 'scanned' | 'total_cookies',
    ExtArgs['result']['as_cli_cookie_scan_url']
  >

  export type $as_cli_cookie_scan_urlPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_cli_cookie_scan_url'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id_cli_cookie_scan_url: number
        id_cli_cookie_scan: number
        url: string
        scanned: number
        total_cookies: number
      },
      ExtArgs['result']['as_cli_cookie_scan_url']
    >
    composites: {}
  }

  type as_cli_cookie_scan_urlGetPayload<
    S extends boolean | null | undefined | as_cli_cookie_scan_urlDefaultArgs
  > = $Result.GetResult<Prisma.$as_cli_cookie_scan_urlPayload, S>

  type as_cli_cookie_scan_urlCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_cli_cookie_scan_urlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_cli_cookie_scan_urlCountAggregateInputType | true
  }

  export interface as_cli_cookie_scan_urlDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_cli_cookie_scan_url']
      meta: { name: 'as_cli_cookie_scan_url' }
    }
    /**
     * Find zero or one As_cli_cookie_scan_url that matches the filter.
     * @param {as_cli_cookie_scan_urlFindUniqueArgs} args - Arguments to find a As_cli_cookie_scan_url
     * @example
     * // Get one As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_cli_cookie_scan_urlFindUniqueArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlFindUniqueArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_cli_cookie_scan_url that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_cli_cookie_scan_urlFindUniqueOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_url
     * @example
     * // Get one As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_cli_cookie_scan_urlFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_url that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlFindFirstArgs} args - Arguments to find a As_cli_cookie_scan_url
     * @example
     * // Get one As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_cli_cookie_scan_urlFindFirstArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_urlFindFirstArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_cookie_scan_url that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlFindFirstOrThrowArgs} args - Arguments to find a As_cli_cookie_scan_url
     * @example
     * // Get one As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_cli_cookie_scan_urlFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_urlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_cli_cookie_scan_urls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_cli_cookie_scan_urls
     * const as_cli_cookie_scan_urls = await prisma.as_cli_cookie_scan_url.findMany()
     *
     * // Get first 10 As_cli_cookie_scan_urls
     * const as_cli_cookie_scan_urls = await prisma.as_cli_cookie_scan_url.findMany({ take: 10 })
     *
     * // Only select the `id_cli_cookie_scan_url`
     * const as_cli_cookie_scan_urlWithId_cli_cookie_scan_urlOnly = await prisma.as_cli_cookie_scan_url.findMany({ select: { id_cli_cookie_scan_url: true } })
     *
     */
    findMany<T extends as_cli_cookie_scan_urlFindManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_urlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_cli_cookie_scan_url.
     * @param {as_cli_cookie_scan_urlCreateArgs} args - Arguments to create a As_cli_cookie_scan_url.
     * @example
     * // Create one As_cli_cookie_scan_url
     * const As_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.create({
     *   data: {
     *     // ... data to create a As_cli_cookie_scan_url
     *   }
     * })
     *
     */
    create<T extends as_cli_cookie_scan_urlCreateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlCreateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_cli_cookie_scan_urls.
     * @param {as_cli_cookie_scan_urlCreateManyArgs} args - Arguments to create many As_cli_cookie_scan_urls.
     * @example
     * // Create many As_cli_cookie_scan_urls
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_cli_cookie_scan_urlCreateManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_urlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_cli_cookie_scan_url.
     * @param {as_cli_cookie_scan_urlDeleteArgs} args - Arguments to delete one As_cli_cookie_scan_url.
     * @example
     * // Delete one As_cli_cookie_scan_url
     * const As_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.delete({
     *   where: {
     *     // ... filter to delete one As_cli_cookie_scan_url
     *   }
     * })
     *
     */
    delete<T extends as_cli_cookie_scan_urlDeleteArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlDeleteArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_cli_cookie_scan_url.
     * @param {as_cli_cookie_scan_urlUpdateArgs} args - Arguments to update one As_cli_cookie_scan_url.
     * @example
     * // Update one As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_cli_cookie_scan_urlUpdateArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlUpdateArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_cli_cookie_scan_urls.
     * @param {as_cli_cookie_scan_urlDeleteManyArgs} args - Arguments to filter As_cli_cookie_scan_urls to delete.
     * @example
     * // Delete a few As_cli_cookie_scan_urls
     * const { count } = await prisma.as_cli_cookie_scan_url.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_cli_cookie_scan_urlDeleteManyArgs>(
      args?: SelectSubset<T, as_cli_cookie_scan_urlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_cli_cookie_scan_urls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_cli_cookie_scan_urls
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_cli_cookie_scan_urlUpdateManyArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_cli_cookie_scan_url.
     * @param {as_cli_cookie_scan_urlUpsertArgs} args - Arguments to update or create a As_cli_cookie_scan_url.
     * @example
     * // Update or create a As_cli_cookie_scan_url
     * const as_cli_cookie_scan_url = await prisma.as_cli_cookie_scan_url.upsert({
     *   create: {
     *     // ... data to create a As_cli_cookie_scan_url
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_url we want to update
     *   }
     * })
     */
    upsert<T extends as_cli_cookie_scan_urlUpsertArgs>(
      args: SelectSubset<T, as_cli_cookie_scan_urlUpsertArgs<ExtArgs>>
    ): Prisma__as_cli_cookie_scan_urlClient<
      $Result.GetResult<
        Prisma.$as_cli_cookie_scan_urlPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_cli_cookie_scan_urls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlCountArgs} args - Arguments to filter As_cli_cookie_scan_urls to count.
     * @example
     * // Count the number of As_cli_cookie_scan_urls
     * const count = await prisma.as_cli_cookie_scan_url.count({
     *   where: {
     *     // ... the filter for the As_cli_cookie_scan_urls we want to count
     *   }
     * })
     */
    count<T extends as_cli_cookie_scan_urlCountArgs>(
      args?: Subset<T, as_cli_cookie_scan_urlCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_cli_cookie_scan_urlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_cli_cookie_scan_url.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_cli_cookie_scan_urlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_cli_cookie_scan_urlAggregateArgs>(
      args: Subset<T, As_cli_cookie_scan_urlAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_cli_cookie_scan_urlAggregateType<T>>

    /**
     * Group by As_cli_cookie_scan_url.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_cookie_scan_urlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_cli_cookie_scan_urlGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_cli_cookie_scan_urlGroupByArgs['orderBy'] }
        : { orderBy?: as_cli_cookie_scan_urlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_cli_cookie_scan_urlGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_cli_cookie_scan_urlGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_cli_cookie_scan_url model
     */
    readonly fields: as_cli_cookie_scan_urlFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_cli_cookie_scan_url.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_cli_cookie_scan_urlClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_cli_cookie_scan_url model
   */
  interface as_cli_cookie_scan_urlFieldRefs {
    readonly id_cli_cookie_scan_url: FieldRef<'as_cli_cookie_scan_url', 'Int'>
    readonly id_cli_cookie_scan: FieldRef<'as_cli_cookie_scan_url', 'Int'>
    readonly url: FieldRef<'as_cli_cookie_scan_url', 'String'>
    readonly scanned: FieldRef<'as_cli_cookie_scan_url', 'Int'>
    readonly total_cookies: FieldRef<'as_cli_cookie_scan_url', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_cli_cookie_scan_url findUnique
   */
  export type as_cli_cookie_scan_urlFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_url to fetch.
     */
    where: as_cli_cookie_scan_urlWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_url findUniqueOrThrow
   */
  export type as_cli_cookie_scan_urlFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_url to fetch.
     */
    where: as_cli_cookie_scan_urlWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_url findFirst
   */
  export type as_cli_cookie_scan_urlFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_url to fetch.
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_urls to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_urlOrderByWithRelationInput
      | as_cli_cookie_scan_urlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_urls.
     */
    cursor?: as_cli_cookie_scan_urlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_urls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_urls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_urls.
     */
    distinct?: As_cli_cookie_scan_urlScalarFieldEnum | As_cli_cookie_scan_urlScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_url findFirstOrThrow
   */
  export type as_cli_cookie_scan_urlFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_url to fetch.
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_urls to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_urlOrderByWithRelationInput
      | as_cli_cookie_scan_urlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_cookie_scan_urls.
     */
    cursor?: as_cli_cookie_scan_urlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_urls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_urls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_cookie_scan_urls.
     */
    distinct?: As_cli_cookie_scan_urlScalarFieldEnum | As_cli_cookie_scan_urlScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_url findMany
   */
  export type as_cli_cookie_scan_urlFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_cookie_scan_urls to fetch.
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_cookie_scan_urls to fetch.
     */
    orderBy?:
      | as_cli_cookie_scan_urlOrderByWithRelationInput
      | as_cli_cookie_scan_urlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_cli_cookie_scan_urls.
     */
    cursor?: as_cli_cookie_scan_urlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_cookie_scan_urls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_cookie_scan_urls.
     */
    skip?: number
    distinct?: As_cli_cookie_scan_urlScalarFieldEnum | As_cli_cookie_scan_urlScalarFieldEnum[]
  }

  /**
   * as_cli_cookie_scan_url create
   */
  export type as_cli_cookie_scan_urlCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * The data needed to create a as_cli_cookie_scan_url.
     */
    data: XOR<as_cli_cookie_scan_urlCreateInput, as_cli_cookie_scan_urlUncheckedCreateInput>
  }

  /**
   * as_cli_cookie_scan_url createMany
   */
  export type as_cli_cookie_scan_urlCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_cli_cookie_scan_urls.
     */
    data: as_cli_cookie_scan_urlCreateManyInput | as_cli_cookie_scan_urlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_cli_cookie_scan_url update
   */
  export type as_cli_cookie_scan_urlUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * The data needed to update a as_cli_cookie_scan_url.
     */
    data: XOR<as_cli_cookie_scan_urlUpdateInput, as_cli_cookie_scan_urlUncheckedUpdateInput>
    /**
     * Choose, which as_cli_cookie_scan_url to update.
     */
    where: as_cli_cookie_scan_urlWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_url updateMany
   */
  export type as_cli_cookie_scan_urlUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_cli_cookie_scan_urls.
     */
    data: XOR<
      as_cli_cookie_scan_urlUpdateManyMutationInput,
      as_cli_cookie_scan_urlUncheckedUpdateManyInput
    >
    /**
     * Filter which as_cli_cookie_scan_urls to update
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * Limit how many as_cli_cookie_scan_urls to update.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_url upsert
   */
  export type as_cli_cookie_scan_urlUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * The filter to search for the as_cli_cookie_scan_url to update in case it exists.
     */
    where: as_cli_cookie_scan_urlWhereUniqueInput
    /**
     * In case the as_cli_cookie_scan_url found by the `where` argument doesn't exist, create a new as_cli_cookie_scan_url with this data.
     */
    create: XOR<as_cli_cookie_scan_urlCreateInput, as_cli_cookie_scan_urlUncheckedCreateInput>
    /**
     * In case the as_cli_cookie_scan_url was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_cli_cookie_scan_urlUpdateInput, as_cli_cookie_scan_urlUncheckedUpdateInput>
  }

  /**
   * as_cli_cookie_scan_url delete
   */
  export type as_cli_cookie_scan_urlDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
    /**
     * Filter which as_cli_cookie_scan_url to delete.
     */
    where: as_cli_cookie_scan_urlWhereUniqueInput
  }

  /**
   * as_cli_cookie_scan_url deleteMany
   */
  export type as_cli_cookie_scan_urlDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_cookie_scan_urls to delete
     */
    where?: as_cli_cookie_scan_urlWhereInput
    /**
     * Limit how many as_cli_cookie_scan_urls to delete.
     */
    limit?: number
  }

  /**
   * as_cli_cookie_scan_url without action
   */
  export type as_cli_cookie_scan_urlDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_cookie_scan_url
     */
    select?: as_cli_cookie_scan_urlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_cookie_scan_url
     */
    omit?: as_cli_cookie_scan_urlOmit<ExtArgs> | null
  }

  /**
   * Model as_cli_scripts
   */

  export type AggregateAs_cli_scripts = {
    _count: As_cli_scriptsCountAggregateOutputType | null
    _avg: As_cli_scriptsAvgAggregateOutputType | null
    _sum: As_cli_scriptsSumAggregateOutputType | null
    _min: As_cli_scriptsMinAggregateOutputType | null
    _max: As_cli_scriptsMaxAggregateOutputType | null
  }

  export type As_cli_scriptsAvgAggregateOutputType = {
    id: number | null
    cliscript_type: number | null
    type: number | null
  }

  export type As_cli_scriptsSumAggregateOutputType = {
    id: number | null
    cliscript_type: number | null
    type: number | null
  }

  export type As_cli_scriptsMinAggregateOutputType = {
    id: number | null
    cliscript_title: string | null
    cliscript_category: string | null
    cliscript_type: number | null
    cliscript_status: string | null
    cliscript_description: string | null
    cliscript_key: string | null
    type: number | null
  }

  export type As_cli_scriptsMaxAggregateOutputType = {
    id: number | null
    cliscript_title: string | null
    cliscript_category: string | null
    cliscript_type: number | null
    cliscript_status: string | null
    cliscript_description: string | null
    cliscript_key: string | null
    type: number | null
  }

  export type As_cli_scriptsCountAggregateOutputType = {
    id: number
    cliscript_title: number
    cliscript_category: number
    cliscript_type: number
    cliscript_status: number
    cliscript_description: number
    cliscript_key: number
    type: number
    _all: number
  }

  export type As_cli_scriptsAvgAggregateInputType = {
    id?: true
    cliscript_type?: true
    type?: true
  }

  export type As_cli_scriptsSumAggregateInputType = {
    id?: true
    cliscript_type?: true
    type?: true
  }

  export type As_cli_scriptsMinAggregateInputType = {
    id?: true
    cliscript_title?: true
    cliscript_category?: true
    cliscript_type?: true
    cliscript_status?: true
    cliscript_description?: true
    cliscript_key?: true
    type?: true
  }

  export type As_cli_scriptsMaxAggregateInputType = {
    id?: true
    cliscript_title?: true
    cliscript_category?: true
    cliscript_type?: true
    cliscript_status?: true
    cliscript_description?: true
    cliscript_key?: true
    type?: true
  }

  export type As_cli_scriptsCountAggregateInputType = {
    id?: true
    cliscript_title?: true
    cliscript_category?: true
    cliscript_type?: true
    cliscript_status?: true
    cliscript_description?: true
    cliscript_key?: true
    type?: true
    _all?: true
  }

  export type As_cli_scriptsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_scripts to aggregate.
     */
    where?: as_cli_scriptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_scripts to fetch.
     */
    orderBy?: as_cli_scriptsOrderByWithRelationInput | as_cli_scriptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_cli_scriptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_cli_scripts
     */
    _count?: true | As_cli_scriptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_cli_scriptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_cli_scriptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_cli_scriptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_cli_scriptsMaxAggregateInputType
  }

  export type GetAs_cli_scriptsAggregateType<T extends As_cli_scriptsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_cli_scripts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_cli_scripts[P]>
      : GetScalarType<T[P], AggregateAs_cli_scripts[P]>
  }

  export type as_cli_scriptsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_cli_scriptsWhereInput
    orderBy?:
      | as_cli_scriptsOrderByWithAggregationInput
      | as_cli_scriptsOrderByWithAggregationInput[]
    by: As_cli_scriptsScalarFieldEnum[] | As_cli_scriptsScalarFieldEnum
    having?: as_cli_scriptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_cli_scriptsCountAggregateInputType | true
    _avg?: As_cli_scriptsAvgAggregateInputType
    _sum?: As_cli_scriptsSumAggregateInputType
    _min?: As_cli_scriptsMinAggregateInputType
    _max?: As_cli_scriptsMaxAggregateInputType
  }

  export type As_cli_scriptsGroupByOutputType = {
    id: number
    cliscript_title: string
    cliscript_category: string
    cliscript_type: number | null
    cliscript_status: string
    cliscript_description: string
    cliscript_key: string
    type: number
    _count: As_cli_scriptsCountAggregateOutputType | null
    _avg: As_cli_scriptsAvgAggregateOutputType | null
    _sum: As_cli_scriptsSumAggregateOutputType | null
    _min: As_cli_scriptsMinAggregateOutputType | null
    _max: As_cli_scriptsMaxAggregateOutputType | null
  }

  type GetAs_cli_scriptsGroupByPayload<T extends as_cli_scriptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_cli_scriptsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_cli_scriptsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_cli_scriptsGroupByOutputType[P]>
          : GetScalarType<T[P], As_cli_scriptsGroupByOutputType[P]>
      }
    >
  >

  export type as_cli_scriptsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      cliscript_title?: boolean
      cliscript_category?: boolean
      cliscript_type?: boolean
      cliscript_status?: boolean
      cliscript_description?: boolean
      cliscript_key?: boolean
      type?: boolean
    },
    ExtArgs['result']['as_cli_scripts']
  >

  export type as_cli_scriptsSelectScalar = {
    id?: boolean
    cliscript_title?: boolean
    cliscript_category?: boolean
    cliscript_type?: boolean
    cliscript_status?: boolean
    cliscript_description?: boolean
    cliscript_key?: boolean
    type?: boolean
  }

  export type as_cli_scriptsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'cliscript_title'
    | 'cliscript_category'
    | 'cliscript_type'
    | 'cliscript_status'
    | 'cliscript_description'
    | 'cliscript_key'
    | 'type',
    ExtArgs['result']['as_cli_scripts']
  >

  export type $as_cli_scriptsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_cli_scripts'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        cliscript_title: string
        cliscript_category: string
        cliscript_type: number | null
        cliscript_status: string
        cliscript_description: string
        cliscript_key: string
        type: number
      },
      ExtArgs['result']['as_cli_scripts']
    >
    composites: {}
  }

  type as_cli_scriptsGetPayload<S extends boolean | null | undefined | as_cli_scriptsDefaultArgs> =
    $Result.GetResult<Prisma.$as_cli_scriptsPayload, S>

  type as_cli_scriptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_cli_scriptsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_cli_scriptsCountAggregateInputType | true
    }

  export interface as_cli_scriptsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_cli_scripts']
      meta: { name: 'as_cli_scripts' }
    }
    /**
     * Find zero or one As_cli_scripts that matches the filter.
     * @param {as_cli_scriptsFindUniqueArgs} args - Arguments to find a As_cli_scripts
     * @example
     * // Get one As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_cli_scriptsFindUniqueArgs>(
      args: SelectSubset<T, as_cli_scriptsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<
        Prisma.$as_cli_scriptsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_cli_scripts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_cli_scriptsFindUniqueOrThrowArgs} args - Arguments to find a As_cli_scripts
     * @example
     * // Get one As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_cli_scriptsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_cli_scriptsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<
        Prisma.$as_cli_scriptsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_scripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsFindFirstArgs} args - Arguments to find a As_cli_scripts
     * @example
     * // Get one As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_cli_scriptsFindFirstArgs>(
      args?: SelectSubset<T, as_cli_scriptsFindFirstArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<
        Prisma.$as_cli_scriptsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_cli_scripts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsFindFirstOrThrowArgs} args - Arguments to find a As_cli_scripts
     * @example
     * // Get one As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_cli_scriptsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_cli_scriptsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<
        Prisma.$as_cli_scriptsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_cli_scripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findMany()
     *
     * // Get first 10 As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_cli_scriptsWithIdOnly = await prisma.as_cli_scripts.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_cli_scriptsFindManyArgs>(
      args?: SelectSubset<T, as_cli_scriptsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_cli_scriptsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_cli_scripts.
     * @param {as_cli_scriptsCreateArgs} args - Arguments to create a As_cli_scripts.
     * @example
     * // Create one As_cli_scripts
     * const As_cli_scripts = await prisma.as_cli_scripts.create({
     *   data: {
     *     // ... data to create a As_cli_scripts
     *   }
     * })
     *
     */
    create<T extends as_cli_scriptsCreateArgs>(
      args: SelectSubset<T, as_cli_scriptsCreateArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<Prisma.$as_cli_scriptsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_cli_scripts.
     * @param {as_cli_scriptsCreateManyArgs} args - Arguments to create many As_cli_scripts.
     * @example
     * // Create many As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_cli_scriptsCreateManyArgs>(
      args?: SelectSubset<T, as_cli_scriptsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_cli_scripts.
     * @param {as_cli_scriptsDeleteArgs} args - Arguments to delete one As_cli_scripts.
     * @example
     * // Delete one As_cli_scripts
     * const As_cli_scripts = await prisma.as_cli_scripts.delete({
     *   where: {
     *     // ... filter to delete one As_cli_scripts
     *   }
     * })
     *
     */
    delete<T extends as_cli_scriptsDeleteArgs>(
      args: SelectSubset<T, as_cli_scriptsDeleteArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<Prisma.$as_cli_scriptsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_cli_scripts.
     * @param {as_cli_scriptsUpdateArgs} args - Arguments to update one As_cli_scripts.
     * @example
     * // Update one As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_cli_scriptsUpdateArgs>(
      args: SelectSubset<T, as_cli_scriptsUpdateArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<Prisma.$as_cli_scriptsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_cli_scripts.
     * @param {as_cli_scriptsDeleteManyArgs} args - Arguments to filter As_cli_scripts to delete.
     * @example
     * // Delete a few As_cli_scripts
     * const { count } = await prisma.as_cli_scripts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_cli_scriptsDeleteManyArgs>(
      args?: SelectSubset<T, as_cli_scriptsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_cli_scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_cli_scriptsUpdateManyArgs>(
      args: SelectSubset<T, as_cli_scriptsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_cli_scripts.
     * @param {as_cli_scriptsUpsertArgs} args - Arguments to update or create a As_cli_scripts.
     * @example
     * // Update or create a As_cli_scripts
     * const as_cli_scripts = await prisma.as_cli_scripts.upsert({
     *   create: {
     *     // ... data to create a As_cli_scripts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_cli_scripts we want to update
     *   }
     * })
     */
    upsert<T extends as_cli_scriptsUpsertArgs>(
      args: SelectSubset<T, as_cli_scriptsUpsertArgs<ExtArgs>>
    ): Prisma__as_cli_scriptsClient<
      $Result.GetResult<Prisma.$as_cli_scriptsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_cli_scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsCountArgs} args - Arguments to filter As_cli_scripts to count.
     * @example
     * // Count the number of As_cli_scripts
     * const count = await prisma.as_cli_scripts.count({
     *   where: {
     *     // ... the filter for the As_cli_scripts we want to count
     *   }
     * })
     */
    count<T extends as_cli_scriptsCountArgs>(
      args?: Subset<T, as_cli_scriptsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_cli_scriptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_cli_scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_cli_scriptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_cli_scriptsAggregateArgs>(
      args: Subset<T, As_cli_scriptsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_cli_scriptsAggregateType<T>>

    /**
     * Group by As_cli_scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_cli_scriptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_cli_scriptsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_cli_scriptsGroupByArgs['orderBy'] }
        : { orderBy?: as_cli_scriptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_cli_scriptsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_cli_scriptsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_cli_scripts model
     */
    readonly fields: as_cli_scriptsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_cli_scripts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_cli_scriptsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_cli_scripts model
   */
  interface as_cli_scriptsFieldRefs {
    readonly id: FieldRef<'as_cli_scripts', 'Int'>
    readonly cliscript_title: FieldRef<'as_cli_scripts', 'String'>
    readonly cliscript_category: FieldRef<'as_cli_scripts', 'String'>
    readonly cliscript_type: FieldRef<'as_cli_scripts', 'Int'>
    readonly cliscript_status: FieldRef<'as_cli_scripts', 'String'>
    readonly cliscript_description: FieldRef<'as_cli_scripts', 'String'>
    readonly cliscript_key: FieldRef<'as_cli_scripts', 'String'>
    readonly type: FieldRef<'as_cli_scripts', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_cli_scripts findUnique
   */
  export type as_cli_scriptsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_scripts to fetch.
     */
    where: as_cli_scriptsWhereUniqueInput
  }

  /**
   * as_cli_scripts findUniqueOrThrow
   */
  export type as_cli_scriptsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_scripts to fetch.
     */
    where: as_cli_scriptsWhereUniqueInput
  }

  /**
   * as_cli_scripts findFirst
   */
  export type as_cli_scriptsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_scripts to fetch.
     */
    where?: as_cli_scriptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_scripts to fetch.
     */
    orderBy?: as_cli_scriptsOrderByWithRelationInput | as_cli_scriptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_scripts.
     */
    cursor?: as_cli_scriptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_scripts.
     */
    distinct?: As_cli_scriptsScalarFieldEnum | As_cli_scriptsScalarFieldEnum[]
  }

  /**
   * as_cli_scripts findFirstOrThrow
   */
  export type as_cli_scriptsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_scripts to fetch.
     */
    where?: as_cli_scriptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_scripts to fetch.
     */
    orderBy?: as_cli_scriptsOrderByWithRelationInput | as_cli_scriptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_cli_scripts.
     */
    cursor?: as_cli_scriptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_cli_scripts.
     */
    distinct?: As_cli_scriptsScalarFieldEnum | As_cli_scriptsScalarFieldEnum[]
  }

  /**
   * as_cli_scripts findMany
   */
  export type as_cli_scriptsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter, which as_cli_scripts to fetch.
     */
    where?: as_cli_scriptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_cli_scripts to fetch.
     */
    orderBy?: as_cli_scriptsOrderByWithRelationInput | as_cli_scriptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_cli_scripts.
     */
    cursor?: as_cli_scriptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_cli_scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_cli_scripts.
     */
    skip?: number
    distinct?: As_cli_scriptsScalarFieldEnum | As_cli_scriptsScalarFieldEnum[]
  }

  /**
   * as_cli_scripts create
   */
  export type as_cli_scriptsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_cli_scripts.
     */
    data: XOR<as_cli_scriptsCreateInput, as_cli_scriptsUncheckedCreateInput>
  }

  /**
   * as_cli_scripts createMany
   */
  export type as_cli_scriptsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_cli_scripts.
     */
    data: as_cli_scriptsCreateManyInput | as_cli_scriptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_cli_scripts update
   */
  export type as_cli_scriptsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_cli_scripts.
     */
    data: XOR<as_cli_scriptsUpdateInput, as_cli_scriptsUncheckedUpdateInput>
    /**
     * Choose, which as_cli_scripts to update.
     */
    where: as_cli_scriptsWhereUniqueInput
  }

  /**
   * as_cli_scripts updateMany
   */
  export type as_cli_scriptsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_cli_scripts.
     */
    data: XOR<as_cli_scriptsUpdateManyMutationInput, as_cli_scriptsUncheckedUpdateManyInput>
    /**
     * Filter which as_cli_scripts to update
     */
    where?: as_cli_scriptsWhereInput
    /**
     * Limit how many as_cli_scripts to update.
     */
    limit?: number
  }

  /**
   * as_cli_scripts upsert
   */
  export type as_cli_scriptsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_cli_scripts to update in case it exists.
     */
    where: as_cli_scriptsWhereUniqueInput
    /**
     * In case the as_cli_scripts found by the `where` argument doesn't exist, create a new as_cli_scripts with this data.
     */
    create: XOR<as_cli_scriptsCreateInput, as_cli_scriptsUncheckedCreateInput>
    /**
     * In case the as_cli_scripts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_cli_scriptsUpdateInput, as_cli_scriptsUncheckedUpdateInput>
  }

  /**
   * as_cli_scripts delete
   */
  export type as_cli_scriptsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
    /**
     * Filter which as_cli_scripts to delete.
     */
    where: as_cli_scriptsWhereUniqueInput
  }

  /**
   * as_cli_scripts deleteMany
   */
  export type as_cli_scriptsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_cli_scripts to delete
     */
    where?: as_cli_scriptsWhereInput
    /**
     * Limit how many as_cli_scripts to delete.
     */
    limit?: number
  }

  /**
   * as_cli_scripts without action
   */
  export type as_cli_scriptsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_cli_scripts
     */
    select?: as_cli_scriptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_cli_scripts
     */
    omit?: as_cli_scriptsOmit<ExtArgs> | null
  }

  /**
   * Model as_commentmeta
   */

  export type AggregateAs_commentmeta = {
    _count: As_commentmetaCountAggregateOutputType | null
    _avg: As_commentmetaAvgAggregateOutputType | null
    _sum: As_commentmetaSumAggregateOutputType | null
    _min: As_commentmetaMinAggregateOutputType | null
    _max: As_commentmetaMaxAggregateOutputType | null
  }

  export type As_commentmetaAvgAggregateOutputType = {
    meta_id: number | null
    comment_id: number | null
  }

  export type As_commentmetaSumAggregateOutputType = {
    meta_id: bigint | null
    comment_id: bigint | null
  }

  export type As_commentmetaMinAggregateOutputType = {
    meta_id: bigint | null
    comment_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_commentmetaMaxAggregateOutputType = {
    meta_id: bigint | null
    comment_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_commentmetaCountAggregateOutputType = {
    meta_id: number
    comment_id: number
    meta_key: number
    meta_value: number
    _all: number
  }

  export type As_commentmetaAvgAggregateInputType = {
    meta_id?: true
    comment_id?: true
  }

  export type As_commentmetaSumAggregateInputType = {
    meta_id?: true
    comment_id?: true
  }

  export type As_commentmetaMinAggregateInputType = {
    meta_id?: true
    comment_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_commentmetaMaxAggregateInputType = {
    meta_id?: true
    comment_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_commentmetaCountAggregateInputType = {
    meta_id?: true
    comment_id?: true
    meta_key?: true
    meta_value?: true
    _all?: true
  }

  export type As_commentmetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_commentmeta to aggregate.
     */
    where?: as_commentmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_commentmetas to fetch.
     */
    orderBy?: as_commentmetaOrderByWithRelationInput | as_commentmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_commentmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_commentmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_commentmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_commentmetas
     */
    _count?: true | As_commentmetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_commentmetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_commentmetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_commentmetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_commentmetaMaxAggregateInputType
  }

  export type GetAs_commentmetaAggregateType<T extends As_commentmetaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_commentmeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_commentmeta[P]>
      : GetScalarType<T[P], AggregateAs_commentmeta[P]>
  }

  export type as_commentmetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_commentmetaWhereInput
    orderBy?:
      | as_commentmetaOrderByWithAggregationInput
      | as_commentmetaOrderByWithAggregationInput[]
    by: As_commentmetaScalarFieldEnum[] | As_commentmetaScalarFieldEnum
    having?: as_commentmetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_commentmetaCountAggregateInputType | true
    _avg?: As_commentmetaAvgAggregateInputType
    _sum?: As_commentmetaSumAggregateInputType
    _min?: As_commentmetaMinAggregateInputType
    _max?: As_commentmetaMaxAggregateInputType
  }

  export type As_commentmetaGroupByOutputType = {
    meta_id: bigint
    comment_id: bigint
    meta_key: string | null
    meta_value: string | null
    _count: As_commentmetaCountAggregateOutputType | null
    _avg: As_commentmetaAvgAggregateOutputType | null
    _sum: As_commentmetaSumAggregateOutputType | null
    _min: As_commentmetaMinAggregateOutputType | null
    _max: As_commentmetaMaxAggregateOutputType | null
  }

  type GetAs_commentmetaGroupByPayload<T extends as_commentmetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_commentmetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_commentmetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_commentmetaGroupByOutputType[P]>
          : GetScalarType<T[P], As_commentmetaGroupByOutputType[P]>
      }
    >
  >

  export type as_commentmetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      meta_id?: boolean
      comment_id?: boolean
      meta_key?: boolean
      meta_value?: boolean
    },
    ExtArgs['result']['as_commentmeta']
  >

  export type as_commentmetaSelectScalar = {
    meta_id?: boolean
    comment_id?: boolean
    meta_key?: boolean
    meta_value?: boolean
  }

  export type as_commentmetaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'meta_id' | 'comment_id' | 'meta_key' | 'meta_value',
    ExtArgs['result']['as_commentmeta']
  >

  export type $as_commentmetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_commentmeta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        meta_id: bigint
        comment_id: bigint
        meta_key: string | null
        meta_value: string | null
      },
      ExtArgs['result']['as_commentmeta']
    >
    composites: {}
  }

  type as_commentmetaGetPayload<S extends boolean | null | undefined | as_commentmetaDefaultArgs> =
    $Result.GetResult<Prisma.$as_commentmetaPayload, S>

  type as_commentmetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_commentmetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_commentmetaCountAggregateInputType | true
    }

  export interface as_commentmetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_commentmeta']
      meta: { name: 'as_commentmeta' }
    }
    /**
     * Find zero or one As_commentmeta that matches the filter.
     * @param {as_commentmetaFindUniqueArgs} args - Arguments to find a As_commentmeta
     * @example
     * // Get one As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_commentmetaFindUniqueArgs>(
      args: SelectSubset<T, as_commentmetaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<
        Prisma.$as_commentmetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_commentmeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_commentmetaFindUniqueOrThrowArgs} args - Arguments to find a As_commentmeta
     * @example
     * // Get one As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_commentmetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_commentmetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<
        Prisma.$as_commentmetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_commentmeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaFindFirstArgs} args - Arguments to find a As_commentmeta
     * @example
     * // Get one As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_commentmetaFindFirstArgs>(
      args?: SelectSubset<T, as_commentmetaFindFirstArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<
        Prisma.$as_commentmetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_commentmeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaFindFirstOrThrowArgs} args - Arguments to find a As_commentmeta
     * @example
     * // Get one As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_commentmetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_commentmetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<
        Prisma.$as_commentmetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_commentmetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_commentmetas
     * const as_commentmetas = await prisma.as_commentmeta.findMany()
     *
     * // Get first 10 As_commentmetas
     * const as_commentmetas = await prisma.as_commentmeta.findMany({ take: 10 })
     *
     * // Only select the `meta_id`
     * const as_commentmetaWithMeta_idOnly = await prisma.as_commentmeta.findMany({ select: { meta_id: true } })
     *
     */
    findMany<T extends as_commentmetaFindManyArgs>(
      args?: SelectSubset<T, as_commentmetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_commentmetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_commentmeta.
     * @param {as_commentmetaCreateArgs} args - Arguments to create a As_commentmeta.
     * @example
     * // Create one As_commentmeta
     * const As_commentmeta = await prisma.as_commentmeta.create({
     *   data: {
     *     // ... data to create a As_commentmeta
     *   }
     * })
     *
     */
    create<T extends as_commentmetaCreateArgs>(
      args: SelectSubset<T, as_commentmetaCreateArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<Prisma.$as_commentmetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_commentmetas.
     * @param {as_commentmetaCreateManyArgs} args - Arguments to create many As_commentmetas.
     * @example
     * // Create many As_commentmetas
     * const as_commentmeta = await prisma.as_commentmeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_commentmetaCreateManyArgs>(
      args?: SelectSubset<T, as_commentmetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_commentmeta.
     * @param {as_commentmetaDeleteArgs} args - Arguments to delete one As_commentmeta.
     * @example
     * // Delete one As_commentmeta
     * const As_commentmeta = await prisma.as_commentmeta.delete({
     *   where: {
     *     // ... filter to delete one As_commentmeta
     *   }
     * })
     *
     */
    delete<T extends as_commentmetaDeleteArgs>(
      args: SelectSubset<T, as_commentmetaDeleteArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<Prisma.$as_commentmetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_commentmeta.
     * @param {as_commentmetaUpdateArgs} args - Arguments to update one As_commentmeta.
     * @example
     * // Update one As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_commentmetaUpdateArgs>(
      args: SelectSubset<T, as_commentmetaUpdateArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<Prisma.$as_commentmetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_commentmetas.
     * @param {as_commentmetaDeleteManyArgs} args - Arguments to filter As_commentmetas to delete.
     * @example
     * // Delete a few As_commentmetas
     * const { count } = await prisma.as_commentmeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_commentmetaDeleteManyArgs>(
      args?: SelectSubset<T, as_commentmetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_commentmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_commentmetas
     * const as_commentmeta = await prisma.as_commentmeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_commentmetaUpdateManyArgs>(
      args: SelectSubset<T, as_commentmetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_commentmeta.
     * @param {as_commentmetaUpsertArgs} args - Arguments to update or create a As_commentmeta.
     * @example
     * // Update or create a As_commentmeta
     * const as_commentmeta = await prisma.as_commentmeta.upsert({
     *   create: {
     *     // ... data to create a As_commentmeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_commentmeta we want to update
     *   }
     * })
     */
    upsert<T extends as_commentmetaUpsertArgs>(
      args: SelectSubset<T, as_commentmetaUpsertArgs<ExtArgs>>
    ): Prisma__as_commentmetaClient<
      $Result.GetResult<Prisma.$as_commentmetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_commentmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaCountArgs} args - Arguments to filter As_commentmetas to count.
     * @example
     * // Count the number of As_commentmetas
     * const count = await prisma.as_commentmeta.count({
     *   where: {
     *     // ... the filter for the As_commentmetas we want to count
     *   }
     * })
     */
    count<T extends as_commentmetaCountArgs>(
      args?: Subset<T, as_commentmetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_commentmetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_commentmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_commentmetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_commentmetaAggregateArgs>(
      args: Subset<T, As_commentmetaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_commentmetaAggregateType<T>>

    /**
     * Group by As_commentmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentmetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_commentmetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_commentmetaGroupByArgs['orderBy'] }
        : { orderBy?: as_commentmetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_commentmetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_commentmetaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_commentmeta model
     */
    readonly fields: as_commentmetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_commentmeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_commentmetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_commentmeta model
   */
  interface as_commentmetaFieldRefs {
    readonly meta_id: FieldRef<'as_commentmeta', 'BigInt'>
    readonly comment_id: FieldRef<'as_commentmeta', 'BigInt'>
    readonly meta_key: FieldRef<'as_commentmeta', 'String'>
    readonly meta_value: FieldRef<'as_commentmeta', 'String'>
  }

  // Custom InputTypes
  /**
   * as_commentmeta findUnique
   */
  export type as_commentmetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_commentmeta to fetch.
     */
    where: as_commentmetaWhereUniqueInput
  }

  /**
   * as_commentmeta findUniqueOrThrow
   */
  export type as_commentmetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_commentmeta to fetch.
     */
    where: as_commentmetaWhereUniqueInput
  }

  /**
   * as_commentmeta findFirst
   */
  export type as_commentmetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_commentmeta to fetch.
     */
    where?: as_commentmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_commentmetas to fetch.
     */
    orderBy?: as_commentmetaOrderByWithRelationInput | as_commentmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_commentmetas.
     */
    cursor?: as_commentmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_commentmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_commentmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_commentmetas.
     */
    distinct?: As_commentmetaScalarFieldEnum | As_commentmetaScalarFieldEnum[]
  }

  /**
   * as_commentmeta findFirstOrThrow
   */
  export type as_commentmetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_commentmeta to fetch.
     */
    where?: as_commentmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_commentmetas to fetch.
     */
    orderBy?: as_commentmetaOrderByWithRelationInput | as_commentmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_commentmetas.
     */
    cursor?: as_commentmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_commentmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_commentmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_commentmetas.
     */
    distinct?: As_commentmetaScalarFieldEnum | As_commentmetaScalarFieldEnum[]
  }

  /**
   * as_commentmeta findMany
   */
  export type as_commentmetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_commentmetas to fetch.
     */
    where?: as_commentmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_commentmetas to fetch.
     */
    orderBy?: as_commentmetaOrderByWithRelationInput | as_commentmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_commentmetas.
     */
    cursor?: as_commentmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_commentmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_commentmetas.
     */
    skip?: number
    distinct?: As_commentmetaScalarFieldEnum | As_commentmetaScalarFieldEnum[]
  }

  /**
   * as_commentmeta create
   */
  export type as_commentmetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_commentmeta.
     */
    data?: XOR<as_commentmetaCreateInput, as_commentmetaUncheckedCreateInput>
  }

  /**
   * as_commentmeta createMany
   */
  export type as_commentmetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_commentmetas.
     */
    data: as_commentmetaCreateManyInput | as_commentmetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_commentmeta update
   */
  export type as_commentmetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_commentmeta.
     */
    data: XOR<as_commentmetaUpdateInput, as_commentmetaUncheckedUpdateInput>
    /**
     * Choose, which as_commentmeta to update.
     */
    where: as_commentmetaWhereUniqueInput
  }

  /**
   * as_commentmeta updateMany
   */
  export type as_commentmetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_commentmetas.
     */
    data: XOR<as_commentmetaUpdateManyMutationInput, as_commentmetaUncheckedUpdateManyInput>
    /**
     * Filter which as_commentmetas to update
     */
    where?: as_commentmetaWhereInput
    /**
     * Limit how many as_commentmetas to update.
     */
    limit?: number
  }

  /**
   * as_commentmeta upsert
   */
  export type as_commentmetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_commentmeta to update in case it exists.
     */
    where: as_commentmetaWhereUniqueInput
    /**
     * In case the as_commentmeta found by the `where` argument doesn't exist, create a new as_commentmeta with this data.
     */
    create: XOR<as_commentmetaCreateInput, as_commentmetaUncheckedCreateInput>
    /**
     * In case the as_commentmeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_commentmetaUpdateInput, as_commentmetaUncheckedUpdateInput>
  }

  /**
   * as_commentmeta delete
   */
  export type as_commentmetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
    /**
     * Filter which as_commentmeta to delete.
     */
    where: as_commentmetaWhereUniqueInput
  }

  /**
   * as_commentmeta deleteMany
   */
  export type as_commentmetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_commentmetas to delete
     */
    where?: as_commentmetaWhereInput
    /**
     * Limit how many as_commentmetas to delete.
     */
    limit?: number
  }

  /**
   * as_commentmeta without action
   */
  export type as_commentmetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_commentmeta
     */
    select?: as_commentmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_commentmeta
     */
    omit?: as_commentmetaOmit<ExtArgs> | null
  }

  /**
   * Model as_comments
   */

  export type AggregateAs_comments = {
    _count: As_commentsCountAggregateOutputType | null
    _avg: As_commentsAvgAggregateOutputType | null
    _sum: As_commentsSumAggregateOutputType | null
    _min: As_commentsMinAggregateOutputType | null
    _max: As_commentsMaxAggregateOutputType | null
  }

  export type As_commentsAvgAggregateOutputType = {
    comment_ID: number | null
    comment_post_ID: number | null
    comment_karma: number | null
    comment_parent: number | null
    user_id: number | null
  }

  export type As_commentsSumAggregateOutputType = {
    comment_ID: bigint | null
    comment_post_ID: bigint | null
    comment_karma: number | null
    comment_parent: bigint | null
    user_id: bigint | null
  }

  export type As_commentsMinAggregateOutputType = {
    comment_ID: bigint | null
    comment_post_ID: bigint | null
    comment_author: string | null
    comment_author_email: string | null
    comment_author_url: string | null
    comment_author_IP: string | null
    comment_date: Date | null
    comment_date_gmt: Date | null
    comment_content: string | null
    comment_karma: number | null
    comment_approved: string | null
    comment_agent: string | null
    comment_type: string | null
    comment_parent: bigint | null
    user_id: bigint | null
  }

  export type As_commentsMaxAggregateOutputType = {
    comment_ID: bigint | null
    comment_post_ID: bigint | null
    comment_author: string | null
    comment_author_email: string | null
    comment_author_url: string | null
    comment_author_IP: string | null
    comment_date: Date | null
    comment_date_gmt: Date | null
    comment_content: string | null
    comment_karma: number | null
    comment_approved: string | null
    comment_agent: string | null
    comment_type: string | null
    comment_parent: bigint | null
    user_id: bigint | null
  }

  export type As_commentsCountAggregateOutputType = {
    comment_ID: number
    comment_post_ID: number
    comment_author: number
    comment_author_email: number
    comment_author_url: number
    comment_author_IP: number
    comment_date: number
    comment_date_gmt: number
    comment_content: number
    comment_karma: number
    comment_approved: number
    comment_agent: number
    comment_type: number
    comment_parent: number
    user_id: number
    _all: number
  }

  export type As_commentsAvgAggregateInputType = {
    comment_ID?: true
    comment_post_ID?: true
    comment_karma?: true
    comment_parent?: true
    user_id?: true
  }

  export type As_commentsSumAggregateInputType = {
    comment_ID?: true
    comment_post_ID?: true
    comment_karma?: true
    comment_parent?: true
    user_id?: true
  }

  export type As_commentsMinAggregateInputType = {
    comment_ID?: true
    comment_post_ID?: true
    comment_author?: true
    comment_author_email?: true
    comment_author_url?: true
    comment_author_IP?: true
    comment_date?: true
    comment_date_gmt?: true
    comment_content?: true
    comment_karma?: true
    comment_approved?: true
    comment_agent?: true
    comment_type?: true
    comment_parent?: true
    user_id?: true
  }

  export type As_commentsMaxAggregateInputType = {
    comment_ID?: true
    comment_post_ID?: true
    comment_author?: true
    comment_author_email?: true
    comment_author_url?: true
    comment_author_IP?: true
    comment_date?: true
    comment_date_gmt?: true
    comment_content?: true
    comment_karma?: true
    comment_approved?: true
    comment_agent?: true
    comment_type?: true
    comment_parent?: true
    user_id?: true
  }

  export type As_commentsCountAggregateInputType = {
    comment_ID?: true
    comment_post_ID?: true
    comment_author?: true
    comment_author_email?: true
    comment_author_url?: true
    comment_author_IP?: true
    comment_date?: true
    comment_date_gmt?: true
    comment_content?: true
    comment_karma?: true
    comment_approved?: true
    comment_agent?: true
    comment_type?: true
    comment_parent?: true
    user_id?: true
    _all?: true
  }

  export type As_commentsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_comments to aggregate.
     */
    where?: as_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_comments to fetch.
     */
    orderBy?: as_commentsOrderByWithRelationInput | as_commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_comments
     */
    _count?: true | As_commentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_commentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_commentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_commentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_commentsMaxAggregateInputType
  }

  export type GetAs_commentsAggregateType<T extends As_commentsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_comments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_comments[P]>
      : GetScalarType<T[P], AggregateAs_comments[P]>
  }

  export type as_commentsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_commentsWhereInput
    orderBy?: as_commentsOrderByWithAggregationInput | as_commentsOrderByWithAggregationInput[]
    by: As_commentsScalarFieldEnum[] | As_commentsScalarFieldEnum
    having?: as_commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_commentsCountAggregateInputType | true
    _avg?: As_commentsAvgAggregateInputType
    _sum?: As_commentsSumAggregateInputType
    _min?: As_commentsMinAggregateInputType
    _max?: As_commentsMaxAggregateInputType
  }

  export type As_commentsGroupByOutputType = {
    comment_ID: bigint
    comment_post_ID: bigint
    comment_author: string
    comment_author_email: string
    comment_author_url: string
    comment_author_IP: string
    comment_date: Date
    comment_date_gmt: Date
    comment_content: string
    comment_karma: number
    comment_approved: string
    comment_agent: string
    comment_type: string
    comment_parent: bigint
    user_id: bigint
    _count: As_commentsCountAggregateOutputType | null
    _avg: As_commentsAvgAggregateOutputType | null
    _sum: As_commentsSumAggregateOutputType | null
    _min: As_commentsMinAggregateOutputType | null
    _max: As_commentsMaxAggregateOutputType | null
  }

  type GetAs_commentsGroupByPayload<T extends as_commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_commentsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_commentsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_commentsGroupByOutputType[P]>
          : GetScalarType<T[P], As_commentsGroupByOutputType[P]>
      }
    >
  >

  export type as_commentsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      comment_ID?: boolean
      comment_post_ID?: boolean
      comment_author?: boolean
      comment_author_email?: boolean
      comment_author_url?: boolean
      comment_author_IP?: boolean
      comment_date?: boolean
      comment_date_gmt?: boolean
      comment_content?: boolean
      comment_karma?: boolean
      comment_approved?: boolean
      comment_agent?: boolean
      comment_type?: boolean
      comment_parent?: boolean
      user_id?: boolean
    },
    ExtArgs['result']['as_comments']
  >

  export type as_commentsSelectScalar = {
    comment_ID?: boolean
    comment_post_ID?: boolean
    comment_author?: boolean
    comment_author_email?: boolean
    comment_author_url?: boolean
    comment_author_IP?: boolean
    comment_date?: boolean
    comment_date_gmt?: boolean
    comment_content?: boolean
    comment_karma?: boolean
    comment_approved?: boolean
    comment_agent?: boolean
    comment_type?: boolean
    comment_parent?: boolean
    user_id?: boolean
  }

  export type as_commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'comment_ID'
      | 'comment_post_ID'
      | 'comment_author'
      | 'comment_author_email'
      | 'comment_author_url'
      | 'comment_author_IP'
      | 'comment_date'
      | 'comment_date_gmt'
      | 'comment_content'
      | 'comment_karma'
      | 'comment_approved'
      | 'comment_agent'
      | 'comment_type'
      | 'comment_parent'
      | 'user_id',
      ExtArgs['result']['as_comments']
    >

  export type $as_commentsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_comments'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        comment_ID: bigint
        comment_post_ID: bigint
        comment_author: string
        comment_author_email: string
        comment_author_url: string
        comment_author_IP: string
        comment_date: Date
        comment_date_gmt: Date
        comment_content: string
        comment_karma: number
        comment_approved: string
        comment_agent: string
        comment_type: string
        comment_parent: bigint
        user_id: bigint
      },
      ExtArgs['result']['as_comments']
    >
    composites: {}
  }

  type as_commentsGetPayload<S extends boolean | null | undefined | as_commentsDefaultArgs> =
    $Result.GetResult<Prisma.$as_commentsPayload, S>

  type as_commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_commentsCountAggregateInputType | true
    }

  export interface as_commentsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_comments']
      meta: { name: 'as_comments' }
    }
    /**
     * Find zero or one As_comments that matches the filter.
     * @param {as_commentsFindUniqueArgs} args - Arguments to find a As_comments
     * @example
     * // Get one As_comments
     * const as_comments = await prisma.as_comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_commentsFindUniqueArgs>(
      args: SelectSubset<T, as_commentsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<
        Prisma.$as_commentsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_commentsFindUniqueOrThrowArgs} args - Arguments to find a As_comments
     * @example
     * // Get one As_comments
     * const as_comments = await prisma.as_comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_commentsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<
        Prisma.$as_commentsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsFindFirstArgs} args - Arguments to find a As_comments
     * @example
     * // Get one As_comments
     * const as_comments = await prisma.as_comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_commentsFindFirstArgs>(
      args?: SelectSubset<T, as_commentsFindFirstArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<
        Prisma.$as_commentsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsFindFirstOrThrowArgs} args - Arguments to find a As_comments
     * @example
     * // Get one As_comments
     * const as_comments = await prisma.as_comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_commentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<
        Prisma.$as_commentsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_comments
     * const as_comments = await prisma.as_comments.findMany()
     *
     * // Get first 10 As_comments
     * const as_comments = await prisma.as_comments.findMany({ take: 10 })
     *
     * // Only select the `comment_ID`
     * const as_commentsWithComment_IDOnly = await prisma.as_comments.findMany({ select: { comment_ID: true } })
     *
     */
    findMany<T extends as_commentsFindManyArgs>(
      args?: SelectSubset<T, as_commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_commentsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_comments.
     * @param {as_commentsCreateArgs} args - Arguments to create a As_comments.
     * @example
     * // Create one As_comments
     * const As_comments = await prisma.as_comments.create({
     *   data: {
     *     // ... data to create a As_comments
     *   }
     * })
     *
     */
    create<T extends as_commentsCreateArgs>(
      args: SelectSubset<T, as_commentsCreateArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<Prisma.$as_commentsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_comments.
     * @param {as_commentsCreateManyArgs} args - Arguments to create many As_comments.
     * @example
     * // Create many As_comments
     * const as_comments = await prisma.as_comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_commentsCreateManyArgs>(
      args?: SelectSubset<T, as_commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_comments.
     * @param {as_commentsDeleteArgs} args - Arguments to delete one As_comments.
     * @example
     * // Delete one As_comments
     * const As_comments = await prisma.as_comments.delete({
     *   where: {
     *     // ... filter to delete one As_comments
     *   }
     * })
     *
     */
    delete<T extends as_commentsDeleteArgs>(
      args: SelectSubset<T, as_commentsDeleteArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<Prisma.$as_commentsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_comments.
     * @param {as_commentsUpdateArgs} args - Arguments to update one As_comments.
     * @example
     * // Update one As_comments
     * const as_comments = await prisma.as_comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_commentsUpdateArgs>(
      args: SelectSubset<T, as_commentsUpdateArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<Prisma.$as_commentsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_comments.
     * @param {as_commentsDeleteManyArgs} args - Arguments to filter As_comments to delete.
     * @example
     * // Delete a few As_comments
     * const { count } = await prisma.as_comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_commentsDeleteManyArgs>(
      args?: SelectSubset<T, as_commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_comments
     * const as_comments = await prisma.as_comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_commentsUpdateManyArgs>(
      args: SelectSubset<T, as_commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_comments.
     * @param {as_commentsUpsertArgs} args - Arguments to update or create a As_comments.
     * @example
     * // Update or create a As_comments
     * const as_comments = await prisma.as_comments.upsert({
     *   create: {
     *     // ... data to create a As_comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_comments we want to update
     *   }
     * })
     */
    upsert<T extends as_commentsUpsertArgs>(
      args: SelectSubset<T, as_commentsUpsertArgs<ExtArgs>>
    ): Prisma__as_commentsClient<
      $Result.GetResult<Prisma.$as_commentsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsCountArgs} args - Arguments to filter As_comments to count.
     * @example
     * // Count the number of As_comments
     * const count = await prisma.as_comments.count({
     *   where: {
     *     // ... the filter for the As_comments we want to count
     *   }
     * })
     */
    count<T extends as_commentsCountArgs>(
      args?: Subset<T, as_commentsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_commentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_commentsAggregateArgs>(
      args: Subset<T, As_commentsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_commentsAggregateType<T>>

    /**
     * Group by As_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_commentsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_commentsGroupByArgs['orderBy'] }
        : { orderBy?: as_commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_commentsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_commentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_comments model
     */
    readonly fields: as_commentsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_commentsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_comments model
   */
  interface as_commentsFieldRefs {
    readonly comment_ID: FieldRef<'as_comments', 'BigInt'>
    readonly comment_post_ID: FieldRef<'as_comments', 'BigInt'>
    readonly comment_author: FieldRef<'as_comments', 'String'>
    readonly comment_author_email: FieldRef<'as_comments', 'String'>
    readonly comment_author_url: FieldRef<'as_comments', 'String'>
    readonly comment_author_IP: FieldRef<'as_comments', 'String'>
    readonly comment_date: FieldRef<'as_comments', 'DateTime'>
    readonly comment_date_gmt: FieldRef<'as_comments', 'DateTime'>
    readonly comment_content: FieldRef<'as_comments', 'String'>
    readonly comment_karma: FieldRef<'as_comments', 'Int'>
    readonly comment_approved: FieldRef<'as_comments', 'String'>
    readonly comment_agent: FieldRef<'as_comments', 'String'>
    readonly comment_type: FieldRef<'as_comments', 'String'>
    readonly comment_parent: FieldRef<'as_comments', 'BigInt'>
    readonly user_id: FieldRef<'as_comments', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_comments findUnique
   */
  export type as_commentsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter, which as_comments to fetch.
     */
    where: as_commentsWhereUniqueInput
  }

  /**
   * as_comments findUniqueOrThrow
   */
  export type as_commentsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter, which as_comments to fetch.
     */
    where: as_commentsWhereUniqueInput
  }

  /**
   * as_comments findFirst
   */
  export type as_commentsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter, which as_comments to fetch.
     */
    where?: as_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_comments to fetch.
     */
    orderBy?: as_commentsOrderByWithRelationInput | as_commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_comments.
     */
    cursor?: as_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_comments.
     */
    distinct?: As_commentsScalarFieldEnum | As_commentsScalarFieldEnum[]
  }

  /**
   * as_comments findFirstOrThrow
   */
  export type as_commentsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter, which as_comments to fetch.
     */
    where?: as_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_comments to fetch.
     */
    orderBy?: as_commentsOrderByWithRelationInput | as_commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_comments.
     */
    cursor?: as_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_comments.
     */
    distinct?: As_commentsScalarFieldEnum | As_commentsScalarFieldEnum[]
  }

  /**
   * as_comments findMany
   */
  export type as_commentsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter, which as_comments to fetch.
     */
    where?: as_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_comments to fetch.
     */
    orderBy?: as_commentsOrderByWithRelationInput | as_commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_comments.
     */
    cursor?: as_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_comments.
     */
    skip?: number
    distinct?: As_commentsScalarFieldEnum | As_commentsScalarFieldEnum[]
  }

  /**
   * as_comments create
   */
  export type as_commentsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_comments.
     */
    data: XOR<as_commentsCreateInput, as_commentsUncheckedCreateInput>
  }

  /**
   * as_comments createMany
   */
  export type as_commentsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_comments.
     */
    data: as_commentsCreateManyInput | as_commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_comments update
   */
  export type as_commentsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_comments.
     */
    data: XOR<as_commentsUpdateInput, as_commentsUncheckedUpdateInput>
    /**
     * Choose, which as_comments to update.
     */
    where: as_commentsWhereUniqueInput
  }

  /**
   * as_comments updateMany
   */
  export type as_commentsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_comments.
     */
    data: XOR<as_commentsUpdateManyMutationInput, as_commentsUncheckedUpdateManyInput>
    /**
     * Filter which as_comments to update
     */
    where?: as_commentsWhereInput
    /**
     * Limit how many as_comments to update.
     */
    limit?: number
  }

  /**
   * as_comments upsert
   */
  export type as_commentsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_comments to update in case it exists.
     */
    where: as_commentsWhereUniqueInput
    /**
     * In case the as_comments found by the `where` argument doesn't exist, create a new as_comments with this data.
     */
    create: XOR<as_commentsCreateInput, as_commentsUncheckedCreateInput>
    /**
     * In case the as_comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_commentsUpdateInput, as_commentsUncheckedUpdateInput>
  }

  /**
   * as_comments delete
   */
  export type as_commentsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
    /**
     * Filter which as_comments to delete.
     */
    where: as_commentsWhereUniqueInput
  }

  /**
   * as_comments deleteMany
   */
  export type as_commentsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_comments to delete
     */
    where?: as_commentsWhereInput
    /**
     * Limit how many as_comments to delete.
     */
    limit?: number
  }

  /**
   * as_comments without action
   */
  export type as_commentsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_comments
     */
    select?: as_commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_comments
     */
    omit?: as_commentsOmit<ExtArgs> | null
  }

  /**
   * Model as_fusion_form_entries
   */

  export type AggregateAs_fusion_form_entries = {
    _count: As_fusion_form_entriesCountAggregateOutputType | null
    _avg: As_fusion_form_entriesAvgAggregateOutputType | null
    _sum: As_fusion_form_entriesSumAggregateOutputType | null
    _min: As_fusion_form_entriesMinAggregateOutputType | null
    _max: As_fusion_form_entriesMaxAggregateOutputType | null
  }

  export type As_fusion_form_entriesAvgAggregateOutputType = {
    id: number | null
    submission_id: number | null
    form_id: number | null
    field_id: number | null
  }

  export type As_fusion_form_entriesSumAggregateOutputType = {
    id: bigint | null
    submission_id: bigint | null
    form_id: bigint | null
    field_id: bigint | null
  }

  export type As_fusion_form_entriesMinAggregateOutputType = {
    id: bigint | null
    submission_id: bigint | null
    form_id: bigint | null
    field_id: bigint | null
    value: string | null
    privacy: boolean | null
    data: string | null
  }

  export type As_fusion_form_entriesMaxAggregateOutputType = {
    id: bigint | null
    submission_id: bigint | null
    form_id: bigint | null
    field_id: bigint | null
    value: string | null
    privacy: boolean | null
    data: string | null
  }

  export type As_fusion_form_entriesCountAggregateOutputType = {
    id: number
    submission_id: number
    form_id: number
    field_id: number
    value: number
    privacy: number
    data: number
    _all: number
  }

  export type As_fusion_form_entriesAvgAggregateInputType = {
    id?: true
    submission_id?: true
    form_id?: true
    field_id?: true
  }

  export type As_fusion_form_entriesSumAggregateInputType = {
    id?: true
    submission_id?: true
    form_id?: true
    field_id?: true
  }

  export type As_fusion_form_entriesMinAggregateInputType = {
    id?: true
    submission_id?: true
    form_id?: true
    field_id?: true
    value?: true
    privacy?: true
    data?: true
  }

  export type As_fusion_form_entriesMaxAggregateInputType = {
    id?: true
    submission_id?: true
    form_id?: true
    field_id?: true
    value?: true
    privacy?: true
    data?: true
  }

  export type As_fusion_form_entriesCountAggregateInputType = {
    id?: true
    submission_id?: true
    form_id?: true
    field_id?: true
    value?: true
    privacy?: true
    data?: true
    _all?: true
  }

  export type As_fusion_form_entriesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_entries to aggregate.
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_entries to fetch.
     */
    orderBy?:
      | as_fusion_form_entriesOrderByWithRelationInput
      | as_fusion_form_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_fusion_form_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_fusion_form_entries
     */
    _count?: true | As_fusion_form_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_fusion_form_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_fusion_form_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_fusion_form_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_fusion_form_entriesMaxAggregateInputType
  }

  export type GetAs_fusion_form_entriesAggregateType<
    T extends As_fusion_form_entriesAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_fusion_form_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_fusion_form_entries[P]>
      : GetScalarType<T[P], AggregateAs_fusion_form_entries[P]>
  }

  export type as_fusion_form_entriesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_fusion_form_entriesWhereInput
    orderBy?:
      | as_fusion_form_entriesOrderByWithAggregationInput
      | as_fusion_form_entriesOrderByWithAggregationInput[]
    by: As_fusion_form_entriesScalarFieldEnum[] | As_fusion_form_entriesScalarFieldEnum
    having?: as_fusion_form_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_fusion_form_entriesCountAggregateInputType | true
    _avg?: As_fusion_form_entriesAvgAggregateInputType
    _sum?: As_fusion_form_entriesSumAggregateInputType
    _min?: As_fusion_form_entriesMinAggregateInputType
    _max?: As_fusion_form_entriesMaxAggregateInputType
  }

  export type As_fusion_form_entriesGroupByOutputType = {
    id: bigint
    submission_id: bigint
    form_id: bigint
    field_id: bigint
    value: string | null
    privacy: boolean | null
    data: string | null
    _count: As_fusion_form_entriesCountAggregateOutputType | null
    _avg: As_fusion_form_entriesAvgAggregateOutputType | null
    _sum: As_fusion_form_entriesSumAggregateOutputType | null
    _min: As_fusion_form_entriesMinAggregateOutputType | null
    _max: As_fusion_form_entriesMaxAggregateOutputType | null
  }

  type GetAs_fusion_form_entriesGroupByPayload<T extends as_fusion_form_entriesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_fusion_form_entriesGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_fusion_form_entriesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_fusion_form_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], As_fusion_form_entriesGroupByOutputType[P]>
        }
      >
    >

  export type as_fusion_form_entriesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      submission_id?: boolean
      form_id?: boolean
      field_id?: boolean
      value?: boolean
      privacy?: boolean
      data?: boolean
    },
    ExtArgs['result']['as_fusion_form_entries']
  >

  export type as_fusion_form_entriesSelectScalar = {
    id?: boolean
    submission_id?: boolean
    form_id?: boolean
    field_id?: boolean
    value?: boolean
    privacy?: boolean
    data?: boolean
  }

  export type as_fusion_form_entriesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'submission_id' | 'form_id' | 'field_id' | 'value' | 'privacy' | 'data',
    ExtArgs['result']['as_fusion_form_entries']
  >

  export type $as_fusion_form_entriesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_fusion_form_entries'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        submission_id: bigint
        form_id: bigint
        field_id: bigint
        value: string | null
        privacy: boolean | null
        data: string | null
      },
      ExtArgs['result']['as_fusion_form_entries']
    >
    composites: {}
  }

  type as_fusion_form_entriesGetPayload<
    S extends boolean | null | undefined | as_fusion_form_entriesDefaultArgs
  > = $Result.GetResult<Prisma.$as_fusion_form_entriesPayload, S>

  type as_fusion_form_entriesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_fusion_form_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_fusion_form_entriesCountAggregateInputType | true
  }

  export interface as_fusion_form_entriesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_fusion_form_entries']
      meta: { name: 'as_fusion_form_entries' }
    }
    /**
     * Find zero or one As_fusion_form_entries that matches the filter.
     * @param {as_fusion_form_entriesFindUniqueArgs} args - Arguments to find a As_fusion_form_entries
     * @example
     * // Get one As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_fusion_form_entriesFindUniqueArgs>(
      args: SelectSubset<T, as_fusion_form_entriesFindUniqueArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_fusion_form_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_fusion_form_entriesFindUniqueOrThrowArgs} args - Arguments to find a As_fusion_form_entries
     * @example
     * // Get one As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_fusion_form_entriesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_fusion_form_entriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesFindFirstArgs} args - Arguments to find a As_fusion_form_entries
     * @example
     * // Get one As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_fusion_form_entriesFindFirstArgs>(
      args?: SelectSubset<T, as_fusion_form_entriesFindFirstArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesFindFirstOrThrowArgs} args - Arguments to find a As_fusion_form_entries
     * @example
     * // Get one As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_fusion_form_entriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_fusion_form_entriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_fusion_form_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findMany()
     *
     * // Get first 10 As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_fusion_form_entriesWithIdOnly = await prisma.as_fusion_form_entries.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_fusion_form_entriesFindManyArgs>(
      args?: SelectSubset<T, as_fusion_form_entriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_fusion_form_entries.
     * @param {as_fusion_form_entriesCreateArgs} args - Arguments to create a As_fusion_form_entries.
     * @example
     * // Create one As_fusion_form_entries
     * const As_fusion_form_entries = await prisma.as_fusion_form_entries.create({
     *   data: {
     *     // ... data to create a As_fusion_form_entries
     *   }
     * })
     *
     */
    create<T extends as_fusion_form_entriesCreateArgs>(
      args: SelectSubset<T, as_fusion_form_entriesCreateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_fusion_form_entries.
     * @param {as_fusion_form_entriesCreateManyArgs} args - Arguments to create many As_fusion_form_entries.
     * @example
     * // Create many As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_fusion_form_entriesCreateManyArgs>(
      args?: SelectSubset<T, as_fusion_form_entriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_fusion_form_entries.
     * @param {as_fusion_form_entriesDeleteArgs} args - Arguments to delete one As_fusion_form_entries.
     * @example
     * // Delete one As_fusion_form_entries
     * const As_fusion_form_entries = await prisma.as_fusion_form_entries.delete({
     *   where: {
     *     // ... filter to delete one As_fusion_form_entries
     *   }
     * })
     *
     */
    delete<T extends as_fusion_form_entriesDeleteArgs>(
      args: SelectSubset<T, as_fusion_form_entriesDeleteArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_fusion_form_entries.
     * @param {as_fusion_form_entriesUpdateArgs} args - Arguments to update one As_fusion_form_entries.
     * @example
     * // Update one As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_fusion_form_entriesUpdateArgs>(
      args: SelectSubset<T, as_fusion_form_entriesUpdateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_fusion_form_entries.
     * @param {as_fusion_form_entriesDeleteManyArgs} args - Arguments to filter As_fusion_form_entries to delete.
     * @example
     * // Delete a few As_fusion_form_entries
     * const { count } = await prisma.as_fusion_form_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_fusion_form_entriesDeleteManyArgs>(
      args?: SelectSubset<T, as_fusion_form_entriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_fusion_form_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_fusion_form_entriesUpdateManyArgs>(
      args: SelectSubset<T, as_fusion_form_entriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_fusion_form_entries.
     * @param {as_fusion_form_entriesUpsertArgs} args - Arguments to update or create a As_fusion_form_entries.
     * @example
     * // Update or create a As_fusion_form_entries
     * const as_fusion_form_entries = await prisma.as_fusion_form_entries.upsert({
     *   create: {
     *     // ... data to create a As_fusion_form_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_fusion_form_entries we want to update
     *   }
     * })
     */
    upsert<T extends as_fusion_form_entriesUpsertArgs>(
      args: SelectSubset<T, as_fusion_form_entriesUpsertArgs<ExtArgs>>
    ): Prisma__as_fusion_form_entriesClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_entriesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_fusion_form_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesCountArgs} args - Arguments to filter As_fusion_form_entries to count.
     * @example
     * // Count the number of As_fusion_form_entries
     * const count = await prisma.as_fusion_form_entries.count({
     *   where: {
     *     // ... the filter for the As_fusion_form_entries we want to count
     *   }
     * })
     */
    count<T extends as_fusion_form_entriesCountArgs>(
      args?: Subset<T, as_fusion_form_entriesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_fusion_form_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_fusion_form_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_fusion_form_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_fusion_form_entriesAggregateArgs>(
      args: Subset<T, As_fusion_form_entriesAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_fusion_form_entriesAggregateType<T>>

    /**
     * Group by As_fusion_form_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_fusion_form_entriesGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_fusion_form_entriesGroupByArgs['orderBy'] }
        : { orderBy?: as_fusion_form_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_fusion_form_entriesGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_fusion_form_entriesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_fusion_form_entries model
     */
    readonly fields: as_fusion_form_entriesFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_fusion_form_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_fusion_form_entriesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_fusion_form_entries model
   */
  interface as_fusion_form_entriesFieldRefs {
    readonly id: FieldRef<'as_fusion_form_entries', 'BigInt'>
    readonly submission_id: FieldRef<'as_fusion_form_entries', 'BigInt'>
    readonly form_id: FieldRef<'as_fusion_form_entries', 'BigInt'>
    readonly field_id: FieldRef<'as_fusion_form_entries', 'BigInt'>
    readonly value: FieldRef<'as_fusion_form_entries', 'String'>
    readonly privacy: FieldRef<'as_fusion_form_entries', 'Boolean'>
    readonly data: FieldRef<'as_fusion_form_entries', 'String'>
  }

  // Custom InputTypes
  /**
   * as_fusion_form_entries findUnique
   */
  export type as_fusion_form_entriesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_entries to fetch.
     */
    where: as_fusion_form_entriesWhereUniqueInput
  }

  /**
   * as_fusion_form_entries findUniqueOrThrow
   */
  export type as_fusion_form_entriesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_entries to fetch.
     */
    where: as_fusion_form_entriesWhereUniqueInput
  }

  /**
   * as_fusion_form_entries findFirst
   */
  export type as_fusion_form_entriesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_entries to fetch.
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_entries to fetch.
     */
    orderBy?:
      | as_fusion_form_entriesOrderByWithRelationInput
      | as_fusion_form_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_entries.
     */
    cursor?: as_fusion_form_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_entries.
     */
    distinct?: As_fusion_form_entriesScalarFieldEnum | As_fusion_form_entriesScalarFieldEnum[]
  }

  /**
   * as_fusion_form_entries findFirstOrThrow
   */
  export type as_fusion_form_entriesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_entries to fetch.
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_entries to fetch.
     */
    orderBy?:
      | as_fusion_form_entriesOrderByWithRelationInput
      | as_fusion_form_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_entries.
     */
    cursor?: as_fusion_form_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_entries.
     */
    distinct?: As_fusion_form_entriesScalarFieldEnum | As_fusion_form_entriesScalarFieldEnum[]
  }

  /**
   * as_fusion_form_entries findMany
   */
  export type as_fusion_form_entriesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_entries to fetch.
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_entries to fetch.
     */
    orderBy?:
      | as_fusion_form_entriesOrderByWithRelationInput
      | as_fusion_form_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_fusion_form_entries.
     */
    cursor?: as_fusion_form_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_entries.
     */
    skip?: number
    distinct?: As_fusion_form_entriesScalarFieldEnum | As_fusion_form_entriesScalarFieldEnum[]
  }

  /**
   * as_fusion_form_entries create
   */
  export type as_fusion_form_entriesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a as_fusion_form_entries.
     */
    data: XOR<as_fusion_form_entriesCreateInput, as_fusion_form_entriesUncheckedCreateInput>
  }

  /**
   * as_fusion_form_entries createMany
   */
  export type as_fusion_form_entriesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_fusion_form_entries.
     */
    data: as_fusion_form_entriesCreateManyInput | as_fusion_form_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_fusion_form_entries update
   */
  export type as_fusion_form_entriesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a as_fusion_form_entries.
     */
    data: XOR<as_fusion_form_entriesUpdateInput, as_fusion_form_entriesUncheckedUpdateInput>
    /**
     * Choose, which as_fusion_form_entries to update.
     */
    where: as_fusion_form_entriesWhereUniqueInput
  }

  /**
   * as_fusion_form_entries updateMany
   */
  export type as_fusion_form_entriesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_fusion_form_entries.
     */
    data: XOR<
      as_fusion_form_entriesUpdateManyMutationInput,
      as_fusion_form_entriesUncheckedUpdateManyInput
    >
    /**
     * Filter which as_fusion_form_entries to update
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * Limit how many as_fusion_form_entries to update.
     */
    limit?: number
  }

  /**
   * as_fusion_form_entries upsert
   */
  export type as_fusion_form_entriesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the as_fusion_form_entries to update in case it exists.
     */
    where: as_fusion_form_entriesWhereUniqueInput
    /**
     * In case the as_fusion_form_entries found by the `where` argument doesn't exist, create a new as_fusion_form_entries with this data.
     */
    create: XOR<as_fusion_form_entriesCreateInput, as_fusion_form_entriesUncheckedCreateInput>
    /**
     * In case the as_fusion_form_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_fusion_form_entriesUpdateInput, as_fusion_form_entriesUncheckedUpdateInput>
  }

  /**
   * as_fusion_form_entries delete
   */
  export type as_fusion_form_entriesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
    /**
     * Filter which as_fusion_form_entries to delete.
     */
    where: as_fusion_form_entriesWhereUniqueInput
  }

  /**
   * as_fusion_form_entries deleteMany
   */
  export type as_fusion_form_entriesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_entries to delete
     */
    where?: as_fusion_form_entriesWhereInput
    /**
     * Limit how many as_fusion_form_entries to delete.
     */
    limit?: number
  }

  /**
   * as_fusion_form_entries without action
   */
  export type as_fusion_form_entriesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_entries
     */
    select?: as_fusion_form_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_entries
     */
    omit?: as_fusion_form_entriesOmit<ExtArgs> | null
  }

  /**
   * Model as_fusion_form_fields
   */

  export type AggregateAs_fusion_form_fields = {
    _count: As_fusion_form_fieldsCountAggregateOutputType | null
    _avg: As_fusion_form_fieldsAvgAggregateOutputType | null
    _sum: As_fusion_form_fieldsSumAggregateOutputType | null
    _min: As_fusion_form_fieldsMinAggregateOutputType | null
    _max: As_fusion_form_fieldsMaxAggregateOutputType | null
  }

  export type As_fusion_form_fieldsAvgAggregateOutputType = {
    id: number | null
    form_id: number | null
  }

  export type As_fusion_form_fieldsSumAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
  }

  export type As_fusion_form_fieldsMinAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    field_name: string | null
    field_label: string | null
    data: string | null
  }

  export type As_fusion_form_fieldsMaxAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    field_name: string | null
    field_label: string | null
    data: string | null
  }

  export type As_fusion_form_fieldsCountAggregateOutputType = {
    id: number
    form_id: number
    field_name: number
    field_label: number
    data: number
    _all: number
  }

  export type As_fusion_form_fieldsAvgAggregateInputType = {
    id?: true
    form_id?: true
  }

  export type As_fusion_form_fieldsSumAggregateInputType = {
    id?: true
    form_id?: true
  }

  export type As_fusion_form_fieldsMinAggregateInputType = {
    id?: true
    form_id?: true
    field_name?: true
    field_label?: true
    data?: true
  }

  export type As_fusion_form_fieldsMaxAggregateInputType = {
    id?: true
    form_id?: true
    field_name?: true
    field_label?: true
    data?: true
  }

  export type As_fusion_form_fieldsCountAggregateInputType = {
    id?: true
    form_id?: true
    field_name?: true
    field_label?: true
    data?: true
    _all?: true
  }

  export type As_fusion_form_fieldsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_fields to aggregate.
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_fields to fetch.
     */
    orderBy?:
      | as_fusion_form_fieldsOrderByWithRelationInput
      | as_fusion_form_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_fusion_form_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_fusion_form_fields
     */
    _count?: true | As_fusion_form_fieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_fusion_form_fieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_fusion_form_fieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_fusion_form_fieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_fusion_form_fieldsMaxAggregateInputType
  }

  export type GetAs_fusion_form_fieldsAggregateType<T extends As_fusion_form_fieldsAggregateArgs> =
    {
      [P in keyof T & keyof AggregateAs_fusion_form_fields]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateAs_fusion_form_fields[P]>
        : GetScalarType<T[P], AggregateAs_fusion_form_fields[P]>
    }

  export type as_fusion_form_fieldsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_fusion_form_fieldsWhereInput
    orderBy?:
      | as_fusion_form_fieldsOrderByWithAggregationInput
      | as_fusion_form_fieldsOrderByWithAggregationInput[]
    by: As_fusion_form_fieldsScalarFieldEnum[] | As_fusion_form_fieldsScalarFieldEnum
    having?: as_fusion_form_fieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_fusion_form_fieldsCountAggregateInputType | true
    _avg?: As_fusion_form_fieldsAvgAggregateInputType
    _sum?: As_fusion_form_fieldsSumAggregateInputType
    _min?: As_fusion_form_fieldsMinAggregateInputType
    _max?: As_fusion_form_fieldsMaxAggregateInputType
  }

  export type As_fusion_form_fieldsGroupByOutputType = {
    id: bigint
    form_id: bigint
    field_name: string
    field_label: string | null
    data: string | null
    _count: As_fusion_form_fieldsCountAggregateOutputType | null
    _avg: As_fusion_form_fieldsAvgAggregateOutputType | null
    _sum: As_fusion_form_fieldsSumAggregateOutputType | null
    _min: As_fusion_form_fieldsMinAggregateOutputType | null
    _max: As_fusion_form_fieldsMaxAggregateOutputType | null
  }

  type GetAs_fusion_form_fieldsGroupByPayload<T extends as_fusion_form_fieldsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_fusion_form_fieldsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_fusion_form_fieldsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_fusion_form_fieldsGroupByOutputType[P]>
            : GetScalarType<T[P], As_fusion_form_fieldsGroupByOutputType[P]>
        }
      >
    >

  export type as_fusion_form_fieldsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      form_id?: boolean
      field_name?: boolean
      field_label?: boolean
      data?: boolean
    },
    ExtArgs['result']['as_fusion_form_fields']
  >

  export type as_fusion_form_fieldsSelectScalar = {
    id?: boolean
    form_id?: boolean
    field_name?: boolean
    field_label?: boolean
    data?: boolean
  }

  export type as_fusion_form_fieldsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'form_id' | 'field_name' | 'field_label' | 'data',
    ExtArgs['result']['as_fusion_form_fields']
  >

  export type $as_fusion_form_fieldsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_fusion_form_fields'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        form_id: bigint
        field_name: string
        field_label: string | null
        data: string | null
      },
      ExtArgs['result']['as_fusion_form_fields']
    >
    composites: {}
  }

  type as_fusion_form_fieldsGetPayload<
    S extends boolean | null | undefined | as_fusion_form_fieldsDefaultArgs
  > = $Result.GetResult<Prisma.$as_fusion_form_fieldsPayload, S>

  type as_fusion_form_fieldsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_fusion_form_fieldsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_fusion_form_fieldsCountAggregateInputType | true
  }

  export interface as_fusion_form_fieldsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_fusion_form_fields']
      meta: { name: 'as_fusion_form_fields' }
    }
    /**
     * Find zero or one As_fusion_form_fields that matches the filter.
     * @param {as_fusion_form_fieldsFindUniqueArgs} args - Arguments to find a As_fusion_form_fields
     * @example
     * // Get one As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_fusion_form_fieldsFindUniqueArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_fusion_form_fields that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_fusion_form_fieldsFindUniqueOrThrowArgs} args - Arguments to find a As_fusion_form_fields
     * @example
     * // Get one As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_fusion_form_fieldsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsFindFirstArgs} args - Arguments to find a As_fusion_form_fields
     * @example
     * // Get one As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_fusion_form_fieldsFindFirstArgs>(
      args?: SelectSubset<T, as_fusion_form_fieldsFindFirstArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_fields that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsFindFirstOrThrowArgs} args - Arguments to find a As_fusion_form_fields
     * @example
     * // Get one As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_fusion_form_fieldsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_fusion_form_fieldsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_fusion_form_fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findMany()
     *
     * // Get first 10 As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_fusion_form_fieldsWithIdOnly = await prisma.as_fusion_form_fields.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_fusion_form_fieldsFindManyArgs>(
      args?: SelectSubset<T, as_fusion_form_fieldsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_fusion_form_fields.
     * @param {as_fusion_form_fieldsCreateArgs} args - Arguments to create a As_fusion_form_fields.
     * @example
     * // Create one As_fusion_form_fields
     * const As_fusion_form_fields = await prisma.as_fusion_form_fields.create({
     *   data: {
     *     // ... data to create a As_fusion_form_fields
     *   }
     * })
     *
     */
    create<T extends as_fusion_form_fieldsCreateArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsCreateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_fusion_form_fields.
     * @param {as_fusion_form_fieldsCreateManyArgs} args - Arguments to create many As_fusion_form_fields.
     * @example
     * // Create many As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_fusion_form_fieldsCreateManyArgs>(
      args?: SelectSubset<T, as_fusion_form_fieldsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_fusion_form_fields.
     * @param {as_fusion_form_fieldsDeleteArgs} args - Arguments to delete one As_fusion_form_fields.
     * @example
     * // Delete one As_fusion_form_fields
     * const As_fusion_form_fields = await prisma.as_fusion_form_fields.delete({
     *   where: {
     *     // ... filter to delete one As_fusion_form_fields
     *   }
     * })
     *
     */
    delete<T extends as_fusion_form_fieldsDeleteArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsDeleteArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_fusion_form_fields.
     * @param {as_fusion_form_fieldsUpdateArgs} args - Arguments to update one As_fusion_form_fields.
     * @example
     * // Update one As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_fusion_form_fieldsUpdateArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsUpdateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_fusion_form_fields.
     * @param {as_fusion_form_fieldsDeleteManyArgs} args - Arguments to filter As_fusion_form_fields to delete.
     * @example
     * // Delete a few As_fusion_form_fields
     * const { count } = await prisma.as_fusion_form_fields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_fusion_form_fieldsDeleteManyArgs>(
      args?: SelectSubset<T, as_fusion_form_fieldsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_fusion_form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_fusion_form_fieldsUpdateManyArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_fusion_form_fields.
     * @param {as_fusion_form_fieldsUpsertArgs} args - Arguments to update or create a As_fusion_form_fields.
     * @example
     * // Update or create a As_fusion_form_fields
     * const as_fusion_form_fields = await prisma.as_fusion_form_fields.upsert({
     *   create: {
     *     // ... data to create a As_fusion_form_fields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_fusion_form_fields we want to update
     *   }
     * })
     */
    upsert<T extends as_fusion_form_fieldsUpsertArgs>(
      args: SelectSubset<T, as_fusion_form_fieldsUpsertArgs<ExtArgs>>
    ): Prisma__as_fusion_form_fieldsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_fieldsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_fusion_form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsCountArgs} args - Arguments to filter As_fusion_form_fields to count.
     * @example
     * // Count the number of As_fusion_form_fields
     * const count = await prisma.as_fusion_form_fields.count({
     *   where: {
     *     // ... the filter for the As_fusion_form_fields we want to count
     *   }
     * })
     */
    count<T extends as_fusion_form_fieldsCountArgs>(
      args?: Subset<T, as_fusion_form_fieldsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_fusion_form_fieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_fusion_form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_fusion_form_fieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_fusion_form_fieldsAggregateArgs>(
      args: Subset<T, As_fusion_form_fieldsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_fusion_form_fieldsAggregateType<T>>

    /**
     * Group by As_fusion_form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_fieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_fusion_form_fieldsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_fusion_form_fieldsGroupByArgs['orderBy'] }
        : { orderBy?: as_fusion_form_fieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_fusion_form_fieldsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_fusion_form_fieldsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_fusion_form_fields model
     */
    readonly fields: as_fusion_form_fieldsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_fusion_form_fields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_fusion_form_fieldsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_fusion_form_fields model
   */
  interface as_fusion_form_fieldsFieldRefs {
    readonly id: FieldRef<'as_fusion_form_fields', 'BigInt'>
    readonly form_id: FieldRef<'as_fusion_form_fields', 'BigInt'>
    readonly field_name: FieldRef<'as_fusion_form_fields', 'String'>
    readonly field_label: FieldRef<'as_fusion_form_fields', 'String'>
    readonly data: FieldRef<'as_fusion_form_fields', 'String'>
  }

  // Custom InputTypes
  /**
   * as_fusion_form_fields findUnique
   */
  export type as_fusion_form_fieldsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_fields to fetch.
     */
    where: as_fusion_form_fieldsWhereUniqueInput
  }

  /**
   * as_fusion_form_fields findUniqueOrThrow
   */
  export type as_fusion_form_fieldsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_fields to fetch.
     */
    where: as_fusion_form_fieldsWhereUniqueInput
  }

  /**
   * as_fusion_form_fields findFirst
   */
  export type as_fusion_form_fieldsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_fields to fetch.
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_fields to fetch.
     */
    orderBy?:
      | as_fusion_form_fieldsOrderByWithRelationInput
      | as_fusion_form_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_fields.
     */
    cursor?: as_fusion_form_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_fields.
     */
    distinct?: As_fusion_form_fieldsScalarFieldEnum | As_fusion_form_fieldsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_fields findFirstOrThrow
   */
  export type as_fusion_form_fieldsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_fields to fetch.
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_fields to fetch.
     */
    orderBy?:
      | as_fusion_form_fieldsOrderByWithRelationInput
      | as_fusion_form_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_fields.
     */
    cursor?: as_fusion_form_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_fields.
     */
    distinct?: As_fusion_form_fieldsScalarFieldEnum | As_fusion_form_fieldsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_fields findMany
   */
  export type as_fusion_form_fieldsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_fields to fetch.
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_fields to fetch.
     */
    orderBy?:
      | as_fusion_form_fieldsOrderByWithRelationInput
      | as_fusion_form_fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_fusion_form_fields.
     */
    cursor?: as_fusion_form_fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_fields.
     */
    skip?: number
    distinct?: As_fusion_form_fieldsScalarFieldEnum | As_fusion_form_fieldsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_fields create
   */
  export type as_fusion_form_fieldsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_fusion_form_fields.
     */
    data: XOR<as_fusion_form_fieldsCreateInput, as_fusion_form_fieldsUncheckedCreateInput>
  }

  /**
   * as_fusion_form_fields createMany
   */
  export type as_fusion_form_fieldsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_fusion_form_fields.
     */
    data: as_fusion_form_fieldsCreateManyInput | as_fusion_form_fieldsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_fusion_form_fields update
   */
  export type as_fusion_form_fieldsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_fusion_form_fields.
     */
    data: XOR<as_fusion_form_fieldsUpdateInput, as_fusion_form_fieldsUncheckedUpdateInput>
    /**
     * Choose, which as_fusion_form_fields to update.
     */
    where: as_fusion_form_fieldsWhereUniqueInput
  }

  /**
   * as_fusion_form_fields updateMany
   */
  export type as_fusion_form_fieldsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_fusion_form_fields.
     */
    data: XOR<
      as_fusion_form_fieldsUpdateManyMutationInput,
      as_fusion_form_fieldsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_fusion_form_fields to update
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * Limit how many as_fusion_form_fields to update.
     */
    limit?: number
  }

  /**
   * as_fusion_form_fields upsert
   */
  export type as_fusion_form_fieldsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_fusion_form_fields to update in case it exists.
     */
    where: as_fusion_form_fieldsWhereUniqueInput
    /**
     * In case the as_fusion_form_fields found by the `where` argument doesn't exist, create a new as_fusion_form_fields with this data.
     */
    create: XOR<as_fusion_form_fieldsCreateInput, as_fusion_form_fieldsUncheckedCreateInput>
    /**
     * In case the as_fusion_form_fields was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_fusion_form_fieldsUpdateInput, as_fusion_form_fieldsUncheckedUpdateInput>
  }

  /**
   * as_fusion_form_fields delete
   */
  export type as_fusion_form_fieldsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
    /**
     * Filter which as_fusion_form_fields to delete.
     */
    where: as_fusion_form_fieldsWhereUniqueInput
  }

  /**
   * as_fusion_form_fields deleteMany
   */
  export type as_fusion_form_fieldsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_fields to delete
     */
    where?: as_fusion_form_fieldsWhereInput
    /**
     * Limit how many as_fusion_form_fields to delete.
     */
    limit?: number
  }

  /**
   * as_fusion_form_fields without action
   */
  export type as_fusion_form_fieldsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_fields
     */
    select?: as_fusion_form_fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_fields
     */
    omit?: as_fusion_form_fieldsOmit<ExtArgs> | null
  }

  /**
   * Model as_fusion_form_submissions
   */

  export type AggregateAs_fusion_form_submissions = {
    _count: As_fusion_form_submissionsCountAggregateOutputType | null
    _avg: As_fusion_form_submissionsAvgAggregateOutputType | null
    _sum: As_fusion_form_submissionsSumAggregateOutputType | null
    _min: As_fusion_form_submissionsMinAggregateOutputType | null
    _max: As_fusion_form_submissionsMaxAggregateOutputType | null
  }

  export type As_fusion_form_submissionsAvgAggregateOutputType = {
    id: number | null
    form_id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type As_fusion_form_submissionsSumAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    post_id: bigint | null
    user_id: bigint | null
  }

  export type As_fusion_form_submissionsMinAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    time: Date | null
    source_url: string | null
    post_id: bigint | null
    user_id: bigint | null
    user_agent: string | null
    ip: string | null
    is_read: boolean | null
    privacy_scrub_date: Date | null
    on_privacy_scrub: string | null
    data: string | null
  }

  export type As_fusion_form_submissionsMaxAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    time: Date | null
    source_url: string | null
    post_id: bigint | null
    user_id: bigint | null
    user_agent: string | null
    ip: string | null
    is_read: boolean | null
    privacy_scrub_date: Date | null
    on_privacy_scrub: string | null
    data: string | null
  }

  export type As_fusion_form_submissionsCountAggregateOutputType = {
    id: number
    form_id: number
    time: number
    source_url: number
    post_id: number
    user_id: number
    user_agent: number
    ip: number
    is_read: number
    privacy_scrub_date: number
    on_privacy_scrub: number
    data: number
    _all: number
  }

  export type As_fusion_form_submissionsAvgAggregateInputType = {
    id?: true
    form_id?: true
    post_id?: true
    user_id?: true
  }

  export type As_fusion_form_submissionsSumAggregateInputType = {
    id?: true
    form_id?: true
    post_id?: true
    user_id?: true
  }

  export type As_fusion_form_submissionsMinAggregateInputType = {
    id?: true
    form_id?: true
    time?: true
    source_url?: true
    post_id?: true
    user_id?: true
    user_agent?: true
    ip?: true
    is_read?: true
    privacy_scrub_date?: true
    on_privacy_scrub?: true
    data?: true
  }

  export type As_fusion_form_submissionsMaxAggregateInputType = {
    id?: true
    form_id?: true
    time?: true
    source_url?: true
    post_id?: true
    user_id?: true
    user_agent?: true
    ip?: true
    is_read?: true
    privacy_scrub_date?: true
    on_privacy_scrub?: true
    data?: true
  }

  export type As_fusion_form_submissionsCountAggregateInputType = {
    id?: true
    form_id?: true
    time?: true
    source_url?: true
    post_id?: true
    user_id?: true
    user_agent?: true
    ip?: true
    is_read?: true
    privacy_scrub_date?: true
    on_privacy_scrub?: true
    data?: true
    _all?: true
  }

  export type As_fusion_form_submissionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_submissions to aggregate.
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_submissions to fetch.
     */
    orderBy?:
      | as_fusion_form_submissionsOrderByWithRelationInput
      | as_fusion_form_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_fusion_form_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_fusion_form_submissions
     */
    _count?: true | As_fusion_form_submissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_fusion_form_submissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_fusion_form_submissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_fusion_form_submissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_fusion_form_submissionsMaxAggregateInputType
  }

  export type GetAs_fusion_form_submissionsAggregateType<
    T extends As_fusion_form_submissionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_fusion_form_submissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_fusion_form_submissions[P]>
      : GetScalarType<T[P], AggregateAs_fusion_form_submissions[P]>
  }

  export type as_fusion_form_submissionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_fusion_form_submissionsWhereInput
    orderBy?:
      | as_fusion_form_submissionsOrderByWithAggregationInput
      | as_fusion_form_submissionsOrderByWithAggregationInput[]
    by: As_fusion_form_submissionsScalarFieldEnum[] | As_fusion_form_submissionsScalarFieldEnum
    having?: as_fusion_form_submissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_fusion_form_submissionsCountAggregateInputType | true
    _avg?: As_fusion_form_submissionsAvgAggregateInputType
    _sum?: As_fusion_form_submissionsSumAggregateInputType
    _min?: As_fusion_form_submissionsMinAggregateInputType
    _max?: As_fusion_form_submissionsMaxAggregateInputType
  }

  export type As_fusion_form_submissionsGroupByOutputType = {
    id: bigint
    form_id: bigint
    time: Date
    source_url: string
    post_id: bigint | null
    user_id: bigint | null
    user_agent: string | null
    ip: string | null
    is_read: boolean | null
    privacy_scrub_date: Date | null
    on_privacy_scrub: string
    data: string | null
    _count: As_fusion_form_submissionsCountAggregateOutputType | null
    _avg: As_fusion_form_submissionsAvgAggregateOutputType | null
    _sum: As_fusion_form_submissionsSumAggregateOutputType | null
    _min: As_fusion_form_submissionsMinAggregateOutputType | null
    _max: As_fusion_form_submissionsMaxAggregateOutputType | null
  }

  type GetAs_fusion_form_submissionsGroupByPayload<
    T extends as_fusion_form_submissionsGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_fusion_form_submissionsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_fusion_form_submissionsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_fusion_form_submissionsGroupByOutputType[P]>
          : GetScalarType<T[P], As_fusion_form_submissionsGroupByOutputType[P]>
      }
    >
  >

  export type as_fusion_form_submissionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      form_id?: boolean
      time?: boolean
      source_url?: boolean
      post_id?: boolean
      user_id?: boolean
      user_agent?: boolean
      ip?: boolean
      is_read?: boolean
      privacy_scrub_date?: boolean
      on_privacy_scrub?: boolean
      data?: boolean
    },
    ExtArgs['result']['as_fusion_form_submissions']
  >

  export type as_fusion_form_submissionsSelectScalar = {
    id?: boolean
    form_id?: boolean
    time?: boolean
    source_url?: boolean
    post_id?: boolean
    user_id?: boolean
    user_agent?: boolean
    ip?: boolean
    is_read?: boolean
    privacy_scrub_date?: boolean
    on_privacy_scrub?: boolean
    data?: boolean
  }

  export type as_fusion_form_submissionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'form_id'
    | 'time'
    | 'source_url'
    | 'post_id'
    | 'user_id'
    | 'user_agent'
    | 'ip'
    | 'is_read'
    | 'privacy_scrub_date'
    | 'on_privacy_scrub'
    | 'data',
    ExtArgs['result']['as_fusion_form_submissions']
  >

  export type $as_fusion_form_submissionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_fusion_form_submissions'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        form_id: bigint
        time: Date
        source_url: string
        post_id: bigint | null
        user_id: bigint | null
        user_agent: string | null
        ip: string | null
        is_read: boolean | null
        privacy_scrub_date: Date | null
        on_privacy_scrub: string
        data: string | null
      },
      ExtArgs['result']['as_fusion_form_submissions']
    >
    composites: {}
  }

  type as_fusion_form_submissionsGetPayload<
    S extends boolean | null | undefined | as_fusion_form_submissionsDefaultArgs
  > = $Result.GetResult<Prisma.$as_fusion_form_submissionsPayload, S>

  type as_fusion_form_submissionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_fusion_form_submissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_fusion_form_submissionsCountAggregateInputType | true
  }

  export interface as_fusion_form_submissionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_fusion_form_submissions']
      meta: { name: 'as_fusion_form_submissions' }
    }
    /**
     * Find zero or one As_fusion_form_submissions that matches the filter.
     * @param {as_fusion_form_submissionsFindUniqueArgs} args - Arguments to find a As_fusion_form_submissions
     * @example
     * // Get one As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_fusion_form_submissionsFindUniqueArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_fusion_form_submissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_fusion_form_submissionsFindUniqueOrThrowArgs} args - Arguments to find a As_fusion_form_submissions
     * @example
     * // Get one As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_fusion_form_submissionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsFindFirstArgs} args - Arguments to find a As_fusion_form_submissions
     * @example
     * // Get one As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_fusion_form_submissionsFindFirstArgs>(
      args?: SelectSubset<T, as_fusion_form_submissionsFindFirstArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_form_submissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsFindFirstOrThrowArgs} args - Arguments to find a As_fusion_form_submissions
     * @example
     * // Get one As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_fusion_form_submissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_fusion_form_submissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_fusion_form_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findMany()
     *
     * // Get first 10 As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_fusion_form_submissionsWithIdOnly = await prisma.as_fusion_form_submissions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_fusion_form_submissionsFindManyArgs>(
      args?: SelectSubset<T, as_fusion_form_submissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsCreateArgs} args - Arguments to create a As_fusion_form_submissions.
     * @example
     * // Create one As_fusion_form_submissions
     * const As_fusion_form_submissions = await prisma.as_fusion_form_submissions.create({
     *   data: {
     *     // ... data to create a As_fusion_form_submissions
     *   }
     * })
     *
     */
    create<T extends as_fusion_form_submissionsCreateArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsCreateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsCreateManyArgs} args - Arguments to create many As_fusion_form_submissions.
     * @example
     * // Create many As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_fusion_form_submissionsCreateManyArgs>(
      args?: SelectSubset<T, as_fusion_form_submissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsDeleteArgs} args - Arguments to delete one As_fusion_form_submissions.
     * @example
     * // Delete one As_fusion_form_submissions
     * const As_fusion_form_submissions = await prisma.as_fusion_form_submissions.delete({
     *   where: {
     *     // ... filter to delete one As_fusion_form_submissions
     *   }
     * })
     *
     */
    delete<T extends as_fusion_form_submissionsDeleteArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsDeleteArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsUpdateArgs} args - Arguments to update one As_fusion_form_submissions.
     * @example
     * // Update one As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_fusion_form_submissionsUpdateArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsUpdateArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsDeleteManyArgs} args - Arguments to filter As_fusion_form_submissions to delete.
     * @example
     * // Delete a few As_fusion_form_submissions
     * const { count } = await prisma.as_fusion_form_submissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_fusion_form_submissionsDeleteManyArgs>(
      args?: SelectSubset<T, as_fusion_form_submissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_fusion_form_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_fusion_form_submissionsUpdateManyArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_fusion_form_submissions.
     * @param {as_fusion_form_submissionsUpsertArgs} args - Arguments to update or create a As_fusion_form_submissions.
     * @example
     * // Update or create a As_fusion_form_submissions
     * const as_fusion_form_submissions = await prisma.as_fusion_form_submissions.upsert({
     *   create: {
     *     // ... data to create a As_fusion_form_submissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_fusion_form_submissions we want to update
     *   }
     * })
     */
    upsert<T extends as_fusion_form_submissionsUpsertArgs>(
      args: SelectSubset<T, as_fusion_form_submissionsUpsertArgs<ExtArgs>>
    ): Prisma__as_fusion_form_submissionsClient<
      $Result.GetResult<
        Prisma.$as_fusion_form_submissionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_fusion_form_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsCountArgs} args - Arguments to filter As_fusion_form_submissions to count.
     * @example
     * // Count the number of As_fusion_form_submissions
     * const count = await prisma.as_fusion_form_submissions.count({
     *   where: {
     *     // ... the filter for the As_fusion_form_submissions we want to count
     *   }
     * })
     */
    count<T extends as_fusion_form_submissionsCountArgs>(
      args?: Subset<T, as_fusion_form_submissionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_fusion_form_submissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_fusion_form_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_fusion_form_submissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_fusion_form_submissionsAggregateArgs>(
      args: Subset<T, As_fusion_form_submissionsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_fusion_form_submissionsAggregateType<T>>

    /**
     * Group by As_fusion_form_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_form_submissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_fusion_form_submissionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_fusion_form_submissionsGroupByArgs['orderBy'] }
        : { orderBy?: as_fusion_form_submissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_fusion_form_submissionsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_fusion_form_submissionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_fusion_form_submissions model
     */
    readonly fields: as_fusion_form_submissionsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_fusion_form_submissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_fusion_form_submissionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_fusion_form_submissions model
   */
  interface as_fusion_form_submissionsFieldRefs {
    readonly id: FieldRef<'as_fusion_form_submissions', 'BigInt'>
    readonly form_id: FieldRef<'as_fusion_form_submissions', 'BigInt'>
    readonly time: FieldRef<'as_fusion_form_submissions', 'DateTime'>
    readonly source_url: FieldRef<'as_fusion_form_submissions', 'String'>
    readonly post_id: FieldRef<'as_fusion_form_submissions', 'BigInt'>
    readonly user_id: FieldRef<'as_fusion_form_submissions', 'BigInt'>
    readonly user_agent: FieldRef<'as_fusion_form_submissions', 'String'>
    readonly ip: FieldRef<'as_fusion_form_submissions', 'String'>
    readonly is_read: FieldRef<'as_fusion_form_submissions', 'Boolean'>
    readonly privacy_scrub_date: FieldRef<'as_fusion_form_submissions', 'DateTime'>
    readonly on_privacy_scrub: FieldRef<'as_fusion_form_submissions', 'String'>
    readonly data: FieldRef<'as_fusion_form_submissions', 'String'>
  }

  // Custom InputTypes
  /**
   * as_fusion_form_submissions findUnique
   */
  export type as_fusion_form_submissionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_submissions to fetch.
     */
    where: as_fusion_form_submissionsWhereUniqueInput
  }

  /**
   * as_fusion_form_submissions findUniqueOrThrow
   */
  export type as_fusion_form_submissionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_submissions to fetch.
     */
    where: as_fusion_form_submissionsWhereUniqueInput
  }

  /**
   * as_fusion_form_submissions findFirst
   */
  export type as_fusion_form_submissionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_submissions to fetch.
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_submissions to fetch.
     */
    orderBy?:
      | as_fusion_form_submissionsOrderByWithRelationInput
      | as_fusion_form_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_submissions.
     */
    cursor?: as_fusion_form_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_submissions.
     */
    distinct?:
      | As_fusion_form_submissionsScalarFieldEnum
      | As_fusion_form_submissionsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_submissions findFirstOrThrow
   */
  export type as_fusion_form_submissionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_submissions to fetch.
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_submissions to fetch.
     */
    orderBy?:
      | as_fusion_form_submissionsOrderByWithRelationInput
      | as_fusion_form_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_form_submissions.
     */
    cursor?: as_fusion_form_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_form_submissions.
     */
    distinct?:
      | As_fusion_form_submissionsScalarFieldEnum
      | As_fusion_form_submissionsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_submissions findMany
   */
  export type as_fusion_form_submissionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_form_submissions to fetch.
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_form_submissions to fetch.
     */
    orderBy?:
      | as_fusion_form_submissionsOrderByWithRelationInput
      | as_fusion_form_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_fusion_form_submissions.
     */
    cursor?: as_fusion_form_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_form_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_form_submissions.
     */
    skip?: number
    distinct?:
      | As_fusion_form_submissionsScalarFieldEnum
      | As_fusion_form_submissionsScalarFieldEnum[]
  }

  /**
   * as_fusion_form_submissions create
   */
  export type as_fusion_form_submissionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_fusion_form_submissions.
     */
    data: XOR<as_fusion_form_submissionsCreateInput, as_fusion_form_submissionsUncheckedCreateInput>
  }

  /**
   * as_fusion_form_submissions createMany
   */
  export type as_fusion_form_submissionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_fusion_form_submissions.
     */
    data: as_fusion_form_submissionsCreateManyInput | as_fusion_form_submissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_fusion_form_submissions update
   */
  export type as_fusion_form_submissionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_fusion_form_submissions.
     */
    data: XOR<as_fusion_form_submissionsUpdateInput, as_fusion_form_submissionsUncheckedUpdateInput>
    /**
     * Choose, which as_fusion_form_submissions to update.
     */
    where: as_fusion_form_submissionsWhereUniqueInput
  }

  /**
   * as_fusion_form_submissions updateMany
   */
  export type as_fusion_form_submissionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_fusion_form_submissions.
     */
    data: XOR<
      as_fusion_form_submissionsUpdateManyMutationInput,
      as_fusion_form_submissionsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_fusion_form_submissions to update
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * Limit how many as_fusion_form_submissions to update.
     */
    limit?: number
  }

  /**
   * as_fusion_form_submissions upsert
   */
  export type as_fusion_form_submissionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_fusion_form_submissions to update in case it exists.
     */
    where: as_fusion_form_submissionsWhereUniqueInput
    /**
     * In case the as_fusion_form_submissions found by the `where` argument doesn't exist, create a new as_fusion_form_submissions with this data.
     */
    create: XOR<
      as_fusion_form_submissionsCreateInput,
      as_fusion_form_submissionsUncheckedCreateInput
    >
    /**
     * In case the as_fusion_form_submissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      as_fusion_form_submissionsUpdateInput,
      as_fusion_form_submissionsUncheckedUpdateInput
    >
  }

  /**
   * as_fusion_form_submissions delete
   */
  export type as_fusion_form_submissionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
    /**
     * Filter which as_fusion_form_submissions to delete.
     */
    where: as_fusion_form_submissionsWhereUniqueInput
  }

  /**
   * as_fusion_form_submissions deleteMany
   */
  export type as_fusion_form_submissionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_form_submissions to delete
     */
    where?: as_fusion_form_submissionsWhereInput
    /**
     * Limit how many as_fusion_form_submissions to delete.
     */
    limit?: number
  }

  /**
   * as_fusion_form_submissions without action
   */
  export type as_fusion_form_submissionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_form_submissions
     */
    select?: as_fusion_form_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_form_submissions
     */
    omit?: as_fusion_form_submissionsOmit<ExtArgs> | null
  }

  /**
   * Model as_fusion_forms
   */

  export type AggregateAs_fusion_forms = {
    _count: As_fusion_formsCountAggregateOutputType | null
    _avg: As_fusion_formsAvgAggregateOutputType | null
    _sum: As_fusion_formsSumAggregateOutputType | null
    _min: As_fusion_formsMinAggregateOutputType | null
    _max: As_fusion_formsMaxAggregateOutputType | null
  }

  export type As_fusion_formsAvgAggregateOutputType = {
    id: number | null
    form_id: number | null
    views: number | null
    submissions_count: number | null
  }

  export type As_fusion_formsSumAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    views: bigint | null
    submissions_count: bigint | null
  }

  export type As_fusion_formsMinAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    views: bigint | null
    submissions_count: bigint | null
    data: string | null
  }

  export type As_fusion_formsMaxAggregateOutputType = {
    id: bigint | null
    form_id: bigint | null
    views: bigint | null
    submissions_count: bigint | null
    data: string | null
  }

  export type As_fusion_formsCountAggregateOutputType = {
    id: number
    form_id: number
    views: number
    submissions_count: number
    data: number
    _all: number
  }

  export type As_fusion_formsAvgAggregateInputType = {
    id?: true
    form_id?: true
    views?: true
    submissions_count?: true
  }

  export type As_fusion_formsSumAggregateInputType = {
    id?: true
    form_id?: true
    views?: true
    submissions_count?: true
  }

  export type As_fusion_formsMinAggregateInputType = {
    id?: true
    form_id?: true
    views?: true
    submissions_count?: true
    data?: true
  }

  export type As_fusion_formsMaxAggregateInputType = {
    id?: true
    form_id?: true
    views?: true
    submissions_count?: true
    data?: true
  }

  export type As_fusion_formsCountAggregateInputType = {
    id?: true
    form_id?: true
    views?: true
    submissions_count?: true
    data?: true
    _all?: true
  }

  export type As_fusion_formsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_forms to aggregate.
     */
    where?: as_fusion_formsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_forms to fetch.
     */
    orderBy?: as_fusion_formsOrderByWithRelationInput | as_fusion_formsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_fusion_formsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_fusion_forms
     */
    _count?: true | As_fusion_formsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_fusion_formsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_fusion_formsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_fusion_formsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_fusion_formsMaxAggregateInputType
  }

  export type GetAs_fusion_formsAggregateType<T extends As_fusion_formsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_fusion_forms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_fusion_forms[P]>
      : GetScalarType<T[P], AggregateAs_fusion_forms[P]>
  }

  export type as_fusion_formsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_fusion_formsWhereInput
    orderBy?:
      | as_fusion_formsOrderByWithAggregationInput
      | as_fusion_formsOrderByWithAggregationInput[]
    by: As_fusion_formsScalarFieldEnum[] | As_fusion_formsScalarFieldEnum
    having?: as_fusion_formsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_fusion_formsCountAggregateInputType | true
    _avg?: As_fusion_formsAvgAggregateInputType
    _sum?: As_fusion_formsSumAggregateInputType
    _min?: As_fusion_formsMinAggregateInputType
    _max?: As_fusion_formsMaxAggregateInputType
  }

  export type As_fusion_formsGroupByOutputType = {
    id: bigint
    form_id: bigint
    views: bigint | null
    submissions_count: bigint | null
    data: string | null
    _count: As_fusion_formsCountAggregateOutputType | null
    _avg: As_fusion_formsAvgAggregateOutputType | null
    _sum: As_fusion_formsSumAggregateOutputType | null
    _min: As_fusion_formsMinAggregateOutputType | null
    _max: As_fusion_formsMaxAggregateOutputType | null
  }

  type GetAs_fusion_formsGroupByPayload<T extends as_fusion_formsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_fusion_formsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_fusion_formsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_fusion_formsGroupByOutputType[P]>
            : GetScalarType<T[P], As_fusion_formsGroupByOutputType[P]>
        }
      >
    >

  export type as_fusion_formsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      form_id?: boolean
      views?: boolean
      submissions_count?: boolean
      data?: boolean
    },
    ExtArgs['result']['as_fusion_forms']
  >

  export type as_fusion_formsSelectScalar = {
    id?: boolean
    form_id?: boolean
    views?: boolean
    submissions_count?: boolean
    data?: boolean
  }

  export type as_fusion_formsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'form_id' | 'views' | 'submissions_count' | 'data',
    ExtArgs['result']['as_fusion_forms']
  >

  export type $as_fusion_formsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_fusion_forms'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        form_id: bigint
        views: bigint | null
        submissions_count: bigint | null
        data: string | null
      },
      ExtArgs['result']['as_fusion_forms']
    >
    composites: {}
  }

  type as_fusion_formsGetPayload<
    S extends boolean | null | undefined | as_fusion_formsDefaultArgs
  > = $Result.GetResult<Prisma.$as_fusion_formsPayload, S>

  type as_fusion_formsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_fusion_formsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_fusion_formsCountAggregateInputType | true
  }

  export interface as_fusion_formsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_fusion_forms']
      meta: { name: 'as_fusion_forms' }
    }
    /**
     * Find zero or one As_fusion_forms that matches the filter.
     * @param {as_fusion_formsFindUniqueArgs} args - Arguments to find a As_fusion_forms
     * @example
     * // Get one As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_fusion_formsFindUniqueArgs>(
      args: SelectSubset<T, as_fusion_formsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<
        Prisma.$as_fusion_formsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_fusion_forms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_fusion_formsFindUniqueOrThrowArgs} args - Arguments to find a As_fusion_forms
     * @example
     * // Get one As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_fusion_formsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_fusion_formsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<
        Prisma.$as_fusion_formsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsFindFirstArgs} args - Arguments to find a As_fusion_forms
     * @example
     * // Get one As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_fusion_formsFindFirstArgs>(
      args?: SelectSubset<T, as_fusion_formsFindFirstArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<
        Prisma.$as_fusion_formsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_fusion_forms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsFindFirstOrThrowArgs} args - Arguments to find a As_fusion_forms
     * @example
     * // Get one As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_fusion_formsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_fusion_formsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<
        Prisma.$as_fusion_formsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_fusion_forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findMany()
     *
     * // Get first 10 As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_fusion_formsWithIdOnly = await prisma.as_fusion_forms.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_fusion_formsFindManyArgs>(
      args?: SelectSubset<T, as_fusion_formsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_fusion_formsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_fusion_forms.
     * @param {as_fusion_formsCreateArgs} args - Arguments to create a As_fusion_forms.
     * @example
     * // Create one As_fusion_forms
     * const As_fusion_forms = await prisma.as_fusion_forms.create({
     *   data: {
     *     // ... data to create a As_fusion_forms
     *   }
     * })
     *
     */
    create<T extends as_fusion_formsCreateArgs>(
      args: SelectSubset<T, as_fusion_formsCreateArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<Prisma.$as_fusion_formsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_fusion_forms.
     * @param {as_fusion_formsCreateManyArgs} args - Arguments to create many As_fusion_forms.
     * @example
     * // Create many As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_fusion_formsCreateManyArgs>(
      args?: SelectSubset<T, as_fusion_formsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_fusion_forms.
     * @param {as_fusion_formsDeleteArgs} args - Arguments to delete one As_fusion_forms.
     * @example
     * // Delete one As_fusion_forms
     * const As_fusion_forms = await prisma.as_fusion_forms.delete({
     *   where: {
     *     // ... filter to delete one As_fusion_forms
     *   }
     * })
     *
     */
    delete<T extends as_fusion_formsDeleteArgs>(
      args: SelectSubset<T, as_fusion_formsDeleteArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<Prisma.$as_fusion_formsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_fusion_forms.
     * @param {as_fusion_formsUpdateArgs} args - Arguments to update one As_fusion_forms.
     * @example
     * // Update one As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_fusion_formsUpdateArgs>(
      args: SelectSubset<T, as_fusion_formsUpdateArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<Prisma.$as_fusion_formsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_fusion_forms.
     * @param {as_fusion_formsDeleteManyArgs} args - Arguments to filter As_fusion_forms to delete.
     * @example
     * // Delete a few As_fusion_forms
     * const { count } = await prisma.as_fusion_forms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_fusion_formsDeleteManyArgs>(
      args?: SelectSubset<T, as_fusion_formsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_fusion_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_fusion_formsUpdateManyArgs>(
      args: SelectSubset<T, as_fusion_formsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_fusion_forms.
     * @param {as_fusion_formsUpsertArgs} args - Arguments to update or create a As_fusion_forms.
     * @example
     * // Update or create a As_fusion_forms
     * const as_fusion_forms = await prisma.as_fusion_forms.upsert({
     *   create: {
     *     // ... data to create a As_fusion_forms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_fusion_forms we want to update
     *   }
     * })
     */
    upsert<T extends as_fusion_formsUpsertArgs>(
      args: SelectSubset<T, as_fusion_formsUpsertArgs<ExtArgs>>
    ): Prisma__as_fusion_formsClient<
      $Result.GetResult<Prisma.$as_fusion_formsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_fusion_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsCountArgs} args - Arguments to filter As_fusion_forms to count.
     * @example
     * // Count the number of As_fusion_forms
     * const count = await prisma.as_fusion_forms.count({
     *   where: {
     *     // ... the filter for the As_fusion_forms we want to count
     *   }
     * })
     */
    count<T extends as_fusion_formsCountArgs>(
      args?: Subset<T, as_fusion_formsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_fusion_formsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_fusion_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_fusion_formsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_fusion_formsAggregateArgs>(
      args: Subset<T, As_fusion_formsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_fusion_formsAggregateType<T>>

    /**
     * Group by As_fusion_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_fusion_formsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_fusion_formsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_fusion_formsGroupByArgs['orderBy'] }
        : { orderBy?: as_fusion_formsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_fusion_formsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_fusion_formsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_fusion_forms model
     */
    readonly fields: as_fusion_formsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_fusion_forms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_fusion_formsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_fusion_forms model
   */
  interface as_fusion_formsFieldRefs {
    readonly id: FieldRef<'as_fusion_forms', 'BigInt'>
    readonly form_id: FieldRef<'as_fusion_forms', 'BigInt'>
    readonly views: FieldRef<'as_fusion_forms', 'BigInt'>
    readonly submissions_count: FieldRef<'as_fusion_forms', 'BigInt'>
    readonly data: FieldRef<'as_fusion_forms', 'String'>
  }

  // Custom InputTypes
  /**
   * as_fusion_forms findUnique
   */
  export type as_fusion_formsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_forms to fetch.
     */
    where: as_fusion_formsWhereUniqueInput
  }

  /**
   * as_fusion_forms findUniqueOrThrow
   */
  export type as_fusion_formsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_forms to fetch.
     */
    where: as_fusion_formsWhereUniqueInput
  }

  /**
   * as_fusion_forms findFirst
   */
  export type as_fusion_formsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_forms to fetch.
     */
    where?: as_fusion_formsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_forms to fetch.
     */
    orderBy?: as_fusion_formsOrderByWithRelationInput | as_fusion_formsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_forms.
     */
    cursor?: as_fusion_formsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_forms.
     */
    distinct?: As_fusion_formsScalarFieldEnum | As_fusion_formsScalarFieldEnum[]
  }

  /**
   * as_fusion_forms findFirstOrThrow
   */
  export type as_fusion_formsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_forms to fetch.
     */
    where?: as_fusion_formsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_forms to fetch.
     */
    orderBy?: as_fusion_formsOrderByWithRelationInput | as_fusion_formsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_fusion_forms.
     */
    cursor?: as_fusion_formsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_fusion_forms.
     */
    distinct?: As_fusion_formsScalarFieldEnum | As_fusion_formsScalarFieldEnum[]
  }

  /**
   * as_fusion_forms findMany
   */
  export type as_fusion_formsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter, which as_fusion_forms to fetch.
     */
    where?: as_fusion_formsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_fusion_forms to fetch.
     */
    orderBy?: as_fusion_formsOrderByWithRelationInput | as_fusion_formsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_fusion_forms.
     */
    cursor?: as_fusion_formsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_fusion_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_fusion_forms.
     */
    skip?: number
    distinct?: As_fusion_formsScalarFieldEnum | As_fusion_formsScalarFieldEnum[]
  }

  /**
   * as_fusion_forms create
   */
  export type as_fusion_formsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_fusion_forms.
     */
    data: XOR<as_fusion_formsCreateInput, as_fusion_formsUncheckedCreateInput>
  }

  /**
   * as_fusion_forms createMany
   */
  export type as_fusion_formsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_fusion_forms.
     */
    data: as_fusion_formsCreateManyInput | as_fusion_formsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_fusion_forms update
   */
  export type as_fusion_formsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_fusion_forms.
     */
    data: XOR<as_fusion_formsUpdateInput, as_fusion_formsUncheckedUpdateInput>
    /**
     * Choose, which as_fusion_forms to update.
     */
    where: as_fusion_formsWhereUniqueInput
  }

  /**
   * as_fusion_forms updateMany
   */
  export type as_fusion_formsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_fusion_forms.
     */
    data: XOR<as_fusion_formsUpdateManyMutationInput, as_fusion_formsUncheckedUpdateManyInput>
    /**
     * Filter which as_fusion_forms to update
     */
    where?: as_fusion_formsWhereInput
    /**
     * Limit how many as_fusion_forms to update.
     */
    limit?: number
  }

  /**
   * as_fusion_forms upsert
   */
  export type as_fusion_formsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_fusion_forms to update in case it exists.
     */
    where: as_fusion_formsWhereUniqueInput
    /**
     * In case the as_fusion_forms found by the `where` argument doesn't exist, create a new as_fusion_forms with this data.
     */
    create: XOR<as_fusion_formsCreateInput, as_fusion_formsUncheckedCreateInput>
    /**
     * In case the as_fusion_forms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_fusion_formsUpdateInput, as_fusion_formsUncheckedUpdateInput>
  }

  /**
   * as_fusion_forms delete
   */
  export type as_fusion_formsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
    /**
     * Filter which as_fusion_forms to delete.
     */
    where: as_fusion_formsWhereUniqueInput
  }

  /**
   * as_fusion_forms deleteMany
   */
  export type as_fusion_formsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_fusion_forms to delete
     */
    where?: as_fusion_formsWhereInput
    /**
     * Limit how many as_fusion_forms to delete.
     */
    limit?: number
  }

  /**
   * as_fusion_forms without action
   */
  export type as_fusion_formsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_fusion_forms
     */
    select?: as_fusion_formsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_fusion_forms
     */
    omit?: as_fusion_formsOmit<ExtArgs> | null
  }

  /**
   * Model as_layerslider
   */

  export type AggregateAs_layerslider = {
    _count: As_layersliderCountAggregateOutputType | null
    _avg: As_layersliderAvgAggregateOutputType | null
    _sum: As_layersliderSumAggregateOutputType | null
    _min: As_layersliderMinAggregateOutputType | null
    _max: As_layersliderMaxAggregateOutputType | null
  }

  export type As_layersliderAvgAggregateOutputType = {
    id: number | null
    group_id: number | null
    author: number | null
    date_c: number | null
    date_m: number | null
    schedule_start: number | null
    schedule_end: number | null
  }

  export type As_layersliderSumAggregateOutputType = {
    id: number | null
    group_id: number | null
    author: number | null
    date_c: number | null
    date_m: number | null
    schedule_start: number | null
    schedule_end: number | null
  }

  export type As_layersliderMinAggregateOutputType = {
    id: number | null
    group_id: number | null
    author: number | null
    name: string | null
    slug: string | null
    data: string | null
    date_c: number | null
    date_m: number | null
    schedule_start: number | null
    schedule_end: number | null
    flag_hidden: boolean | null
    flag_deleted: boolean | null
    flag_popup: boolean | null
    flag_group: boolean | null
  }

  export type As_layersliderMaxAggregateOutputType = {
    id: number | null
    group_id: number | null
    author: number | null
    name: string | null
    slug: string | null
    data: string | null
    date_c: number | null
    date_m: number | null
    schedule_start: number | null
    schedule_end: number | null
    flag_hidden: boolean | null
    flag_deleted: boolean | null
    flag_popup: boolean | null
    flag_group: boolean | null
  }

  export type As_layersliderCountAggregateOutputType = {
    id: number
    group_id: number
    author: number
    name: number
    slug: number
    data: number
    date_c: number
    date_m: number
    schedule_start: number
    schedule_end: number
    flag_hidden: number
    flag_deleted: number
    flag_popup: number
    flag_group: number
    _all: number
  }

  export type As_layersliderAvgAggregateInputType = {
    id?: true
    group_id?: true
    author?: true
    date_c?: true
    date_m?: true
    schedule_start?: true
    schedule_end?: true
  }

  export type As_layersliderSumAggregateInputType = {
    id?: true
    group_id?: true
    author?: true
    date_c?: true
    date_m?: true
    schedule_start?: true
    schedule_end?: true
  }

  export type As_layersliderMinAggregateInputType = {
    id?: true
    group_id?: true
    author?: true
    name?: true
    slug?: true
    data?: true
    date_c?: true
    date_m?: true
    schedule_start?: true
    schedule_end?: true
    flag_hidden?: true
    flag_deleted?: true
    flag_popup?: true
    flag_group?: true
  }

  export type As_layersliderMaxAggregateInputType = {
    id?: true
    group_id?: true
    author?: true
    name?: true
    slug?: true
    data?: true
    date_c?: true
    date_m?: true
    schedule_start?: true
    schedule_end?: true
    flag_hidden?: true
    flag_deleted?: true
    flag_popup?: true
    flag_group?: true
  }

  export type As_layersliderCountAggregateInputType = {
    id?: true
    group_id?: true
    author?: true
    name?: true
    slug?: true
    data?: true
    date_c?: true
    date_m?: true
    schedule_start?: true
    schedule_end?: true
    flag_hidden?: true
    flag_deleted?: true
    flag_popup?: true
    flag_group?: true
    _all?: true
  }

  export type As_layersliderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_layerslider to aggregate.
     */
    where?: as_layersliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layersliders to fetch.
     */
    orderBy?: as_layersliderOrderByWithRelationInput | as_layersliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_layersliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layersliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layersliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_layersliders
     */
    _count?: true | As_layersliderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_layersliderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_layersliderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_layersliderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_layersliderMaxAggregateInputType
  }

  export type GetAs_layersliderAggregateType<T extends As_layersliderAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_layerslider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_layerslider[P]>
      : GetScalarType<T[P], AggregateAs_layerslider[P]>
  }

  export type as_layersliderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_layersliderWhereInput
    orderBy?:
      | as_layersliderOrderByWithAggregationInput
      | as_layersliderOrderByWithAggregationInput[]
    by: As_layersliderScalarFieldEnum[] | As_layersliderScalarFieldEnum
    having?: as_layersliderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_layersliderCountAggregateInputType | true
    _avg?: As_layersliderAvgAggregateInputType
    _sum?: As_layersliderSumAggregateInputType
    _min?: As_layersliderMinAggregateInputType
    _max?: As_layersliderMaxAggregateInputType
  }

  export type As_layersliderGroupByOutputType = {
    id: number
    group_id: number | null
    author: number
    name: string | null
    slug: string | null
    data: string
    date_c: number
    date_m: number
    schedule_start: number
    schedule_end: number
    flag_hidden: boolean
    flag_deleted: boolean
    flag_popup: boolean
    flag_group: boolean
    _count: As_layersliderCountAggregateOutputType | null
    _avg: As_layersliderAvgAggregateOutputType | null
    _sum: As_layersliderSumAggregateOutputType | null
    _min: As_layersliderMinAggregateOutputType | null
    _max: As_layersliderMaxAggregateOutputType | null
  }

  type GetAs_layersliderGroupByPayload<T extends as_layersliderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_layersliderGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_layersliderGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_layersliderGroupByOutputType[P]>
          : GetScalarType<T[P], As_layersliderGroupByOutputType[P]>
      }
    >
  >

  export type as_layersliderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      group_id?: boolean
      author?: boolean
      name?: boolean
      slug?: boolean
      data?: boolean
      date_c?: boolean
      date_m?: boolean
      schedule_start?: boolean
      schedule_end?: boolean
      flag_hidden?: boolean
      flag_deleted?: boolean
      flag_popup?: boolean
      flag_group?: boolean
    },
    ExtArgs['result']['as_layerslider']
  >

  export type as_layersliderSelectScalar = {
    id?: boolean
    group_id?: boolean
    author?: boolean
    name?: boolean
    slug?: boolean
    data?: boolean
    date_c?: boolean
    date_m?: boolean
    schedule_start?: boolean
    schedule_end?: boolean
    flag_hidden?: boolean
    flag_deleted?: boolean
    flag_popup?: boolean
    flag_group?: boolean
  }

  export type as_layersliderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'group_id'
    | 'author'
    | 'name'
    | 'slug'
    | 'data'
    | 'date_c'
    | 'date_m'
    | 'schedule_start'
    | 'schedule_end'
    | 'flag_hidden'
    | 'flag_deleted'
    | 'flag_popup'
    | 'flag_group',
    ExtArgs['result']['as_layerslider']
  >

  export type $as_layersliderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_layerslider'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        group_id: number | null
        author: number
        name: string | null
        slug: string | null
        data: string
        date_c: number
        date_m: number
        schedule_start: number
        schedule_end: number
        flag_hidden: boolean
        flag_deleted: boolean
        flag_popup: boolean
        flag_group: boolean
      },
      ExtArgs['result']['as_layerslider']
    >
    composites: {}
  }

  type as_layersliderGetPayload<S extends boolean | null | undefined | as_layersliderDefaultArgs> =
    $Result.GetResult<Prisma.$as_layersliderPayload, S>

  type as_layersliderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_layersliderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_layersliderCountAggregateInputType | true
    }

  export interface as_layersliderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_layerslider']
      meta: { name: 'as_layerslider' }
    }
    /**
     * Find zero or one As_layerslider that matches the filter.
     * @param {as_layersliderFindUniqueArgs} args - Arguments to find a As_layerslider
     * @example
     * // Get one As_layerslider
     * const as_layerslider = await prisma.as_layerslider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_layersliderFindUniqueArgs>(
      args: SelectSubset<T, as_layersliderFindUniqueArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<
        Prisma.$as_layersliderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_layerslider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_layersliderFindUniqueOrThrowArgs} args - Arguments to find a As_layerslider
     * @example
     * // Get one As_layerslider
     * const as_layerslider = await prisma.as_layerslider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_layersliderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_layersliderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<
        Prisma.$as_layersliderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_layerslider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderFindFirstArgs} args - Arguments to find a As_layerslider
     * @example
     * // Get one As_layerslider
     * const as_layerslider = await prisma.as_layerslider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_layersliderFindFirstArgs>(
      args?: SelectSubset<T, as_layersliderFindFirstArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<
        Prisma.$as_layersliderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_layerslider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderFindFirstOrThrowArgs} args - Arguments to find a As_layerslider
     * @example
     * // Get one As_layerslider
     * const as_layerslider = await prisma.as_layerslider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_layersliderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_layersliderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<
        Prisma.$as_layersliderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_layersliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_layersliders
     * const as_layersliders = await prisma.as_layerslider.findMany()
     *
     * // Get first 10 As_layersliders
     * const as_layersliders = await prisma.as_layerslider.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_layersliderWithIdOnly = await prisma.as_layerslider.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_layersliderFindManyArgs>(
      args?: SelectSubset<T, as_layersliderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_layersliderPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_layerslider.
     * @param {as_layersliderCreateArgs} args - Arguments to create a As_layerslider.
     * @example
     * // Create one As_layerslider
     * const As_layerslider = await prisma.as_layerslider.create({
     *   data: {
     *     // ... data to create a As_layerslider
     *   }
     * })
     *
     */
    create<T extends as_layersliderCreateArgs>(
      args: SelectSubset<T, as_layersliderCreateArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<Prisma.$as_layersliderPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_layersliders.
     * @param {as_layersliderCreateManyArgs} args - Arguments to create many As_layersliders.
     * @example
     * // Create many As_layersliders
     * const as_layerslider = await prisma.as_layerslider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_layersliderCreateManyArgs>(
      args?: SelectSubset<T, as_layersliderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_layerslider.
     * @param {as_layersliderDeleteArgs} args - Arguments to delete one As_layerslider.
     * @example
     * // Delete one As_layerslider
     * const As_layerslider = await prisma.as_layerslider.delete({
     *   where: {
     *     // ... filter to delete one As_layerslider
     *   }
     * })
     *
     */
    delete<T extends as_layersliderDeleteArgs>(
      args: SelectSubset<T, as_layersliderDeleteArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<Prisma.$as_layersliderPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_layerslider.
     * @param {as_layersliderUpdateArgs} args - Arguments to update one As_layerslider.
     * @example
     * // Update one As_layerslider
     * const as_layerslider = await prisma.as_layerslider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_layersliderUpdateArgs>(
      args: SelectSubset<T, as_layersliderUpdateArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<Prisma.$as_layersliderPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_layersliders.
     * @param {as_layersliderDeleteManyArgs} args - Arguments to filter As_layersliders to delete.
     * @example
     * // Delete a few As_layersliders
     * const { count } = await prisma.as_layerslider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_layersliderDeleteManyArgs>(
      args?: SelectSubset<T, as_layersliderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_layersliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_layersliders
     * const as_layerslider = await prisma.as_layerslider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_layersliderUpdateManyArgs>(
      args: SelectSubset<T, as_layersliderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_layerslider.
     * @param {as_layersliderUpsertArgs} args - Arguments to update or create a As_layerslider.
     * @example
     * // Update or create a As_layerslider
     * const as_layerslider = await prisma.as_layerslider.upsert({
     *   create: {
     *     // ... data to create a As_layerslider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_layerslider we want to update
     *   }
     * })
     */
    upsert<T extends as_layersliderUpsertArgs>(
      args: SelectSubset<T, as_layersliderUpsertArgs<ExtArgs>>
    ): Prisma__as_layersliderClient<
      $Result.GetResult<Prisma.$as_layersliderPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_layersliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderCountArgs} args - Arguments to filter As_layersliders to count.
     * @example
     * // Count the number of As_layersliders
     * const count = await prisma.as_layerslider.count({
     *   where: {
     *     // ... the filter for the As_layersliders we want to count
     *   }
     * })
     */
    count<T extends as_layersliderCountArgs>(
      args?: Subset<T, as_layersliderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_layersliderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_layerslider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_layersliderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_layersliderAggregateArgs>(
      args: Subset<T, As_layersliderAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_layersliderAggregateType<T>>

    /**
     * Group by As_layerslider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layersliderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_layersliderGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_layersliderGroupByArgs['orderBy'] }
        : { orderBy?: as_layersliderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_layersliderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_layersliderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_layerslider model
     */
    readonly fields: as_layersliderFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_layerslider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_layersliderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_layerslider model
   */
  interface as_layersliderFieldRefs {
    readonly id: FieldRef<'as_layerslider', 'Int'>
    readonly group_id: FieldRef<'as_layerslider', 'Int'>
    readonly author: FieldRef<'as_layerslider', 'Int'>
    readonly name: FieldRef<'as_layerslider', 'String'>
    readonly slug: FieldRef<'as_layerslider', 'String'>
    readonly data: FieldRef<'as_layerslider', 'String'>
    readonly date_c: FieldRef<'as_layerslider', 'Int'>
    readonly date_m: FieldRef<'as_layerslider', 'Int'>
    readonly schedule_start: FieldRef<'as_layerslider', 'Int'>
    readonly schedule_end: FieldRef<'as_layerslider', 'Int'>
    readonly flag_hidden: FieldRef<'as_layerslider', 'Boolean'>
    readonly flag_deleted: FieldRef<'as_layerslider', 'Boolean'>
    readonly flag_popup: FieldRef<'as_layerslider', 'Boolean'>
    readonly flag_group: FieldRef<'as_layerslider', 'Boolean'>
  }

  // Custom InputTypes
  /**
   * as_layerslider findUnique
   */
  export type as_layersliderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider to fetch.
     */
    where: as_layersliderWhereUniqueInput
  }

  /**
   * as_layerslider findUniqueOrThrow
   */
  export type as_layersliderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider to fetch.
     */
    where: as_layersliderWhereUniqueInput
  }

  /**
   * as_layerslider findFirst
   */
  export type as_layersliderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider to fetch.
     */
    where?: as_layersliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layersliders to fetch.
     */
    orderBy?: as_layersliderOrderByWithRelationInput | as_layersliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_layersliders.
     */
    cursor?: as_layersliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layersliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layersliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_layersliders.
     */
    distinct?: As_layersliderScalarFieldEnum | As_layersliderScalarFieldEnum[]
  }

  /**
   * as_layerslider findFirstOrThrow
   */
  export type as_layersliderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider to fetch.
     */
    where?: as_layersliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layersliders to fetch.
     */
    orderBy?: as_layersliderOrderByWithRelationInput | as_layersliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_layersliders.
     */
    cursor?: as_layersliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layersliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layersliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_layersliders.
     */
    distinct?: As_layersliderScalarFieldEnum | As_layersliderScalarFieldEnum[]
  }

  /**
   * as_layerslider findMany
   */
  export type as_layersliderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter, which as_layersliders to fetch.
     */
    where?: as_layersliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layersliders to fetch.
     */
    orderBy?: as_layersliderOrderByWithRelationInput | as_layersliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_layersliders.
     */
    cursor?: as_layersliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layersliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layersliders.
     */
    skip?: number
    distinct?: As_layersliderScalarFieldEnum | As_layersliderScalarFieldEnum[]
  }

  /**
   * as_layerslider create
   */
  export type as_layersliderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * The data needed to create a as_layerslider.
     */
    data: XOR<as_layersliderCreateInput, as_layersliderUncheckedCreateInput>
  }

  /**
   * as_layerslider createMany
   */
  export type as_layersliderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_layersliders.
     */
    data: as_layersliderCreateManyInput | as_layersliderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_layerslider update
   */
  export type as_layersliderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * The data needed to update a as_layerslider.
     */
    data: XOR<as_layersliderUpdateInput, as_layersliderUncheckedUpdateInput>
    /**
     * Choose, which as_layerslider to update.
     */
    where: as_layersliderWhereUniqueInput
  }

  /**
   * as_layerslider updateMany
   */
  export type as_layersliderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_layersliders.
     */
    data: XOR<as_layersliderUpdateManyMutationInput, as_layersliderUncheckedUpdateManyInput>
    /**
     * Filter which as_layersliders to update
     */
    where?: as_layersliderWhereInput
    /**
     * Limit how many as_layersliders to update.
     */
    limit?: number
  }

  /**
   * as_layerslider upsert
   */
  export type as_layersliderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * The filter to search for the as_layerslider to update in case it exists.
     */
    where: as_layersliderWhereUniqueInput
    /**
     * In case the as_layerslider found by the `where` argument doesn't exist, create a new as_layerslider with this data.
     */
    create: XOR<as_layersliderCreateInput, as_layersliderUncheckedCreateInput>
    /**
     * In case the as_layerslider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_layersliderUpdateInput, as_layersliderUncheckedUpdateInput>
  }

  /**
   * as_layerslider delete
   */
  export type as_layersliderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
    /**
     * Filter which as_layerslider to delete.
     */
    where: as_layersliderWhereUniqueInput
  }

  /**
   * as_layerslider deleteMany
   */
  export type as_layersliderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_layersliders to delete
     */
    where?: as_layersliderWhereInput
    /**
     * Limit how many as_layersliders to delete.
     */
    limit?: number
  }

  /**
   * as_layerslider without action
   */
  export type as_layersliderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider
     */
    select?: as_layersliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider
     */
    omit?: as_layersliderOmit<ExtArgs> | null
  }

  /**
   * Model as_layerslider_revisions
   */

  export type AggregateAs_layerslider_revisions = {
    _count: As_layerslider_revisionsCountAggregateOutputType | null
    _avg: As_layerslider_revisionsAvgAggregateOutputType | null
    _sum: As_layerslider_revisionsSumAggregateOutputType | null
    _min: As_layerslider_revisionsMinAggregateOutputType | null
    _max: As_layerslider_revisionsMaxAggregateOutputType | null
  }

  export type As_layerslider_revisionsAvgAggregateOutputType = {
    id: number | null
    slider_id: number | null
    author: number | null
    date_c: number | null
  }

  export type As_layerslider_revisionsSumAggregateOutputType = {
    id: number | null
    slider_id: number | null
    author: number | null
    date_c: number | null
  }

  export type As_layerslider_revisionsMinAggregateOutputType = {
    id: number | null
    slider_id: number | null
    author: number | null
    data: string | null
    date_c: number | null
  }

  export type As_layerslider_revisionsMaxAggregateOutputType = {
    id: number | null
    slider_id: number | null
    author: number | null
    data: string | null
    date_c: number | null
  }

  export type As_layerslider_revisionsCountAggregateOutputType = {
    id: number
    slider_id: number
    author: number
    data: number
    date_c: number
    _all: number
  }

  export type As_layerslider_revisionsAvgAggregateInputType = {
    id?: true
    slider_id?: true
    author?: true
    date_c?: true
  }

  export type As_layerslider_revisionsSumAggregateInputType = {
    id?: true
    slider_id?: true
    author?: true
    date_c?: true
  }

  export type As_layerslider_revisionsMinAggregateInputType = {
    id?: true
    slider_id?: true
    author?: true
    data?: true
    date_c?: true
  }

  export type As_layerslider_revisionsMaxAggregateInputType = {
    id?: true
    slider_id?: true
    author?: true
    data?: true
    date_c?: true
  }

  export type As_layerslider_revisionsCountAggregateInputType = {
    id?: true
    slider_id?: true
    author?: true
    data?: true
    date_c?: true
    _all?: true
  }

  export type As_layerslider_revisionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_layerslider_revisions to aggregate.
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layerslider_revisions to fetch.
     */
    orderBy?:
      | as_layerslider_revisionsOrderByWithRelationInput
      | as_layerslider_revisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_layerslider_revisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layerslider_revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layerslider_revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_layerslider_revisions
     */
    _count?: true | As_layerslider_revisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_layerslider_revisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_layerslider_revisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_layerslider_revisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_layerslider_revisionsMaxAggregateInputType
  }

  export type GetAs_layerslider_revisionsAggregateType<
    T extends As_layerslider_revisionsAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_layerslider_revisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_layerslider_revisions[P]>
      : GetScalarType<T[P], AggregateAs_layerslider_revisions[P]>
  }

  export type as_layerslider_revisionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_layerslider_revisionsWhereInput
    orderBy?:
      | as_layerslider_revisionsOrderByWithAggregationInput
      | as_layerslider_revisionsOrderByWithAggregationInput[]
    by: As_layerslider_revisionsScalarFieldEnum[] | As_layerslider_revisionsScalarFieldEnum
    having?: as_layerslider_revisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_layerslider_revisionsCountAggregateInputType | true
    _avg?: As_layerslider_revisionsAvgAggregateInputType
    _sum?: As_layerslider_revisionsSumAggregateInputType
    _min?: As_layerslider_revisionsMinAggregateInputType
    _max?: As_layerslider_revisionsMaxAggregateInputType
  }

  export type As_layerslider_revisionsGroupByOutputType = {
    id: number
    slider_id: number
    author: number
    data: string
    date_c: number
    _count: As_layerslider_revisionsCountAggregateOutputType | null
    _avg: As_layerslider_revisionsAvgAggregateOutputType | null
    _sum: As_layerslider_revisionsSumAggregateOutputType | null
    _min: As_layerslider_revisionsMinAggregateOutputType | null
    _max: As_layerslider_revisionsMaxAggregateOutputType | null
  }

  type GetAs_layerslider_revisionsGroupByPayload<T extends as_layerslider_revisionsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_layerslider_revisionsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_layerslider_revisionsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_layerslider_revisionsGroupByOutputType[P]>
            : GetScalarType<T[P], As_layerslider_revisionsGroupByOutputType[P]>
        }
      >
    >

  export type as_layerslider_revisionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slider_id?: boolean
      author?: boolean
      data?: boolean
      date_c?: boolean
    },
    ExtArgs['result']['as_layerslider_revisions']
  >

  export type as_layerslider_revisionsSelectScalar = {
    id?: boolean
    slider_id?: boolean
    author?: boolean
    data?: boolean
    date_c?: boolean
  }

  export type as_layerslider_revisionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'slider_id' | 'author' | 'data' | 'date_c',
    ExtArgs['result']['as_layerslider_revisions']
  >

  export type $as_layerslider_revisionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_layerslider_revisions'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        slider_id: number
        author: number
        data: string
        date_c: number
      },
      ExtArgs['result']['as_layerslider_revisions']
    >
    composites: {}
  }

  type as_layerslider_revisionsGetPayload<
    S extends boolean | null | undefined | as_layerslider_revisionsDefaultArgs
  > = $Result.GetResult<Prisma.$as_layerslider_revisionsPayload, S>

  type as_layerslider_revisionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_layerslider_revisionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_layerslider_revisionsCountAggregateInputType | true
  }

  export interface as_layerslider_revisionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_layerslider_revisions']
      meta: { name: 'as_layerslider_revisions' }
    }
    /**
     * Find zero or one As_layerslider_revisions that matches the filter.
     * @param {as_layerslider_revisionsFindUniqueArgs} args - Arguments to find a As_layerslider_revisions
     * @example
     * // Get one As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_layerslider_revisionsFindUniqueArgs>(
      args: SelectSubset<T, as_layerslider_revisionsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_layerslider_revisions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_layerslider_revisionsFindUniqueOrThrowArgs} args - Arguments to find a As_layerslider_revisions
     * @example
     * // Get one As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_layerslider_revisionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_layerslider_revisionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_layerslider_revisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsFindFirstArgs} args - Arguments to find a As_layerslider_revisions
     * @example
     * // Get one As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_layerslider_revisionsFindFirstArgs>(
      args?: SelectSubset<T, as_layerslider_revisionsFindFirstArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_layerslider_revisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsFindFirstOrThrowArgs} args - Arguments to find a As_layerslider_revisions
     * @example
     * // Get one As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_layerslider_revisionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_layerslider_revisionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_layerslider_revisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findMany()
     *
     * // Get first 10 As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_layerslider_revisionsWithIdOnly = await prisma.as_layerslider_revisions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_layerslider_revisionsFindManyArgs>(
      args?: SelectSubset<T, as_layerslider_revisionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_layerslider_revisions.
     * @param {as_layerslider_revisionsCreateArgs} args - Arguments to create a As_layerslider_revisions.
     * @example
     * // Create one As_layerslider_revisions
     * const As_layerslider_revisions = await prisma.as_layerslider_revisions.create({
     *   data: {
     *     // ... data to create a As_layerslider_revisions
     *   }
     * })
     *
     */
    create<T extends as_layerslider_revisionsCreateArgs>(
      args: SelectSubset<T, as_layerslider_revisionsCreateArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_layerslider_revisions.
     * @param {as_layerslider_revisionsCreateManyArgs} args - Arguments to create many As_layerslider_revisions.
     * @example
     * // Create many As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_layerslider_revisionsCreateManyArgs>(
      args?: SelectSubset<T, as_layerslider_revisionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_layerslider_revisions.
     * @param {as_layerslider_revisionsDeleteArgs} args - Arguments to delete one As_layerslider_revisions.
     * @example
     * // Delete one As_layerslider_revisions
     * const As_layerslider_revisions = await prisma.as_layerslider_revisions.delete({
     *   where: {
     *     // ... filter to delete one As_layerslider_revisions
     *   }
     * })
     *
     */
    delete<T extends as_layerslider_revisionsDeleteArgs>(
      args: SelectSubset<T, as_layerslider_revisionsDeleteArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_layerslider_revisions.
     * @param {as_layerslider_revisionsUpdateArgs} args - Arguments to update one As_layerslider_revisions.
     * @example
     * // Update one As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_layerslider_revisionsUpdateArgs>(
      args: SelectSubset<T, as_layerslider_revisionsUpdateArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_layerslider_revisions.
     * @param {as_layerslider_revisionsDeleteManyArgs} args - Arguments to filter As_layerslider_revisions to delete.
     * @example
     * // Delete a few As_layerslider_revisions
     * const { count } = await prisma.as_layerslider_revisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_layerslider_revisionsDeleteManyArgs>(
      args?: SelectSubset<T, as_layerslider_revisionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_layerslider_revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_layerslider_revisionsUpdateManyArgs>(
      args: SelectSubset<T, as_layerslider_revisionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_layerslider_revisions.
     * @param {as_layerslider_revisionsUpsertArgs} args - Arguments to update or create a As_layerslider_revisions.
     * @example
     * // Update or create a As_layerslider_revisions
     * const as_layerslider_revisions = await prisma.as_layerslider_revisions.upsert({
     *   create: {
     *     // ... data to create a As_layerslider_revisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_layerslider_revisions we want to update
     *   }
     * })
     */
    upsert<T extends as_layerslider_revisionsUpsertArgs>(
      args: SelectSubset<T, as_layerslider_revisionsUpsertArgs<ExtArgs>>
    ): Prisma__as_layerslider_revisionsClient<
      $Result.GetResult<
        Prisma.$as_layerslider_revisionsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_layerslider_revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsCountArgs} args - Arguments to filter As_layerslider_revisions to count.
     * @example
     * // Count the number of As_layerslider_revisions
     * const count = await prisma.as_layerslider_revisions.count({
     *   where: {
     *     // ... the filter for the As_layerslider_revisions we want to count
     *   }
     * })
     */
    count<T extends as_layerslider_revisionsCountArgs>(
      args?: Subset<T, as_layerslider_revisionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_layerslider_revisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_layerslider_revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_layerslider_revisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_layerslider_revisionsAggregateArgs>(
      args: Subset<T, As_layerslider_revisionsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_layerslider_revisionsAggregateType<T>>

    /**
     * Group by As_layerslider_revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_layerslider_revisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_layerslider_revisionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_layerslider_revisionsGroupByArgs['orderBy'] }
        : { orderBy?: as_layerslider_revisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_layerslider_revisionsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_layerslider_revisionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_layerslider_revisions model
     */
    readonly fields: as_layerslider_revisionsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_layerslider_revisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_layerslider_revisionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_layerslider_revisions model
   */
  interface as_layerslider_revisionsFieldRefs {
    readonly id: FieldRef<'as_layerslider_revisions', 'Int'>
    readonly slider_id: FieldRef<'as_layerslider_revisions', 'Int'>
    readonly author: FieldRef<'as_layerslider_revisions', 'Int'>
    readonly data: FieldRef<'as_layerslider_revisions', 'String'>
    readonly date_c: FieldRef<'as_layerslider_revisions', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_layerslider_revisions findUnique
   */
  export type as_layerslider_revisionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider_revisions to fetch.
     */
    where: as_layerslider_revisionsWhereUniqueInput
  }

  /**
   * as_layerslider_revisions findUniqueOrThrow
   */
  export type as_layerslider_revisionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider_revisions to fetch.
     */
    where: as_layerslider_revisionsWhereUniqueInput
  }

  /**
   * as_layerslider_revisions findFirst
   */
  export type as_layerslider_revisionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider_revisions to fetch.
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layerslider_revisions to fetch.
     */
    orderBy?:
      | as_layerslider_revisionsOrderByWithRelationInput
      | as_layerslider_revisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_layerslider_revisions.
     */
    cursor?: as_layerslider_revisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layerslider_revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layerslider_revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_layerslider_revisions.
     */
    distinct?: As_layerslider_revisionsScalarFieldEnum | As_layerslider_revisionsScalarFieldEnum[]
  }

  /**
   * as_layerslider_revisions findFirstOrThrow
   */
  export type as_layerslider_revisionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider_revisions to fetch.
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layerslider_revisions to fetch.
     */
    orderBy?:
      | as_layerslider_revisionsOrderByWithRelationInput
      | as_layerslider_revisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_layerslider_revisions.
     */
    cursor?: as_layerslider_revisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layerslider_revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layerslider_revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_layerslider_revisions.
     */
    distinct?: As_layerslider_revisionsScalarFieldEnum | As_layerslider_revisionsScalarFieldEnum[]
  }

  /**
   * as_layerslider_revisions findMany
   */
  export type as_layerslider_revisionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter, which as_layerslider_revisions to fetch.
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_layerslider_revisions to fetch.
     */
    orderBy?:
      | as_layerslider_revisionsOrderByWithRelationInput
      | as_layerslider_revisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_layerslider_revisions.
     */
    cursor?: as_layerslider_revisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_layerslider_revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_layerslider_revisions.
     */
    skip?: number
    distinct?: As_layerslider_revisionsScalarFieldEnum | As_layerslider_revisionsScalarFieldEnum[]
  }

  /**
   * as_layerslider_revisions create
   */
  export type as_layerslider_revisionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_layerslider_revisions.
     */
    data: XOR<as_layerslider_revisionsCreateInput, as_layerslider_revisionsUncheckedCreateInput>
  }

  /**
   * as_layerslider_revisions createMany
   */
  export type as_layerslider_revisionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_layerslider_revisions.
     */
    data: as_layerslider_revisionsCreateManyInput | as_layerslider_revisionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_layerslider_revisions update
   */
  export type as_layerslider_revisionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_layerslider_revisions.
     */
    data: XOR<as_layerslider_revisionsUpdateInput, as_layerslider_revisionsUncheckedUpdateInput>
    /**
     * Choose, which as_layerslider_revisions to update.
     */
    where: as_layerslider_revisionsWhereUniqueInput
  }

  /**
   * as_layerslider_revisions updateMany
   */
  export type as_layerslider_revisionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_layerslider_revisions.
     */
    data: XOR<
      as_layerslider_revisionsUpdateManyMutationInput,
      as_layerslider_revisionsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_layerslider_revisions to update
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * Limit how many as_layerslider_revisions to update.
     */
    limit?: number
  }

  /**
   * as_layerslider_revisions upsert
   */
  export type as_layerslider_revisionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_layerslider_revisions to update in case it exists.
     */
    where: as_layerslider_revisionsWhereUniqueInput
    /**
     * In case the as_layerslider_revisions found by the `where` argument doesn't exist, create a new as_layerslider_revisions with this data.
     */
    create: XOR<as_layerslider_revisionsCreateInput, as_layerslider_revisionsUncheckedCreateInput>
    /**
     * In case the as_layerslider_revisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_layerslider_revisionsUpdateInput, as_layerslider_revisionsUncheckedUpdateInput>
  }

  /**
   * as_layerslider_revisions delete
   */
  export type as_layerslider_revisionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
    /**
     * Filter which as_layerslider_revisions to delete.
     */
    where: as_layerslider_revisionsWhereUniqueInput
  }

  /**
   * as_layerslider_revisions deleteMany
   */
  export type as_layerslider_revisionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_layerslider_revisions to delete
     */
    where?: as_layerslider_revisionsWhereInput
    /**
     * Limit how many as_layerslider_revisions to delete.
     */
    limit?: number
  }

  /**
   * as_layerslider_revisions without action
   */
  export type as_layerslider_revisionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_layerslider_revisions
     */
    select?: as_layerslider_revisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_layerslider_revisions
     */
    omit?: as_layerslider_revisionsOmit<ExtArgs> | null
  }

  /**
   * Model as_links
   */

  export type AggregateAs_links = {
    _count: As_linksCountAggregateOutputType | null
    _avg: As_linksAvgAggregateOutputType | null
    _sum: As_linksSumAggregateOutputType | null
    _min: As_linksMinAggregateOutputType | null
    _max: As_linksMaxAggregateOutputType | null
  }

  export type As_linksAvgAggregateOutputType = {
    link_id: number | null
    link_owner: number | null
    link_rating: number | null
  }

  export type As_linksSumAggregateOutputType = {
    link_id: bigint | null
    link_owner: bigint | null
    link_rating: number | null
  }

  export type As_linksMinAggregateOutputType = {
    link_id: bigint | null
    link_url: string | null
    link_name: string | null
    link_image: string | null
    link_target: string | null
    link_description: string | null
    link_visible: string | null
    link_owner: bigint | null
    link_rating: number | null
    link_updated: Date | null
    link_rel: string | null
    link_notes: string | null
    link_rss: string | null
  }

  export type As_linksMaxAggregateOutputType = {
    link_id: bigint | null
    link_url: string | null
    link_name: string | null
    link_image: string | null
    link_target: string | null
    link_description: string | null
    link_visible: string | null
    link_owner: bigint | null
    link_rating: number | null
    link_updated: Date | null
    link_rel: string | null
    link_notes: string | null
    link_rss: string | null
  }

  export type As_linksCountAggregateOutputType = {
    link_id: number
    link_url: number
    link_name: number
    link_image: number
    link_target: number
    link_description: number
    link_visible: number
    link_owner: number
    link_rating: number
    link_updated: number
    link_rel: number
    link_notes: number
    link_rss: number
    _all: number
  }

  export type As_linksAvgAggregateInputType = {
    link_id?: true
    link_owner?: true
    link_rating?: true
  }

  export type As_linksSumAggregateInputType = {
    link_id?: true
    link_owner?: true
    link_rating?: true
  }

  export type As_linksMinAggregateInputType = {
    link_id?: true
    link_url?: true
    link_name?: true
    link_image?: true
    link_target?: true
    link_description?: true
    link_visible?: true
    link_owner?: true
    link_rating?: true
    link_updated?: true
    link_rel?: true
    link_notes?: true
    link_rss?: true
  }

  export type As_linksMaxAggregateInputType = {
    link_id?: true
    link_url?: true
    link_name?: true
    link_image?: true
    link_target?: true
    link_description?: true
    link_visible?: true
    link_owner?: true
    link_rating?: true
    link_updated?: true
    link_rel?: true
    link_notes?: true
    link_rss?: true
  }

  export type As_linksCountAggregateInputType = {
    link_id?: true
    link_url?: true
    link_name?: true
    link_image?: true
    link_target?: true
    link_description?: true
    link_visible?: true
    link_owner?: true
    link_rating?: true
    link_updated?: true
    link_rel?: true
    link_notes?: true
    link_rss?: true
    _all?: true
  }

  export type As_linksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_links to aggregate.
     */
    where?: as_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_links to fetch.
     */
    orderBy?: as_linksOrderByWithRelationInput | as_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_links
     */
    _count?: true | As_linksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_linksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_linksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_linksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_linksMaxAggregateInputType
  }

  export type GetAs_linksAggregateType<T extends As_linksAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_links[P]>
      : GetScalarType<T[P], AggregateAs_links[P]>
  }

  export type as_linksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_linksWhereInput
    orderBy?: as_linksOrderByWithAggregationInput | as_linksOrderByWithAggregationInput[]
    by: As_linksScalarFieldEnum[] | As_linksScalarFieldEnum
    having?: as_linksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_linksCountAggregateInputType | true
    _avg?: As_linksAvgAggregateInputType
    _sum?: As_linksSumAggregateInputType
    _min?: As_linksMinAggregateInputType
    _max?: As_linksMaxAggregateInputType
  }

  export type As_linksGroupByOutputType = {
    link_id: bigint
    link_url: string
    link_name: string
    link_image: string
    link_target: string
    link_description: string
    link_visible: string
    link_owner: bigint
    link_rating: number
    link_updated: Date
    link_rel: string
    link_notes: string
    link_rss: string
    _count: As_linksCountAggregateOutputType | null
    _avg: As_linksAvgAggregateOutputType | null
    _sum: As_linksSumAggregateOutputType | null
    _min: As_linksMinAggregateOutputType | null
    _max: As_linksMaxAggregateOutputType | null
  }

  type GetAs_linksGroupByPayload<T extends as_linksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_linksGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_linksGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_linksGroupByOutputType[P]>
          : GetScalarType<T[P], As_linksGroupByOutputType[P]>
      }
    >
  >

  export type as_linksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        link_id?: boolean
        link_url?: boolean
        link_name?: boolean
        link_image?: boolean
        link_target?: boolean
        link_description?: boolean
        link_visible?: boolean
        link_owner?: boolean
        link_rating?: boolean
        link_updated?: boolean
        link_rel?: boolean
        link_notes?: boolean
        link_rss?: boolean
      },
      ExtArgs['result']['as_links']
    >

  export type as_linksSelectScalar = {
    link_id?: boolean
    link_url?: boolean
    link_name?: boolean
    link_image?: boolean
    link_target?: boolean
    link_description?: boolean
    link_visible?: boolean
    link_owner?: boolean
    link_rating?: boolean
    link_updated?: boolean
    link_rel?: boolean
    link_notes?: boolean
    link_rss?: boolean
  }

  export type as_linksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'link_id'
      | 'link_url'
      | 'link_name'
      | 'link_image'
      | 'link_target'
      | 'link_description'
      | 'link_visible'
      | 'link_owner'
      | 'link_rating'
      | 'link_updated'
      | 'link_rel'
      | 'link_notes'
      | 'link_rss',
      ExtArgs['result']['as_links']
    >

  export type $as_linksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'as_links'
      objects: {}
      scalars: $Extensions.GetPayloadResult<
        {
          link_id: bigint
          link_url: string
          link_name: string
          link_image: string
          link_target: string
          link_description: string
          link_visible: string
          link_owner: bigint
          link_rating: number
          link_updated: Date
          link_rel: string
          link_notes: string
          link_rss: string
        },
        ExtArgs['result']['as_links']
      >
      composites: {}
    }

  type as_linksGetPayload<S extends boolean | null | undefined | as_linksDefaultArgs> =
    $Result.GetResult<Prisma.$as_linksPayload, S>

  type as_linksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    as_linksFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: As_linksCountAggregateInputType | true
  }

  export interface as_linksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['as_links']; meta: { name: 'as_links' } }
    /**
     * Find zero or one As_links that matches the filter.
     * @param {as_linksFindUniqueArgs} args - Arguments to find a As_links
     * @example
     * // Get one As_links
     * const as_links = await prisma.as_links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_linksFindUniqueArgs>(
      args: SelectSubset<T, as_linksFindUniqueArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<
        Prisma.$as_linksPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_links that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_linksFindUniqueOrThrowArgs} args - Arguments to find a As_links
     * @example
     * // Get one As_links
     * const as_links = await prisma.as_links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_linksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_linksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<
        Prisma.$as_linksPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksFindFirstArgs} args - Arguments to find a As_links
     * @example
     * // Get one As_links
     * const as_links = await prisma.as_links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_linksFindFirstArgs>(
      args?: SelectSubset<T, as_linksFindFirstArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksFindFirstOrThrowArgs} args - Arguments to find a As_links
     * @example
     * // Get one As_links
     * const as_links = await prisma.as_links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_linksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_linksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_links
     * const as_links = await prisma.as_links.findMany()
     *
     * // Get first 10 As_links
     * const as_links = await prisma.as_links.findMany({ take: 10 })
     *
     * // Only select the `link_id`
     * const as_linksWithLink_idOnly = await prisma.as_links.findMany({ select: { link_id: true } })
     *
     */
    findMany<T extends as_linksFindManyArgs>(
      args?: SelectSubset<T, as_linksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_links.
     * @param {as_linksCreateArgs} args - Arguments to create a As_links.
     * @example
     * // Create one As_links
     * const As_links = await prisma.as_links.create({
     *   data: {
     *     // ... data to create a As_links
     *   }
     * })
     *
     */
    create<T extends as_linksCreateArgs>(
      args: SelectSubset<T, as_linksCreateArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_links.
     * @param {as_linksCreateManyArgs} args - Arguments to create many As_links.
     * @example
     * // Create many As_links
     * const as_links = await prisma.as_links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_linksCreateManyArgs>(
      args?: SelectSubset<T, as_linksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_links.
     * @param {as_linksDeleteArgs} args - Arguments to delete one As_links.
     * @example
     * // Delete one As_links
     * const As_links = await prisma.as_links.delete({
     *   where: {
     *     // ... filter to delete one As_links
     *   }
     * })
     *
     */
    delete<T extends as_linksDeleteArgs>(
      args: SelectSubset<T, as_linksDeleteArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_links.
     * @param {as_linksUpdateArgs} args - Arguments to update one As_links.
     * @example
     * // Update one As_links
     * const as_links = await prisma.as_links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_linksUpdateArgs>(
      args: SelectSubset<T, as_linksUpdateArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_links.
     * @param {as_linksDeleteManyArgs} args - Arguments to filter As_links to delete.
     * @example
     * // Delete a few As_links
     * const { count } = await prisma.as_links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_linksDeleteManyArgs>(
      args?: SelectSubset<T, as_linksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_links
     * const as_links = await prisma.as_links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_linksUpdateManyArgs>(
      args: SelectSubset<T, as_linksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_links.
     * @param {as_linksUpsertArgs} args - Arguments to update or create a As_links.
     * @example
     * // Update or create a As_links
     * const as_links = await prisma.as_links.upsert({
     *   create: {
     *     // ... data to create a As_links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_links we want to update
     *   }
     * })
     */
    upsert<T extends as_linksUpsertArgs>(
      args: SelectSubset<T, as_linksUpsertArgs<ExtArgs>>
    ): Prisma__as_linksClient<
      $Result.GetResult<Prisma.$as_linksPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksCountArgs} args - Arguments to filter As_links to count.
     * @example
     * // Count the number of As_links
     * const count = await prisma.as_links.count({
     *   where: {
     *     // ... the filter for the As_links we want to count
     *   }
     * })
     */
    count<T extends as_linksCountArgs>(
      args?: Subset<T, as_linksCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_linksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_linksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_linksAggregateArgs>(
      args: Subset<T, As_linksAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_linksAggregateType<T>>

    /**
     * Group by As_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_linksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_linksGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_linksGroupByArgs['orderBy'] }
        : { orderBy?: as_linksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_linksGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_linksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_links model
     */
    readonly fields: as_linksFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_linksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_links model
   */
  interface as_linksFieldRefs {
    readonly link_id: FieldRef<'as_links', 'BigInt'>
    readonly link_url: FieldRef<'as_links', 'String'>
    readonly link_name: FieldRef<'as_links', 'String'>
    readonly link_image: FieldRef<'as_links', 'String'>
    readonly link_target: FieldRef<'as_links', 'String'>
    readonly link_description: FieldRef<'as_links', 'String'>
    readonly link_visible: FieldRef<'as_links', 'String'>
    readonly link_owner: FieldRef<'as_links', 'BigInt'>
    readonly link_rating: FieldRef<'as_links', 'Int'>
    readonly link_updated: FieldRef<'as_links', 'DateTime'>
    readonly link_rel: FieldRef<'as_links', 'String'>
    readonly link_notes: FieldRef<'as_links', 'String'>
    readonly link_rss: FieldRef<'as_links', 'String'>
  }

  // Custom InputTypes
  /**
   * as_links findUnique
   */
  export type as_linksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_links to fetch.
     */
    where: as_linksWhereUniqueInput
  }

  /**
   * as_links findUniqueOrThrow
   */
  export type as_linksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_links to fetch.
     */
    where: as_linksWhereUniqueInput
  }

  /**
   * as_links findFirst
   */
  export type as_linksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_links to fetch.
     */
    where?: as_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_links to fetch.
     */
    orderBy?: as_linksOrderByWithRelationInput | as_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_links.
     */
    cursor?: as_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_links.
     */
    distinct?: As_linksScalarFieldEnum | As_linksScalarFieldEnum[]
  }

  /**
   * as_links findFirstOrThrow
   */
  export type as_linksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_links to fetch.
     */
    where?: as_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_links to fetch.
     */
    orderBy?: as_linksOrderByWithRelationInput | as_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_links.
     */
    cursor?: as_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_links.
     */
    distinct?: As_linksScalarFieldEnum | As_linksScalarFieldEnum[]
  }

  /**
   * as_links findMany
   */
  export type as_linksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_links to fetch.
     */
    where?: as_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_links to fetch.
     */
    orderBy?: as_linksOrderByWithRelationInput | as_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_links.
     */
    cursor?: as_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_links.
     */
    skip?: number
    distinct?: As_linksScalarFieldEnum | As_linksScalarFieldEnum[]
  }

  /**
   * as_links create
   */
  export type as_linksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * The data needed to create a as_links.
     */
    data: XOR<as_linksCreateInput, as_linksUncheckedCreateInput>
  }

  /**
   * as_links createMany
   */
  export type as_linksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_links.
     */
    data: as_linksCreateManyInput | as_linksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_links update
   */
  export type as_linksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * The data needed to update a as_links.
     */
    data: XOR<as_linksUpdateInput, as_linksUncheckedUpdateInput>
    /**
     * Choose, which as_links to update.
     */
    where: as_linksWhereUniqueInput
  }

  /**
   * as_links updateMany
   */
  export type as_linksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_links.
     */
    data: XOR<as_linksUpdateManyMutationInput, as_linksUncheckedUpdateManyInput>
    /**
     * Filter which as_links to update
     */
    where?: as_linksWhereInput
    /**
     * Limit how many as_links to update.
     */
    limit?: number
  }

  /**
   * as_links upsert
   */
  export type as_linksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * The filter to search for the as_links to update in case it exists.
     */
    where: as_linksWhereUniqueInput
    /**
     * In case the as_links found by the `where` argument doesn't exist, create a new as_links with this data.
     */
    create: XOR<as_linksCreateInput, as_linksUncheckedCreateInput>
    /**
     * In case the as_links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_linksUpdateInput, as_linksUncheckedUpdateInput>
  }

  /**
   * as_links delete
   */
  export type as_linksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
    /**
     * Filter which as_links to delete.
     */
    where: as_linksWhereUniqueInput
  }

  /**
   * as_links deleteMany
   */
  export type as_linksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_links to delete
     */
    where?: as_linksWhereInput
    /**
     * Limit how many as_links to delete.
     */
    limit?: number
  }

  /**
   * as_links without action
   */
  export type as_linksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_links
     */
    select?: as_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_links
     */
    omit?: as_linksOmit<ExtArgs> | null
  }

  /**
   * Model as_loginizer_logs
   */

  export type AggregateAs_loginizer_logs = {
    _count: As_loginizer_logsCountAggregateOutputType | null
    _avg: As_loginizer_logsAvgAggregateOutputType | null
    _sum: As_loginizer_logsSumAggregateOutputType | null
    _min: As_loginizer_logsMinAggregateOutputType | null
    _max: As_loginizer_logsMaxAggregateOutputType | null
  }

  export type As_loginizer_logsAvgAggregateOutputType = {
    time: number | null
    count: number | null
    lockout: number | null
  }

  export type As_loginizer_logsSumAggregateOutputType = {
    time: number | null
    count: number | null
    lockout: number | null
  }

  export type As_loginizer_logsMinAggregateOutputType = {
    username: string | null
    time: number | null
    count: number | null
    lockout: number | null
    ip: string | null
    url: string | null
  }

  export type As_loginizer_logsMaxAggregateOutputType = {
    username: string | null
    time: number | null
    count: number | null
    lockout: number | null
    ip: string | null
    url: string | null
  }

  export type As_loginizer_logsCountAggregateOutputType = {
    username: number
    time: number
    count: number
    lockout: number
    ip: number
    url: number
    _all: number
  }

  export type As_loginizer_logsAvgAggregateInputType = {
    time?: true
    count?: true
    lockout?: true
  }

  export type As_loginizer_logsSumAggregateInputType = {
    time?: true
    count?: true
    lockout?: true
  }

  export type As_loginizer_logsMinAggregateInputType = {
    username?: true
    time?: true
    count?: true
    lockout?: true
    ip?: true
    url?: true
  }

  export type As_loginizer_logsMaxAggregateInputType = {
    username?: true
    time?: true
    count?: true
    lockout?: true
    ip?: true
    url?: true
  }

  export type As_loginizer_logsCountAggregateInputType = {
    username?: true
    time?: true
    count?: true
    lockout?: true
    ip?: true
    url?: true
    _all?: true
  }

  export type As_loginizer_logsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_loginizer_logs to aggregate.
     */
    where?: as_loginizer_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_loginizer_logs to fetch.
     */
    orderBy?:
      | as_loginizer_logsOrderByWithRelationInput
      | as_loginizer_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_loginizer_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_loginizer_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_loginizer_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_loginizer_logs
     */
    _count?: true | As_loginizer_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_loginizer_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_loginizer_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_loginizer_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_loginizer_logsMaxAggregateInputType
  }

  export type GetAs_loginizer_logsAggregateType<T extends As_loginizer_logsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_loginizer_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_loginizer_logs[P]>
      : GetScalarType<T[P], AggregateAs_loginizer_logs[P]>
  }

  export type as_loginizer_logsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_loginizer_logsWhereInput
    orderBy?:
      | as_loginizer_logsOrderByWithAggregationInput
      | as_loginizer_logsOrderByWithAggregationInput[]
    by: As_loginizer_logsScalarFieldEnum[] | As_loginizer_logsScalarFieldEnum
    having?: as_loginizer_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_loginizer_logsCountAggregateInputType | true
    _avg?: As_loginizer_logsAvgAggregateInputType
    _sum?: As_loginizer_logsSumAggregateInputType
    _min?: As_loginizer_logsMinAggregateInputType
    _max?: As_loginizer_logsMaxAggregateInputType
  }

  export type As_loginizer_logsGroupByOutputType = {
    username: string
    time: number
    count: number
    lockout: number
    ip: string
    url: string
    _count: As_loginizer_logsCountAggregateOutputType | null
    _avg: As_loginizer_logsAvgAggregateOutputType | null
    _sum: As_loginizer_logsSumAggregateOutputType | null
    _min: As_loginizer_logsMinAggregateOutputType | null
    _max: As_loginizer_logsMaxAggregateOutputType | null
  }

  type GetAs_loginizer_logsGroupByPayload<T extends as_loginizer_logsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_loginizer_logsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_loginizer_logsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_loginizer_logsGroupByOutputType[P]>
            : GetScalarType<T[P], As_loginizer_logsGroupByOutputType[P]>
        }
      >
    >

  export type as_loginizer_logsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      username?: boolean
      time?: boolean
      count?: boolean
      lockout?: boolean
      ip?: boolean
      url?: boolean
    },
    ExtArgs['result']['as_loginizer_logs']
  >

  export type as_loginizer_logsSelectScalar = {
    username?: boolean
    time?: boolean
    count?: boolean
    lockout?: boolean
    ip?: boolean
    url?: boolean
  }

  export type as_loginizer_logsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'username' | 'time' | 'count' | 'lockout' | 'ip' | 'url',
    ExtArgs['result']['as_loginizer_logs']
  >

  export type $as_loginizer_logsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_loginizer_logs'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        username: string
        time: number
        count: number
        lockout: number
        ip: string
        url: string
      },
      ExtArgs['result']['as_loginizer_logs']
    >
    composites: {}
  }

  type as_loginizer_logsGetPayload<
    S extends boolean | null | undefined | as_loginizer_logsDefaultArgs
  > = $Result.GetResult<Prisma.$as_loginizer_logsPayload, S>

  type as_loginizer_logsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_loginizer_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_loginizer_logsCountAggregateInputType | true
  }

  export interface as_loginizer_logsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_loginizer_logs']
      meta: { name: 'as_loginizer_logs' }
    }
    /**
     * Find zero or one As_loginizer_logs that matches the filter.
     * @param {as_loginizer_logsFindUniqueArgs} args - Arguments to find a As_loginizer_logs
     * @example
     * // Get one As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_loginizer_logsFindUniqueArgs>(
      args: SelectSubset<T, as_loginizer_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<
        Prisma.$as_loginizer_logsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_loginizer_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_loginizer_logsFindUniqueOrThrowArgs} args - Arguments to find a As_loginizer_logs
     * @example
     * // Get one As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_loginizer_logsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_loginizer_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<
        Prisma.$as_loginizer_logsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_loginizer_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsFindFirstArgs} args - Arguments to find a As_loginizer_logs
     * @example
     * // Get one As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_loginizer_logsFindFirstArgs>(
      args?: SelectSubset<T, as_loginizer_logsFindFirstArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<
        Prisma.$as_loginizer_logsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_loginizer_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsFindFirstOrThrowArgs} args - Arguments to find a As_loginizer_logs
     * @example
     * // Get one As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_loginizer_logsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_loginizer_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<
        Prisma.$as_loginizer_logsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_loginizer_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findMany()
     *
     * // Get first 10 As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.findMany({ take: 10 })
     *
     * // Only select the `username`
     * const as_loginizer_logsWithUsernameOnly = await prisma.as_loginizer_logs.findMany({ select: { username: true } })
     *
     */
    findMany<T extends as_loginizer_logsFindManyArgs>(
      args?: SelectSubset<T, as_loginizer_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_loginizer_logsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_loginizer_logs.
     * @param {as_loginizer_logsCreateArgs} args - Arguments to create a As_loginizer_logs.
     * @example
     * // Create one As_loginizer_logs
     * const As_loginizer_logs = await prisma.as_loginizer_logs.create({
     *   data: {
     *     // ... data to create a As_loginizer_logs
     *   }
     * })
     *
     */
    create<T extends as_loginizer_logsCreateArgs>(
      args: SelectSubset<T, as_loginizer_logsCreateArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<Prisma.$as_loginizer_logsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_loginizer_logs.
     * @param {as_loginizer_logsCreateManyArgs} args - Arguments to create many As_loginizer_logs.
     * @example
     * // Create many As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_loginizer_logsCreateManyArgs>(
      args?: SelectSubset<T, as_loginizer_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_loginizer_logs.
     * @param {as_loginizer_logsDeleteArgs} args - Arguments to delete one As_loginizer_logs.
     * @example
     * // Delete one As_loginizer_logs
     * const As_loginizer_logs = await prisma.as_loginizer_logs.delete({
     *   where: {
     *     // ... filter to delete one As_loginizer_logs
     *   }
     * })
     *
     */
    delete<T extends as_loginizer_logsDeleteArgs>(
      args: SelectSubset<T, as_loginizer_logsDeleteArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<Prisma.$as_loginizer_logsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_loginizer_logs.
     * @param {as_loginizer_logsUpdateArgs} args - Arguments to update one As_loginizer_logs.
     * @example
     * // Update one As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_loginizer_logsUpdateArgs>(
      args: SelectSubset<T, as_loginizer_logsUpdateArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<Prisma.$as_loginizer_logsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_loginizer_logs.
     * @param {as_loginizer_logsDeleteManyArgs} args - Arguments to filter As_loginizer_logs to delete.
     * @example
     * // Delete a few As_loginizer_logs
     * const { count } = await prisma.as_loginizer_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_loginizer_logsDeleteManyArgs>(
      args?: SelectSubset<T, as_loginizer_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_loginizer_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_loginizer_logsUpdateManyArgs>(
      args: SelectSubset<T, as_loginizer_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_loginizer_logs.
     * @param {as_loginizer_logsUpsertArgs} args - Arguments to update or create a As_loginizer_logs.
     * @example
     * // Update or create a As_loginizer_logs
     * const as_loginizer_logs = await prisma.as_loginizer_logs.upsert({
     *   create: {
     *     // ... data to create a As_loginizer_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_loginizer_logs we want to update
     *   }
     * })
     */
    upsert<T extends as_loginizer_logsUpsertArgs>(
      args: SelectSubset<T, as_loginizer_logsUpsertArgs<ExtArgs>>
    ): Prisma__as_loginizer_logsClient<
      $Result.GetResult<Prisma.$as_loginizer_logsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_loginizer_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsCountArgs} args - Arguments to filter As_loginizer_logs to count.
     * @example
     * // Count the number of As_loginizer_logs
     * const count = await prisma.as_loginizer_logs.count({
     *   where: {
     *     // ... the filter for the As_loginizer_logs we want to count
     *   }
     * })
     */
    count<T extends as_loginizer_logsCountArgs>(
      args?: Subset<T, as_loginizer_logsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_loginizer_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_loginizer_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_loginizer_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_loginizer_logsAggregateArgs>(
      args: Subset<T, As_loginizer_logsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_loginizer_logsAggregateType<T>>

    /**
     * Group by As_loginizer_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_loginizer_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_loginizer_logsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_loginizer_logsGroupByArgs['orderBy'] }
        : { orderBy?: as_loginizer_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_loginizer_logsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_loginizer_logsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_loginizer_logs model
     */
    readonly fields: as_loginizer_logsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_loginizer_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_loginizer_logsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_loginizer_logs model
   */
  interface as_loginizer_logsFieldRefs {
    readonly username: FieldRef<'as_loginizer_logs', 'String'>
    readonly time: FieldRef<'as_loginizer_logs', 'Int'>
    readonly count: FieldRef<'as_loginizer_logs', 'Int'>
    readonly lockout: FieldRef<'as_loginizer_logs', 'Int'>
    readonly ip: FieldRef<'as_loginizer_logs', 'String'>
    readonly url: FieldRef<'as_loginizer_logs', 'String'>
  }

  // Custom InputTypes
  /**
   * as_loginizer_logs findUnique
   */
  export type as_loginizer_logsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_loginizer_logs to fetch.
     */
    where: as_loginizer_logsWhereUniqueInput
  }

  /**
   * as_loginizer_logs findUniqueOrThrow
   */
  export type as_loginizer_logsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_loginizer_logs to fetch.
     */
    where: as_loginizer_logsWhereUniqueInput
  }

  /**
   * as_loginizer_logs findFirst
   */
  export type as_loginizer_logsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_loginizer_logs to fetch.
     */
    where?: as_loginizer_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_loginizer_logs to fetch.
     */
    orderBy?:
      | as_loginizer_logsOrderByWithRelationInput
      | as_loginizer_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_loginizer_logs.
     */
    cursor?: as_loginizer_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_loginizer_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_loginizer_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_loginizer_logs.
     */
    distinct?: As_loginizer_logsScalarFieldEnum | As_loginizer_logsScalarFieldEnum[]
  }

  /**
   * as_loginizer_logs findFirstOrThrow
   */
  export type as_loginizer_logsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_loginizer_logs to fetch.
     */
    where?: as_loginizer_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_loginizer_logs to fetch.
     */
    orderBy?:
      | as_loginizer_logsOrderByWithRelationInput
      | as_loginizer_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_loginizer_logs.
     */
    cursor?: as_loginizer_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_loginizer_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_loginizer_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_loginizer_logs.
     */
    distinct?: As_loginizer_logsScalarFieldEnum | As_loginizer_logsScalarFieldEnum[]
  }

  /**
   * as_loginizer_logs findMany
   */
  export type as_loginizer_logsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter, which as_loginizer_logs to fetch.
     */
    where?: as_loginizer_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_loginizer_logs to fetch.
     */
    orderBy?:
      | as_loginizer_logsOrderByWithRelationInput
      | as_loginizer_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_loginizer_logs.
     */
    cursor?: as_loginizer_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_loginizer_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_loginizer_logs.
     */
    skip?: number
    distinct?: As_loginizer_logsScalarFieldEnum | As_loginizer_logsScalarFieldEnum[]
  }

  /**
   * as_loginizer_logs create
   */
  export type as_loginizer_logsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_loginizer_logs.
     */
    data?: XOR<as_loginizer_logsCreateInput, as_loginizer_logsUncheckedCreateInput>
  }

  /**
   * as_loginizer_logs createMany
   */
  export type as_loginizer_logsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_loginizer_logs.
     */
    data: as_loginizer_logsCreateManyInput | as_loginizer_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_loginizer_logs update
   */
  export type as_loginizer_logsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_loginizer_logs.
     */
    data: XOR<as_loginizer_logsUpdateInput, as_loginizer_logsUncheckedUpdateInput>
    /**
     * Choose, which as_loginizer_logs to update.
     */
    where: as_loginizer_logsWhereUniqueInput
  }

  /**
   * as_loginizer_logs updateMany
   */
  export type as_loginizer_logsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_loginizer_logs.
     */
    data: XOR<as_loginizer_logsUpdateManyMutationInput, as_loginizer_logsUncheckedUpdateManyInput>
    /**
     * Filter which as_loginizer_logs to update
     */
    where?: as_loginizer_logsWhereInput
    /**
     * Limit how many as_loginizer_logs to update.
     */
    limit?: number
  }

  /**
   * as_loginizer_logs upsert
   */
  export type as_loginizer_logsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_loginizer_logs to update in case it exists.
     */
    where: as_loginizer_logsWhereUniqueInput
    /**
     * In case the as_loginizer_logs found by the `where` argument doesn't exist, create a new as_loginizer_logs with this data.
     */
    create: XOR<as_loginizer_logsCreateInput, as_loginizer_logsUncheckedCreateInput>
    /**
     * In case the as_loginizer_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_loginizer_logsUpdateInput, as_loginizer_logsUncheckedUpdateInput>
  }

  /**
   * as_loginizer_logs delete
   */
  export type as_loginizer_logsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
    /**
     * Filter which as_loginizer_logs to delete.
     */
    where: as_loginizer_logsWhereUniqueInput
  }

  /**
   * as_loginizer_logs deleteMany
   */
  export type as_loginizer_logsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_loginizer_logs to delete
     */
    where?: as_loginizer_logsWhereInput
    /**
     * Limit how many as_loginizer_logs to delete.
     */
    limit?: number
  }

  /**
   * as_loginizer_logs without action
   */
  export type as_loginizer_logsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_loginizer_logs
     */
    select?: as_loginizer_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_loginizer_logs
     */
    omit?: as_loginizer_logsOmit<ExtArgs> | null
  }

  /**
   * Model as_options
   */

  export type AggregateAs_options = {
    _count: As_optionsCountAggregateOutputType | null
    _avg: As_optionsAvgAggregateOutputType | null
    _sum: As_optionsSumAggregateOutputType | null
    _min: As_optionsMinAggregateOutputType | null
    _max: As_optionsMaxAggregateOutputType | null
  }

  export type As_optionsAvgAggregateOutputType = {
    option_id: number | null
  }

  export type As_optionsSumAggregateOutputType = {
    option_id: bigint | null
  }

  export type As_optionsMinAggregateOutputType = {
    option_id: bigint | null
    option_name: string | null
    option_value: string | null
    autoload: string | null
  }

  export type As_optionsMaxAggregateOutputType = {
    option_id: bigint | null
    option_name: string | null
    option_value: string | null
    autoload: string | null
  }

  export type As_optionsCountAggregateOutputType = {
    option_id: number
    option_name: number
    option_value: number
    autoload: number
    _all: number
  }

  export type As_optionsAvgAggregateInputType = {
    option_id?: true
  }

  export type As_optionsSumAggregateInputType = {
    option_id?: true
  }

  export type As_optionsMinAggregateInputType = {
    option_id?: true
    option_name?: true
    option_value?: true
    autoload?: true
  }

  export type As_optionsMaxAggregateInputType = {
    option_id?: true
    option_name?: true
    option_value?: true
    autoload?: true
  }

  export type As_optionsCountAggregateInputType = {
    option_id?: true
    option_name?: true
    option_value?: true
    autoload?: true
    _all?: true
  }

  export type As_optionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_options to aggregate.
     */
    where?: as_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_options to fetch.
     */
    orderBy?: as_optionsOrderByWithRelationInput | as_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_options
     */
    _count?: true | As_optionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_optionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_optionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_optionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_optionsMaxAggregateInputType
  }

  export type GetAs_optionsAggregateType<T extends As_optionsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_options]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_options[P]>
      : GetScalarType<T[P], AggregateAs_options[P]>
  }

  export type as_optionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_optionsWhereInput
    orderBy?: as_optionsOrderByWithAggregationInput | as_optionsOrderByWithAggregationInput[]
    by: As_optionsScalarFieldEnum[] | As_optionsScalarFieldEnum
    having?: as_optionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_optionsCountAggregateInputType | true
    _avg?: As_optionsAvgAggregateInputType
    _sum?: As_optionsSumAggregateInputType
    _min?: As_optionsMinAggregateInputType
    _max?: As_optionsMaxAggregateInputType
  }

  export type As_optionsGroupByOutputType = {
    option_id: bigint
    option_name: string
    option_value: string
    autoload: string
    _count: As_optionsCountAggregateOutputType | null
    _avg: As_optionsAvgAggregateOutputType | null
    _sum: As_optionsSumAggregateOutputType | null
    _min: As_optionsMinAggregateOutputType | null
    _max: As_optionsMaxAggregateOutputType | null
  }

  type GetAs_optionsGroupByPayload<T extends as_optionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_optionsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_optionsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_optionsGroupByOutputType[P]>
          : GetScalarType<T[P], As_optionsGroupByOutputType[P]>
      }
    >
  >

  export type as_optionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        option_id?: boolean
        option_name?: boolean
        option_value?: boolean
        autoload?: boolean
      },
      ExtArgs['result']['as_options']
    >

  export type as_optionsSelectScalar = {
    option_id?: boolean
    option_name?: boolean
    option_value?: boolean
    autoload?: boolean
  }

  export type as_optionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'option_id' | 'option_name' | 'option_value' | 'autoload',
      ExtArgs['result']['as_options']
    >

  export type $as_optionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_options'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        option_id: bigint
        option_name: string
        option_value: string
        autoload: string
      },
      ExtArgs['result']['as_options']
    >
    composites: {}
  }

  type as_optionsGetPayload<S extends boolean | null | undefined | as_optionsDefaultArgs> =
    $Result.GetResult<Prisma.$as_optionsPayload, S>

  type as_optionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_optionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_optionsCountAggregateInputType | true
    }

  export interface as_optionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_options']
      meta: { name: 'as_options' }
    }
    /**
     * Find zero or one As_options that matches the filter.
     * @param {as_optionsFindUniqueArgs} args - Arguments to find a As_options
     * @example
     * // Get one As_options
     * const as_options = await prisma.as_options.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_optionsFindUniqueArgs>(
      args: SelectSubset<T, as_optionsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<
        Prisma.$as_optionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_options that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_optionsFindUniqueOrThrowArgs} args - Arguments to find a As_options
     * @example
     * // Get one As_options
     * const as_options = await prisma.as_options.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_optionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_optionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<
        Prisma.$as_optionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsFindFirstArgs} args - Arguments to find a As_options
     * @example
     * // Get one As_options
     * const as_options = await prisma.as_options.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_optionsFindFirstArgs>(
      args?: SelectSubset<T, as_optionsFindFirstArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<
        Prisma.$as_optionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_options that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsFindFirstOrThrowArgs} args - Arguments to find a As_options
     * @example
     * // Get one As_options
     * const as_options = await prisma.as_options.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_optionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_optionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<
        Prisma.$as_optionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_options
     * const as_options = await prisma.as_options.findMany()
     *
     * // Get first 10 As_options
     * const as_options = await prisma.as_options.findMany({ take: 10 })
     *
     * // Only select the `option_id`
     * const as_optionsWithOption_idOnly = await prisma.as_options.findMany({ select: { option_id: true } })
     *
     */
    findMany<T extends as_optionsFindManyArgs>(
      args?: SelectSubset<T, as_optionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_optionsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_options.
     * @param {as_optionsCreateArgs} args - Arguments to create a As_options.
     * @example
     * // Create one As_options
     * const As_options = await prisma.as_options.create({
     *   data: {
     *     // ... data to create a As_options
     *   }
     * })
     *
     */
    create<T extends as_optionsCreateArgs>(
      args: SelectSubset<T, as_optionsCreateArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<Prisma.$as_optionsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_options.
     * @param {as_optionsCreateManyArgs} args - Arguments to create many As_options.
     * @example
     * // Create many As_options
     * const as_options = await prisma.as_options.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_optionsCreateManyArgs>(
      args?: SelectSubset<T, as_optionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_options.
     * @param {as_optionsDeleteArgs} args - Arguments to delete one As_options.
     * @example
     * // Delete one As_options
     * const As_options = await prisma.as_options.delete({
     *   where: {
     *     // ... filter to delete one As_options
     *   }
     * })
     *
     */
    delete<T extends as_optionsDeleteArgs>(
      args: SelectSubset<T, as_optionsDeleteArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<Prisma.$as_optionsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_options.
     * @param {as_optionsUpdateArgs} args - Arguments to update one As_options.
     * @example
     * // Update one As_options
     * const as_options = await prisma.as_options.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_optionsUpdateArgs>(
      args: SelectSubset<T, as_optionsUpdateArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<Prisma.$as_optionsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_options.
     * @param {as_optionsDeleteManyArgs} args - Arguments to filter As_options to delete.
     * @example
     * // Delete a few As_options
     * const { count } = await prisma.as_options.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_optionsDeleteManyArgs>(
      args?: SelectSubset<T, as_optionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_options
     * const as_options = await prisma.as_options.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_optionsUpdateManyArgs>(
      args: SelectSubset<T, as_optionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_options.
     * @param {as_optionsUpsertArgs} args - Arguments to update or create a As_options.
     * @example
     * // Update or create a As_options
     * const as_options = await prisma.as_options.upsert({
     *   create: {
     *     // ... data to create a As_options
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_options we want to update
     *   }
     * })
     */
    upsert<T extends as_optionsUpsertArgs>(
      args: SelectSubset<T, as_optionsUpsertArgs<ExtArgs>>
    ): Prisma__as_optionsClient<
      $Result.GetResult<Prisma.$as_optionsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsCountArgs} args - Arguments to filter As_options to count.
     * @example
     * // Count the number of As_options
     * const count = await prisma.as_options.count({
     *   where: {
     *     // ... the filter for the As_options we want to count
     *   }
     * })
     */
    count<T extends as_optionsCountArgs>(
      args?: Subset<T, as_optionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_optionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_optionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_optionsAggregateArgs>(
      args: Subset<T, As_optionsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_optionsAggregateType<T>>

    /**
     * Group by As_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_optionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_optionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_optionsGroupByArgs['orderBy'] }
        : { orderBy?: as_optionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_optionsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_optionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_options model
     */
    readonly fields: as_optionsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_options.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_optionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_options model
   */
  interface as_optionsFieldRefs {
    readonly option_id: FieldRef<'as_options', 'BigInt'>
    readonly option_name: FieldRef<'as_options', 'String'>
    readonly option_value: FieldRef<'as_options', 'String'>
    readonly autoload: FieldRef<'as_options', 'String'>
  }

  // Custom InputTypes
  /**
   * as_options findUnique
   */
  export type as_optionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter, which as_options to fetch.
     */
    where: as_optionsWhereUniqueInput
  }

  /**
   * as_options findUniqueOrThrow
   */
  export type as_optionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter, which as_options to fetch.
     */
    where: as_optionsWhereUniqueInput
  }

  /**
   * as_options findFirst
   */
  export type as_optionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter, which as_options to fetch.
     */
    where?: as_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_options to fetch.
     */
    orderBy?: as_optionsOrderByWithRelationInput | as_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_options.
     */
    cursor?: as_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_options.
     */
    distinct?: As_optionsScalarFieldEnum | As_optionsScalarFieldEnum[]
  }

  /**
   * as_options findFirstOrThrow
   */
  export type as_optionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter, which as_options to fetch.
     */
    where?: as_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_options to fetch.
     */
    orderBy?: as_optionsOrderByWithRelationInput | as_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_options.
     */
    cursor?: as_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_options.
     */
    distinct?: As_optionsScalarFieldEnum | As_optionsScalarFieldEnum[]
  }

  /**
   * as_options findMany
   */
  export type as_optionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter, which as_options to fetch.
     */
    where?: as_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_options to fetch.
     */
    orderBy?: as_optionsOrderByWithRelationInput | as_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_options.
     */
    cursor?: as_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_options.
     */
    skip?: number
    distinct?: As_optionsScalarFieldEnum | As_optionsScalarFieldEnum[]
  }

  /**
   * as_options create
   */
  export type as_optionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_options.
     */
    data: XOR<as_optionsCreateInput, as_optionsUncheckedCreateInput>
  }

  /**
   * as_options createMany
   */
  export type as_optionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_options.
     */
    data: as_optionsCreateManyInput | as_optionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_options update
   */
  export type as_optionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_options.
     */
    data: XOR<as_optionsUpdateInput, as_optionsUncheckedUpdateInput>
    /**
     * Choose, which as_options to update.
     */
    where: as_optionsWhereUniqueInput
  }

  /**
   * as_options updateMany
   */
  export type as_optionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_options.
     */
    data: XOR<as_optionsUpdateManyMutationInput, as_optionsUncheckedUpdateManyInput>
    /**
     * Filter which as_options to update
     */
    where?: as_optionsWhereInput
    /**
     * Limit how many as_options to update.
     */
    limit?: number
  }

  /**
   * as_options upsert
   */
  export type as_optionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_options to update in case it exists.
     */
    where: as_optionsWhereUniqueInput
    /**
     * In case the as_options found by the `where` argument doesn't exist, create a new as_options with this data.
     */
    create: XOR<as_optionsCreateInput, as_optionsUncheckedCreateInput>
    /**
     * In case the as_options was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_optionsUpdateInput, as_optionsUncheckedUpdateInput>
  }

  /**
   * as_options delete
   */
  export type as_optionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
    /**
     * Filter which as_options to delete.
     */
    where: as_optionsWhereUniqueInput
  }

  /**
   * as_options deleteMany
   */
  export type as_optionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_options to delete
     */
    where?: as_optionsWhereInput
    /**
     * Limit how many as_options to delete.
     */
    limit?: number
  }

  /**
   * as_options without action
   */
  export type as_optionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_options
     */
    select?: as_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_options
     */
    omit?: as_optionsOmit<ExtArgs> | null
  }

  /**
   * Model as_postmeta
   */

  export type AggregateAs_postmeta = {
    _count: As_postmetaCountAggregateOutputType | null
    _avg: As_postmetaAvgAggregateOutputType | null
    _sum: As_postmetaSumAggregateOutputType | null
    _min: As_postmetaMinAggregateOutputType | null
    _max: As_postmetaMaxAggregateOutputType | null
  }

  export type As_postmetaAvgAggregateOutputType = {
    meta_id: number | null
    post_id: number | null
  }

  export type As_postmetaSumAggregateOutputType = {
    meta_id: bigint | null
    post_id: bigint | null
  }

  export type As_postmetaMinAggregateOutputType = {
    meta_id: bigint | null
    post_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_postmetaMaxAggregateOutputType = {
    meta_id: bigint | null
    post_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_postmetaCountAggregateOutputType = {
    meta_id: number
    post_id: number
    meta_key: number
    meta_value: number
    _all: number
  }

  export type As_postmetaAvgAggregateInputType = {
    meta_id?: true
    post_id?: true
  }

  export type As_postmetaSumAggregateInputType = {
    meta_id?: true
    post_id?: true
  }

  export type As_postmetaMinAggregateInputType = {
    meta_id?: true
    post_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_postmetaMaxAggregateInputType = {
    meta_id?: true
    post_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_postmetaCountAggregateInputType = {
    meta_id?: true
    post_id?: true
    meta_key?: true
    meta_value?: true
    _all?: true
  }

  export type As_postmetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_postmeta to aggregate.
     */
    where?: as_postmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_postmetas to fetch.
     */
    orderBy?: as_postmetaOrderByWithRelationInput | as_postmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_postmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_postmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_postmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_postmetas
     */
    _count?: true | As_postmetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_postmetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_postmetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_postmetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_postmetaMaxAggregateInputType
  }

  export type GetAs_postmetaAggregateType<T extends As_postmetaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_postmeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_postmeta[P]>
      : GetScalarType<T[P], AggregateAs_postmeta[P]>
  }

  export type as_postmetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_postmetaWhereInput
    orderBy?: as_postmetaOrderByWithAggregationInput | as_postmetaOrderByWithAggregationInput[]
    by: As_postmetaScalarFieldEnum[] | As_postmetaScalarFieldEnum
    having?: as_postmetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_postmetaCountAggregateInputType | true
    _avg?: As_postmetaAvgAggregateInputType
    _sum?: As_postmetaSumAggregateInputType
    _min?: As_postmetaMinAggregateInputType
    _max?: As_postmetaMaxAggregateInputType
  }

  export type As_postmetaGroupByOutputType = {
    meta_id: bigint
    post_id: bigint
    meta_key: string | null
    meta_value: string | null
    _count: As_postmetaCountAggregateOutputType | null
    _avg: As_postmetaAvgAggregateOutputType | null
    _sum: As_postmetaSumAggregateOutputType | null
    _min: As_postmetaMinAggregateOutputType | null
    _max: As_postmetaMaxAggregateOutputType | null
  }

  type GetAs_postmetaGroupByPayload<T extends as_postmetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_postmetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_postmetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_postmetaGroupByOutputType[P]>
          : GetScalarType<T[P], As_postmetaGroupByOutputType[P]>
      }
    >
  >

  export type as_postmetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      meta_id?: boolean
      post_id?: boolean
      meta_key?: boolean
      meta_value?: boolean
    },
    ExtArgs['result']['as_postmeta']
  >

  export type as_postmetaSelectScalar = {
    meta_id?: boolean
    post_id?: boolean
    meta_key?: boolean
    meta_value?: boolean
  }

  export type as_postmetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'meta_id' | 'post_id' | 'meta_key' | 'meta_value',
      ExtArgs['result']['as_postmeta']
    >

  export type $as_postmetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_postmeta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        meta_id: bigint
        post_id: bigint
        meta_key: string | null
        meta_value: string | null
      },
      ExtArgs['result']['as_postmeta']
    >
    composites: {}
  }

  type as_postmetaGetPayload<S extends boolean | null | undefined | as_postmetaDefaultArgs> =
    $Result.GetResult<Prisma.$as_postmetaPayload, S>

  type as_postmetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_postmetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_postmetaCountAggregateInputType | true
    }

  export interface as_postmetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_postmeta']
      meta: { name: 'as_postmeta' }
    }
    /**
     * Find zero or one As_postmeta that matches the filter.
     * @param {as_postmetaFindUniqueArgs} args - Arguments to find a As_postmeta
     * @example
     * // Get one As_postmeta
     * const as_postmeta = await prisma.as_postmeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_postmetaFindUniqueArgs>(
      args: SelectSubset<T, as_postmetaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<
        Prisma.$as_postmetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_postmeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_postmetaFindUniqueOrThrowArgs} args - Arguments to find a As_postmeta
     * @example
     * // Get one As_postmeta
     * const as_postmeta = await prisma.as_postmeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_postmetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_postmetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<
        Prisma.$as_postmetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_postmeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaFindFirstArgs} args - Arguments to find a As_postmeta
     * @example
     * // Get one As_postmeta
     * const as_postmeta = await prisma.as_postmeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_postmetaFindFirstArgs>(
      args?: SelectSubset<T, as_postmetaFindFirstArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<
        Prisma.$as_postmetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_postmeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaFindFirstOrThrowArgs} args - Arguments to find a As_postmeta
     * @example
     * // Get one As_postmeta
     * const as_postmeta = await prisma.as_postmeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_postmetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_postmetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<
        Prisma.$as_postmetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_postmetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_postmetas
     * const as_postmetas = await prisma.as_postmeta.findMany()
     *
     * // Get first 10 As_postmetas
     * const as_postmetas = await prisma.as_postmeta.findMany({ take: 10 })
     *
     * // Only select the `meta_id`
     * const as_postmetaWithMeta_idOnly = await prisma.as_postmeta.findMany({ select: { meta_id: true } })
     *
     */
    findMany<T extends as_postmetaFindManyArgs>(
      args?: SelectSubset<T, as_postmetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_postmetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_postmeta.
     * @param {as_postmetaCreateArgs} args - Arguments to create a As_postmeta.
     * @example
     * // Create one As_postmeta
     * const As_postmeta = await prisma.as_postmeta.create({
     *   data: {
     *     // ... data to create a As_postmeta
     *   }
     * })
     *
     */
    create<T extends as_postmetaCreateArgs>(
      args: SelectSubset<T, as_postmetaCreateArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<Prisma.$as_postmetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_postmetas.
     * @param {as_postmetaCreateManyArgs} args - Arguments to create many As_postmetas.
     * @example
     * // Create many As_postmetas
     * const as_postmeta = await prisma.as_postmeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_postmetaCreateManyArgs>(
      args?: SelectSubset<T, as_postmetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_postmeta.
     * @param {as_postmetaDeleteArgs} args - Arguments to delete one As_postmeta.
     * @example
     * // Delete one As_postmeta
     * const As_postmeta = await prisma.as_postmeta.delete({
     *   where: {
     *     // ... filter to delete one As_postmeta
     *   }
     * })
     *
     */
    delete<T extends as_postmetaDeleteArgs>(
      args: SelectSubset<T, as_postmetaDeleteArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<Prisma.$as_postmetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_postmeta.
     * @param {as_postmetaUpdateArgs} args - Arguments to update one As_postmeta.
     * @example
     * // Update one As_postmeta
     * const as_postmeta = await prisma.as_postmeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_postmetaUpdateArgs>(
      args: SelectSubset<T, as_postmetaUpdateArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<Prisma.$as_postmetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_postmetas.
     * @param {as_postmetaDeleteManyArgs} args - Arguments to filter As_postmetas to delete.
     * @example
     * // Delete a few As_postmetas
     * const { count } = await prisma.as_postmeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_postmetaDeleteManyArgs>(
      args?: SelectSubset<T, as_postmetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_postmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_postmetas
     * const as_postmeta = await prisma.as_postmeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_postmetaUpdateManyArgs>(
      args: SelectSubset<T, as_postmetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_postmeta.
     * @param {as_postmetaUpsertArgs} args - Arguments to update or create a As_postmeta.
     * @example
     * // Update or create a As_postmeta
     * const as_postmeta = await prisma.as_postmeta.upsert({
     *   create: {
     *     // ... data to create a As_postmeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_postmeta we want to update
     *   }
     * })
     */
    upsert<T extends as_postmetaUpsertArgs>(
      args: SelectSubset<T, as_postmetaUpsertArgs<ExtArgs>>
    ): Prisma__as_postmetaClient<
      $Result.GetResult<Prisma.$as_postmetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_postmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaCountArgs} args - Arguments to filter As_postmetas to count.
     * @example
     * // Count the number of As_postmetas
     * const count = await prisma.as_postmeta.count({
     *   where: {
     *     // ... the filter for the As_postmetas we want to count
     *   }
     * })
     */
    count<T extends as_postmetaCountArgs>(
      args?: Subset<T, as_postmetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_postmetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_postmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_postmetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_postmetaAggregateArgs>(
      args: Subset<T, As_postmetaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_postmetaAggregateType<T>>

    /**
     * Group by As_postmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postmetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_postmetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_postmetaGroupByArgs['orderBy'] }
        : { orderBy?: as_postmetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_postmetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_postmetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_postmeta model
     */
    readonly fields: as_postmetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_postmeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_postmetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_postmeta model
   */
  interface as_postmetaFieldRefs {
    readonly meta_id: FieldRef<'as_postmeta', 'BigInt'>
    readonly post_id: FieldRef<'as_postmeta', 'BigInt'>
    readonly meta_key: FieldRef<'as_postmeta', 'String'>
    readonly meta_value: FieldRef<'as_postmeta', 'String'>
  }

  // Custom InputTypes
  /**
   * as_postmeta findUnique
   */
  export type as_postmetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_postmeta to fetch.
     */
    where: as_postmetaWhereUniqueInput
  }

  /**
   * as_postmeta findUniqueOrThrow
   */
  export type as_postmetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_postmeta to fetch.
     */
    where: as_postmetaWhereUniqueInput
  }

  /**
   * as_postmeta findFirst
   */
  export type as_postmetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_postmeta to fetch.
     */
    where?: as_postmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_postmetas to fetch.
     */
    orderBy?: as_postmetaOrderByWithRelationInput | as_postmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_postmetas.
     */
    cursor?: as_postmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_postmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_postmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_postmetas.
     */
    distinct?: As_postmetaScalarFieldEnum | As_postmetaScalarFieldEnum[]
  }

  /**
   * as_postmeta findFirstOrThrow
   */
  export type as_postmetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_postmeta to fetch.
     */
    where?: as_postmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_postmetas to fetch.
     */
    orderBy?: as_postmetaOrderByWithRelationInput | as_postmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_postmetas.
     */
    cursor?: as_postmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_postmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_postmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_postmetas.
     */
    distinct?: As_postmetaScalarFieldEnum | As_postmetaScalarFieldEnum[]
  }

  /**
   * as_postmeta findMany
   */
  export type as_postmetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_postmetas to fetch.
     */
    where?: as_postmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_postmetas to fetch.
     */
    orderBy?: as_postmetaOrderByWithRelationInput | as_postmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_postmetas.
     */
    cursor?: as_postmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_postmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_postmetas.
     */
    skip?: number
    distinct?: As_postmetaScalarFieldEnum | As_postmetaScalarFieldEnum[]
  }

  /**
   * as_postmeta create
   */
  export type as_postmetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_postmeta.
     */
    data?: XOR<as_postmetaCreateInput, as_postmetaUncheckedCreateInput>
  }

  /**
   * as_postmeta createMany
   */
  export type as_postmetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_postmetas.
     */
    data: as_postmetaCreateManyInput | as_postmetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_postmeta update
   */
  export type as_postmetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_postmeta.
     */
    data: XOR<as_postmetaUpdateInput, as_postmetaUncheckedUpdateInput>
    /**
     * Choose, which as_postmeta to update.
     */
    where: as_postmetaWhereUniqueInput
  }

  /**
   * as_postmeta updateMany
   */
  export type as_postmetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_postmetas.
     */
    data: XOR<as_postmetaUpdateManyMutationInput, as_postmetaUncheckedUpdateManyInput>
    /**
     * Filter which as_postmetas to update
     */
    where?: as_postmetaWhereInput
    /**
     * Limit how many as_postmetas to update.
     */
    limit?: number
  }

  /**
   * as_postmeta upsert
   */
  export type as_postmetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_postmeta to update in case it exists.
     */
    where: as_postmetaWhereUniqueInput
    /**
     * In case the as_postmeta found by the `where` argument doesn't exist, create a new as_postmeta with this data.
     */
    create: XOR<as_postmetaCreateInput, as_postmetaUncheckedCreateInput>
    /**
     * In case the as_postmeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_postmetaUpdateInput, as_postmetaUncheckedUpdateInput>
  }

  /**
   * as_postmeta delete
   */
  export type as_postmetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
    /**
     * Filter which as_postmeta to delete.
     */
    where: as_postmetaWhereUniqueInput
  }

  /**
   * as_postmeta deleteMany
   */
  export type as_postmetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_postmetas to delete
     */
    where?: as_postmetaWhereInput
    /**
     * Limit how many as_postmetas to delete.
     */
    limit?: number
  }

  /**
   * as_postmeta without action
   */
  export type as_postmetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_postmeta
     */
    select?: as_postmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_postmeta
     */
    omit?: as_postmetaOmit<ExtArgs> | null
  }

  /**
   * Model as_posts
   */

  export type AggregateAs_posts = {
    _count: As_postsCountAggregateOutputType | null
    _avg: As_postsAvgAggregateOutputType | null
    _sum: As_postsSumAggregateOutputType | null
    _min: As_postsMinAggregateOutputType | null
    _max: As_postsMaxAggregateOutputType | null
  }

  export type As_postsAvgAggregateOutputType = {
    ID: number | null
    post_author: number | null
    post_parent: number | null
    menu_order: number | null
    comment_count: number | null
  }

  export type As_postsSumAggregateOutputType = {
    ID: bigint | null
    post_author: bigint | null
    post_parent: bigint | null
    menu_order: number | null
    comment_count: bigint | null
  }

  export type As_postsMinAggregateOutputType = {
    ID: bigint | null
    post_author: bigint | null
    post_date: Date | null
    post_date_gmt: Date | null
    post_content: string | null
    post_title: string | null
    post_excerpt: string | null
    post_status: string | null
    comment_status: string | null
    ping_status: string | null
    post_password: string | null
    post_name: string | null
    to_ping: string | null
    pinged: string | null
    post_modified: Date | null
    post_modified_gmt: Date | null
    post_content_filtered: string | null
    post_parent: bigint | null
    guid: string | null
    menu_order: number | null
    post_type: string | null
    post_mime_type: string | null
    comment_count: bigint | null
  }

  export type As_postsMaxAggregateOutputType = {
    ID: bigint | null
    post_author: bigint | null
    post_date: Date | null
    post_date_gmt: Date | null
    post_content: string | null
    post_title: string | null
    post_excerpt: string | null
    post_status: string | null
    comment_status: string | null
    ping_status: string | null
    post_password: string | null
    post_name: string | null
    to_ping: string | null
    pinged: string | null
    post_modified: Date | null
    post_modified_gmt: Date | null
    post_content_filtered: string | null
    post_parent: bigint | null
    guid: string | null
    menu_order: number | null
    post_type: string | null
    post_mime_type: string | null
    comment_count: bigint | null
  }

  export type As_postsCountAggregateOutputType = {
    ID: number
    post_author: number
    post_date: number
    post_date_gmt: number
    post_content: number
    post_title: number
    post_excerpt: number
    post_status: number
    comment_status: number
    ping_status: number
    post_password: number
    post_name: number
    to_ping: number
    pinged: number
    post_modified: number
    post_modified_gmt: number
    post_content_filtered: number
    post_parent: number
    guid: number
    menu_order: number
    post_type: number
    post_mime_type: number
    comment_count: number
    _all: number
  }

  export type As_postsAvgAggregateInputType = {
    ID?: true
    post_author?: true
    post_parent?: true
    menu_order?: true
    comment_count?: true
  }

  export type As_postsSumAggregateInputType = {
    ID?: true
    post_author?: true
    post_parent?: true
    menu_order?: true
    comment_count?: true
  }

  export type As_postsMinAggregateInputType = {
    ID?: true
    post_author?: true
    post_date?: true
    post_date_gmt?: true
    post_content?: true
    post_title?: true
    post_excerpt?: true
    post_status?: true
    comment_status?: true
    ping_status?: true
    post_password?: true
    post_name?: true
    to_ping?: true
    pinged?: true
    post_modified?: true
    post_modified_gmt?: true
    post_content_filtered?: true
    post_parent?: true
    guid?: true
    menu_order?: true
    post_type?: true
    post_mime_type?: true
    comment_count?: true
  }

  export type As_postsMaxAggregateInputType = {
    ID?: true
    post_author?: true
    post_date?: true
    post_date_gmt?: true
    post_content?: true
    post_title?: true
    post_excerpt?: true
    post_status?: true
    comment_status?: true
    ping_status?: true
    post_password?: true
    post_name?: true
    to_ping?: true
    pinged?: true
    post_modified?: true
    post_modified_gmt?: true
    post_content_filtered?: true
    post_parent?: true
    guid?: true
    menu_order?: true
    post_type?: true
    post_mime_type?: true
    comment_count?: true
  }

  export type As_postsCountAggregateInputType = {
    ID?: true
    post_author?: true
    post_date?: true
    post_date_gmt?: true
    post_content?: true
    post_title?: true
    post_excerpt?: true
    post_status?: true
    comment_status?: true
    ping_status?: true
    post_password?: true
    post_name?: true
    to_ping?: true
    pinged?: true
    post_modified?: true
    post_modified_gmt?: true
    post_content_filtered?: true
    post_parent?: true
    guid?: true
    menu_order?: true
    post_type?: true
    post_mime_type?: true
    comment_count?: true
    _all?: true
  }

  export type As_postsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_posts to aggregate.
     */
    where?: as_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_posts to fetch.
     */
    orderBy?: as_postsOrderByWithRelationInput | as_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_posts
     */
    _count?: true | As_postsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_postsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_postsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_postsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_postsMaxAggregateInputType
  }

  export type GetAs_postsAggregateType<T extends As_postsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_posts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_posts[P]>
      : GetScalarType<T[P], AggregateAs_posts[P]>
  }

  export type as_postsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_postsWhereInput
    orderBy?: as_postsOrderByWithAggregationInput | as_postsOrderByWithAggregationInput[]
    by: As_postsScalarFieldEnum[] | As_postsScalarFieldEnum
    having?: as_postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_postsCountAggregateInputType | true
    _avg?: As_postsAvgAggregateInputType
    _sum?: As_postsSumAggregateInputType
    _min?: As_postsMinAggregateInputType
    _max?: As_postsMaxAggregateInputType
  }

  export type As_postsGroupByOutputType = {
    ID: bigint
    post_author: bigint
    post_date: Date
    post_date_gmt: Date
    post_content: string
    post_title: string
    post_excerpt: string
    post_status: string
    comment_status: string
    ping_status: string
    post_password: string
    post_name: string
    to_ping: string
    pinged: string
    post_modified: Date
    post_modified_gmt: Date
    post_content_filtered: string
    post_parent: bigint
    guid: string
    menu_order: number
    post_type: string
    post_mime_type: string
    comment_count: bigint
    _count: As_postsCountAggregateOutputType | null
    _avg: As_postsAvgAggregateOutputType | null
    _sum: As_postsSumAggregateOutputType | null
    _min: As_postsMinAggregateOutputType | null
    _max: As_postsMaxAggregateOutputType | null
  }

  type GetAs_postsGroupByPayload<T extends as_postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_postsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_postsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_postsGroupByOutputType[P]>
          : GetScalarType<T[P], As_postsGroupByOutputType[P]>
      }
    >
  >

  export type as_postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        ID?: boolean
        post_author?: boolean
        post_date?: boolean
        post_date_gmt?: boolean
        post_content?: boolean
        post_title?: boolean
        post_excerpt?: boolean
        post_status?: boolean
        comment_status?: boolean
        ping_status?: boolean
        post_password?: boolean
        post_name?: boolean
        to_ping?: boolean
        pinged?: boolean
        post_modified?: boolean
        post_modified_gmt?: boolean
        post_content_filtered?: boolean
        post_parent?: boolean
        guid?: boolean
        menu_order?: boolean
        post_type?: boolean
        post_mime_type?: boolean
        comment_count?: boolean
      },
      ExtArgs['result']['as_posts']
    >

  export type as_postsSelectScalar = {
    ID?: boolean
    post_author?: boolean
    post_date?: boolean
    post_date_gmt?: boolean
    post_content?: boolean
    post_title?: boolean
    post_excerpt?: boolean
    post_status?: boolean
    comment_status?: boolean
    ping_status?: boolean
    post_password?: boolean
    post_name?: boolean
    to_ping?: boolean
    pinged?: boolean
    post_modified?: boolean
    post_modified_gmt?: boolean
    post_content_filtered?: boolean
    post_parent?: boolean
    guid?: boolean
    menu_order?: boolean
    post_type?: boolean
    post_mime_type?: boolean
    comment_count?: boolean
  }

  export type as_postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'ID'
      | 'post_author'
      | 'post_date'
      | 'post_date_gmt'
      | 'post_content'
      | 'post_title'
      | 'post_excerpt'
      | 'post_status'
      | 'comment_status'
      | 'ping_status'
      | 'post_password'
      | 'post_name'
      | 'to_ping'
      | 'pinged'
      | 'post_modified'
      | 'post_modified_gmt'
      | 'post_content_filtered'
      | 'post_parent'
      | 'guid'
      | 'menu_order'
      | 'post_type'
      | 'post_mime_type'
      | 'comment_count',
      ExtArgs['result']['as_posts']
    >

  export type $as_postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'as_posts'
      objects: {}
      scalars: $Extensions.GetPayloadResult<
        {
          ID: bigint
          post_author: bigint
          post_date: Date
          post_date_gmt: Date
          post_content: string
          post_title: string
          post_excerpt: string
          post_status: string
          comment_status: string
          ping_status: string
          post_password: string
          post_name: string
          to_ping: string
          pinged: string
          post_modified: Date
          post_modified_gmt: Date
          post_content_filtered: string
          post_parent: bigint
          guid: string
          menu_order: number
          post_type: string
          post_mime_type: string
          comment_count: bigint
        },
        ExtArgs['result']['as_posts']
      >
      composites: {}
    }

  type as_postsGetPayload<S extends boolean | null | undefined | as_postsDefaultArgs> =
    $Result.GetResult<Prisma.$as_postsPayload, S>

  type as_postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    as_postsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: As_postsCountAggregateInputType | true
  }

  export interface as_postsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['as_posts']; meta: { name: 'as_posts' } }
    /**
     * Find zero or one As_posts that matches the filter.
     * @param {as_postsFindUniqueArgs} args - Arguments to find a As_posts
     * @example
     * // Get one As_posts
     * const as_posts = await prisma.as_posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_postsFindUniqueArgs>(
      args: SelectSubset<T, as_postsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<
        Prisma.$as_postsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_postsFindUniqueOrThrowArgs} args - Arguments to find a As_posts
     * @example
     * // Get one As_posts
     * const as_posts = await prisma.as_posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_postsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_postsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<
        Prisma.$as_postsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsFindFirstArgs} args - Arguments to find a As_posts
     * @example
     * // Get one As_posts
     * const as_posts = await prisma.as_posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_postsFindFirstArgs>(
      args?: SelectSubset<T, as_postsFindFirstArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsFindFirstOrThrowArgs} args - Arguments to find a As_posts
     * @example
     * // Get one As_posts
     * const as_posts = await prisma.as_posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_postsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_postsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_posts
     * const as_posts = await prisma.as_posts.findMany()
     *
     * // Get first 10 As_posts
     * const as_posts = await prisma.as_posts.findMany({ take: 10 })
     *
     * // Only select the `ID`
     * const as_postsWithIDOnly = await prisma.as_posts.findMany({ select: { ID: true } })
     *
     */
    findMany<T extends as_postsFindManyArgs>(
      args?: SelectSubset<T, as_postsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_posts.
     * @param {as_postsCreateArgs} args - Arguments to create a As_posts.
     * @example
     * // Create one As_posts
     * const As_posts = await prisma.as_posts.create({
     *   data: {
     *     // ... data to create a As_posts
     *   }
     * })
     *
     */
    create<T extends as_postsCreateArgs>(
      args: SelectSubset<T, as_postsCreateArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_posts.
     * @param {as_postsCreateManyArgs} args - Arguments to create many As_posts.
     * @example
     * // Create many As_posts
     * const as_posts = await prisma.as_posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_postsCreateManyArgs>(
      args?: SelectSubset<T, as_postsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_posts.
     * @param {as_postsDeleteArgs} args - Arguments to delete one As_posts.
     * @example
     * // Delete one As_posts
     * const As_posts = await prisma.as_posts.delete({
     *   where: {
     *     // ... filter to delete one As_posts
     *   }
     * })
     *
     */
    delete<T extends as_postsDeleteArgs>(
      args: SelectSubset<T, as_postsDeleteArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_posts.
     * @param {as_postsUpdateArgs} args - Arguments to update one As_posts.
     * @example
     * // Update one As_posts
     * const as_posts = await prisma.as_posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_postsUpdateArgs>(
      args: SelectSubset<T, as_postsUpdateArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_posts.
     * @param {as_postsDeleteManyArgs} args - Arguments to filter As_posts to delete.
     * @example
     * // Delete a few As_posts
     * const { count } = await prisma.as_posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_postsDeleteManyArgs>(
      args?: SelectSubset<T, as_postsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_posts
     * const as_posts = await prisma.as_posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_postsUpdateManyArgs>(
      args: SelectSubset<T, as_postsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_posts.
     * @param {as_postsUpsertArgs} args - Arguments to update or create a As_posts.
     * @example
     * // Update or create a As_posts
     * const as_posts = await prisma.as_posts.upsert({
     *   create: {
     *     // ... data to create a As_posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_posts we want to update
     *   }
     * })
     */
    upsert<T extends as_postsUpsertArgs>(
      args: SelectSubset<T, as_postsUpsertArgs<ExtArgs>>
    ): Prisma__as_postsClient<
      $Result.GetResult<Prisma.$as_postsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsCountArgs} args - Arguments to filter As_posts to count.
     * @example
     * // Count the number of As_posts
     * const count = await prisma.as_posts.count({
     *   where: {
     *     // ... the filter for the As_posts we want to count
     *   }
     * })
     */
    count<T extends as_postsCountArgs>(
      args?: Subset<T, as_postsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_postsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_postsAggregateArgs>(
      args: Subset<T, As_postsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_postsAggregateType<T>>

    /**
     * Group by As_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_postsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_postsGroupByArgs['orderBy'] }
        : { orderBy?: as_postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_postsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_posts model
     */
    readonly fields: as_postsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_postsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_posts model
   */
  interface as_postsFieldRefs {
    readonly ID: FieldRef<'as_posts', 'BigInt'>
    readonly post_author: FieldRef<'as_posts', 'BigInt'>
    readonly post_date: FieldRef<'as_posts', 'DateTime'>
    readonly post_date_gmt: FieldRef<'as_posts', 'DateTime'>
    readonly post_content: FieldRef<'as_posts', 'String'>
    readonly post_title: FieldRef<'as_posts', 'String'>
    readonly post_excerpt: FieldRef<'as_posts', 'String'>
    readonly post_status: FieldRef<'as_posts', 'String'>
    readonly comment_status: FieldRef<'as_posts', 'String'>
    readonly ping_status: FieldRef<'as_posts', 'String'>
    readonly post_password: FieldRef<'as_posts', 'String'>
    readonly post_name: FieldRef<'as_posts', 'String'>
    readonly to_ping: FieldRef<'as_posts', 'String'>
    readonly pinged: FieldRef<'as_posts', 'String'>
    readonly post_modified: FieldRef<'as_posts', 'DateTime'>
    readonly post_modified_gmt: FieldRef<'as_posts', 'DateTime'>
    readonly post_content_filtered: FieldRef<'as_posts', 'String'>
    readonly post_parent: FieldRef<'as_posts', 'BigInt'>
    readonly guid: FieldRef<'as_posts', 'String'>
    readonly menu_order: FieldRef<'as_posts', 'Int'>
    readonly post_type: FieldRef<'as_posts', 'String'>
    readonly post_mime_type: FieldRef<'as_posts', 'String'>
    readonly comment_count: FieldRef<'as_posts', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_posts findUnique
   */
  export type as_postsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter, which as_posts to fetch.
     */
    where: as_postsWhereUniqueInput
  }

  /**
   * as_posts findUniqueOrThrow
   */
  export type as_postsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter, which as_posts to fetch.
     */
    where: as_postsWhereUniqueInput
  }

  /**
   * as_posts findFirst
   */
  export type as_postsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter, which as_posts to fetch.
     */
    where?: as_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_posts to fetch.
     */
    orderBy?: as_postsOrderByWithRelationInput | as_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_posts.
     */
    cursor?: as_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_posts.
     */
    distinct?: As_postsScalarFieldEnum | As_postsScalarFieldEnum[]
  }

  /**
   * as_posts findFirstOrThrow
   */
  export type as_postsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter, which as_posts to fetch.
     */
    where?: as_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_posts to fetch.
     */
    orderBy?: as_postsOrderByWithRelationInput | as_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_posts.
     */
    cursor?: as_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_posts.
     */
    distinct?: As_postsScalarFieldEnum | As_postsScalarFieldEnum[]
  }

  /**
   * as_posts findMany
   */
  export type as_postsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter, which as_posts to fetch.
     */
    where?: as_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_posts to fetch.
     */
    orderBy?: as_postsOrderByWithRelationInput | as_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_posts.
     */
    cursor?: as_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_posts.
     */
    skip?: number
    distinct?: As_postsScalarFieldEnum | As_postsScalarFieldEnum[]
  }

  /**
   * as_posts create
   */
  export type as_postsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_posts.
     */
    data: XOR<as_postsCreateInput, as_postsUncheckedCreateInput>
  }

  /**
   * as_posts createMany
   */
  export type as_postsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_posts.
     */
    data: as_postsCreateManyInput | as_postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_posts update
   */
  export type as_postsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_posts.
     */
    data: XOR<as_postsUpdateInput, as_postsUncheckedUpdateInput>
    /**
     * Choose, which as_posts to update.
     */
    where: as_postsWhereUniqueInput
  }

  /**
   * as_posts updateMany
   */
  export type as_postsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_posts.
     */
    data: XOR<as_postsUpdateManyMutationInput, as_postsUncheckedUpdateManyInput>
    /**
     * Filter which as_posts to update
     */
    where?: as_postsWhereInput
    /**
     * Limit how many as_posts to update.
     */
    limit?: number
  }

  /**
   * as_posts upsert
   */
  export type as_postsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_posts to update in case it exists.
     */
    where: as_postsWhereUniqueInput
    /**
     * In case the as_posts found by the `where` argument doesn't exist, create a new as_posts with this data.
     */
    create: XOR<as_postsCreateInput, as_postsUncheckedCreateInput>
    /**
     * In case the as_posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_postsUpdateInput, as_postsUncheckedUpdateInput>
  }

  /**
   * as_posts delete
   */
  export type as_postsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
    /**
     * Filter which as_posts to delete.
     */
    where: as_postsWhereUniqueInput
  }

  /**
   * as_posts deleteMany
   */
  export type as_postsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_posts to delete
     */
    where?: as_postsWhereInput
    /**
     * Limit how many as_posts to delete.
     */
    limit?: number
  }

  /**
   * as_posts without action
   */
  export type as_postsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_posts
     */
    select?: as_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_posts
     */
    omit?: as_postsOmit<ExtArgs> | null
  }

  /**
   * Model as_term_relationships
   */

  export type AggregateAs_term_relationships = {
    _count: As_term_relationshipsCountAggregateOutputType | null
    _avg: As_term_relationshipsAvgAggregateOutputType | null
    _sum: As_term_relationshipsSumAggregateOutputType | null
    _min: As_term_relationshipsMinAggregateOutputType | null
    _max: As_term_relationshipsMaxAggregateOutputType | null
  }

  export type As_term_relationshipsAvgAggregateOutputType = {
    object_id: number | null
    term_taxonomy_id: number | null
    term_order: number | null
  }

  export type As_term_relationshipsSumAggregateOutputType = {
    object_id: bigint | null
    term_taxonomy_id: bigint | null
    term_order: number | null
  }

  export type As_term_relationshipsMinAggregateOutputType = {
    object_id: bigint | null
    term_taxonomy_id: bigint | null
    term_order: number | null
  }

  export type As_term_relationshipsMaxAggregateOutputType = {
    object_id: bigint | null
    term_taxonomy_id: bigint | null
    term_order: number | null
  }

  export type As_term_relationshipsCountAggregateOutputType = {
    object_id: number
    term_taxonomy_id: number
    term_order: number
    _all: number
  }

  export type As_term_relationshipsAvgAggregateInputType = {
    object_id?: true
    term_taxonomy_id?: true
    term_order?: true
  }

  export type As_term_relationshipsSumAggregateInputType = {
    object_id?: true
    term_taxonomy_id?: true
    term_order?: true
  }

  export type As_term_relationshipsMinAggregateInputType = {
    object_id?: true
    term_taxonomy_id?: true
    term_order?: true
  }

  export type As_term_relationshipsMaxAggregateInputType = {
    object_id?: true
    term_taxonomy_id?: true
    term_order?: true
  }

  export type As_term_relationshipsCountAggregateInputType = {
    object_id?: true
    term_taxonomy_id?: true
    term_order?: true
    _all?: true
  }

  export type As_term_relationshipsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_term_relationships to aggregate.
     */
    where?: as_term_relationshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_relationships to fetch.
     */
    orderBy?:
      | as_term_relationshipsOrderByWithRelationInput
      | as_term_relationshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_term_relationshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_term_relationships
     */
    _count?: true | As_term_relationshipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_term_relationshipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_term_relationshipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_term_relationshipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_term_relationshipsMaxAggregateInputType
  }

  export type GetAs_term_relationshipsAggregateType<T extends As_term_relationshipsAggregateArgs> =
    {
      [P in keyof T & keyof AggregateAs_term_relationships]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateAs_term_relationships[P]>
        : GetScalarType<T[P], AggregateAs_term_relationships[P]>
    }

  export type as_term_relationshipsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_term_relationshipsWhereInput
    orderBy?:
      | as_term_relationshipsOrderByWithAggregationInput
      | as_term_relationshipsOrderByWithAggregationInput[]
    by: As_term_relationshipsScalarFieldEnum[] | As_term_relationshipsScalarFieldEnum
    having?: as_term_relationshipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_term_relationshipsCountAggregateInputType | true
    _avg?: As_term_relationshipsAvgAggregateInputType
    _sum?: As_term_relationshipsSumAggregateInputType
    _min?: As_term_relationshipsMinAggregateInputType
    _max?: As_term_relationshipsMaxAggregateInputType
  }

  export type As_term_relationshipsGroupByOutputType = {
    object_id: bigint
    term_taxonomy_id: bigint
    term_order: number
    _count: As_term_relationshipsCountAggregateOutputType | null
    _avg: As_term_relationshipsAvgAggregateOutputType | null
    _sum: As_term_relationshipsSumAggregateOutputType | null
    _min: As_term_relationshipsMinAggregateOutputType | null
    _max: As_term_relationshipsMaxAggregateOutputType | null
  }

  type GetAs_term_relationshipsGroupByPayload<T extends as_term_relationshipsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_term_relationshipsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_term_relationshipsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_term_relationshipsGroupByOutputType[P]>
            : GetScalarType<T[P], As_term_relationshipsGroupByOutputType[P]>
        }
      >
    >

  export type as_term_relationshipsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      object_id?: boolean
      term_taxonomy_id?: boolean
      term_order?: boolean
    },
    ExtArgs['result']['as_term_relationships']
  >

  export type as_term_relationshipsSelectScalar = {
    object_id?: boolean
    term_taxonomy_id?: boolean
    term_order?: boolean
  }

  export type as_term_relationshipsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'object_id' | 'term_taxonomy_id' | 'term_order',
    ExtArgs['result']['as_term_relationships']
  >

  export type $as_term_relationshipsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_term_relationships'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        object_id: bigint
        term_taxonomy_id: bigint
        term_order: number
      },
      ExtArgs['result']['as_term_relationships']
    >
    composites: {}
  }

  type as_term_relationshipsGetPayload<
    S extends boolean | null | undefined | as_term_relationshipsDefaultArgs
  > = $Result.GetResult<Prisma.$as_term_relationshipsPayload, S>

  type as_term_relationshipsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_term_relationshipsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_term_relationshipsCountAggregateInputType | true
  }

  export interface as_term_relationshipsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_term_relationships']
      meta: { name: 'as_term_relationships' }
    }
    /**
     * Find zero or one As_term_relationships that matches the filter.
     * @param {as_term_relationshipsFindUniqueArgs} args - Arguments to find a As_term_relationships
     * @example
     * // Get one As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_term_relationshipsFindUniqueArgs>(
      args: SelectSubset<T, as_term_relationshipsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_term_relationships that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_term_relationshipsFindUniqueOrThrowArgs} args - Arguments to find a As_term_relationships
     * @example
     * // Get one As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_term_relationshipsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_term_relationshipsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_term_relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsFindFirstArgs} args - Arguments to find a As_term_relationships
     * @example
     * // Get one As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_term_relationshipsFindFirstArgs>(
      args?: SelectSubset<T, as_term_relationshipsFindFirstArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_term_relationships that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsFindFirstOrThrowArgs} args - Arguments to find a As_term_relationships
     * @example
     * // Get one As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_term_relationshipsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_term_relationshipsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_term_relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findMany()
     *
     * // Get first 10 As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.findMany({ take: 10 })
     *
     * // Only select the `object_id`
     * const as_term_relationshipsWithObject_idOnly = await prisma.as_term_relationships.findMany({ select: { object_id: true } })
     *
     */
    findMany<T extends as_term_relationshipsFindManyArgs>(
      args?: SelectSubset<T, as_term_relationshipsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_term_relationships.
     * @param {as_term_relationshipsCreateArgs} args - Arguments to create a As_term_relationships.
     * @example
     * // Create one As_term_relationships
     * const As_term_relationships = await prisma.as_term_relationships.create({
     *   data: {
     *     // ... data to create a As_term_relationships
     *   }
     * })
     *
     */
    create<T extends as_term_relationshipsCreateArgs>(
      args: SelectSubset<T, as_term_relationshipsCreateArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_term_relationships.
     * @param {as_term_relationshipsCreateManyArgs} args - Arguments to create many As_term_relationships.
     * @example
     * // Create many As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_term_relationshipsCreateManyArgs>(
      args?: SelectSubset<T, as_term_relationshipsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_term_relationships.
     * @param {as_term_relationshipsDeleteArgs} args - Arguments to delete one As_term_relationships.
     * @example
     * // Delete one As_term_relationships
     * const As_term_relationships = await prisma.as_term_relationships.delete({
     *   where: {
     *     // ... filter to delete one As_term_relationships
     *   }
     * })
     *
     */
    delete<T extends as_term_relationshipsDeleteArgs>(
      args: SelectSubset<T, as_term_relationshipsDeleteArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_term_relationships.
     * @param {as_term_relationshipsUpdateArgs} args - Arguments to update one As_term_relationships.
     * @example
     * // Update one As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_term_relationshipsUpdateArgs>(
      args: SelectSubset<T, as_term_relationshipsUpdateArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_term_relationships.
     * @param {as_term_relationshipsDeleteManyArgs} args - Arguments to filter As_term_relationships to delete.
     * @example
     * // Delete a few As_term_relationships
     * const { count } = await prisma.as_term_relationships.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_term_relationshipsDeleteManyArgs>(
      args?: SelectSubset<T, as_term_relationshipsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_term_relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_term_relationshipsUpdateManyArgs>(
      args: SelectSubset<T, as_term_relationshipsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_term_relationships.
     * @param {as_term_relationshipsUpsertArgs} args - Arguments to update or create a As_term_relationships.
     * @example
     * // Update or create a As_term_relationships
     * const as_term_relationships = await prisma.as_term_relationships.upsert({
     *   create: {
     *     // ... data to create a As_term_relationships
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_term_relationships we want to update
     *   }
     * })
     */
    upsert<T extends as_term_relationshipsUpsertArgs>(
      args: SelectSubset<T, as_term_relationshipsUpsertArgs<ExtArgs>>
    ): Prisma__as_term_relationshipsClient<
      $Result.GetResult<
        Prisma.$as_term_relationshipsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_term_relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsCountArgs} args - Arguments to filter As_term_relationships to count.
     * @example
     * // Count the number of As_term_relationships
     * const count = await prisma.as_term_relationships.count({
     *   where: {
     *     // ... the filter for the As_term_relationships we want to count
     *   }
     * })
     */
    count<T extends as_term_relationshipsCountArgs>(
      args?: Subset<T, as_term_relationshipsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_term_relationshipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_term_relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_term_relationshipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_term_relationshipsAggregateArgs>(
      args: Subset<T, As_term_relationshipsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_term_relationshipsAggregateType<T>>

    /**
     * Group by As_term_relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_relationshipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_term_relationshipsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_term_relationshipsGroupByArgs['orderBy'] }
        : { orderBy?: as_term_relationshipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_term_relationshipsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_term_relationshipsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_term_relationships model
     */
    readonly fields: as_term_relationshipsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_term_relationships.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_term_relationshipsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_term_relationships model
   */
  interface as_term_relationshipsFieldRefs {
    readonly object_id: FieldRef<'as_term_relationships', 'BigInt'>
    readonly term_taxonomy_id: FieldRef<'as_term_relationships', 'BigInt'>
    readonly term_order: FieldRef<'as_term_relationships', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_term_relationships findUnique
   */
  export type as_term_relationshipsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter, which as_term_relationships to fetch.
     */
    where: as_term_relationshipsWhereUniqueInput
  }

  /**
   * as_term_relationships findUniqueOrThrow
   */
  export type as_term_relationshipsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter, which as_term_relationships to fetch.
     */
    where: as_term_relationshipsWhereUniqueInput
  }

  /**
   * as_term_relationships findFirst
   */
  export type as_term_relationshipsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter, which as_term_relationships to fetch.
     */
    where?: as_term_relationshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_relationships to fetch.
     */
    orderBy?:
      | as_term_relationshipsOrderByWithRelationInput
      | as_term_relationshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_term_relationships.
     */
    cursor?: as_term_relationshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_term_relationships.
     */
    distinct?: As_term_relationshipsScalarFieldEnum | As_term_relationshipsScalarFieldEnum[]
  }

  /**
   * as_term_relationships findFirstOrThrow
   */
  export type as_term_relationshipsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter, which as_term_relationships to fetch.
     */
    where?: as_term_relationshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_relationships to fetch.
     */
    orderBy?:
      | as_term_relationshipsOrderByWithRelationInput
      | as_term_relationshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_term_relationships.
     */
    cursor?: as_term_relationshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_term_relationships.
     */
    distinct?: As_term_relationshipsScalarFieldEnum | As_term_relationshipsScalarFieldEnum[]
  }

  /**
   * as_term_relationships findMany
   */
  export type as_term_relationshipsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter, which as_term_relationships to fetch.
     */
    where?: as_term_relationshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_relationships to fetch.
     */
    orderBy?:
      | as_term_relationshipsOrderByWithRelationInput
      | as_term_relationshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_term_relationships.
     */
    cursor?: as_term_relationshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_relationships.
     */
    skip?: number
    distinct?: As_term_relationshipsScalarFieldEnum | As_term_relationshipsScalarFieldEnum[]
  }

  /**
   * as_term_relationships create
   */
  export type as_term_relationshipsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_term_relationships.
     */
    data?: XOR<as_term_relationshipsCreateInput, as_term_relationshipsUncheckedCreateInput>
  }

  /**
   * as_term_relationships createMany
   */
  export type as_term_relationshipsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_term_relationships.
     */
    data: as_term_relationshipsCreateManyInput | as_term_relationshipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_term_relationships update
   */
  export type as_term_relationshipsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_term_relationships.
     */
    data: XOR<as_term_relationshipsUpdateInput, as_term_relationshipsUncheckedUpdateInput>
    /**
     * Choose, which as_term_relationships to update.
     */
    where: as_term_relationshipsWhereUniqueInput
  }

  /**
   * as_term_relationships updateMany
   */
  export type as_term_relationshipsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_term_relationships.
     */
    data: XOR<
      as_term_relationshipsUpdateManyMutationInput,
      as_term_relationshipsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_term_relationships to update
     */
    where?: as_term_relationshipsWhereInput
    /**
     * Limit how many as_term_relationships to update.
     */
    limit?: number
  }

  /**
   * as_term_relationships upsert
   */
  export type as_term_relationshipsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_term_relationships to update in case it exists.
     */
    where: as_term_relationshipsWhereUniqueInput
    /**
     * In case the as_term_relationships found by the `where` argument doesn't exist, create a new as_term_relationships with this data.
     */
    create: XOR<as_term_relationshipsCreateInput, as_term_relationshipsUncheckedCreateInput>
    /**
     * In case the as_term_relationships was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_term_relationshipsUpdateInput, as_term_relationshipsUncheckedUpdateInput>
  }

  /**
   * as_term_relationships delete
   */
  export type as_term_relationshipsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
    /**
     * Filter which as_term_relationships to delete.
     */
    where: as_term_relationshipsWhereUniqueInput
  }

  /**
   * as_term_relationships deleteMany
   */
  export type as_term_relationshipsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_term_relationships to delete
     */
    where?: as_term_relationshipsWhereInput
    /**
     * Limit how many as_term_relationships to delete.
     */
    limit?: number
  }

  /**
   * as_term_relationships without action
   */
  export type as_term_relationshipsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_relationships
     */
    select?: as_term_relationshipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_relationships
     */
    omit?: as_term_relationshipsOmit<ExtArgs> | null
  }

  /**
   * Model as_term_taxonomy
   */

  export type AggregateAs_term_taxonomy = {
    _count: As_term_taxonomyCountAggregateOutputType | null
    _avg: As_term_taxonomyAvgAggregateOutputType | null
    _sum: As_term_taxonomySumAggregateOutputType | null
    _min: As_term_taxonomyMinAggregateOutputType | null
    _max: As_term_taxonomyMaxAggregateOutputType | null
  }

  export type As_term_taxonomyAvgAggregateOutputType = {
    term_taxonomy_id: number | null
    term_id: number | null
    parent: number | null
    count: number | null
  }

  export type As_term_taxonomySumAggregateOutputType = {
    term_taxonomy_id: bigint | null
    term_id: bigint | null
    parent: bigint | null
    count: bigint | null
  }

  export type As_term_taxonomyMinAggregateOutputType = {
    term_taxonomy_id: bigint | null
    term_id: bigint | null
    taxonomy: string | null
    description: string | null
    parent: bigint | null
    count: bigint | null
  }

  export type As_term_taxonomyMaxAggregateOutputType = {
    term_taxonomy_id: bigint | null
    term_id: bigint | null
    taxonomy: string | null
    description: string | null
    parent: bigint | null
    count: bigint | null
  }

  export type As_term_taxonomyCountAggregateOutputType = {
    term_taxonomy_id: number
    term_id: number
    taxonomy: number
    description: number
    parent: number
    count: number
    _all: number
  }

  export type As_term_taxonomyAvgAggregateInputType = {
    term_taxonomy_id?: true
    term_id?: true
    parent?: true
    count?: true
  }

  export type As_term_taxonomySumAggregateInputType = {
    term_taxonomy_id?: true
    term_id?: true
    parent?: true
    count?: true
  }

  export type As_term_taxonomyMinAggregateInputType = {
    term_taxonomy_id?: true
    term_id?: true
    taxonomy?: true
    description?: true
    parent?: true
    count?: true
  }

  export type As_term_taxonomyMaxAggregateInputType = {
    term_taxonomy_id?: true
    term_id?: true
    taxonomy?: true
    description?: true
    parent?: true
    count?: true
  }

  export type As_term_taxonomyCountAggregateInputType = {
    term_taxonomy_id?: true
    term_id?: true
    taxonomy?: true
    description?: true
    parent?: true
    count?: true
    _all?: true
  }

  export type As_term_taxonomyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_term_taxonomy to aggregate.
     */
    where?: as_term_taxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_taxonomies to fetch.
     */
    orderBy?: as_term_taxonomyOrderByWithRelationInput | as_term_taxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_term_taxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_taxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_taxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_term_taxonomies
     */
    _count?: true | As_term_taxonomyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_term_taxonomyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_term_taxonomySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_term_taxonomyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_term_taxonomyMaxAggregateInputType
  }

  export type GetAs_term_taxonomyAggregateType<T extends As_term_taxonomyAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_term_taxonomy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_term_taxonomy[P]>
      : GetScalarType<T[P], AggregateAs_term_taxonomy[P]>
  }

  export type as_term_taxonomyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_term_taxonomyWhereInput
    orderBy?:
      | as_term_taxonomyOrderByWithAggregationInput
      | as_term_taxonomyOrderByWithAggregationInput[]
    by: As_term_taxonomyScalarFieldEnum[] | As_term_taxonomyScalarFieldEnum
    having?: as_term_taxonomyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_term_taxonomyCountAggregateInputType | true
    _avg?: As_term_taxonomyAvgAggregateInputType
    _sum?: As_term_taxonomySumAggregateInputType
    _min?: As_term_taxonomyMinAggregateInputType
    _max?: As_term_taxonomyMaxAggregateInputType
  }

  export type As_term_taxonomyGroupByOutputType = {
    term_taxonomy_id: bigint
    term_id: bigint
    taxonomy: string
    description: string
    parent: bigint
    count: bigint
    _count: As_term_taxonomyCountAggregateOutputType | null
    _avg: As_term_taxonomyAvgAggregateOutputType | null
    _sum: As_term_taxonomySumAggregateOutputType | null
    _min: As_term_taxonomyMinAggregateOutputType | null
    _max: As_term_taxonomyMaxAggregateOutputType | null
  }

  type GetAs_term_taxonomyGroupByPayload<T extends as_term_taxonomyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_term_taxonomyGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_term_taxonomyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_term_taxonomyGroupByOutputType[P]>
            : GetScalarType<T[P], As_term_taxonomyGroupByOutputType[P]>
        }
      >
    >

  export type as_term_taxonomySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      term_taxonomy_id?: boolean
      term_id?: boolean
      taxonomy?: boolean
      description?: boolean
      parent?: boolean
      count?: boolean
    },
    ExtArgs['result']['as_term_taxonomy']
  >

  export type as_term_taxonomySelectScalar = {
    term_taxonomy_id?: boolean
    term_id?: boolean
    taxonomy?: boolean
    description?: boolean
    parent?: boolean
    count?: boolean
  }

  export type as_term_taxonomyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'term_taxonomy_id' | 'term_id' | 'taxonomy' | 'description' | 'parent' | 'count',
    ExtArgs['result']['as_term_taxonomy']
  >

  export type $as_term_taxonomyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_term_taxonomy'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        term_taxonomy_id: bigint
        term_id: bigint
        taxonomy: string
        description: string
        parent: bigint
        count: bigint
      },
      ExtArgs['result']['as_term_taxonomy']
    >
    composites: {}
  }

  type as_term_taxonomyGetPayload<
    S extends boolean | null | undefined | as_term_taxonomyDefaultArgs
  > = $Result.GetResult<Prisma.$as_term_taxonomyPayload, S>

  type as_term_taxonomyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_term_taxonomyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_term_taxonomyCountAggregateInputType | true
  }

  export interface as_term_taxonomyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_term_taxonomy']
      meta: { name: 'as_term_taxonomy' }
    }
    /**
     * Find zero or one As_term_taxonomy that matches the filter.
     * @param {as_term_taxonomyFindUniqueArgs} args - Arguments to find a As_term_taxonomy
     * @example
     * // Get one As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_term_taxonomyFindUniqueArgs>(
      args: SelectSubset<T, as_term_taxonomyFindUniqueArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<
        Prisma.$as_term_taxonomyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_term_taxonomy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_term_taxonomyFindUniqueOrThrowArgs} args - Arguments to find a As_term_taxonomy
     * @example
     * // Get one As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_term_taxonomyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_term_taxonomyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<
        Prisma.$as_term_taxonomyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_term_taxonomy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyFindFirstArgs} args - Arguments to find a As_term_taxonomy
     * @example
     * // Get one As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_term_taxonomyFindFirstArgs>(
      args?: SelectSubset<T, as_term_taxonomyFindFirstArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<
        Prisma.$as_term_taxonomyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_term_taxonomy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyFindFirstOrThrowArgs} args - Arguments to find a As_term_taxonomy
     * @example
     * // Get one As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_term_taxonomyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_term_taxonomyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<
        Prisma.$as_term_taxonomyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_term_taxonomies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_term_taxonomies
     * const as_term_taxonomies = await prisma.as_term_taxonomy.findMany()
     *
     * // Get first 10 As_term_taxonomies
     * const as_term_taxonomies = await prisma.as_term_taxonomy.findMany({ take: 10 })
     *
     * // Only select the `term_taxonomy_id`
     * const as_term_taxonomyWithTerm_taxonomy_idOnly = await prisma.as_term_taxonomy.findMany({ select: { term_taxonomy_id: true } })
     *
     */
    findMany<T extends as_term_taxonomyFindManyArgs>(
      args?: SelectSubset<T, as_term_taxonomyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_term_taxonomyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_term_taxonomy.
     * @param {as_term_taxonomyCreateArgs} args - Arguments to create a As_term_taxonomy.
     * @example
     * // Create one As_term_taxonomy
     * const As_term_taxonomy = await prisma.as_term_taxonomy.create({
     *   data: {
     *     // ... data to create a As_term_taxonomy
     *   }
     * })
     *
     */
    create<T extends as_term_taxonomyCreateArgs>(
      args: SelectSubset<T, as_term_taxonomyCreateArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<Prisma.$as_term_taxonomyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_term_taxonomies.
     * @param {as_term_taxonomyCreateManyArgs} args - Arguments to create many As_term_taxonomies.
     * @example
     * // Create many As_term_taxonomies
     * const as_term_taxonomy = await prisma.as_term_taxonomy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_term_taxonomyCreateManyArgs>(
      args?: SelectSubset<T, as_term_taxonomyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_term_taxonomy.
     * @param {as_term_taxonomyDeleteArgs} args - Arguments to delete one As_term_taxonomy.
     * @example
     * // Delete one As_term_taxonomy
     * const As_term_taxonomy = await prisma.as_term_taxonomy.delete({
     *   where: {
     *     // ... filter to delete one As_term_taxonomy
     *   }
     * })
     *
     */
    delete<T extends as_term_taxonomyDeleteArgs>(
      args: SelectSubset<T, as_term_taxonomyDeleteArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<Prisma.$as_term_taxonomyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_term_taxonomy.
     * @param {as_term_taxonomyUpdateArgs} args - Arguments to update one As_term_taxonomy.
     * @example
     * // Update one As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_term_taxonomyUpdateArgs>(
      args: SelectSubset<T, as_term_taxonomyUpdateArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<Prisma.$as_term_taxonomyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_term_taxonomies.
     * @param {as_term_taxonomyDeleteManyArgs} args - Arguments to filter As_term_taxonomies to delete.
     * @example
     * // Delete a few As_term_taxonomies
     * const { count } = await prisma.as_term_taxonomy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_term_taxonomyDeleteManyArgs>(
      args?: SelectSubset<T, as_term_taxonomyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_term_taxonomies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_term_taxonomies
     * const as_term_taxonomy = await prisma.as_term_taxonomy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_term_taxonomyUpdateManyArgs>(
      args: SelectSubset<T, as_term_taxonomyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_term_taxonomy.
     * @param {as_term_taxonomyUpsertArgs} args - Arguments to update or create a As_term_taxonomy.
     * @example
     * // Update or create a As_term_taxonomy
     * const as_term_taxonomy = await prisma.as_term_taxonomy.upsert({
     *   create: {
     *     // ... data to create a As_term_taxonomy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_term_taxonomy we want to update
     *   }
     * })
     */
    upsert<T extends as_term_taxonomyUpsertArgs>(
      args: SelectSubset<T, as_term_taxonomyUpsertArgs<ExtArgs>>
    ): Prisma__as_term_taxonomyClient<
      $Result.GetResult<Prisma.$as_term_taxonomyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_term_taxonomies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyCountArgs} args - Arguments to filter As_term_taxonomies to count.
     * @example
     * // Count the number of As_term_taxonomies
     * const count = await prisma.as_term_taxonomy.count({
     *   where: {
     *     // ... the filter for the As_term_taxonomies we want to count
     *   }
     * })
     */
    count<T extends as_term_taxonomyCountArgs>(
      args?: Subset<T, as_term_taxonomyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_term_taxonomyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_term_taxonomy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_term_taxonomyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_term_taxonomyAggregateArgs>(
      args: Subset<T, As_term_taxonomyAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_term_taxonomyAggregateType<T>>

    /**
     * Group by As_term_taxonomy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_term_taxonomyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_term_taxonomyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_term_taxonomyGroupByArgs['orderBy'] }
        : { orderBy?: as_term_taxonomyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_term_taxonomyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_term_taxonomyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_term_taxonomy model
     */
    readonly fields: as_term_taxonomyFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_term_taxonomy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_term_taxonomyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_term_taxonomy model
   */
  interface as_term_taxonomyFieldRefs {
    readonly term_taxonomy_id: FieldRef<'as_term_taxonomy', 'BigInt'>
    readonly term_id: FieldRef<'as_term_taxonomy', 'BigInt'>
    readonly taxonomy: FieldRef<'as_term_taxonomy', 'String'>
    readonly description: FieldRef<'as_term_taxonomy', 'String'>
    readonly parent: FieldRef<'as_term_taxonomy', 'BigInt'>
    readonly count: FieldRef<'as_term_taxonomy', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_term_taxonomy findUnique
   */
  export type as_term_taxonomyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter, which as_term_taxonomy to fetch.
     */
    where: as_term_taxonomyWhereUniqueInput
  }

  /**
   * as_term_taxonomy findUniqueOrThrow
   */
  export type as_term_taxonomyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter, which as_term_taxonomy to fetch.
     */
    where: as_term_taxonomyWhereUniqueInput
  }

  /**
   * as_term_taxonomy findFirst
   */
  export type as_term_taxonomyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter, which as_term_taxonomy to fetch.
     */
    where?: as_term_taxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_taxonomies to fetch.
     */
    orderBy?: as_term_taxonomyOrderByWithRelationInput | as_term_taxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_term_taxonomies.
     */
    cursor?: as_term_taxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_taxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_taxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_term_taxonomies.
     */
    distinct?: As_term_taxonomyScalarFieldEnum | As_term_taxonomyScalarFieldEnum[]
  }

  /**
   * as_term_taxonomy findFirstOrThrow
   */
  export type as_term_taxonomyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter, which as_term_taxonomy to fetch.
     */
    where?: as_term_taxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_taxonomies to fetch.
     */
    orderBy?: as_term_taxonomyOrderByWithRelationInput | as_term_taxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_term_taxonomies.
     */
    cursor?: as_term_taxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_taxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_taxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_term_taxonomies.
     */
    distinct?: As_term_taxonomyScalarFieldEnum | As_term_taxonomyScalarFieldEnum[]
  }

  /**
   * as_term_taxonomy findMany
   */
  export type as_term_taxonomyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter, which as_term_taxonomies to fetch.
     */
    where?: as_term_taxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_term_taxonomies to fetch.
     */
    orderBy?: as_term_taxonomyOrderByWithRelationInput | as_term_taxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_term_taxonomies.
     */
    cursor?: as_term_taxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_term_taxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_term_taxonomies.
     */
    skip?: number
    distinct?: As_term_taxonomyScalarFieldEnum | As_term_taxonomyScalarFieldEnum[]
  }

  /**
   * as_term_taxonomy create
   */
  export type as_term_taxonomyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * The data needed to create a as_term_taxonomy.
     */
    data: XOR<as_term_taxonomyCreateInput, as_term_taxonomyUncheckedCreateInput>
  }

  /**
   * as_term_taxonomy createMany
   */
  export type as_term_taxonomyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_term_taxonomies.
     */
    data: as_term_taxonomyCreateManyInput | as_term_taxonomyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_term_taxonomy update
   */
  export type as_term_taxonomyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * The data needed to update a as_term_taxonomy.
     */
    data: XOR<as_term_taxonomyUpdateInput, as_term_taxonomyUncheckedUpdateInput>
    /**
     * Choose, which as_term_taxonomy to update.
     */
    where: as_term_taxonomyWhereUniqueInput
  }

  /**
   * as_term_taxonomy updateMany
   */
  export type as_term_taxonomyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_term_taxonomies.
     */
    data: XOR<as_term_taxonomyUpdateManyMutationInput, as_term_taxonomyUncheckedUpdateManyInput>
    /**
     * Filter which as_term_taxonomies to update
     */
    where?: as_term_taxonomyWhereInput
    /**
     * Limit how many as_term_taxonomies to update.
     */
    limit?: number
  }

  /**
   * as_term_taxonomy upsert
   */
  export type as_term_taxonomyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * The filter to search for the as_term_taxonomy to update in case it exists.
     */
    where: as_term_taxonomyWhereUniqueInput
    /**
     * In case the as_term_taxonomy found by the `where` argument doesn't exist, create a new as_term_taxonomy with this data.
     */
    create: XOR<as_term_taxonomyCreateInput, as_term_taxonomyUncheckedCreateInput>
    /**
     * In case the as_term_taxonomy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_term_taxonomyUpdateInput, as_term_taxonomyUncheckedUpdateInput>
  }

  /**
   * as_term_taxonomy delete
   */
  export type as_term_taxonomyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
    /**
     * Filter which as_term_taxonomy to delete.
     */
    where: as_term_taxonomyWhereUniqueInput
  }

  /**
   * as_term_taxonomy deleteMany
   */
  export type as_term_taxonomyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_term_taxonomies to delete
     */
    where?: as_term_taxonomyWhereInput
    /**
     * Limit how many as_term_taxonomies to delete.
     */
    limit?: number
  }

  /**
   * as_term_taxonomy without action
   */
  export type as_term_taxonomyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_term_taxonomy
     */
    select?: as_term_taxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_term_taxonomy
     */
    omit?: as_term_taxonomyOmit<ExtArgs> | null
  }

  /**
   * Model as_termmeta
   */

  export type AggregateAs_termmeta = {
    _count: As_termmetaCountAggregateOutputType | null
    _avg: As_termmetaAvgAggregateOutputType | null
    _sum: As_termmetaSumAggregateOutputType | null
    _min: As_termmetaMinAggregateOutputType | null
    _max: As_termmetaMaxAggregateOutputType | null
  }

  export type As_termmetaAvgAggregateOutputType = {
    meta_id: number | null
    term_id: number | null
  }

  export type As_termmetaSumAggregateOutputType = {
    meta_id: bigint | null
    term_id: bigint | null
  }

  export type As_termmetaMinAggregateOutputType = {
    meta_id: bigint | null
    term_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_termmetaMaxAggregateOutputType = {
    meta_id: bigint | null
    term_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_termmetaCountAggregateOutputType = {
    meta_id: number
    term_id: number
    meta_key: number
    meta_value: number
    _all: number
  }

  export type As_termmetaAvgAggregateInputType = {
    meta_id?: true
    term_id?: true
  }

  export type As_termmetaSumAggregateInputType = {
    meta_id?: true
    term_id?: true
  }

  export type As_termmetaMinAggregateInputType = {
    meta_id?: true
    term_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_termmetaMaxAggregateInputType = {
    meta_id?: true
    term_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_termmetaCountAggregateInputType = {
    meta_id?: true
    term_id?: true
    meta_key?: true
    meta_value?: true
    _all?: true
  }

  export type As_termmetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_termmeta to aggregate.
     */
    where?: as_termmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_termmetas to fetch.
     */
    orderBy?: as_termmetaOrderByWithRelationInput | as_termmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_termmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_termmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_termmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_termmetas
     */
    _count?: true | As_termmetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_termmetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_termmetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_termmetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_termmetaMaxAggregateInputType
  }

  export type GetAs_termmetaAggregateType<T extends As_termmetaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_termmeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_termmeta[P]>
      : GetScalarType<T[P], AggregateAs_termmeta[P]>
  }

  export type as_termmetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_termmetaWhereInput
    orderBy?: as_termmetaOrderByWithAggregationInput | as_termmetaOrderByWithAggregationInput[]
    by: As_termmetaScalarFieldEnum[] | As_termmetaScalarFieldEnum
    having?: as_termmetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_termmetaCountAggregateInputType | true
    _avg?: As_termmetaAvgAggregateInputType
    _sum?: As_termmetaSumAggregateInputType
    _min?: As_termmetaMinAggregateInputType
    _max?: As_termmetaMaxAggregateInputType
  }

  export type As_termmetaGroupByOutputType = {
    meta_id: bigint
    term_id: bigint
    meta_key: string | null
    meta_value: string | null
    _count: As_termmetaCountAggregateOutputType | null
    _avg: As_termmetaAvgAggregateOutputType | null
    _sum: As_termmetaSumAggregateOutputType | null
    _min: As_termmetaMinAggregateOutputType | null
    _max: As_termmetaMaxAggregateOutputType | null
  }

  type GetAs_termmetaGroupByPayload<T extends as_termmetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_termmetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_termmetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_termmetaGroupByOutputType[P]>
          : GetScalarType<T[P], As_termmetaGroupByOutputType[P]>
      }
    >
  >

  export type as_termmetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      meta_id?: boolean
      term_id?: boolean
      meta_key?: boolean
      meta_value?: boolean
    },
    ExtArgs['result']['as_termmeta']
  >

  export type as_termmetaSelectScalar = {
    meta_id?: boolean
    term_id?: boolean
    meta_key?: boolean
    meta_value?: boolean
  }

  export type as_termmetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'meta_id' | 'term_id' | 'meta_key' | 'meta_value',
      ExtArgs['result']['as_termmeta']
    >

  export type $as_termmetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_termmeta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        meta_id: bigint
        term_id: bigint
        meta_key: string | null
        meta_value: string | null
      },
      ExtArgs['result']['as_termmeta']
    >
    composites: {}
  }

  type as_termmetaGetPayload<S extends boolean | null | undefined | as_termmetaDefaultArgs> =
    $Result.GetResult<Prisma.$as_termmetaPayload, S>

  type as_termmetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_termmetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_termmetaCountAggregateInputType | true
    }

  export interface as_termmetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_termmeta']
      meta: { name: 'as_termmeta' }
    }
    /**
     * Find zero or one As_termmeta that matches the filter.
     * @param {as_termmetaFindUniqueArgs} args - Arguments to find a As_termmeta
     * @example
     * // Get one As_termmeta
     * const as_termmeta = await prisma.as_termmeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_termmetaFindUniqueArgs>(
      args: SelectSubset<T, as_termmetaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<
        Prisma.$as_termmetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_termmeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_termmetaFindUniqueOrThrowArgs} args - Arguments to find a As_termmeta
     * @example
     * // Get one As_termmeta
     * const as_termmeta = await prisma.as_termmeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_termmetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_termmetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<
        Prisma.$as_termmetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_termmeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaFindFirstArgs} args - Arguments to find a As_termmeta
     * @example
     * // Get one As_termmeta
     * const as_termmeta = await prisma.as_termmeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_termmetaFindFirstArgs>(
      args?: SelectSubset<T, as_termmetaFindFirstArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<
        Prisma.$as_termmetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_termmeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaFindFirstOrThrowArgs} args - Arguments to find a As_termmeta
     * @example
     * // Get one As_termmeta
     * const as_termmeta = await prisma.as_termmeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_termmetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_termmetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<
        Prisma.$as_termmetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_termmetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_termmetas
     * const as_termmetas = await prisma.as_termmeta.findMany()
     *
     * // Get first 10 As_termmetas
     * const as_termmetas = await prisma.as_termmeta.findMany({ take: 10 })
     *
     * // Only select the `meta_id`
     * const as_termmetaWithMeta_idOnly = await prisma.as_termmeta.findMany({ select: { meta_id: true } })
     *
     */
    findMany<T extends as_termmetaFindManyArgs>(
      args?: SelectSubset<T, as_termmetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_termmetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_termmeta.
     * @param {as_termmetaCreateArgs} args - Arguments to create a As_termmeta.
     * @example
     * // Create one As_termmeta
     * const As_termmeta = await prisma.as_termmeta.create({
     *   data: {
     *     // ... data to create a As_termmeta
     *   }
     * })
     *
     */
    create<T extends as_termmetaCreateArgs>(
      args: SelectSubset<T, as_termmetaCreateArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<Prisma.$as_termmetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_termmetas.
     * @param {as_termmetaCreateManyArgs} args - Arguments to create many As_termmetas.
     * @example
     * // Create many As_termmetas
     * const as_termmeta = await prisma.as_termmeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_termmetaCreateManyArgs>(
      args?: SelectSubset<T, as_termmetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_termmeta.
     * @param {as_termmetaDeleteArgs} args - Arguments to delete one As_termmeta.
     * @example
     * // Delete one As_termmeta
     * const As_termmeta = await prisma.as_termmeta.delete({
     *   where: {
     *     // ... filter to delete one As_termmeta
     *   }
     * })
     *
     */
    delete<T extends as_termmetaDeleteArgs>(
      args: SelectSubset<T, as_termmetaDeleteArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<Prisma.$as_termmetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_termmeta.
     * @param {as_termmetaUpdateArgs} args - Arguments to update one As_termmeta.
     * @example
     * // Update one As_termmeta
     * const as_termmeta = await prisma.as_termmeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_termmetaUpdateArgs>(
      args: SelectSubset<T, as_termmetaUpdateArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<Prisma.$as_termmetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_termmetas.
     * @param {as_termmetaDeleteManyArgs} args - Arguments to filter As_termmetas to delete.
     * @example
     * // Delete a few As_termmetas
     * const { count } = await prisma.as_termmeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_termmetaDeleteManyArgs>(
      args?: SelectSubset<T, as_termmetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_termmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_termmetas
     * const as_termmeta = await prisma.as_termmeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_termmetaUpdateManyArgs>(
      args: SelectSubset<T, as_termmetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_termmeta.
     * @param {as_termmetaUpsertArgs} args - Arguments to update or create a As_termmeta.
     * @example
     * // Update or create a As_termmeta
     * const as_termmeta = await prisma.as_termmeta.upsert({
     *   create: {
     *     // ... data to create a As_termmeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_termmeta we want to update
     *   }
     * })
     */
    upsert<T extends as_termmetaUpsertArgs>(
      args: SelectSubset<T, as_termmetaUpsertArgs<ExtArgs>>
    ): Prisma__as_termmetaClient<
      $Result.GetResult<Prisma.$as_termmetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_termmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaCountArgs} args - Arguments to filter As_termmetas to count.
     * @example
     * // Count the number of As_termmetas
     * const count = await prisma.as_termmeta.count({
     *   where: {
     *     // ... the filter for the As_termmetas we want to count
     *   }
     * })
     */
    count<T extends as_termmetaCountArgs>(
      args?: Subset<T, as_termmetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_termmetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_termmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_termmetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_termmetaAggregateArgs>(
      args: Subset<T, As_termmetaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_termmetaAggregateType<T>>

    /**
     * Group by As_termmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termmetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_termmetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_termmetaGroupByArgs['orderBy'] }
        : { orderBy?: as_termmetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_termmetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_termmetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_termmeta model
     */
    readonly fields: as_termmetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_termmeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_termmetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_termmeta model
   */
  interface as_termmetaFieldRefs {
    readonly meta_id: FieldRef<'as_termmeta', 'BigInt'>
    readonly term_id: FieldRef<'as_termmeta', 'BigInt'>
    readonly meta_key: FieldRef<'as_termmeta', 'String'>
    readonly meta_value: FieldRef<'as_termmeta', 'String'>
  }

  // Custom InputTypes
  /**
   * as_termmeta findUnique
   */
  export type as_termmetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_termmeta to fetch.
     */
    where: as_termmetaWhereUniqueInput
  }

  /**
   * as_termmeta findUniqueOrThrow
   */
  export type as_termmetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_termmeta to fetch.
     */
    where: as_termmetaWhereUniqueInput
  }

  /**
   * as_termmeta findFirst
   */
  export type as_termmetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_termmeta to fetch.
     */
    where?: as_termmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_termmetas to fetch.
     */
    orderBy?: as_termmetaOrderByWithRelationInput | as_termmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_termmetas.
     */
    cursor?: as_termmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_termmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_termmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_termmetas.
     */
    distinct?: As_termmetaScalarFieldEnum | As_termmetaScalarFieldEnum[]
  }

  /**
   * as_termmeta findFirstOrThrow
   */
  export type as_termmetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_termmeta to fetch.
     */
    where?: as_termmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_termmetas to fetch.
     */
    orderBy?: as_termmetaOrderByWithRelationInput | as_termmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_termmetas.
     */
    cursor?: as_termmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_termmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_termmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_termmetas.
     */
    distinct?: As_termmetaScalarFieldEnum | As_termmetaScalarFieldEnum[]
  }

  /**
   * as_termmeta findMany
   */
  export type as_termmetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_termmetas to fetch.
     */
    where?: as_termmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_termmetas to fetch.
     */
    orderBy?: as_termmetaOrderByWithRelationInput | as_termmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_termmetas.
     */
    cursor?: as_termmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_termmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_termmetas.
     */
    skip?: number
    distinct?: As_termmetaScalarFieldEnum | As_termmetaScalarFieldEnum[]
  }

  /**
   * as_termmeta create
   */
  export type as_termmetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_termmeta.
     */
    data?: XOR<as_termmetaCreateInput, as_termmetaUncheckedCreateInput>
  }

  /**
   * as_termmeta createMany
   */
  export type as_termmetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_termmetas.
     */
    data: as_termmetaCreateManyInput | as_termmetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_termmeta update
   */
  export type as_termmetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_termmeta.
     */
    data: XOR<as_termmetaUpdateInput, as_termmetaUncheckedUpdateInput>
    /**
     * Choose, which as_termmeta to update.
     */
    where: as_termmetaWhereUniqueInput
  }

  /**
   * as_termmeta updateMany
   */
  export type as_termmetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_termmetas.
     */
    data: XOR<as_termmetaUpdateManyMutationInput, as_termmetaUncheckedUpdateManyInput>
    /**
     * Filter which as_termmetas to update
     */
    where?: as_termmetaWhereInput
    /**
     * Limit how many as_termmetas to update.
     */
    limit?: number
  }

  /**
   * as_termmeta upsert
   */
  export type as_termmetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_termmeta to update in case it exists.
     */
    where: as_termmetaWhereUniqueInput
    /**
     * In case the as_termmeta found by the `where` argument doesn't exist, create a new as_termmeta with this data.
     */
    create: XOR<as_termmetaCreateInput, as_termmetaUncheckedCreateInput>
    /**
     * In case the as_termmeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_termmetaUpdateInput, as_termmetaUncheckedUpdateInput>
  }

  /**
   * as_termmeta delete
   */
  export type as_termmetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
    /**
     * Filter which as_termmeta to delete.
     */
    where: as_termmetaWhereUniqueInput
  }

  /**
   * as_termmeta deleteMany
   */
  export type as_termmetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_termmetas to delete
     */
    where?: as_termmetaWhereInput
    /**
     * Limit how many as_termmetas to delete.
     */
    limit?: number
  }

  /**
   * as_termmeta without action
   */
  export type as_termmetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_termmeta
     */
    select?: as_termmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_termmeta
     */
    omit?: as_termmetaOmit<ExtArgs> | null
  }

  /**
   * Model as_terms
   */

  export type AggregateAs_terms = {
    _count: As_termsCountAggregateOutputType | null
    _avg: As_termsAvgAggregateOutputType | null
    _sum: As_termsSumAggregateOutputType | null
    _min: As_termsMinAggregateOutputType | null
    _max: As_termsMaxAggregateOutputType | null
  }

  export type As_termsAvgAggregateOutputType = {
    term_id: number | null
    term_group: number | null
  }

  export type As_termsSumAggregateOutputType = {
    term_id: bigint | null
    term_group: bigint | null
  }

  export type As_termsMinAggregateOutputType = {
    term_id: bigint | null
    name: string | null
    slug: string | null
    term_group: bigint | null
  }

  export type As_termsMaxAggregateOutputType = {
    term_id: bigint | null
    name: string | null
    slug: string | null
    term_group: bigint | null
  }

  export type As_termsCountAggregateOutputType = {
    term_id: number
    name: number
    slug: number
    term_group: number
    _all: number
  }

  export type As_termsAvgAggregateInputType = {
    term_id?: true
    term_group?: true
  }

  export type As_termsSumAggregateInputType = {
    term_id?: true
    term_group?: true
  }

  export type As_termsMinAggregateInputType = {
    term_id?: true
    name?: true
    slug?: true
    term_group?: true
  }

  export type As_termsMaxAggregateInputType = {
    term_id?: true
    name?: true
    slug?: true
    term_group?: true
  }

  export type As_termsCountAggregateInputType = {
    term_id?: true
    name?: true
    slug?: true
    term_group?: true
    _all?: true
  }

  export type As_termsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_terms to aggregate.
     */
    where?: as_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_terms to fetch.
     */
    orderBy?: as_termsOrderByWithRelationInput | as_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_terms
     */
    _count?: true | As_termsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_termsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_termsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_termsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_termsMaxAggregateInputType
  }

  export type GetAs_termsAggregateType<T extends As_termsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_terms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_terms[P]>
      : GetScalarType<T[P], AggregateAs_terms[P]>
  }

  export type as_termsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_termsWhereInput
    orderBy?: as_termsOrderByWithAggregationInput | as_termsOrderByWithAggregationInput[]
    by: As_termsScalarFieldEnum[] | As_termsScalarFieldEnum
    having?: as_termsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_termsCountAggregateInputType | true
    _avg?: As_termsAvgAggregateInputType
    _sum?: As_termsSumAggregateInputType
    _min?: As_termsMinAggregateInputType
    _max?: As_termsMaxAggregateInputType
  }

  export type As_termsGroupByOutputType = {
    term_id: bigint
    name: string
    slug: string
    term_group: bigint
    _count: As_termsCountAggregateOutputType | null
    _avg: As_termsAvgAggregateOutputType | null
    _sum: As_termsSumAggregateOutputType | null
    _min: As_termsMinAggregateOutputType | null
    _max: As_termsMaxAggregateOutputType | null
  }

  type GetAs_termsGroupByPayload<T extends as_termsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_termsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_termsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_termsGroupByOutputType[P]>
          : GetScalarType<T[P], As_termsGroupByOutputType[P]>
      }
    >
  >

  export type as_termsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        term_id?: boolean
        name?: boolean
        slug?: boolean
        term_group?: boolean
      },
      ExtArgs['result']['as_terms']
    >

  export type as_termsSelectScalar = {
    term_id?: boolean
    name?: boolean
    slug?: boolean
    term_group?: boolean
  }

  export type as_termsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'term_id' | 'name' | 'slug' | 'term_group', ExtArgs['result']['as_terms']>

  export type $as_termsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'as_terms'
      objects: {}
      scalars: $Extensions.GetPayloadResult<
        {
          term_id: bigint
          name: string
          slug: string
          term_group: bigint
        },
        ExtArgs['result']['as_terms']
      >
      composites: {}
    }

  type as_termsGetPayload<S extends boolean | null | undefined | as_termsDefaultArgs> =
    $Result.GetResult<Prisma.$as_termsPayload, S>

  type as_termsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    as_termsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: As_termsCountAggregateInputType | true
  }

  export interface as_termsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['as_terms']; meta: { name: 'as_terms' } }
    /**
     * Find zero or one As_terms that matches the filter.
     * @param {as_termsFindUniqueArgs} args - Arguments to find a As_terms
     * @example
     * // Get one As_terms
     * const as_terms = await prisma.as_terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_termsFindUniqueArgs>(
      args: SelectSubset<T, as_termsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<
        Prisma.$as_termsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_terms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_termsFindUniqueOrThrowArgs} args - Arguments to find a As_terms
     * @example
     * // Get one As_terms
     * const as_terms = await prisma.as_terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_termsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_termsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<
        Prisma.$as_termsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsFindFirstArgs} args - Arguments to find a As_terms
     * @example
     * // Get one As_terms
     * const as_terms = await prisma.as_terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_termsFindFirstArgs>(
      args?: SelectSubset<T, as_termsFindFirstArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsFindFirstOrThrowArgs} args - Arguments to find a As_terms
     * @example
     * // Get one As_terms
     * const as_terms = await prisma.as_terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_termsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_termsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_terms
     * const as_terms = await prisma.as_terms.findMany()
     *
     * // Get first 10 As_terms
     * const as_terms = await prisma.as_terms.findMany({ take: 10 })
     *
     * // Only select the `term_id`
     * const as_termsWithTerm_idOnly = await prisma.as_terms.findMany({ select: { term_id: true } })
     *
     */
    findMany<T extends as_termsFindManyArgs>(
      args?: SelectSubset<T, as_termsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_terms.
     * @param {as_termsCreateArgs} args - Arguments to create a As_terms.
     * @example
     * // Create one As_terms
     * const As_terms = await prisma.as_terms.create({
     *   data: {
     *     // ... data to create a As_terms
     *   }
     * })
     *
     */
    create<T extends as_termsCreateArgs>(
      args: SelectSubset<T, as_termsCreateArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_terms.
     * @param {as_termsCreateManyArgs} args - Arguments to create many As_terms.
     * @example
     * // Create many As_terms
     * const as_terms = await prisma.as_terms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_termsCreateManyArgs>(
      args?: SelectSubset<T, as_termsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_terms.
     * @param {as_termsDeleteArgs} args - Arguments to delete one As_terms.
     * @example
     * // Delete one As_terms
     * const As_terms = await prisma.as_terms.delete({
     *   where: {
     *     // ... filter to delete one As_terms
     *   }
     * })
     *
     */
    delete<T extends as_termsDeleteArgs>(
      args: SelectSubset<T, as_termsDeleteArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_terms.
     * @param {as_termsUpdateArgs} args - Arguments to update one As_terms.
     * @example
     * // Update one As_terms
     * const as_terms = await prisma.as_terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_termsUpdateArgs>(
      args: SelectSubset<T, as_termsUpdateArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_terms.
     * @param {as_termsDeleteManyArgs} args - Arguments to filter As_terms to delete.
     * @example
     * // Delete a few As_terms
     * const { count } = await prisma.as_terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_termsDeleteManyArgs>(
      args?: SelectSubset<T, as_termsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_terms
     * const as_terms = await prisma.as_terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_termsUpdateManyArgs>(
      args: SelectSubset<T, as_termsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_terms.
     * @param {as_termsUpsertArgs} args - Arguments to update or create a As_terms.
     * @example
     * // Update or create a As_terms
     * const as_terms = await prisma.as_terms.upsert({
     *   create: {
     *     // ... data to create a As_terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_terms we want to update
     *   }
     * })
     */
    upsert<T extends as_termsUpsertArgs>(
      args: SelectSubset<T, as_termsUpsertArgs<ExtArgs>>
    ): Prisma__as_termsClient<
      $Result.GetResult<Prisma.$as_termsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsCountArgs} args - Arguments to filter As_terms to count.
     * @example
     * // Count the number of As_terms
     * const count = await prisma.as_terms.count({
     *   where: {
     *     // ... the filter for the As_terms we want to count
     *   }
     * })
     */
    count<T extends as_termsCountArgs>(
      args?: Subset<T, as_termsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_termsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_termsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_termsAggregateArgs>(
      args: Subset<T, As_termsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_termsAggregateType<T>>

    /**
     * Group by As_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_termsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_termsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_termsGroupByArgs['orderBy'] }
        : { orderBy?: as_termsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_termsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_termsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_terms model
     */
    readonly fields: as_termsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_termsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_terms model
   */
  interface as_termsFieldRefs {
    readonly term_id: FieldRef<'as_terms', 'BigInt'>
    readonly name: FieldRef<'as_terms', 'String'>
    readonly slug: FieldRef<'as_terms', 'String'>
    readonly term_group: FieldRef<'as_terms', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_terms findUnique
   */
  export type as_termsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter, which as_terms to fetch.
     */
    where: as_termsWhereUniqueInput
  }

  /**
   * as_terms findUniqueOrThrow
   */
  export type as_termsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter, which as_terms to fetch.
     */
    where: as_termsWhereUniqueInput
  }

  /**
   * as_terms findFirst
   */
  export type as_termsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter, which as_terms to fetch.
     */
    where?: as_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_terms to fetch.
     */
    orderBy?: as_termsOrderByWithRelationInput | as_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_terms.
     */
    cursor?: as_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_terms.
     */
    distinct?: As_termsScalarFieldEnum | As_termsScalarFieldEnum[]
  }

  /**
   * as_terms findFirstOrThrow
   */
  export type as_termsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter, which as_terms to fetch.
     */
    where?: as_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_terms to fetch.
     */
    orderBy?: as_termsOrderByWithRelationInput | as_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_terms.
     */
    cursor?: as_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_terms.
     */
    distinct?: As_termsScalarFieldEnum | As_termsScalarFieldEnum[]
  }

  /**
   * as_terms findMany
   */
  export type as_termsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter, which as_terms to fetch.
     */
    where?: as_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_terms to fetch.
     */
    orderBy?: as_termsOrderByWithRelationInput | as_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_terms.
     */
    cursor?: as_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_terms.
     */
    skip?: number
    distinct?: As_termsScalarFieldEnum | As_termsScalarFieldEnum[]
  }

  /**
   * as_terms create
   */
  export type as_termsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_terms.
     */
    data?: XOR<as_termsCreateInput, as_termsUncheckedCreateInput>
  }

  /**
   * as_terms createMany
   */
  export type as_termsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_terms.
     */
    data: as_termsCreateManyInput | as_termsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_terms update
   */
  export type as_termsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_terms.
     */
    data: XOR<as_termsUpdateInput, as_termsUncheckedUpdateInput>
    /**
     * Choose, which as_terms to update.
     */
    where: as_termsWhereUniqueInput
  }

  /**
   * as_terms updateMany
   */
  export type as_termsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_terms.
     */
    data: XOR<as_termsUpdateManyMutationInput, as_termsUncheckedUpdateManyInput>
    /**
     * Filter which as_terms to update
     */
    where?: as_termsWhereInput
    /**
     * Limit how many as_terms to update.
     */
    limit?: number
  }

  /**
   * as_terms upsert
   */
  export type as_termsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_terms to update in case it exists.
     */
    where: as_termsWhereUniqueInput
    /**
     * In case the as_terms found by the `where` argument doesn't exist, create a new as_terms with this data.
     */
    create: XOR<as_termsCreateInput, as_termsUncheckedCreateInput>
    /**
     * In case the as_terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_termsUpdateInput, as_termsUncheckedUpdateInput>
  }

  /**
   * as_terms delete
   */
  export type as_termsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
    /**
     * Filter which as_terms to delete.
     */
    where: as_termsWhereUniqueInput
  }

  /**
   * as_terms deleteMany
   */
  export type as_termsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_terms to delete
     */
    where?: as_termsWhereInput
    /**
     * Limit how many as_terms to delete.
     */
    limit?: number
  }

  /**
   * as_terms without action
   */
  export type as_termsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_terms
     */
    select?: as_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_terms
     */
    omit?: as_termsOmit<ExtArgs> | null
  }

  /**
   * Model as_tm_taskmeta
   */

  export type AggregateAs_tm_taskmeta = {
    _count: As_tm_taskmetaCountAggregateOutputType | null
    _avg: As_tm_taskmetaAvgAggregateOutputType | null
    _sum: As_tm_taskmetaSumAggregateOutputType | null
    _min: As_tm_taskmetaMinAggregateOutputType | null
    _max: As_tm_taskmetaMaxAggregateOutputType | null
  }

  export type As_tm_taskmetaAvgAggregateOutputType = {
    meta_id: number | null
    task_id: number | null
  }

  export type As_tm_taskmetaSumAggregateOutputType = {
    meta_id: bigint | null
    task_id: bigint | null
  }

  export type As_tm_taskmetaMinAggregateOutputType = {
    meta_id: bigint | null
    task_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_tm_taskmetaMaxAggregateOutputType = {
    meta_id: bigint | null
    task_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_tm_taskmetaCountAggregateOutputType = {
    meta_id: number
    task_id: number
    meta_key: number
    meta_value: number
    _all: number
  }

  export type As_tm_taskmetaAvgAggregateInputType = {
    meta_id?: true
    task_id?: true
  }

  export type As_tm_taskmetaSumAggregateInputType = {
    meta_id?: true
    task_id?: true
  }

  export type As_tm_taskmetaMinAggregateInputType = {
    meta_id?: true
    task_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_tm_taskmetaMaxAggregateInputType = {
    meta_id?: true
    task_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_tm_taskmetaCountAggregateInputType = {
    meta_id?: true
    task_id?: true
    meta_key?: true
    meta_value?: true
    _all?: true
  }

  export type As_tm_taskmetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_tm_taskmeta to aggregate.
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_taskmetas to fetch.
     */
    orderBy?: as_tm_taskmetaOrderByWithRelationInput | as_tm_taskmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_tm_taskmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_taskmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_taskmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_tm_taskmetas
     */
    _count?: true | As_tm_taskmetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_tm_taskmetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_tm_taskmetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_tm_taskmetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_tm_taskmetaMaxAggregateInputType
  }

  export type GetAs_tm_taskmetaAggregateType<T extends As_tm_taskmetaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_tm_taskmeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_tm_taskmeta[P]>
      : GetScalarType<T[P], AggregateAs_tm_taskmeta[P]>
  }

  export type as_tm_taskmetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_tm_taskmetaWhereInput
    orderBy?:
      | as_tm_taskmetaOrderByWithAggregationInput
      | as_tm_taskmetaOrderByWithAggregationInput[]
    by: As_tm_taskmetaScalarFieldEnum[] | As_tm_taskmetaScalarFieldEnum
    having?: as_tm_taskmetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_tm_taskmetaCountAggregateInputType | true
    _avg?: As_tm_taskmetaAvgAggregateInputType
    _sum?: As_tm_taskmetaSumAggregateInputType
    _min?: As_tm_taskmetaMinAggregateInputType
    _max?: As_tm_taskmetaMaxAggregateInputType
  }

  export type As_tm_taskmetaGroupByOutputType = {
    meta_id: bigint
    task_id: bigint
    meta_key: string | null
    meta_value: string | null
    _count: As_tm_taskmetaCountAggregateOutputType | null
    _avg: As_tm_taskmetaAvgAggregateOutputType | null
    _sum: As_tm_taskmetaSumAggregateOutputType | null
    _min: As_tm_taskmetaMinAggregateOutputType | null
    _max: As_tm_taskmetaMaxAggregateOutputType | null
  }

  type GetAs_tm_taskmetaGroupByPayload<T extends as_tm_taskmetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_tm_taskmetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_tm_taskmetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_tm_taskmetaGroupByOutputType[P]>
          : GetScalarType<T[P], As_tm_taskmetaGroupByOutputType[P]>
      }
    >
  >

  export type as_tm_taskmetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      meta_id?: boolean
      task_id?: boolean
      meta_key?: boolean
      meta_value?: boolean
    },
    ExtArgs['result']['as_tm_taskmeta']
  >

  export type as_tm_taskmetaSelectScalar = {
    meta_id?: boolean
    task_id?: boolean
    meta_key?: boolean
    meta_value?: boolean
  }

  export type as_tm_taskmetaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'meta_id' | 'task_id' | 'meta_key' | 'meta_value',
    ExtArgs['result']['as_tm_taskmeta']
  >

  export type $as_tm_taskmetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_tm_taskmeta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        meta_id: bigint
        task_id: bigint
        meta_key: string | null
        meta_value: string | null
      },
      ExtArgs['result']['as_tm_taskmeta']
    >
    composites: {}
  }

  type as_tm_taskmetaGetPayload<S extends boolean | null | undefined | as_tm_taskmetaDefaultArgs> =
    $Result.GetResult<Prisma.$as_tm_taskmetaPayload, S>

  type as_tm_taskmetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_tm_taskmetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_tm_taskmetaCountAggregateInputType | true
    }

  export interface as_tm_taskmetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_tm_taskmeta']
      meta: { name: 'as_tm_taskmeta' }
    }
    /**
     * Find zero or one As_tm_taskmeta that matches the filter.
     * @param {as_tm_taskmetaFindUniqueArgs} args - Arguments to find a As_tm_taskmeta
     * @example
     * // Get one As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_tm_taskmetaFindUniqueArgs>(
      args: SelectSubset<T, as_tm_taskmetaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<
        Prisma.$as_tm_taskmetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_tm_taskmeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_tm_taskmetaFindUniqueOrThrowArgs} args - Arguments to find a As_tm_taskmeta
     * @example
     * // Get one As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_tm_taskmetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_tm_taskmetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<
        Prisma.$as_tm_taskmetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_tm_taskmeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaFindFirstArgs} args - Arguments to find a As_tm_taskmeta
     * @example
     * // Get one As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_tm_taskmetaFindFirstArgs>(
      args?: SelectSubset<T, as_tm_taskmetaFindFirstArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<
        Prisma.$as_tm_taskmetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_tm_taskmeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaFindFirstOrThrowArgs} args - Arguments to find a As_tm_taskmeta
     * @example
     * // Get one As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_tm_taskmetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_tm_taskmetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<
        Prisma.$as_tm_taskmetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_tm_taskmetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_tm_taskmetas
     * const as_tm_taskmetas = await prisma.as_tm_taskmeta.findMany()
     *
     * // Get first 10 As_tm_taskmetas
     * const as_tm_taskmetas = await prisma.as_tm_taskmeta.findMany({ take: 10 })
     *
     * // Only select the `meta_id`
     * const as_tm_taskmetaWithMeta_idOnly = await prisma.as_tm_taskmeta.findMany({ select: { meta_id: true } })
     *
     */
    findMany<T extends as_tm_taskmetaFindManyArgs>(
      args?: SelectSubset<T, as_tm_taskmetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_tm_taskmetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_tm_taskmeta.
     * @param {as_tm_taskmetaCreateArgs} args - Arguments to create a As_tm_taskmeta.
     * @example
     * // Create one As_tm_taskmeta
     * const As_tm_taskmeta = await prisma.as_tm_taskmeta.create({
     *   data: {
     *     // ... data to create a As_tm_taskmeta
     *   }
     * })
     *
     */
    create<T extends as_tm_taskmetaCreateArgs>(
      args: SelectSubset<T, as_tm_taskmetaCreateArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<Prisma.$as_tm_taskmetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_tm_taskmetas.
     * @param {as_tm_taskmetaCreateManyArgs} args - Arguments to create many As_tm_taskmetas.
     * @example
     * // Create many As_tm_taskmetas
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_tm_taskmetaCreateManyArgs>(
      args?: SelectSubset<T, as_tm_taskmetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_tm_taskmeta.
     * @param {as_tm_taskmetaDeleteArgs} args - Arguments to delete one As_tm_taskmeta.
     * @example
     * // Delete one As_tm_taskmeta
     * const As_tm_taskmeta = await prisma.as_tm_taskmeta.delete({
     *   where: {
     *     // ... filter to delete one As_tm_taskmeta
     *   }
     * })
     *
     */
    delete<T extends as_tm_taskmetaDeleteArgs>(
      args: SelectSubset<T, as_tm_taskmetaDeleteArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<Prisma.$as_tm_taskmetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_tm_taskmeta.
     * @param {as_tm_taskmetaUpdateArgs} args - Arguments to update one As_tm_taskmeta.
     * @example
     * // Update one As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_tm_taskmetaUpdateArgs>(
      args: SelectSubset<T, as_tm_taskmetaUpdateArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<Prisma.$as_tm_taskmetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_tm_taskmetas.
     * @param {as_tm_taskmetaDeleteManyArgs} args - Arguments to filter As_tm_taskmetas to delete.
     * @example
     * // Delete a few As_tm_taskmetas
     * const { count } = await prisma.as_tm_taskmeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_tm_taskmetaDeleteManyArgs>(
      args?: SelectSubset<T, as_tm_taskmetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_tm_taskmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_tm_taskmetas
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_tm_taskmetaUpdateManyArgs>(
      args: SelectSubset<T, as_tm_taskmetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_tm_taskmeta.
     * @param {as_tm_taskmetaUpsertArgs} args - Arguments to update or create a As_tm_taskmeta.
     * @example
     * // Update or create a As_tm_taskmeta
     * const as_tm_taskmeta = await prisma.as_tm_taskmeta.upsert({
     *   create: {
     *     // ... data to create a As_tm_taskmeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_tm_taskmeta we want to update
     *   }
     * })
     */
    upsert<T extends as_tm_taskmetaUpsertArgs>(
      args: SelectSubset<T, as_tm_taskmetaUpsertArgs<ExtArgs>>
    ): Prisma__as_tm_taskmetaClient<
      $Result.GetResult<Prisma.$as_tm_taskmetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_tm_taskmetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaCountArgs} args - Arguments to filter As_tm_taskmetas to count.
     * @example
     * // Count the number of As_tm_taskmetas
     * const count = await prisma.as_tm_taskmeta.count({
     *   where: {
     *     // ... the filter for the As_tm_taskmetas we want to count
     *   }
     * })
     */
    count<T extends as_tm_taskmetaCountArgs>(
      args?: Subset<T, as_tm_taskmetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_tm_taskmetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_tm_taskmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_tm_taskmetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_tm_taskmetaAggregateArgs>(
      args: Subset<T, As_tm_taskmetaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_tm_taskmetaAggregateType<T>>

    /**
     * Group by As_tm_taskmeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_taskmetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_tm_taskmetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_tm_taskmetaGroupByArgs['orderBy'] }
        : { orderBy?: as_tm_taskmetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_tm_taskmetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_tm_taskmetaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_tm_taskmeta model
     */
    readonly fields: as_tm_taskmetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_tm_taskmeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_tm_taskmetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_tm_taskmeta model
   */
  interface as_tm_taskmetaFieldRefs {
    readonly meta_id: FieldRef<'as_tm_taskmeta', 'BigInt'>
    readonly task_id: FieldRef<'as_tm_taskmeta', 'BigInt'>
    readonly meta_key: FieldRef<'as_tm_taskmeta', 'String'>
    readonly meta_value: FieldRef<'as_tm_taskmeta', 'String'>
  }

  // Custom InputTypes
  /**
   * as_tm_taskmeta findUnique
   */
  export type as_tm_taskmetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_taskmeta to fetch.
     */
    where: as_tm_taskmetaWhereUniqueInput
  }

  /**
   * as_tm_taskmeta findUniqueOrThrow
   */
  export type as_tm_taskmetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_taskmeta to fetch.
     */
    where: as_tm_taskmetaWhereUniqueInput
  }

  /**
   * as_tm_taskmeta findFirst
   */
  export type as_tm_taskmetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_taskmeta to fetch.
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_taskmetas to fetch.
     */
    orderBy?: as_tm_taskmetaOrderByWithRelationInput | as_tm_taskmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_tm_taskmetas.
     */
    cursor?: as_tm_taskmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_taskmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_taskmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_tm_taskmetas.
     */
    distinct?: As_tm_taskmetaScalarFieldEnum | As_tm_taskmetaScalarFieldEnum[]
  }

  /**
   * as_tm_taskmeta findFirstOrThrow
   */
  export type as_tm_taskmetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_taskmeta to fetch.
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_taskmetas to fetch.
     */
    orderBy?: as_tm_taskmetaOrderByWithRelationInput | as_tm_taskmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_tm_taskmetas.
     */
    cursor?: as_tm_taskmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_taskmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_taskmetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_tm_taskmetas.
     */
    distinct?: As_tm_taskmetaScalarFieldEnum | As_tm_taskmetaScalarFieldEnum[]
  }

  /**
   * as_tm_taskmeta findMany
   */
  export type as_tm_taskmetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_taskmetas to fetch.
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_taskmetas to fetch.
     */
    orderBy?: as_tm_taskmetaOrderByWithRelationInput | as_tm_taskmetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_tm_taskmetas.
     */
    cursor?: as_tm_taskmetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_taskmetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_taskmetas.
     */
    skip?: number
    distinct?: As_tm_taskmetaScalarFieldEnum | As_tm_taskmetaScalarFieldEnum[]
  }

  /**
   * as_tm_taskmeta create
   */
  export type as_tm_taskmetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_tm_taskmeta.
     */
    data?: XOR<as_tm_taskmetaCreateInput, as_tm_taskmetaUncheckedCreateInput>
  }

  /**
   * as_tm_taskmeta createMany
   */
  export type as_tm_taskmetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_tm_taskmetas.
     */
    data: as_tm_taskmetaCreateManyInput | as_tm_taskmetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_tm_taskmeta update
   */
  export type as_tm_taskmetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_tm_taskmeta.
     */
    data: XOR<as_tm_taskmetaUpdateInput, as_tm_taskmetaUncheckedUpdateInput>
    /**
     * Choose, which as_tm_taskmeta to update.
     */
    where: as_tm_taskmetaWhereUniqueInput
  }

  /**
   * as_tm_taskmeta updateMany
   */
  export type as_tm_taskmetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_tm_taskmetas.
     */
    data: XOR<as_tm_taskmetaUpdateManyMutationInput, as_tm_taskmetaUncheckedUpdateManyInput>
    /**
     * Filter which as_tm_taskmetas to update
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * Limit how many as_tm_taskmetas to update.
     */
    limit?: number
  }

  /**
   * as_tm_taskmeta upsert
   */
  export type as_tm_taskmetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_tm_taskmeta to update in case it exists.
     */
    where: as_tm_taskmetaWhereUniqueInput
    /**
     * In case the as_tm_taskmeta found by the `where` argument doesn't exist, create a new as_tm_taskmeta with this data.
     */
    create: XOR<as_tm_taskmetaCreateInput, as_tm_taskmetaUncheckedCreateInput>
    /**
     * In case the as_tm_taskmeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_tm_taskmetaUpdateInput, as_tm_taskmetaUncheckedUpdateInput>
  }

  /**
   * as_tm_taskmeta delete
   */
  export type as_tm_taskmetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
    /**
     * Filter which as_tm_taskmeta to delete.
     */
    where: as_tm_taskmetaWhereUniqueInput
  }

  /**
   * as_tm_taskmeta deleteMany
   */
  export type as_tm_taskmetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_tm_taskmetas to delete
     */
    where?: as_tm_taskmetaWhereInput
    /**
     * Limit how many as_tm_taskmetas to delete.
     */
    limit?: number
  }

  /**
   * as_tm_taskmeta without action
   */
  export type as_tm_taskmetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_taskmeta
     */
    select?: as_tm_taskmetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_taskmeta
     */
    omit?: as_tm_taskmetaOmit<ExtArgs> | null
  }

  /**
   * Model as_tm_tasks
   */

  export type AggregateAs_tm_tasks = {
    _count: As_tm_tasksCountAggregateOutputType | null
    _avg: As_tm_tasksAvgAggregateOutputType | null
    _sum: As_tm_tasksSumAggregateOutputType | null
    _min: As_tm_tasksMinAggregateOutputType | null
    _max: As_tm_tasksMaxAggregateOutputType | null
  }

  export type As_tm_tasksAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    attempts: number | null
    last_locked_at: number | null
  }

  export type As_tm_tasksSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    attempts: number | null
    last_locked_at: bigint | null
  }

  export type As_tm_tasksMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    type: string | null
    class_identifier: string | null
    attempts: number | null
    description: string | null
    time_created: Date | null
    last_locked_at: bigint | null
    status: string | null
  }

  export type As_tm_tasksMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    type: string | null
    class_identifier: string | null
    attempts: number | null
    description: string | null
    time_created: Date | null
    last_locked_at: bigint | null
    status: string | null
  }

  export type As_tm_tasksCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    class_identifier: number
    attempts: number
    description: number
    time_created: number
    last_locked_at: number
    status: number
    _all: number
  }

  export type As_tm_tasksAvgAggregateInputType = {
    id?: true
    user_id?: true
    attempts?: true
    last_locked_at?: true
  }

  export type As_tm_tasksSumAggregateInputType = {
    id?: true
    user_id?: true
    attempts?: true
    last_locked_at?: true
  }

  export type As_tm_tasksMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    class_identifier?: true
    attempts?: true
    description?: true
    time_created?: true
    last_locked_at?: true
    status?: true
  }

  export type As_tm_tasksMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    class_identifier?: true
    attempts?: true
    description?: true
    time_created?: true
    last_locked_at?: true
    status?: true
  }

  export type As_tm_tasksCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    class_identifier?: true
    attempts?: true
    description?: true
    time_created?: true
    last_locked_at?: true
    status?: true
    _all?: true
  }

  export type As_tm_tasksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_tm_tasks to aggregate.
     */
    where?: as_tm_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_tasks to fetch.
     */
    orderBy?: as_tm_tasksOrderByWithRelationInput | as_tm_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_tm_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_tm_tasks
     */
    _count?: true | As_tm_tasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_tm_tasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_tm_tasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_tm_tasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_tm_tasksMaxAggregateInputType
  }

  export type GetAs_tm_tasksAggregateType<T extends As_tm_tasksAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_tm_tasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_tm_tasks[P]>
      : GetScalarType<T[P], AggregateAs_tm_tasks[P]>
  }

  export type as_tm_tasksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_tm_tasksWhereInput
    orderBy?: as_tm_tasksOrderByWithAggregationInput | as_tm_tasksOrderByWithAggregationInput[]
    by: As_tm_tasksScalarFieldEnum[] | As_tm_tasksScalarFieldEnum
    having?: as_tm_tasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_tm_tasksCountAggregateInputType | true
    _avg?: As_tm_tasksAvgAggregateInputType
    _sum?: As_tm_tasksSumAggregateInputType
    _min?: As_tm_tasksMinAggregateInputType
    _max?: As_tm_tasksMaxAggregateInputType
  }

  export type As_tm_tasksGroupByOutputType = {
    id: number
    user_id: bigint
    type: string
    class_identifier: string | null
    attempts: number | null
    description: string | null
    time_created: Date
    last_locked_at: bigint | null
    status: string | null
    _count: As_tm_tasksCountAggregateOutputType | null
    _avg: As_tm_tasksAvgAggregateOutputType | null
    _sum: As_tm_tasksSumAggregateOutputType | null
    _min: As_tm_tasksMinAggregateOutputType | null
    _max: As_tm_tasksMaxAggregateOutputType | null
  }

  type GetAs_tm_tasksGroupByPayload<T extends as_tm_tasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_tm_tasksGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_tm_tasksGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_tm_tasksGroupByOutputType[P]>
          : GetScalarType<T[P], As_tm_tasksGroupByOutputType[P]>
      }
    >
  >

  export type as_tm_tasksSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      user_id?: boolean
      type?: boolean
      class_identifier?: boolean
      attempts?: boolean
      description?: boolean
      time_created?: boolean
      last_locked_at?: boolean
      status?: boolean
    },
    ExtArgs['result']['as_tm_tasks']
  >

  export type as_tm_tasksSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    class_identifier?: boolean
    attempts?: boolean
    description?: boolean
    time_created?: boolean
    last_locked_at?: boolean
    status?: boolean
  }

  export type as_tm_tasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'user_id'
      | 'type'
      | 'class_identifier'
      | 'attempts'
      | 'description'
      | 'time_created'
      | 'last_locked_at'
      | 'status',
      ExtArgs['result']['as_tm_tasks']
    >

  export type $as_tm_tasksPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_tm_tasks'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        user_id: bigint
        type: string
        class_identifier: string | null
        attempts: number | null
        description: string | null
        time_created: Date
        last_locked_at: bigint | null
        status: string | null
      },
      ExtArgs['result']['as_tm_tasks']
    >
    composites: {}
  }

  type as_tm_tasksGetPayload<S extends boolean | null | undefined | as_tm_tasksDefaultArgs> =
    $Result.GetResult<Prisma.$as_tm_tasksPayload, S>

  type as_tm_tasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_tm_tasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_tm_tasksCountAggregateInputType | true
    }

  export interface as_tm_tasksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_tm_tasks']
      meta: { name: 'as_tm_tasks' }
    }
    /**
     * Find zero or one As_tm_tasks that matches the filter.
     * @param {as_tm_tasksFindUniqueArgs} args - Arguments to find a As_tm_tasks
     * @example
     * // Get one As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_tm_tasksFindUniqueArgs>(
      args: SelectSubset<T, as_tm_tasksFindUniqueArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<
        Prisma.$as_tm_tasksPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_tm_tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_tm_tasksFindUniqueOrThrowArgs} args - Arguments to find a As_tm_tasks
     * @example
     * // Get one As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_tm_tasksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_tm_tasksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<
        Prisma.$as_tm_tasksPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_tm_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksFindFirstArgs} args - Arguments to find a As_tm_tasks
     * @example
     * // Get one As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_tm_tasksFindFirstArgs>(
      args?: SelectSubset<T, as_tm_tasksFindFirstArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<
        Prisma.$as_tm_tasksPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_tm_tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksFindFirstOrThrowArgs} args - Arguments to find a As_tm_tasks
     * @example
     * // Get one As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_tm_tasksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_tm_tasksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<
        Prisma.$as_tm_tasksPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_tm_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findMany()
     *
     * // Get first 10 As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_tm_tasksWithIdOnly = await prisma.as_tm_tasks.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_tm_tasksFindManyArgs>(
      args?: SelectSubset<T, as_tm_tasksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_tm_tasksPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_tm_tasks.
     * @param {as_tm_tasksCreateArgs} args - Arguments to create a As_tm_tasks.
     * @example
     * // Create one As_tm_tasks
     * const As_tm_tasks = await prisma.as_tm_tasks.create({
     *   data: {
     *     // ... data to create a As_tm_tasks
     *   }
     * })
     *
     */
    create<T extends as_tm_tasksCreateArgs>(
      args: SelectSubset<T, as_tm_tasksCreateArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<Prisma.$as_tm_tasksPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_tm_tasks.
     * @param {as_tm_tasksCreateManyArgs} args - Arguments to create many As_tm_tasks.
     * @example
     * // Create many As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_tm_tasksCreateManyArgs>(
      args?: SelectSubset<T, as_tm_tasksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_tm_tasks.
     * @param {as_tm_tasksDeleteArgs} args - Arguments to delete one As_tm_tasks.
     * @example
     * // Delete one As_tm_tasks
     * const As_tm_tasks = await prisma.as_tm_tasks.delete({
     *   where: {
     *     // ... filter to delete one As_tm_tasks
     *   }
     * })
     *
     */
    delete<T extends as_tm_tasksDeleteArgs>(
      args: SelectSubset<T, as_tm_tasksDeleteArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<Prisma.$as_tm_tasksPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_tm_tasks.
     * @param {as_tm_tasksUpdateArgs} args - Arguments to update one As_tm_tasks.
     * @example
     * // Update one As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_tm_tasksUpdateArgs>(
      args: SelectSubset<T, as_tm_tasksUpdateArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<Prisma.$as_tm_tasksPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_tm_tasks.
     * @param {as_tm_tasksDeleteManyArgs} args - Arguments to filter As_tm_tasks to delete.
     * @example
     * // Delete a few As_tm_tasks
     * const { count } = await prisma.as_tm_tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_tm_tasksDeleteManyArgs>(
      args?: SelectSubset<T, as_tm_tasksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_tm_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_tm_tasksUpdateManyArgs>(
      args: SelectSubset<T, as_tm_tasksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_tm_tasks.
     * @param {as_tm_tasksUpsertArgs} args - Arguments to update or create a As_tm_tasks.
     * @example
     * // Update or create a As_tm_tasks
     * const as_tm_tasks = await prisma.as_tm_tasks.upsert({
     *   create: {
     *     // ... data to create a As_tm_tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_tm_tasks we want to update
     *   }
     * })
     */
    upsert<T extends as_tm_tasksUpsertArgs>(
      args: SelectSubset<T, as_tm_tasksUpsertArgs<ExtArgs>>
    ): Prisma__as_tm_tasksClient<
      $Result.GetResult<Prisma.$as_tm_tasksPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_tm_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksCountArgs} args - Arguments to filter As_tm_tasks to count.
     * @example
     * // Count the number of As_tm_tasks
     * const count = await prisma.as_tm_tasks.count({
     *   where: {
     *     // ... the filter for the As_tm_tasks we want to count
     *   }
     * })
     */
    count<T extends as_tm_tasksCountArgs>(
      args?: Subset<T, as_tm_tasksCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_tm_tasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_tm_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_tm_tasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_tm_tasksAggregateArgs>(
      args: Subset<T, As_tm_tasksAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_tm_tasksAggregateType<T>>

    /**
     * Group by As_tm_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_tm_tasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_tm_tasksGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_tm_tasksGroupByArgs['orderBy'] }
        : { orderBy?: as_tm_tasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_tm_tasksGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_tm_tasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_tm_tasks model
     */
    readonly fields: as_tm_tasksFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_tm_tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_tm_tasksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_tm_tasks model
   */
  interface as_tm_tasksFieldRefs {
    readonly id: FieldRef<'as_tm_tasks', 'Int'>
    readonly user_id: FieldRef<'as_tm_tasks', 'BigInt'>
    readonly type: FieldRef<'as_tm_tasks', 'String'>
    readonly class_identifier: FieldRef<'as_tm_tasks', 'String'>
    readonly attempts: FieldRef<'as_tm_tasks', 'Int'>
    readonly description: FieldRef<'as_tm_tasks', 'String'>
    readonly time_created: FieldRef<'as_tm_tasks', 'DateTime'>
    readonly last_locked_at: FieldRef<'as_tm_tasks', 'BigInt'>
    readonly status: FieldRef<'as_tm_tasks', 'String'>
  }

  // Custom InputTypes
  /**
   * as_tm_tasks findUnique
   */
  export type as_tm_tasksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_tasks to fetch.
     */
    where: as_tm_tasksWhereUniqueInput
  }

  /**
   * as_tm_tasks findUniqueOrThrow
   */
  export type as_tm_tasksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_tasks to fetch.
     */
    where: as_tm_tasksWhereUniqueInput
  }

  /**
   * as_tm_tasks findFirst
   */
  export type as_tm_tasksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_tasks to fetch.
     */
    where?: as_tm_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_tasks to fetch.
     */
    orderBy?: as_tm_tasksOrderByWithRelationInput | as_tm_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_tm_tasks.
     */
    cursor?: as_tm_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_tm_tasks.
     */
    distinct?: As_tm_tasksScalarFieldEnum | As_tm_tasksScalarFieldEnum[]
  }

  /**
   * as_tm_tasks findFirstOrThrow
   */
  export type as_tm_tasksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_tasks to fetch.
     */
    where?: as_tm_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_tasks to fetch.
     */
    orderBy?: as_tm_tasksOrderByWithRelationInput | as_tm_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_tm_tasks.
     */
    cursor?: as_tm_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_tm_tasks.
     */
    distinct?: As_tm_tasksScalarFieldEnum | As_tm_tasksScalarFieldEnum[]
  }

  /**
   * as_tm_tasks findMany
   */
  export type as_tm_tasksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter, which as_tm_tasks to fetch.
     */
    where?: as_tm_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_tm_tasks to fetch.
     */
    orderBy?: as_tm_tasksOrderByWithRelationInput | as_tm_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_tm_tasks.
     */
    cursor?: as_tm_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_tm_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_tm_tasks.
     */
    skip?: number
    distinct?: As_tm_tasksScalarFieldEnum | As_tm_tasksScalarFieldEnum[]
  }

  /**
   * as_tm_tasks create
   */
  export type as_tm_tasksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * The data needed to create a as_tm_tasks.
     */
    data: XOR<as_tm_tasksCreateInput, as_tm_tasksUncheckedCreateInput>
  }

  /**
   * as_tm_tasks createMany
   */
  export type as_tm_tasksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_tm_tasks.
     */
    data: as_tm_tasksCreateManyInput | as_tm_tasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_tm_tasks update
   */
  export type as_tm_tasksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * The data needed to update a as_tm_tasks.
     */
    data: XOR<as_tm_tasksUpdateInput, as_tm_tasksUncheckedUpdateInput>
    /**
     * Choose, which as_tm_tasks to update.
     */
    where: as_tm_tasksWhereUniqueInput
  }

  /**
   * as_tm_tasks updateMany
   */
  export type as_tm_tasksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_tm_tasks.
     */
    data: XOR<as_tm_tasksUpdateManyMutationInput, as_tm_tasksUncheckedUpdateManyInput>
    /**
     * Filter which as_tm_tasks to update
     */
    where?: as_tm_tasksWhereInput
    /**
     * Limit how many as_tm_tasks to update.
     */
    limit?: number
  }

  /**
   * as_tm_tasks upsert
   */
  export type as_tm_tasksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * The filter to search for the as_tm_tasks to update in case it exists.
     */
    where: as_tm_tasksWhereUniqueInput
    /**
     * In case the as_tm_tasks found by the `where` argument doesn't exist, create a new as_tm_tasks with this data.
     */
    create: XOR<as_tm_tasksCreateInput, as_tm_tasksUncheckedCreateInput>
    /**
     * In case the as_tm_tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_tm_tasksUpdateInput, as_tm_tasksUncheckedUpdateInput>
  }

  /**
   * as_tm_tasks delete
   */
  export type as_tm_tasksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
    /**
     * Filter which as_tm_tasks to delete.
     */
    where: as_tm_tasksWhereUniqueInput
  }

  /**
   * as_tm_tasks deleteMany
   */
  export type as_tm_tasksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_tm_tasks to delete
     */
    where?: as_tm_tasksWhereInput
    /**
     * Limit how many as_tm_tasks to delete.
     */
    limit?: number
  }

  /**
   * as_tm_tasks without action
   */
  export type as_tm_tasksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_tm_tasks
     */
    select?: as_tm_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_tm_tasks
     */
    omit?: as_tm_tasksOmit<ExtArgs> | null
  }

  /**
   * Model as_usermeta
   */

  export type AggregateAs_usermeta = {
    _count: As_usermetaCountAggregateOutputType | null
    _avg: As_usermetaAvgAggregateOutputType | null
    _sum: As_usermetaSumAggregateOutputType | null
    _min: As_usermetaMinAggregateOutputType | null
    _max: As_usermetaMaxAggregateOutputType | null
  }

  export type As_usermetaAvgAggregateOutputType = {
    umeta_id: number | null
    user_id: number | null
  }

  export type As_usermetaSumAggregateOutputType = {
    umeta_id: bigint | null
    user_id: bigint | null
  }

  export type As_usermetaMinAggregateOutputType = {
    umeta_id: bigint | null
    user_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_usermetaMaxAggregateOutputType = {
    umeta_id: bigint | null
    user_id: bigint | null
    meta_key: string | null
    meta_value: string | null
  }

  export type As_usermetaCountAggregateOutputType = {
    umeta_id: number
    user_id: number
    meta_key: number
    meta_value: number
    _all: number
  }

  export type As_usermetaAvgAggregateInputType = {
    umeta_id?: true
    user_id?: true
  }

  export type As_usermetaSumAggregateInputType = {
    umeta_id?: true
    user_id?: true
  }

  export type As_usermetaMinAggregateInputType = {
    umeta_id?: true
    user_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_usermetaMaxAggregateInputType = {
    umeta_id?: true
    user_id?: true
    meta_key?: true
    meta_value?: true
  }

  export type As_usermetaCountAggregateInputType = {
    umeta_id?: true
    user_id?: true
    meta_key?: true
    meta_value?: true
    _all?: true
  }

  export type As_usermetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_usermeta to aggregate.
     */
    where?: as_usermetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_usermetas to fetch.
     */
    orderBy?: as_usermetaOrderByWithRelationInput | as_usermetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_usermetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_usermetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_usermetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_usermetas
     */
    _count?: true | As_usermetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_usermetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_usermetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_usermetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_usermetaMaxAggregateInputType
  }

  export type GetAs_usermetaAggregateType<T extends As_usermetaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_usermeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_usermeta[P]>
      : GetScalarType<T[P], AggregateAs_usermeta[P]>
  }

  export type as_usermetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_usermetaWhereInput
    orderBy?: as_usermetaOrderByWithAggregationInput | as_usermetaOrderByWithAggregationInput[]
    by: As_usermetaScalarFieldEnum[] | As_usermetaScalarFieldEnum
    having?: as_usermetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_usermetaCountAggregateInputType | true
    _avg?: As_usermetaAvgAggregateInputType
    _sum?: As_usermetaSumAggregateInputType
    _min?: As_usermetaMinAggregateInputType
    _max?: As_usermetaMaxAggregateInputType
  }

  export type As_usermetaGroupByOutputType = {
    umeta_id: bigint
    user_id: bigint
    meta_key: string | null
    meta_value: string | null
    _count: As_usermetaCountAggregateOutputType | null
    _avg: As_usermetaAvgAggregateOutputType | null
    _sum: As_usermetaSumAggregateOutputType | null
    _min: As_usermetaMinAggregateOutputType | null
    _max: As_usermetaMaxAggregateOutputType | null
  }

  type GetAs_usermetaGroupByPayload<T extends as_usermetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_usermetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_usermetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_usermetaGroupByOutputType[P]>
          : GetScalarType<T[P], As_usermetaGroupByOutputType[P]>
      }
    >
  >

  export type as_usermetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      umeta_id?: boolean
      user_id?: boolean
      meta_key?: boolean
      meta_value?: boolean
    },
    ExtArgs['result']['as_usermeta']
  >

  export type as_usermetaSelectScalar = {
    umeta_id?: boolean
    user_id?: boolean
    meta_key?: boolean
    meta_value?: boolean
  }

  export type as_usermetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'umeta_id' | 'user_id' | 'meta_key' | 'meta_value',
      ExtArgs['result']['as_usermeta']
    >

  export type $as_usermetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_usermeta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        umeta_id: bigint
        user_id: bigint
        meta_key: string | null
        meta_value: string | null
      },
      ExtArgs['result']['as_usermeta']
    >
    composites: {}
  }

  type as_usermetaGetPayload<S extends boolean | null | undefined | as_usermetaDefaultArgs> =
    $Result.GetResult<Prisma.$as_usermetaPayload, S>

  type as_usermetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<as_usermetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: As_usermetaCountAggregateInputType | true
    }

  export interface as_usermetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_usermeta']
      meta: { name: 'as_usermeta' }
    }
    /**
     * Find zero or one As_usermeta that matches the filter.
     * @param {as_usermetaFindUniqueArgs} args - Arguments to find a As_usermeta
     * @example
     * // Get one As_usermeta
     * const as_usermeta = await prisma.as_usermeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_usermetaFindUniqueArgs>(
      args: SelectSubset<T, as_usermetaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<
        Prisma.$as_usermetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_usermeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_usermetaFindUniqueOrThrowArgs} args - Arguments to find a As_usermeta
     * @example
     * // Get one As_usermeta
     * const as_usermeta = await prisma.as_usermeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_usermetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_usermetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<
        Prisma.$as_usermetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_usermeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaFindFirstArgs} args - Arguments to find a As_usermeta
     * @example
     * // Get one As_usermeta
     * const as_usermeta = await prisma.as_usermeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_usermetaFindFirstArgs>(
      args?: SelectSubset<T, as_usermetaFindFirstArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<
        Prisma.$as_usermetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_usermeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaFindFirstOrThrowArgs} args - Arguments to find a As_usermeta
     * @example
     * // Get one As_usermeta
     * const as_usermeta = await prisma.as_usermeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_usermetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_usermetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<
        Prisma.$as_usermetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_usermetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_usermetas
     * const as_usermetas = await prisma.as_usermeta.findMany()
     *
     * // Get first 10 As_usermetas
     * const as_usermetas = await prisma.as_usermeta.findMany({ take: 10 })
     *
     * // Only select the `umeta_id`
     * const as_usermetaWithUmeta_idOnly = await prisma.as_usermeta.findMany({ select: { umeta_id: true } })
     *
     */
    findMany<T extends as_usermetaFindManyArgs>(
      args?: SelectSubset<T, as_usermetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_usermetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_usermeta.
     * @param {as_usermetaCreateArgs} args - Arguments to create a As_usermeta.
     * @example
     * // Create one As_usermeta
     * const As_usermeta = await prisma.as_usermeta.create({
     *   data: {
     *     // ... data to create a As_usermeta
     *   }
     * })
     *
     */
    create<T extends as_usermetaCreateArgs>(
      args: SelectSubset<T, as_usermetaCreateArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<Prisma.$as_usermetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_usermetas.
     * @param {as_usermetaCreateManyArgs} args - Arguments to create many As_usermetas.
     * @example
     * // Create many As_usermetas
     * const as_usermeta = await prisma.as_usermeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_usermetaCreateManyArgs>(
      args?: SelectSubset<T, as_usermetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_usermeta.
     * @param {as_usermetaDeleteArgs} args - Arguments to delete one As_usermeta.
     * @example
     * // Delete one As_usermeta
     * const As_usermeta = await prisma.as_usermeta.delete({
     *   where: {
     *     // ... filter to delete one As_usermeta
     *   }
     * })
     *
     */
    delete<T extends as_usermetaDeleteArgs>(
      args: SelectSubset<T, as_usermetaDeleteArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<Prisma.$as_usermetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_usermeta.
     * @param {as_usermetaUpdateArgs} args - Arguments to update one As_usermeta.
     * @example
     * // Update one As_usermeta
     * const as_usermeta = await prisma.as_usermeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_usermetaUpdateArgs>(
      args: SelectSubset<T, as_usermetaUpdateArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<Prisma.$as_usermetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_usermetas.
     * @param {as_usermetaDeleteManyArgs} args - Arguments to filter As_usermetas to delete.
     * @example
     * // Delete a few As_usermetas
     * const { count } = await prisma.as_usermeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_usermetaDeleteManyArgs>(
      args?: SelectSubset<T, as_usermetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_usermetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_usermetas
     * const as_usermeta = await prisma.as_usermeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_usermetaUpdateManyArgs>(
      args: SelectSubset<T, as_usermetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_usermeta.
     * @param {as_usermetaUpsertArgs} args - Arguments to update or create a As_usermeta.
     * @example
     * // Update or create a As_usermeta
     * const as_usermeta = await prisma.as_usermeta.upsert({
     *   create: {
     *     // ... data to create a As_usermeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_usermeta we want to update
     *   }
     * })
     */
    upsert<T extends as_usermetaUpsertArgs>(
      args: SelectSubset<T, as_usermetaUpsertArgs<ExtArgs>>
    ): Prisma__as_usermetaClient<
      $Result.GetResult<Prisma.$as_usermetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_usermetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaCountArgs} args - Arguments to filter As_usermetas to count.
     * @example
     * // Count the number of As_usermetas
     * const count = await prisma.as_usermeta.count({
     *   where: {
     *     // ... the filter for the As_usermetas we want to count
     *   }
     * })
     */
    count<T extends as_usermetaCountArgs>(
      args?: Subset<T, as_usermetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_usermetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_usermeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_usermetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_usermetaAggregateArgs>(
      args: Subset<T, As_usermetaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_usermetaAggregateType<T>>

    /**
     * Group by As_usermeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usermetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_usermetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_usermetaGroupByArgs['orderBy'] }
        : { orderBy?: as_usermetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_usermetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_usermetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_usermeta model
     */
    readonly fields: as_usermetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_usermeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_usermetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_usermeta model
   */
  interface as_usermetaFieldRefs {
    readonly umeta_id: FieldRef<'as_usermeta', 'BigInt'>
    readonly user_id: FieldRef<'as_usermeta', 'BigInt'>
    readonly meta_key: FieldRef<'as_usermeta', 'String'>
    readonly meta_value: FieldRef<'as_usermeta', 'String'>
  }

  // Custom InputTypes
  /**
   * as_usermeta findUnique
   */
  export type as_usermetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter, which as_usermeta to fetch.
     */
    where: as_usermetaWhereUniqueInput
  }

  /**
   * as_usermeta findUniqueOrThrow
   */
  export type as_usermetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter, which as_usermeta to fetch.
     */
    where: as_usermetaWhereUniqueInput
  }

  /**
   * as_usermeta findFirst
   */
  export type as_usermetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter, which as_usermeta to fetch.
     */
    where?: as_usermetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_usermetas to fetch.
     */
    orderBy?: as_usermetaOrderByWithRelationInput | as_usermetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_usermetas.
     */
    cursor?: as_usermetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_usermetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_usermetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_usermetas.
     */
    distinct?: As_usermetaScalarFieldEnum | As_usermetaScalarFieldEnum[]
  }

  /**
   * as_usermeta findFirstOrThrow
   */
  export type as_usermetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter, which as_usermeta to fetch.
     */
    where?: as_usermetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_usermetas to fetch.
     */
    orderBy?: as_usermetaOrderByWithRelationInput | as_usermetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_usermetas.
     */
    cursor?: as_usermetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_usermetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_usermetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_usermetas.
     */
    distinct?: As_usermetaScalarFieldEnum | As_usermetaScalarFieldEnum[]
  }

  /**
   * as_usermeta findMany
   */
  export type as_usermetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter, which as_usermetas to fetch.
     */
    where?: as_usermetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_usermetas to fetch.
     */
    orderBy?: as_usermetaOrderByWithRelationInput | as_usermetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_usermetas.
     */
    cursor?: as_usermetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_usermetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_usermetas.
     */
    skip?: number
    distinct?: As_usermetaScalarFieldEnum | As_usermetaScalarFieldEnum[]
  }

  /**
   * as_usermeta create
   */
  export type as_usermetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_usermeta.
     */
    data?: XOR<as_usermetaCreateInput, as_usermetaUncheckedCreateInput>
  }

  /**
   * as_usermeta createMany
   */
  export type as_usermetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_usermetas.
     */
    data: as_usermetaCreateManyInput | as_usermetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_usermeta update
   */
  export type as_usermetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_usermeta.
     */
    data: XOR<as_usermetaUpdateInput, as_usermetaUncheckedUpdateInput>
    /**
     * Choose, which as_usermeta to update.
     */
    where: as_usermetaWhereUniqueInput
  }

  /**
   * as_usermeta updateMany
   */
  export type as_usermetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_usermetas.
     */
    data: XOR<as_usermetaUpdateManyMutationInput, as_usermetaUncheckedUpdateManyInput>
    /**
     * Filter which as_usermetas to update
     */
    where?: as_usermetaWhereInput
    /**
     * Limit how many as_usermetas to update.
     */
    limit?: number
  }

  /**
   * as_usermeta upsert
   */
  export type as_usermetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_usermeta to update in case it exists.
     */
    where: as_usermetaWhereUniqueInput
    /**
     * In case the as_usermeta found by the `where` argument doesn't exist, create a new as_usermeta with this data.
     */
    create: XOR<as_usermetaCreateInput, as_usermetaUncheckedCreateInput>
    /**
     * In case the as_usermeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_usermetaUpdateInput, as_usermetaUncheckedUpdateInput>
  }

  /**
   * as_usermeta delete
   */
  export type as_usermetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
    /**
     * Filter which as_usermeta to delete.
     */
    where: as_usermetaWhereUniqueInput
  }

  /**
   * as_usermeta deleteMany
   */
  export type as_usermetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_usermetas to delete
     */
    where?: as_usermetaWhereInput
    /**
     * Limit how many as_usermetas to delete.
     */
    limit?: number
  }

  /**
   * as_usermeta without action
   */
  export type as_usermetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_usermeta
     */
    select?: as_usermetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_usermeta
     */
    omit?: as_usermetaOmit<ExtArgs> | null
  }

  /**
   * Model as_users
   */

  export type AggregateAs_users = {
    _count: As_usersCountAggregateOutputType | null
    _avg: As_usersAvgAggregateOutputType | null
    _sum: As_usersSumAggregateOutputType | null
    _min: As_usersMinAggregateOutputType | null
    _max: As_usersMaxAggregateOutputType | null
  }

  export type As_usersAvgAggregateOutputType = {
    ID: number | null
    user_status: number | null
  }

  export type As_usersSumAggregateOutputType = {
    ID: bigint | null
    user_status: number | null
  }

  export type As_usersMinAggregateOutputType = {
    ID: bigint | null
    user_login: string | null
    user_pass: string | null
    user_nicename: string | null
    user_email: string | null
    user_url: string | null
    user_registered: Date | null
    user_activation_key: string | null
    user_status: number | null
    display_name: string | null
  }

  export type As_usersMaxAggregateOutputType = {
    ID: bigint | null
    user_login: string | null
    user_pass: string | null
    user_nicename: string | null
    user_email: string | null
    user_url: string | null
    user_registered: Date | null
    user_activation_key: string | null
    user_status: number | null
    display_name: string | null
  }

  export type As_usersCountAggregateOutputType = {
    ID: number
    user_login: number
    user_pass: number
    user_nicename: number
    user_email: number
    user_url: number
    user_registered: number
    user_activation_key: number
    user_status: number
    display_name: number
    _all: number
  }

  export type As_usersAvgAggregateInputType = {
    ID?: true
    user_status?: true
  }

  export type As_usersSumAggregateInputType = {
    ID?: true
    user_status?: true
  }

  export type As_usersMinAggregateInputType = {
    ID?: true
    user_login?: true
    user_pass?: true
    user_nicename?: true
    user_email?: true
    user_url?: true
    user_registered?: true
    user_activation_key?: true
    user_status?: true
    display_name?: true
  }

  export type As_usersMaxAggregateInputType = {
    ID?: true
    user_login?: true
    user_pass?: true
    user_nicename?: true
    user_email?: true
    user_url?: true
    user_registered?: true
    user_activation_key?: true
    user_status?: true
    display_name?: true
  }

  export type As_usersCountAggregateInputType = {
    ID?: true
    user_login?: true
    user_pass?: true
    user_nicename?: true
    user_email?: true
    user_url?: true
    user_registered?: true
    user_activation_key?: true
    user_status?: true
    display_name?: true
    _all?: true
  }

  export type As_usersAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_users to aggregate.
     */
    where?: as_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_users to fetch.
     */
    orderBy?: as_usersOrderByWithRelationInput | as_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_users
     */
    _count?: true | As_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_usersMaxAggregateInputType
  }

  export type GetAs_usersAggregateType<T extends As_usersAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_users[P]>
      : GetScalarType<T[P], AggregateAs_users[P]>
  }

  export type as_usersGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_usersWhereInput
    orderBy?: as_usersOrderByWithAggregationInput | as_usersOrderByWithAggregationInput[]
    by: As_usersScalarFieldEnum[] | As_usersScalarFieldEnum
    having?: as_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_usersCountAggregateInputType | true
    _avg?: As_usersAvgAggregateInputType
    _sum?: As_usersSumAggregateInputType
    _min?: As_usersMinAggregateInputType
    _max?: As_usersMaxAggregateInputType
  }

  export type As_usersGroupByOutputType = {
    ID: bigint
    user_login: string
    user_pass: string
    user_nicename: string
    user_email: string
    user_url: string
    user_registered: Date
    user_activation_key: string
    user_status: number
    display_name: string
    _count: As_usersCountAggregateOutputType | null
    _avg: As_usersAvgAggregateOutputType | null
    _sum: As_usersSumAggregateOutputType | null
    _min: As_usersMinAggregateOutputType | null
    _max: As_usersMaxAggregateOutputType | null
  }

  type GetAs_usersGroupByPayload<T extends as_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_usersGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_usersGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_usersGroupByOutputType[P]>
          : GetScalarType<T[P], As_usersGroupByOutputType[P]>
      }
    >
  >

  export type as_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        ID?: boolean
        user_login?: boolean
        user_pass?: boolean
        user_nicename?: boolean
        user_email?: boolean
        user_url?: boolean
        user_registered?: boolean
        user_activation_key?: boolean
        user_status?: boolean
        display_name?: boolean
      },
      ExtArgs['result']['as_users']
    >

  export type as_usersSelectScalar = {
    ID?: boolean
    user_login?: boolean
    user_pass?: boolean
    user_nicename?: boolean
    user_email?: boolean
    user_url?: boolean
    user_registered?: boolean
    user_activation_key?: boolean
    user_status?: boolean
    display_name?: boolean
  }

  export type as_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'ID'
      | 'user_login'
      | 'user_pass'
      | 'user_nicename'
      | 'user_email'
      | 'user_url'
      | 'user_registered'
      | 'user_activation_key'
      | 'user_status'
      | 'display_name',
      ExtArgs['result']['as_users']
    >

  export type $as_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'as_users'
      objects: {}
      scalars: $Extensions.GetPayloadResult<
        {
          ID: bigint
          user_login: string
          user_pass: string
          user_nicename: string
          user_email: string
          user_url: string
          user_registered: Date
          user_activation_key: string
          user_status: number
          display_name: string
        },
        ExtArgs['result']['as_users']
      >
      composites: {}
    }

  type as_usersGetPayload<S extends boolean | null | undefined | as_usersDefaultArgs> =
    $Result.GetResult<Prisma.$as_usersPayload, S>

  type as_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    as_usersFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: As_usersCountAggregateInputType | true
  }

  export interface as_usersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['as_users']; meta: { name: 'as_users' } }
    /**
     * Find zero or one As_users that matches the filter.
     * @param {as_usersFindUniqueArgs} args - Arguments to find a As_users
     * @example
     * // Get one As_users
     * const as_users = await prisma.as_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_usersFindUniqueArgs>(
      args: SelectSubset<T, as_usersFindUniqueArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<
        Prisma.$as_usersPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_usersFindUniqueOrThrowArgs} args - Arguments to find a As_users
     * @example
     * // Get one As_users
     * const as_users = await prisma.as_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_usersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<
        Prisma.$as_usersPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersFindFirstArgs} args - Arguments to find a As_users
     * @example
     * // Get one As_users
     * const as_users = await prisma.as_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_usersFindFirstArgs>(
      args?: SelectSubset<T, as_usersFindFirstArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersFindFirstOrThrowArgs} args - Arguments to find a As_users
     * @example
     * // Get one As_users
     * const as_users = await prisma.as_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_users
     * const as_users = await prisma.as_users.findMany()
     *
     * // Get first 10 As_users
     * const as_users = await prisma.as_users.findMany({ take: 10 })
     *
     * // Only select the `ID`
     * const as_usersWithIDOnly = await prisma.as_users.findMany({ select: { ID: true } })
     *
     */
    findMany<T extends as_usersFindManyArgs>(
      args?: SelectSubset<T, as_usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_users.
     * @param {as_usersCreateArgs} args - Arguments to create a As_users.
     * @example
     * // Create one As_users
     * const As_users = await prisma.as_users.create({
     *   data: {
     *     // ... data to create a As_users
     *   }
     * })
     *
     */
    create<T extends as_usersCreateArgs>(
      args: SelectSubset<T, as_usersCreateArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_users.
     * @param {as_usersCreateManyArgs} args - Arguments to create many As_users.
     * @example
     * // Create many As_users
     * const as_users = await prisma.as_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_usersCreateManyArgs>(
      args?: SelectSubset<T, as_usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_users.
     * @param {as_usersDeleteArgs} args - Arguments to delete one As_users.
     * @example
     * // Delete one As_users
     * const As_users = await prisma.as_users.delete({
     *   where: {
     *     // ... filter to delete one As_users
     *   }
     * })
     *
     */
    delete<T extends as_usersDeleteArgs>(
      args: SelectSubset<T, as_usersDeleteArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_users.
     * @param {as_usersUpdateArgs} args - Arguments to update one As_users.
     * @example
     * // Update one As_users
     * const as_users = await prisma.as_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_usersUpdateArgs>(
      args: SelectSubset<T, as_usersUpdateArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_users.
     * @param {as_usersDeleteManyArgs} args - Arguments to filter As_users to delete.
     * @example
     * // Delete a few As_users
     * const { count } = await prisma.as_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_usersDeleteManyArgs>(
      args?: SelectSubset<T, as_usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_users
     * const as_users = await prisma.as_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_usersUpdateManyArgs>(
      args: SelectSubset<T, as_usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_users.
     * @param {as_usersUpsertArgs} args - Arguments to update or create a As_users.
     * @example
     * // Update or create a As_users
     * const as_users = await prisma.as_users.upsert({
     *   create: {
     *     // ... data to create a As_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_users we want to update
     *   }
     * })
     */
    upsert<T extends as_usersUpsertArgs>(
      args: SelectSubset<T, as_usersUpsertArgs<ExtArgs>>
    ): Prisma__as_usersClient<
      $Result.GetResult<Prisma.$as_usersPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersCountArgs} args - Arguments to filter As_users to count.
     * @example
     * // Count the number of As_users
     * const count = await prisma.as_users.count({
     *   where: {
     *     // ... the filter for the As_users we want to count
     *   }
     * })
     */
    count<T extends as_usersCountArgs>(
      args?: Subset<T, as_usersCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_usersAggregateArgs>(
      args: Subset<T, As_usersAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_usersAggregateType<T>>

    /**
     * Group by As_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_usersGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_usersGroupByArgs['orderBy'] }
        : { orderBy?: as_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_usersGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAs_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_users model
     */
    readonly fields: as_usersFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_usersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_users model
   */
  interface as_usersFieldRefs {
    readonly ID: FieldRef<'as_users', 'BigInt'>
    readonly user_login: FieldRef<'as_users', 'String'>
    readonly user_pass: FieldRef<'as_users', 'String'>
    readonly user_nicename: FieldRef<'as_users', 'String'>
    readonly user_email: FieldRef<'as_users', 'String'>
    readonly user_url: FieldRef<'as_users', 'String'>
    readonly user_registered: FieldRef<'as_users', 'DateTime'>
    readonly user_activation_key: FieldRef<'as_users', 'String'>
    readonly user_status: FieldRef<'as_users', 'Int'>
    readonly display_name: FieldRef<'as_users', 'String'>
  }

  // Custom InputTypes
  /**
   * as_users findUnique
   */
  export type as_usersFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter, which as_users to fetch.
     */
    where: as_usersWhereUniqueInput
  }

  /**
   * as_users findUniqueOrThrow
   */
  export type as_usersFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter, which as_users to fetch.
     */
    where: as_usersWhereUniqueInput
  }

  /**
   * as_users findFirst
   */
  export type as_usersFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter, which as_users to fetch.
     */
    where?: as_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_users to fetch.
     */
    orderBy?: as_usersOrderByWithRelationInput | as_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_users.
     */
    cursor?: as_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_users.
     */
    distinct?: As_usersScalarFieldEnum | As_usersScalarFieldEnum[]
  }

  /**
   * as_users findFirstOrThrow
   */
  export type as_usersFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter, which as_users to fetch.
     */
    where?: as_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_users to fetch.
     */
    orderBy?: as_usersOrderByWithRelationInput | as_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_users.
     */
    cursor?: as_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_users.
     */
    distinct?: As_usersScalarFieldEnum | As_usersScalarFieldEnum[]
  }

  /**
   * as_users findMany
   */
  export type as_usersFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter, which as_users to fetch.
     */
    where?: as_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_users to fetch.
     */
    orderBy?: as_usersOrderByWithRelationInput | as_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_users.
     */
    cursor?: as_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_users.
     */
    skip?: number
    distinct?: As_usersScalarFieldEnum | As_usersScalarFieldEnum[]
  }

  /**
   * as_users create
   */
  export type as_usersCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a as_users.
     */
    data?: XOR<as_usersCreateInput, as_usersUncheckedCreateInput>
  }

  /**
   * as_users createMany
   */
  export type as_usersCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_users.
     */
    data: as_usersCreateManyInput | as_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_users update
   */
  export type as_usersUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a as_users.
     */
    data: XOR<as_usersUpdateInput, as_usersUncheckedUpdateInput>
    /**
     * Choose, which as_users to update.
     */
    where: as_usersWhereUniqueInput
  }

  /**
   * as_users updateMany
   */
  export type as_usersUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_users.
     */
    data: XOR<as_usersUpdateManyMutationInput, as_usersUncheckedUpdateManyInput>
    /**
     * Filter which as_users to update
     */
    where?: as_usersWhereInput
    /**
     * Limit how many as_users to update.
     */
    limit?: number
  }

  /**
   * as_users upsert
   */
  export type as_usersUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the as_users to update in case it exists.
     */
    where: as_usersWhereUniqueInput
    /**
     * In case the as_users found by the `where` argument doesn't exist, create a new as_users with this data.
     */
    create: XOR<as_usersCreateInput, as_usersUncheckedCreateInput>
    /**
     * In case the as_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_usersUpdateInput, as_usersUncheckedUpdateInput>
  }

  /**
   * as_users delete
   */
  export type as_usersDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
    /**
     * Filter which as_users to delete.
     */
    where: as_usersWhereUniqueInput
  }

  /**
   * as_users deleteMany
   */
  export type as_usersDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_users to delete
     */
    where?: as_usersWhereInput
    /**
     * Limit how many as_users to delete.
     */
    limit?: number
  }

  /**
   * as_users without action
   */
  export type as_usersDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_users
     */
    select?: as_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_users
     */
    omit?: as_usersOmit<ExtArgs> | null
  }

  /**
   * Model as_wpo_404_detector
   */

  export type AggregateAs_wpo_404_detector = {
    _count: As_wpo_404_detectorCountAggregateOutputType | null
    _avg: As_wpo_404_detectorAvgAggregateOutputType | null
    _sum: As_wpo_404_detectorSumAggregateOutputType | null
    _min: As_wpo_404_detectorMinAggregateOutputType | null
    _max: As_wpo_404_detectorMaxAggregateOutputType | null
  }

  export type As_wpo_404_detectorAvgAggregateOutputType = {
    ID: number | null
    request_timestamp: number | null
    request_count: number | null
  }

  export type As_wpo_404_detectorSumAggregateOutputType = {
    ID: number | null
    request_timestamp: bigint | null
    request_count: bigint | null
  }

  export type As_wpo_404_detectorMinAggregateOutputType = {
    ID: number | null
    url: string | null
    request_timestamp: bigint | null
    request_count: bigint | null
    referrer: string | null
  }

  export type As_wpo_404_detectorMaxAggregateOutputType = {
    ID: number | null
    url: string | null
    request_timestamp: bigint | null
    request_count: bigint | null
    referrer: string | null
  }

  export type As_wpo_404_detectorCountAggregateOutputType = {
    ID: number
    url: number
    request_timestamp: number
    request_count: number
    referrer: number
    _all: number
  }

  export type As_wpo_404_detectorAvgAggregateInputType = {
    ID?: true
    request_timestamp?: true
    request_count?: true
  }

  export type As_wpo_404_detectorSumAggregateInputType = {
    ID?: true
    request_timestamp?: true
    request_count?: true
  }

  export type As_wpo_404_detectorMinAggregateInputType = {
    ID?: true
    url?: true
    request_timestamp?: true
    request_count?: true
    referrer?: true
  }

  export type As_wpo_404_detectorMaxAggregateInputType = {
    ID?: true
    url?: true
    request_timestamp?: true
    request_count?: true
    referrer?: true
  }

  export type As_wpo_404_detectorCountAggregateInputType = {
    ID?: true
    url?: true
    request_timestamp?: true
    request_count?: true
    referrer?: true
    _all?: true
  }

  export type As_wpo_404_detectorAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_wpo_404_detector to aggregate.
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_wpo_404_detectors to fetch.
     */
    orderBy?:
      | as_wpo_404_detectorOrderByWithRelationInput
      | as_wpo_404_detectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_wpo_404_detectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_wpo_404_detectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_wpo_404_detectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_wpo_404_detectors
     */
    _count?: true | As_wpo_404_detectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_wpo_404_detectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_wpo_404_detectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_wpo_404_detectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_wpo_404_detectorMaxAggregateInputType
  }

  export type GetAs_wpo_404_detectorAggregateType<T extends As_wpo_404_detectorAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_wpo_404_detector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_wpo_404_detector[P]>
      : GetScalarType<T[P], AggregateAs_wpo_404_detector[P]>
  }

  export type as_wpo_404_detectorGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_wpo_404_detectorWhereInput
    orderBy?:
      | as_wpo_404_detectorOrderByWithAggregationInput
      | as_wpo_404_detectorOrderByWithAggregationInput[]
    by: As_wpo_404_detectorScalarFieldEnum[] | As_wpo_404_detectorScalarFieldEnum
    having?: as_wpo_404_detectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_wpo_404_detectorCountAggregateInputType | true
    _avg?: As_wpo_404_detectorAvgAggregateInputType
    _sum?: As_wpo_404_detectorSumAggregateInputType
    _min?: As_wpo_404_detectorMinAggregateInputType
    _max?: As_wpo_404_detectorMaxAggregateInputType
  }

  export type As_wpo_404_detectorGroupByOutputType = {
    ID: number
    url: string
    request_timestamp: bigint
    request_count: bigint
    referrer: string
    _count: As_wpo_404_detectorCountAggregateOutputType | null
    _avg: As_wpo_404_detectorAvgAggregateOutputType | null
    _sum: As_wpo_404_detectorSumAggregateOutputType | null
    _min: As_wpo_404_detectorMinAggregateOutputType | null
    _max: As_wpo_404_detectorMaxAggregateOutputType | null
  }

  type GetAs_wpo_404_detectorGroupByPayload<T extends as_wpo_404_detectorGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_wpo_404_detectorGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_wpo_404_detectorGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_wpo_404_detectorGroupByOutputType[P]>
            : GetScalarType<T[P], As_wpo_404_detectorGroupByOutputType[P]>
        }
      >
    >

  export type as_wpo_404_detectorSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      ID?: boolean
      url?: boolean
      request_timestamp?: boolean
      request_count?: boolean
      referrer?: boolean
    },
    ExtArgs['result']['as_wpo_404_detector']
  >

  export type as_wpo_404_detectorSelectScalar = {
    ID?: boolean
    url?: boolean
    request_timestamp?: boolean
    request_count?: boolean
    referrer?: boolean
  }

  export type as_wpo_404_detectorOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'ID' | 'url' | 'request_timestamp' | 'request_count' | 'referrer',
    ExtArgs['result']['as_wpo_404_detector']
  >

  export type $as_wpo_404_detectorPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_wpo_404_detector'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        ID: number
        url: string
        request_timestamp: bigint
        request_count: bigint
        referrer: string
      },
      ExtArgs['result']['as_wpo_404_detector']
    >
    composites: {}
  }

  type as_wpo_404_detectorGetPayload<
    S extends boolean | null | undefined | as_wpo_404_detectorDefaultArgs
  > = $Result.GetResult<Prisma.$as_wpo_404_detectorPayload, S>

  type as_wpo_404_detectorCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_wpo_404_detectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_wpo_404_detectorCountAggregateInputType | true
  }

  export interface as_wpo_404_detectorDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_wpo_404_detector']
      meta: { name: 'as_wpo_404_detector' }
    }
    /**
     * Find zero or one As_wpo_404_detector that matches the filter.
     * @param {as_wpo_404_detectorFindUniqueArgs} args - Arguments to find a As_wpo_404_detector
     * @example
     * // Get one As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_wpo_404_detectorFindUniqueArgs>(
      args: SelectSubset<T, as_wpo_404_detectorFindUniqueArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_wpo_404_detector that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_wpo_404_detectorFindUniqueOrThrowArgs} args - Arguments to find a As_wpo_404_detector
     * @example
     * // Get one As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_wpo_404_detectorFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_wpo_404_detectorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_wpo_404_detector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorFindFirstArgs} args - Arguments to find a As_wpo_404_detector
     * @example
     * // Get one As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_wpo_404_detectorFindFirstArgs>(
      args?: SelectSubset<T, as_wpo_404_detectorFindFirstArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_wpo_404_detector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorFindFirstOrThrowArgs} args - Arguments to find a As_wpo_404_detector
     * @example
     * // Get one As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_wpo_404_detectorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_wpo_404_detectorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_wpo_404_detectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_wpo_404_detectors
     * const as_wpo_404_detectors = await prisma.as_wpo_404_detector.findMany()
     *
     * // Get first 10 As_wpo_404_detectors
     * const as_wpo_404_detectors = await prisma.as_wpo_404_detector.findMany({ take: 10 })
     *
     * // Only select the `ID`
     * const as_wpo_404_detectorWithIDOnly = await prisma.as_wpo_404_detector.findMany({ select: { ID: true } })
     *
     */
    findMany<T extends as_wpo_404_detectorFindManyArgs>(
      args?: SelectSubset<T, as_wpo_404_detectorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_wpo_404_detector.
     * @param {as_wpo_404_detectorCreateArgs} args - Arguments to create a As_wpo_404_detector.
     * @example
     * // Create one As_wpo_404_detector
     * const As_wpo_404_detector = await prisma.as_wpo_404_detector.create({
     *   data: {
     *     // ... data to create a As_wpo_404_detector
     *   }
     * })
     *
     */
    create<T extends as_wpo_404_detectorCreateArgs>(
      args: SelectSubset<T, as_wpo_404_detectorCreateArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_wpo_404_detectors.
     * @param {as_wpo_404_detectorCreateManyArgs} args - Arguments to create many As_wpo_404_detectors.
     * @example
     * // Create many As_wpo_404_detectors
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_wpo_404_detectorCreateManyArgs>(
      args?: SelectSubset<T, as_wpo_404_detectorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_wpo_404_detector.
     * @param {as_wpo_404_detectorDeleteArgs} args - Arguments to delete one As_wpo_404_detector.
     * @example
     * // Delete one As_wpo_404_detector
     * const As_wpo_404_detector = await prisma.as_wpo_404_detector.delete({
     *   where: {
     *     // ... filter to delete one As_wpo_404_detector
     *   }
     * })
     *
     */
    delete<T extends as_wpo_404_detectorDeleteArgs>(
      args: SelectSubset<T, as_wpo_404_detectorDeleteArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_wpo_404_detector.
     * @param {as_wpo_404_detectorUpdateArgs} args - Arguments to update one As_wpo_404_detector.
     * @example
     * // Update one As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_wpo_404_detectorUpdateArgs>(
      args: SelectSubset<T, as_wpo_404_detectorUpdateArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_wpo_404_detectors.
     * @param {as_wpo_404_detectorDeleteManyArgs} args - Arguments to filter As_wpo_404_detectors to delete.
     * @example
     * // Delete a few As_wpo_404_detectors
     * const { count } = await prisma.as_wpo_404_detector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_wpo_404_detectorDeleteManyArgs>(
      args?: SelectSubset<T, as_wpo_404_detectorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_wpo_404_detectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_wpo_404_detectors
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_wpo_404_detectorUpdateManyArgs>(
      args: SelectSubset<T, as_wpo_404_detectorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_wpo_404_detector.
     * @param {as_wpo_404_detectorUpsertArgs} args - Arguments to update or create a As_wpo_404_detector.
     * @example
     * // Update or create a As_wpo_404_detector
     * const as_wpo_404_detector = await prisma.as_wpo_404_detector.upsert({
     *   create: {
     *     // ... data to create a As_wpo_404_detector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_wpo_404_detector we want to update
     *   }
     * })
     */
    upsert<T extends as_wpo_404_detectorUpsertArgs>(
      args: SelectSubset<T, as_wpo_404_detectorUpsertArgs<ExtArgs>>
    ): Prisma__as_wpo_404_detectorClient<
      $Result.GetResult<
        Prisma.$as_wpo_404_detectorPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_wpo_404_detectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorCountArgs} args - Arguments to filter As_wpo_404_detectors to count.
     * @example
     * // Count the number of As_wpo_404_detectors
     * const count = await prisma.as_wpo_404_detector.count({
     *   where: {
     *     // ... the filter for the As_wpo_404_detectors we want to count
     *   }
     * })
     */
    count<T extends as_wpo_404_detectorCountArgs>(
      args?: Subset<T, as_wpo_404_detectorCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_wpo_404_detectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_wpo_404_detector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_wpo_404_detectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_wpo_404_detectorAggregateArgs>(
      args: Subset<T, As_wpo_404_detectorAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_wpo_404_detectorAggregateType<T>>

    /**
     * Group by As_wpo_404_detector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_wpo_404_detectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_wpo_404_detectorGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_wpo_404_detectorGroupByArgs['orderBy'] }
        : { orderBy?: as_wpo_404_detectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_wpo_404_detectorGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_wpo_404_detectorGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_wpo_404_detector model
     */
    readonly fields: as_wpo_404_detectorFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_wpo_404_detector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_wpo_404_detectorClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_wpo_404_detector model
   */
  interface as_wpo_404_detectorFieldRefs {
    readonly ID: FieldRef<'as_wpo_404_detector', 'Int'>
    readonly url: FieldRef<'as_wpo_404_detector', 'String'>
    readonly request_timestamp: FieldRef<'as_wpo_404_detector', 'BigInt'>
    readonly request_count: FieldRef<'as_wpo_404_detector', 'BigInt'>
    readonly referrer: FieldRef<'as_wpo_404_detector', 'String'>
  }

  // Custom InputTypes
  /**
   * as_wpo_404_detector findUnique
   */
  export type as_wpo_404_detectorFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter, which as_wpo_404_detector to fetch.
     */
    where: as_wpo_404_detectorWhereUniqueInput
  }

  /**
   * as_wpo_404_detector findUniqueOrThrow
   */
  export type as_wpo_404_detectorFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter, which as_wpo_404_detector to fetch.
     */
    where: as_wpo_404_detectorWhereUniqueInput
  }

  /**
   * as_wpo_404_detector findFirst
   */
  export type as_wpo_404_detectorFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter, which as_wpo_404_detector to fetch.
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_wpo_404_detectors to fetch.
     */
    orderBy?:
      | as_wpo_404_detectorOrderByWithRelationInput
      | as_wpo_404_detectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_wpo_404_detectors.
     */
    cursor?: as_wpo_404_detectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_wpo_404_detectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_wpo_404_detectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_wpo_404_detectors.
     */
    distinct?: As_wpo_404_detectorScalarFieldEnum | As_wpo_404_detectorScalarFieldEnum[]
  }

  /**
   * as_wpo_404_detector findFirstOrThrow
   */
  export type as_wpo_404_detectorFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter, which as_wpo_404_detector to fetch.
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_wpo_404_detectors to fetch.
     */
    orderBy?:
      | as_wpo_404_detectorOrderByWithRelationInput
      | as_wpo_404_detectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_wpo_404_detectors.
     */
    cursor?: as_wpo_404_detectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_wpo_404_detectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_wpo_404_detectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_wpo_404_detectors.
     */
    distinct?: As_wpo_404_detectorScalarFieldEnum | As_wpo_404_detectorScalarFieldEnum[]
  }

  /**
   * as_wpo_404_detector findMany
   */
  export type as_wpo_404_detectorFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter, which as_wpo_404_detectors to fetch.
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_wpo_404_detectors to fetch.
     */
    orderBy?:
      | as_wpo_404_detectorOrderByWithRelationInput
      | as_wpo_404_detectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_wpo_404_detectors.
     */
    cursor?: as_wpo_404_detectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_wpo_404_detectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_wpo_404_detectors.
     */
    skip?: number
    distinct?: As_wpo_404_detectorScalarFieldEnum | As_wpo_404_detectorScalarFieldEnum[]
  }

  /**
   * as_wpo_404_detector create
   */
  export type as_wpo_404_detectorCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * The data needed to create a as_wpo_404_detector.
     */
    data: XOR<as_wpo_404_detectorCreateInput, as_wpo_404_detectorUncheckedCreateInput>
  }

  /**
   * as_wpo_404_detector createMany
   */
  export type as_wpo_404_detectorCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_wpo_404_detectors.
     */
    data: as_wpo_404_detectorCreateManyInput | as_wpo_404_detectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_wpo_404_detector update
   */
  export type as_wpo_404_detectorUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * The data needed to update a as_wpo_404_detector.
     */
    data: XOR<as_wpo_404_detectorUpdateInput, as_wpo_404_detectorUncheckedUpdateInput>
    /**
     * Choose, which as_wpo_404_detector to update.
     */
    where: as_wpo_404_detectorWhereUniqueInput
  }

  /**
   * as_wpo_404_detector updateMany
   */
  export type as_wpo_404_detectorUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_wpo_404_detectors.
     */
    data: XOR<
      as_wpo_404_detectorUpdateManyMutationInput,
      as_wpo_404_detectorUncheckedUpdateManyInput
    >
    /**
     * Filter which as_wpo_404_detectors to update
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * Limit how many as_wpo_404_detectors to update.
     */
    limit?: number
  }

  /**
   * as_wpo_404_detector upsert
   */
  export type as_wpo_404_detectorUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * The filter to search for the as_wpo_404_detector to update in case it exists.
     */
    where: as_wpo_404_detectorWhereUniqueInput
    /**
     * In case the as_wpo_404_detector found by the `where` argument doesn't exist, create a new as_wpo_404_detector with this data.
     */
    create: XOR<as_wpo_404_detectorCreateInput, as_wpo_404_detectorUncheckedCreateInput>
    /**
     * In case the as_wpo_404_detector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_wpo_404_detectorUpdateInput, as_wpo_404_detectorUncheckedUpdateInput>
  }

  /**
   * as_wpo_404_detector delete
   */
  export type as_wpo_404_detectorDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
    /**
     * Filter which as_wpo_404_detector to delete.
     */
    where: as_wpo_404_detectorWhereUniqueInput
  }

  /**
   * as_wpo_404_detector deleteMany
   */
  export type as_wpo_404_detectorDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_wpo_404_detectors to delete
     */
    where?: as_wpo_404_detectorWhereInput
    /**
     * Limit how many as_wpo_404_detectors to delete.
     */
    limit?: number
  }

  /**
   * as_wpo_404_detector without action
   */
  export type as_wpo_404_detectorDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_wpo_404_detector
     */
    select?: as_wpo_404_detectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_wpo_404_detector
     */
    omit?: as_wpo_404_detectorOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_indexable
   */

  export type AggregateAs_yoast_indexable = {
    _count: As_yoast_indexableCountAggregateOutputType | null
    _avg: As_yoast_indexableAvgAggregateOutputType | null
    _sum: As_yoast_indexableSumAggregateOutputType | null
    _min: As_yoast_indexableMinAggregateOutputType | null
    _max: As_yoast_indexableMaxAggregateOutputType | null
  }

  export type As_yoast_indexableAvgAggregateOutputType = {
    id: number | null
    object_id: number | null
    author_id: number | null
    post_parent: number | null
    number_of_pages: number | null
    primary_focus_keyword_score: number | null
    readability_score: number | null
    link_count: number | null
    incoming_link_count: number | null
    prominent_words_version: number | null
    blog_id: number | null
    estimated_reading_time_minutes: number | null
    version: number | null
    inclusive_language_score: number | null
  }

  export type As_yoast_indexableSumAggregateOutputType = {
    id: number | null
    object_id: bigint | null
    author_id: bigint | null
    post_parent: bigint | null
    number_of_pages: number | null
    primary_focus_keyword_score: number | null
    readability_score: number | null
    link_count: number | null
    incoming_link_count: number | null
    prominent_words_version: number | null
    blog_id: bigint | null
    estimated_reading_time_minutes: number | null
    version: number | null
    inclusive_language_score: number | null
  }

  export type As_yoast_indexableMinAggregateOutputType = {
    id: number | null
    permalink: string | null
    permalink_hash: string | null
    object_id: bigint | null
    object_type: string | null
    object_sub_type: string | null
    author_id: bigint | null
    post_parent: bigint | null
    title: string | null
    description: string | null
    breadcrumb_title: string | null
    post_status: string | null
    is_public: boolean | null
    is_protected: boolean | null
    has_public_posts: boolean | null
    number_of_pages: number | null
    canonical: string | null
    primary_focus_keyword: string | null
    primary_focus_keyword_score: number | null
    readability_score: number | null
    is_cornerstone: boolean | null
    is_robots_noindex: boolean | null
    is_robots_nofollow: boolean | null
    is_robots_noarchive: boolean | null
    is_robots_noimageindex: boolean | null
    is_robots_nosnippet: boolean | null
    twitter_title: string | null
    twitter_image: string | null
    twitter_description: string | null
    twitter_image_id: string | null
    twitter_image_source: string | null
    open_graph_title: string | null
    open_graph_description: string | null
    open_graph_image: string | null
    open_graph_image_id: string | null
    open_graph_image_source: string | null
    open_graph_image_meta: string | null
    link_count: number | null
    incoming_link_count: number | null
    prominent_words_version: number | null
    created_at: Date | null
    updated_at: Date | null
    blog_id: bigint | null
    language: string | null
    region: string | null
    schema_page_type: string | null
    schema_article_type: string | null
    has_ancestors: boolean | null
    estimated_reading_time_minutes: number | null
    version: number | null
    object_last_modified: Date | null
    object_published_at: Date | null
    inclusive_language_score: number | null
  }

  export type As_yoast_indexableMaxAggregateOutputType = {
    id: number | null
    permalink: string | null
    permalink_hash: string | null
    object_id: bigint | null
    object_type: string | null
    object_sub_type: string | null
    author_id: bigint | null
    post_parent: bigint | null
    title: string | null
    description: string | null
    breadcrumb_title: string | null
    post_status: string | null
    is_public: boolean | null
    is_protected: boolean | null
    has_public_posts: boolean | null
    number_of_pages: number | null
    canonical: string | null
    primary_focus_keyword: string | null
    primary_focus_keyword_score: number | null
    readability_score: number | null
    is_cornerstone: boolean | null
    is_robots_noindex: boolean | null
    is_robots_nofollow: boolean | null
    is_robots_noarchive: boolean | null
    is_robots_noimageindex: boolean | null
    is_robots_nosnippet: boolean | null
    twitter_title: string | null
    twitter_image: string | null
    twitter_description: string | null
    twitter_image_id: string | null
    twitter_image_source: string | null
    open_graph_title: string | null
    open_graph_description: string | null
    open_graph_image: string | null
    open_graph_image_id: string | null
    open_graph_image_source: string | null
    open_graph_image_meta: string | null
    link_count: number | null
    incoming_link_count: number | null
    prominent_words_version: number | null
    created_at: Date | null
    updated_at: Date | null
    blog_id: bigint | null
    language: string | null
    region: string | null
    schema_page_type: string | null
    schema_article_type: string | null
    has_ancestors: boolean | null
    estimated_reading_time_minutes: number | null
    version: number | null
    object_last_modified: Date | null
    object_published_at: Date | null
    inclusive_language_score: number | null
  }

  export type As_yoast_indexableCountAggregateOutputType = {
    id: number
    permalink: number
    permalink_hash: number
    object_id: number
    object_type: number
    object_sub_type: number
    author_id: number
    post_parent: number
    title: number
    description: number
    breadcrumb_title: number
    post_status: number
    is_public: number
    is_protected: number
    has_public_posts: number
    number_of_pages: number
    canonical: number
    primary_focus_keyword: number
    primary_focus_keyword_score: number
    readability_score: number
    is_cornerstone: number
    is_robots_noindex: number
    is_robots_nofollow: number
    is_robots_noarchive: number
    is_robots_noimageindex: number
    is_robots_nosnippet: number
    twitter_title: number
    twitter_image: number
    twitter_description: number
    twitter_image_id: number
    twitter_image_source: number
    open_graph_title: number
    open_graph_description: number
    open_graph_image: number
    open_graph_image_id: number
    open_graph_image_source: number
    open_graph_image_meta: number
    link_count: number
    incoming_link_count: number
    prominent_words_version: number
    created_at: number
    updated_at: number
    blog_id: number
    language: number
    region: number
    schema_page_type: number
    schema_article_type: number
    has_ancestors: number
    estimated_reading_time_minutes: number
    version: number
    object_last_modified: number
    object_published_at: number
    inclusive_language_score: number
    _all: number
  }

  export type As_yoast_indexableAvgAggregateInputType = {
    id?: true
    object_id?: true
    author_id?: true
    post_parent?: true
    number_of_pages?: true
    primary_focus_keyword_score?: true
    readability_score?: true
    link_count?: true
    incoming_link_count?: true
    prominent_words_version?: true
    blog_id?: true
    estimated_reading_time_minutes?: true
    version?: true
    inclusive_language_score?: true
  }

  export type As_yoast_indexableSumAggregateInputType = {
    id?: true
    object_id?: true
    author_id?: true
    post_parent?: true
    number_of_pages?: true
    primary_focus_keyword_score?: true
    readability_score?: true
    link_count?: true
    incoming_link_count?: true
    prominent_words_version?: true
    blog_id?: true
    estimated_reading_time_minutes?: true
    version?: true
    inclusive_language_score?: true
  }

  export type As_yoast_indexableMinAggregateInputType = {
    id?: true
    permalink?: true
    permalink_hash?: true
    object_id?: true
    object_type?: true
    object_sub_type?: true
    author_id?: true
    post_parent?: true
    title?: true
    description?: true
    breadcrumb_title?: true
    post_status?: true
    is_public?: true
    is_protected?: true
    has_public_posts?: true
    number_of_pages?: true
    canonical?: true
    primary_focus_keyword?: true
    primary_focus_keyword_score?: true
    readability_score?: true
    is_cornerstone?: true
    is_robots_noindex?: true
    is_robots_nofollow?: true
    is_robots_noarchive?: true
    is_robots_noimageindex?: true
    is_robots_nosnippet?: true
    twitter_title?: true
    twitter_image?: true
    twitter_description?: true
    twitter_image_id?: true
    twitter_image_source?: true
    open_graph_title?: true
    open_graph_description?: true
    open_graph_image?: true
    open_graph_image_id?: true
    open_graph_image_source?: true
    open_graph_image_meta?: true
    link_count?: true
    incoming_link_count?: true
    prominent_words_version?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
    language?: true
    region?: true
    schema_page_type?: true
    schema_article_type?: true
    has_ancestors?: true
    estimated_reading_time_minutes?: true
    version?: true
    object_last_modified?: true
    object_published_at?: true
    inclusive_language_score?: true
  }

  export type As_yoast_indexableMaxAggregateInputType = {
    id?: true
    permalink?: true
    permalink_hash?: true
    object_id?: true
    object_type?: true
    object_sub_type?: true
    author_id?: true
    post_parent?: true
    title?: true
    description?: true
    breadcrumb_title?: true
    post_status?: true
    is_public?: true
    is_protected?: true
    has_public_posts?: true
    number_of_pages?: true
    canonical?: true
    primary_focus_keyword?: true
    primary_focus_keyword_score?: true
    readability_score?: true
    is_cornerstone?: true
    is_robots_noindex?: true
    is_robots_nofollow?: true
    is_robots_noarchive?: true
    is_robots_noimageindex?: true
    is_robots_nosnippet?: true
    twitter_title?: true
    twitter_image?: true
    twitter_description?: true
    twitter_image_id?: true
    twitter_image_source?: true
    open_graph_title?: true
    open_graph_description?: true
    open_graph_image?: true
    open_graph_image_id?: true
    open_graph_image_source?: true
    open_graph_image_meta?: true
    link_count?: true
    incoming_link_count?: true
    prominent_words_version?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
    language?: true
    region?: true
    schema_page_type?: true
    schema_article_type?: true
    has_ancestors?: true
    estimated_reading_time_minutes?: true
    version?: true
    object_last_modified?: true
    object_published_at?: true
    inclusive_language_score?: true
  }

  export type As_yoast_indexableCountAggregateInputType = {
    id?: true
    permalink?: true
    permalink_hash?: true
    object_id?: true
    object_type?: true
    object_sub_type?: true
    author_id?: true
    post_parent?: true
    title?: true
    description?: true
    breadcrumb_title?: true
    post_status?: true
    is_public?: true
    is_protected?: true
    has_public_posts?: true
    number_of_pages?: true
    canonical?: true
    primary_focus_keyword?: true
    primary_focus_keyword_score?: true
    readability_score?: true
    is_cornerstone?: true
    is_robots_noindex?: true
    is_robots_nofollow?: true
    is_robots_noarchive?: true
    is_robots_noimageindex?: true
    is_robots_nosnippet?: true
    twitter_title?: true
    twitter_image?: true
    twitter_description?: true
    twitter_image_id?: true
    twitter_image_source?: true
    open_graph_title?: true
    open_graph_description?: true
    open_graph_image?: true
    open_graph_image_id?: true
    open_graph_image_source?: true
    open_graph_image_meta?: true
    link_count?: true
    incoming_link_count?: true
    prominent_words_version?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
    language?: true
    region?: true
    schema_page_type?: true
    schema_article_type?: true
    has_ancestors?: true
    estimated_reading_time_minutes?: true
    version?: true
    object_last_modified?: true
    object_published_at?: true
    inclusive_language_score?: true
    _all?: true
  }

  export type As_yoast_indexableAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_indexable to aggregate.
     */
    where?: as_yoast_indexableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexables to fetch.
     */
    orderBy?:
      | as_yoast_indexableOrderByWithRelationInput
      | as_yoast_indexableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_indexableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_indexables
     */
    _count?: true | As_yoast_indexableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_indexableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_indexableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_indexableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_indexableMaxAggregateInputType
  }

  export type GetAs_yoast_indexableAggregateType<T extends As_yoast_indexableAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_yoast_indexable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_yoast_indexable[P]>
      : GetScalarType<T[P], AggregateAs_yoast_indexable[P]>
  }

  export type as_yoast_indexableGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_indexableWhereInput
    orderBy?:
      | as_yoast_indexableOrderByWithAggregationInput
      | as_yoast_indexableOrderByWithAggregationInput[]
    by: As_yoast_indexableScalarFieldEnum[] | As_yoast_indexableScalarFieldEnum
    having?: as_yoast_indexableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_indexableCountAggregateInputType | true
    _avg?: As_yoast_indexableAvgAggregateInputType
    _sum?: As_yoast_indexableSumAggregateInputType
    _min?: As_yoast_indexableMinAggregateInputType
    _max?: As_yoast_indexableMaxAggregateInputType
  }

  export type As_yoast_indexableGroupByOutputType = {
    id: number
    permalink: string | null
    permalink_hash: string | null
    object_id: bigint | null
    object_type: string
    object_sub_type: string | null
    author_id: bigint | null
    post_parent: bigint | null
    title: string | null
    description: string | null
    breadcrumb_title: string | null
    post_status: string | null
    is_public: boolean | null
    is_protected: boolean | null
    has_public_posts: boolean | null
    number_of_pages: number | null
    canonical: string | null
    primary_focus_keyword: string | null
    primary_focus_keyword_score: number | null
    readability_score: number | null
    is_cornerstone: boolean | null
    is_robots_noindex: boolean | null
    is_robots_nofollow: boolean | null
    is_robots_noarchive: boolean | null
    is_robots_noimageindex: boolean | null
    is_robots_nosnippet: boolean | null
    twitter_title: string | null
    twitter_image: string | null
    twitter_description: string | null
    twitter_image_id: string | null
    twitter_image_source: string | null
    open_graph_title: string | null
    open_graph_description: string | null
    open_graph_image: string | null
    open_graph_image_id: string | null
    open_graph_image_source: string | null
    open_graph_image_meta: string | null
    link_count: number | null
    incoming_link_count: number | null
    prominent_words_version: number | null
    created_at: Date | null
    updated_at: Date
    blog_id: bigint
    language: string | null
    region: string | null
    schema_page_type: string | null
    schema_article_type: string | null
    has_ancestors: boolean | null
    estimated_reading_time_minutes: number | null
    version: number | null
    object_last_modified: Date | null
    object_published_at: Date | null
    inclusive_language_score: number | null
    _count: As_yoast_indexableCountAggregateOutputType | null
    _avg: As_yoast_indexableAvgAggregateOutputType | null
    _sum: As_yoast_indexableSumAggregateOutputType | null
    _min: As_yoast_indexableMinAggregateOutputType | null
    _max: As_yoast_indexableMaxAggregateOutputType | null
  }

  type GetAs_yoast_indexableGroupByPayload<T extends as_yoast_indexableGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_yoast_indexableGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_yoast_indexableGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_yoast_indexableGroupByOutputType[P]>
            : GetScalarType<T[P], As_yoast_indexableGroupByOutputType[P]>
        }
      >
    >

  export type as_yoast_indexableSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      permalink?: boolean
      permalink_hash?: boolean
      object_id?: boolean
      object_type?: boolean
      object_sub_type?: boolean
      author_id?: boolean
      post_parent?: boolean
      title?: boolean
      description?: boolean
      breadcrumb_title?: boolean
      post_status?: boolean
      is_public?: boolean
      is_protected?: boolean
      has_public_posts?: boolean
      number_of_pages?: boolean
      canonical?: boolean
      primary_focus_keyword?: boolean
      primary_focus_keyword_score?: boolean
      readability_score?: boolean
      is_cornerstone?: boolean
      is_robots_noindex?: boolean
      is_robots_nofollow?: boolean
      is_robots_noarchive?: boolean
      is_robots_noimageindex?: boolean
      is_robots_nosnippet?: boolean
      twitter_title?: boolean
      twitter_image?: boolean
      twitter_description?: boolean
      twitter_image_id?: boolean
      twitter_image_source?: boolean
      open_graph_title?: boolean
      open_graph_description?: boolean
      open_graph_image?: boolean
      open_graph_image_id?: boolean
      open_graph_image_source?: boolean
      open_graph_image_meta?: boolean
      link_count?: boolean
      incoming_link_count?: boolean
      prominent_words_version?: boolean
      created_at?: boolean
      updated_at?: boolean
      blog_id?: boolean
      language?: boolean
      region?: boolean
      schema_page_type?: boolean
      schema_article_type?: boolean
      has_ancestors?: boolean
      estimated_reading_time_minutes?: boolean
      version?: boolean
      object_last_modified?: boolean
      object_published_at?: boolean
      inclusive_language_score?: boolean
    },
    ExtArgs['result']['as_yoast_indexable']
  >

  export type as_yoast_indexableSelectScalar = {
    id?: boolean
    permalink?: boolean
    permalink_hash?: boolean
    object_id?: boolean
    object_type?: boolean
    object_sub_type?: boolean
    author_id?: boolean
    post_parent?: boolean
    title?: boolean
    description?: boolean
    breadcrumb_title?: boolean
    post_status?: boolean
    is_public?: boolean
    is_protected?: boolean
    has_public_posts?: boolean
    number_of_pages?: boolean
    canonical?: boolean
    primary_focus_keyword?: boolean
    primary_focus_keyword_score?: boolean
    readability_score?: boolean
    is_cornerstone?: boolean
    is_robots_noindex?: boolean
    is_robots_nofollow?: boolean
    is_robots_noarchive?: boolean
    is_robots_noimageindex?: boolean
    is_robots_nosnippet?: boolean
    twitter_title?: boolean
    twitter_image?: boolean
    twitter_description?: boolean
    twitter_image_id?: boolean
    twitter_image_source?: boolean
    open_graph_title?: boolean
    open_graph_description?: boolean
    open_graph_image?: boolean
    open_graph_image_id?: boolean
    open_graph_image_source?: boolean
    open_graph_image_meta?: boolean
    link_count?: boolean
    incoming_link_count?: boolean
    prominent_words_version?: boolean
    created_at?: boolean
    updated_at?: boolean
    blog_id?: boolean
    language?: boolean
    region?: boolean
    schema_page_type?: boolean
    schema_article_type?: boolean
    has_ancestors?: boolean
    estimated_reading_time_minutes?: boolean
    version?: boolean
    object_last_modified?: boolean
    object_published_at?: boolean
    inclusive_language_score?: boolean
  }

  export type as_yoast_indexableOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'permalink'
    | 'permalink_hash'
    | 'object_id'
    | 'object_type'
    | 'object_sub_type'
    | 'author_id'
    | 'post_parent'
    | 'title'
    | 'description'
    | 'breadcrumb_title'
    | 'post_status'
    | 'is_public'
    | 'is_protected'
    | 'has_public_posts'
    | 'number_of_pages'
    | 'canonical'
    | 'primary_focus_keyword'
    | 'primary_focus_keyword_score'
    | 'readability_score'
    | 'is_cornerstone'
    | 'is_robots_noindex'
    | 'is_robots_nofollow'
    | 'is_robots_noarchive'
    | 'is_robots_noimageindex'
    | 'is_robots_nosnippet'
    | 'twitter_title'
    | 'twitter_image'
    | 'twitter_description'
    | 'twitter_image_id'
    | 'twitter_image_source'
    | 'open_graph_title'
    | 'open_graph_description'
    | 'open_graph_image'
    | 'open_graph_image_id'
    | 'open_graph_image_source'
    | 'open_graph_image_meta'
    | 'link_count'
    | 'incoming_link_count'
    | 'prominent_words_version'
    | 'created_at'
    | 'updated_at'
    | 'blog_id'
    | 'language'
    | 'region'
    | 'schema_page_type'
    | 'schema_article_type'
    | 'has_ancestors'
    | 'estimated_reading_time_minutes'
    | 'version'
    | 'object_last_modified'
    | 'object_published_at'
    | 'inclusive_language_score',
    ExtArgs['result']['as_yoast_indexable']
  >

  export type $as_yoast_indexablePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_indexable'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        permalink: string | null
        permalink_hash: string | null
        object_id: bigint | null
        object_type: string
        object_sub_type: string | null
        author_id: bigint | null
        post_parent: bigint | null
        title: string | null
        description: string | null
        breadcrumb_title: string | null
        post_status: string | null
        is_public: boolean | null
        is_protected: boolean | null
        has_public_posts: boolean | null
        number_of_pages: number | null
        canonical: string | null
        primary_focus_keyword: string | null
        primary_focus_keyword_score: number | null
        readability_score: number | null
        is_cornerstone: boolean | null
        is_robots_noindex: boolean | null
        is_robots_nofollow: boolean | null
        is_robots_noarchive: boolean | null
        is_robots_noimageindex: boolean | null
        is_robots_nosnippet: boolean | null
        twitter_title: string | null
        twitter_image: string | null
        twitter_description: string | null
        twitter_image_id: string | null
        twitter_image_source: string | null
        open_graph_title: string | null
        open_graph_description: string | null
        open_graph_image: string | null
        open_graph_image_id: string | null
        open_graph_image_source: string | null
        open_graph_image_meta: string | null
        link_count: number | null
        incoming_link_count: number | null
        prominent_words_version: number | null
        created_at: Date | null
        updated_at: Date
        blog_id: bigint
        language: string | null
        region: string | null
        schema_page_type: string | null
        schema_article_type: string | null
        has_ancestors: boolean | null
        estimated_reading_time_minutes: number | null
        version: number | null
        object_last_modified: Date | null
        object_published_at: Date | null
        inclusive_language_score: number | null
      },
      ExtArgs['result']['as_yoast_indexable']
    >
    composites: {}
  }

  type as_yoast_indexableGetPayload<
    S extends boolean | null | undefined | as_yoast_indexableDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_indexablePayload, S>

  type as_yoast_indexableCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_indexableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_indexableCountAggregateInputType | true
  }

  export interface as_yoast_indexableDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_indexable']
      meta: { name: 'as_yoast_indexable' }
    }
    /**
     * Find zero or one As_yoast_indexable that matches the filter.
     * @param {as_yoast_indexableFindUniqueArgs} args - Arguments to find a As_yoast_indexable
     * @example
     * // Get one As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_indexableFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_indexableFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexablePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_indexable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_indexableFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_indexable
     * @example
     * // Get one As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_indexableFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_indexableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexablePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_indexable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableFindFirstArgs} args - Arguments to find a As_yoast_indexable
     * @example
     * // Get one As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_indexableFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_indexableFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexablePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_indexable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableFindFirstOrThrowArgs} args - Arguments to find a As_yoast_indexable
     * @example
     * // Get one As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_indexableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_indexableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexablePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_indexables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_indexables
     * const as_yoast_indexables = await prisma.as_yoast_indexable.findMany()
     *
     * // Get first 10 As_yoast_indexables
     * const as_yoast_indexables = await prisma.as_yoast_indexable.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_yoast_indexableWithIdOnly = await prisma.as_yoast_indexable.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_yoast_indexableFindManyArgs>(
      args?: SelectSubset<T, as_yoast_indexableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_yoast_indexablePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_yoast_indexable.
     * @param {as_yoast_indexableCreateArgs} args - Arguments to create a As_yoast_indexable.
     * @example
     * // Create one As_yoast_indexable
     * const As_yoast_indexable = await prisma.as_yoast_indexable.create({
     *   data: {
     *     // ... data to create a As_yoast_indexable
     *   }
     * })
     *
     */
    create<T extends as_yoast_indexableCreateArgs>(
      args: SelectSubset<T, as_yoast_indexableCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<Prisma.$as_yoast_indexablePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_indexables.
     * @param {as_yoast_indexableCreateManyArgs} args - Arguments to create many As_yoast_indexables.
     * @example
     * // Create many As_yoast_indexables
     * const as_yoast_indexable = await prisma.as_yoast_indexable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_indexableCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_indexableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_indexable.
     * @param {as_yoast_indexableDeleteArgs} args - Arguments to delete one As_yoast_indexable.
     * @example
     * // Delete one As_yoast_indexable
     * const As_yoast_indexable = await prisma.as_yoast_indexable.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_indexable
     *   }
     * })
     *
     */
    delete<T extends as_yoast_indexableDeleteArgs>(
      args: SelectSubset<T, as_yoast_indexableDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<Prisma.$as_yoast_indexablePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_indexable.
     * @param {as_yoast_indexableUpdateArgs} args - Arguments to update one As_yoast_indexable.
     * @example
     * // Update one As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_indexableUpdateArgs>(
      args: SelectSubset<T, as_yoast_indexableUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<Prisma.$as_yoast_indexablePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_indexables.
     * @param {as_yoast_indexableDeleteManyArgs} args - Arguments to filter As_yoast_indexables to delete.
     * @example
     * // Delete a few As_yoast_indexables
     * const { count } = await prisma.as_yoast_indexable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_indexableDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_indexableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_indexables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_indexables
     * const as_yoast_indexable = await prisma.as_yoast_indexable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_indexableUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_indexableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_indexable.
     * @param {as_yoast_indexableUpsertArgs} args - Arguments to update or create a As_yoast_indexable.
     * @example
     * // Update or create a As_yoast_indexable
     * const as_yoast_indexable = await prisma.as_yoast_indexable.upsert({
     *   create: {
     *     // ... data to create a As_yoast_indexable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_indexable we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_indexableUpsertArgs>(
      args: SelectSubset<T, as_yoast_indexableUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_indexableClient<
      $Result.GetResult<Prisma.$as_yoast_indexablePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_indexables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableCountArgs} args - Arguments to filter As_yoast_indexables to count.
     * @example
     * // Count the number of As_yoast_indexables
     * const count = await prisma.as_yoast_indexable.count({
     *   where: {
     *     // ... the filter for the As_yoast_indexables we want to count
     *   }
     * })
     */
    count<T extends as_yoast_indexableCountArgs>(
      args?: Subset<T, as_yoast_indexableCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_indexableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_indexable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_indexableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_indexableAggregateArgs>(
      args: Subset<T, As_yoast_indexableAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_indexableAggregateType<T>>

    /**
     * Group by As_yoast_indexable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_indexableGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_indexableGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_indexableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_indexableGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_indexableGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_indexable model
     */
    readonly fields: as_yoast_indexableFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_indexable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_indexableClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_indexable model
   */
  interface as_yoast_indexableFieldRefs {
    readonly id: FieldRef<'as_yoast_indexable', 'Int'>
    readonly permalink: FieldRef<'as_yoast_indexable', 'String'>
    readonly permalink_hash: FieldRef<'as_yoast_indexable', 'String'>
    readonly object_id: FieldRef<'as_yoast_indexable', 'BigInt'>
    readonly object_type: FieldRef<'as_yoast_indexable', 'String'>
    readonly object_sub_type: FieldRef<'as_yoast_indexable', 'String'>
    readonly author_id: FieldRef<'as_yoast_indexable', 'BigInt'>
    readonly post_parent: FieldRef<'as_yoast_indexable', 'BigInt'>
    readonly title: FieldRef<'as_yoast_indexable', 'String'>
    readonly description: FieldRef<'as_yoast_indexable', 'String'>
    readonly breadcrumb_title: FieldRef<'as_yoast_indexable', 'String'>
    readonly post_status: FieldRef<'as_yoast_indexable', 'String'>
    readonly is_public: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_protected: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly has_public_posts: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly number_of_pages: FieldRef<'as_yoast_indexable', 'Int'>
    readonly canonical: FieldRef<'as_yoast_indexable', 'String'>
    readonly primary_focus_keyword: FieldRef<'as_yoast_indexable', 'String'>
    readonly primary_focus_keyword_score: FieldRef<'as_yoast_indexable', 'Int'>
    readonly readability_score: FieldRef<'as_yoast_indexable', 'Int'>
    readonly is_cornerstone: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_robots_noindex: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_robots_nofollow: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_robots_noarchive: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_robots_noimageindex: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly is_robots_nosnippet: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly twitter_title: FieldRef<'as_yoast_indexable', 'String'>
    readonly twitter_image: FieldRef<'as_yoast_indexable', 'String'>
    readonly twitter_description: FieldRef<'as_yoast_indexable', 'String'>
    readonly twitter_image_id: FieldRef<'as_yoast_indexable', 'String'>
    readonly twitter_image_source: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_title: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_description: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_image: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_image_id: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_image_source: FieldRef<'as_yoast_indexable', 'String'>
    readonly open_graph_image_meta: FieldRef<'as_yoast_indexable', 'String'>
    readonly link_count: FieldRef<'as_yoast_indexable', 'Int'>
    readonly incoming_link_count: FieldRef<'as_yoast_indexable', 'Int'>
    readonly prominent_words_version: FieldRef<'as_yoast_indexable', 'Int'>
    readonly created_at: FieldRef<'as_yoast_indexable', 'DateTime'>
    readonly updated_at: FieldRef<'as_yoast_indexable', 'DateTime'>
    readonly blog_id: FieldRef<'as_yoast_indexable', 'BigInt'>
    readonly language: FieldRef<'as_yoast_indexable', 'String'>
    readonly region: FieldRef<'as_yoast_indexable', 'String'>
    readonly schema_page_type: FieldRef<'as_yoast_indexable', 'String'>
    readonly schema_article_type: FieldRef<'as_yoast_indexable', 'String'>
    readonly has_ancestors: FieldRef<'as_yoast_indexable', 'Boolean'>
    readonly estimated_reading_time_minutes: FieldRef<'as_yoast_indexable', 'Int'>
    readonly version: FieldRef<'as_yoast_indexable', 'Int'>
    readonly object_last_modified: FieldRef<'as_yoast_indexable', 'DateTime'>
    readonly object_published_at: FieldRef<'as_yoast_indexable', 'DateTime'>
    readonly inclusive_language_score: FieldRef<'as_yoast_indexable', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_yoast_indexable findUnique
   */
  export type as_yoast_indexableFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable to fetch.
     */
    where: as_yoast_indexableWhereUniqueInput
  }

  /**
   * as_yoast_indexable findUniqueOrThrow
   */
  export type as_yoast_indexableFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable to fetch.
     */
    where: as_yoast_indexableWhereUniqueInput
  }

  /**
   * as_yoast_indexable findFirst
   */
  export type as_yoast_indexableFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable to fetch.
     */
    where?: as_yoast_indexableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexables to fetch.
     */
    orderBy?:
      | as_yoast_indexableOrderByWithRelationInput
      | as_yoast_indexableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_indexables.
     */
    cursor?: as_yoast_indexableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_indexables.
     */
    distinct?: As_yoast_indexableScalarFieldEnum | As_yoast_indexableScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable findFirstOrThrow
   */
  export type as_yoast_indexableFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable to fetch.
     */
    where?: as_yoast_indexableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexables to fetch.
     */
    orderBy?:
      | as_yoast_indexableOrderByWithRelationInput
      | as_yoast_indexableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_indexables.
     */
    cursor?: as_yoast_indexableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_indexables.
     */
    distinct?: As_yoast_indexableScalarFieldEnum | As_yoast_indexableScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable findMany
   */
  export type as_yoast_indexableFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexables to fetch.
     */
    where?: as_yoast_indexableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexables to fetch.
     */
    orderBy?:
      | as_yoast_indexableOrderByWithRelationInput
      | as_yoast_indexableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_indexables.
     */
    cursor?: as_yoast_indexableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexables.
     */
    skip?: number
    distinct?: As_yoast_indexableScalarFieldEnum | As_yoast_indexableScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable create
   */
  export type as_yoast_indexableCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_indexable.
     */
    data: XOR<as_yoast_indexableCreateInput, as_yoast_indexableUncheckedCreateInput>
  }

  /**
   * as_yoast_indexable createMany
   */
  export type as_yoast_indexableCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_indexables.
     */
    data: as_yoast_indexableCreateManyInput | as_yoast_indexableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_indexable update
   */
  export type as_yoast_indexableUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_indexable.
     */
    data: XOR<as_yoast_indexableUpdateInput, as_yoast_indexableUncheckedUpdateInput>
    /**
     * Choose, which as_yoast_indexable to update.
     */
    where: as_yoast_indexableWhereUniqueInput
  }

  /**
   * as_yoast_indexable updateMany
   */
  export type as_yoast_indexableUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_indexables.
     */
    data: XOR<as_yoast_indexableUpdateManyMutationInput, as_yoast_indexableUncheckedUpdateManyInput>
    /**
     * Filter which as_yoast_indexables to update
     */
    where?: as_yoast_indexableWhereInput
    /**
     * Limit how many as_yoast_indexables to update.
     */
    limit?: number
  }

  /**
   * as_yoast_indexable upsert
   */
  export type as_yoast_indexableUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_indexable to update in case it exists.
     */
    where: as_yoast_indexableWhereUniqueInput
    /**
     * In case the as_yoast_indexable found by the `where` argument doesn't exist, create a new as_yoast_indexable with this data.
     */
    create: XOR<as_yoast_indexableCreateInput, as_yoast_indexableUncheckedCreateInput>
    /**
     * In case the as_yoast_indexable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_yoast_indexableUpdateInput, as_yoast_indexableUncheckedUpdateInput>
  }

  /**
   * as_yoast_indexable delete
   */
  export type as_yoast_indexableDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_indexable to delete.
     */
    where: as_yoast_indexableWhereUniqueInput
  }

  /**
   * as_yoast_indexable deleteMany
   */
  export type as_yoast_indexableDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_indexables to delete
     */
    where?: as_yoast_indexableWhereInput
    /**
     * Limit how many as_yoast_indexables to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_indexable without action
   */
  export type as_yoast_indexableDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable
     */
    select?: as_yoast_indexableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable
     */
    omit?: as_yoast_indexableOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_indexable_hierarchy
   */

  export type AggregateAs_yoast_indexable_hierarchy = {
    _count: As_yoast_indexable_hierarchyCountAggregateOutputType | null
    _avg: As_yoast_indexable_hierarchyAvgAggregateOutputType | null
    _sum: As_yoast_indexable_hierarchySumAggregateOutputType | null
    _min: As_yoast_indexable_hierarchyMinAggregateOutputType | null
    _max: As_yoast_indexable_hierarchyMaxAggregateOutputType | null
  }

  export type As_yoast_indexable_hierarchyAvgAggregateOutputType = {
    indexable_id: number | null
    ancestor_id: number | null
    depth: number | null
    blog_id: number | null
  }

  export type As_yoast_indexable_hierarchySumAggregateOutputType = {
    indexable_id: number | null
    ancestor_id: number | null
    depth: number | null
    blog_id: bigint | null
  }

  export type As_yoast_indexable_hierarchyMinAggregateOutputType = {
    indexable_id: number | null
    ancestor_id: number | null
    depth: number | null
    blog_id: bigint | null
  }

  export type As_yoast_indexable_hierarchyMaxAggregateOutputType = {
    indexable_id: number | null
    ancestor_id: number | null
    depth: number | null
    blog_id: bigint | null
  }

  export type As_yoast_indexable_hierarchyCountAggregateOutputType = {
    indexable_id: number
    ancestor_id: number
    depth: number
    blog_id: number
    _all: number
  }

  export type As_yoast_indexable_hierarchyAvgAggregateInputType = {
    indexable_id?: true
    ancestor_id?: true
    depth?: true
    blog_id?: true
  }

  export type As_yoast_indexable_hierarchySumAggregateInputType = {
    indexable_id?: true
    ancestor_id?: true
    depth?: true
    blog_id?: true
  }

  export type As_yoast_indexable_hierarchyMinAggregateInputType = {
    indexable_id?: true
    ancestor_id?: true
    depth?: true
    blog_id?: true
  }

  export type As_yoast_indexable_hierarchyMaxAggregateInputType = {
    indexable_id?: true
    ancestor_id?: true
    depth?: true
    blog_id?: true
  }

  export type As_yoast_indexable_hierarchyCountAggregateInputType = {
    indexable_id?: true
    ancestor_id?: true
    depth?: true
    blog_id?: true
    _all?: true
  }

  export type As_yoast_indexable_hierarchyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_indexable_hierarchy to aggregate.
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexable_hierarchies to fetch.
     */
    orderBy?:
      | as_yoast_indexable_hierarchyOrderByWithRelationInput
      | as_yoast_indexable_hierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_indexable_hierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexable_hierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexable_hierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_indexable_hierarchies
     */
    _count?: true | As_yoast_indexable_hierarchyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_indexable_hierarchyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_indexable_hierarchySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_indexable_hierarchyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_indexable_hierarchyMaxAggregateInputType
  }

  export type GetAs_yoast_indexable_hierarchyAggregateType<
    T extends As_yoast_indexable_hierarchyAggregateArgs
  > = {
    [P in keyof T & keyof AggregateAs_yoast_indexable_hierarchy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_yoast_indexable_hierarchy[P]>
      : GetScalarType<T[P], AggregateAs_yoast_indexable_hierarchy[P]>
  }

  export type as_yoast_indexable_hierarchyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_indexable_hierarchyWhereInput
    orderBy?:
      | as_yoast_indexable_hierarchyOrderByWithAggregationInput
      | as_yoast_indexable_hierarchyOrderByWithAggregationInput[]
    by: As_yoast_indexable_hierarchyScalarFieldEnum[] | As_yoast_indexable_hierarchyScalarFieldEnum
    having?: as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_indexable_hierarchyCountAggregateInputType | true
    _avg?: As_yoast_indexable_hierarchyAvgAggregateInputType
    _sum?: As_yoast_indexable_hierarchySumAggregateInputType
    _min?: As_yoast_indexable_hierarchyMinAggregateInputType
    _max?: As_yoast_indexable_hierarchyMaxAggregateInputType
  }

  export type As_yoast_indexable_hierarchyGroupByOutputType = {
    indexable_id: number
    ancestor_id: number
    depth: number | null
    blog_id: bigint
    _count: As_yoast_indexable_hierarchyCountAggregateOutputType | null
    _avg: As_yoast_indexable_hierarchyAvgAggregateOutputType | null
    _sum: As_yoast_indexable_hierarchySumAggregateOutputType | null
    _min: As_yoast_indexable_hierarchyMinAggregateOutputType | null
    _max: As_yoast_indexable_hierarchyMaxAggregateOutputType | null
  }

  type GetAs_yoast_indexable_hierarchyGroupByPayload<
    T extends as_yoast_indexable_hierarchyGroupByArgs
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<As_yoast_indexable_hierarchyGroupByOutputType, T['by']> & {
        [P in keyof T & keyof As_yoast_indexable_hierarchyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], As_yoast_indexable_hierarchyGroupByOutputType[P]>
          : GetScalarType<T[P], As_yoast_indexable_hierarchyGroupByOutputType[P]>
      }
    >
  >

  export type as_yoast_indexable_hierarchySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      indexable_id?: boolean
      ancestor_id?: boolean
      depth?: boolean
      blog_id?: boolean
    },
    ExtArgs['result']['as_yoast_indexable_hierarchy']
  >

  export type as_yoast_indexable_hierarchySelectScalar = {
    indexable_id?: boolean
    ancestor_id?: boolean
    depth?: boolean
    blog_id?: boolean
  }

  export type as_yoast_indexable_hierarchyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'indexable_id' | 'ancestor_id' | 'depth' | 'blog_id',
    ExtArgs['result']['as_yoast_indexable_hierarchy']
  >

  export type $as_yoast_indexable_hierarchyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_indexable_hierarchy'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        indexable_id: number
        ancestor_id: number
        depth: number | null
        blog_id: bigint
      },
      ExtArgs['result']['as_yoast_indexable_hierarchy']
    >
    composites: {}
  }

  type as_yoast_indexable_hierarchyGetPayload<
    S extends boolean | null | undefined | as_yoast_indexable_hierarchyDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_indexable_hierarchyPayload, S>

  type as_yoast_indexable_hierarchyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_indexable_hierarchyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_indexable_hierarchyCountAggregateInputType | true
  }

  export interface as_yoast_indexable_hierarchyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_indexable_hierarchy']
      meta: { name: 'as_yoast_indexable_hierarchy' }
    }
    /**
     * Find zero or one As_yoast_indexable_hierarchy that matches the filter.
     * @param {as_yoast_indexable_hierarchyFindUniqueArgs} args - Arguments to find a As_yoast_indexable_hierarchy
     * @example
     * // Get one As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_indexable_hierarchyFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_indexable_hierarchy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_indexable_hierarchyFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_indexable_hierarchy
     * @example
     * // Get one As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_indexable_hierarchyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_indexable_hierarchy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyFindFirstArgs} args - Arguments to find a As_yoast_indexable_hierarchy
     * @example
     * // Get one As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_indexable_hierarchyFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_indexable_hierarchyFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_indexable_hierarchy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyFindFirstOrThrowArgs} args - Arguments to find a As_yoast_indexable_hierarchy
     * @example
     * // Get one As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_indexable_hierarchyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_indexable_hierarchyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_indexable_hierarchies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_indexable_hierarchies
     * const as_yoast_indexable_hierarchies = await prisma.as_yoast_indexable_hierarchy.findMany()
     *
     * // Get first 10 As_yoast_indexable_hierarchies
     * const as_yoast_indexable_hierarchies = await prisma.as_yoast_indexable_hierarchy.findMany({ take: 10 })
     *
     * // Only select the `indexable_id`
     * const as_yoast_indexable_hierarchyWithIndexable_idOnly = await prisma.as_yoast_indexable_hierarchy.findMany({ select: { indexable_id: true } })
     *
     */
    findMany<T extends as_yoast_indexable_hierarchyFindManyArgs>(
      args?: SelectSubset<T, as_yoast_indexable_hierarchyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_yoast_indexable_hierarchy.
     * @param {as_yoast_indexable_hierarchyCreateArgs} args - Arguments to create a As_yoast_indexable_hierarchy.
     * @example
     * // Create one As_yoast_indexable_hierarchy
     * const As_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.create({
     *   data: {
     *     // ... data to create a As_yoast_indexable_hierarchy
     *   }
     * })
     *
     */
    create<T extends as_yoast_indexable_hierarchyCreateArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_indexable_hierarchies.
     * @param {as_yoast_indexable_hierarchyCreateManyArgs} args - Arguments to create many As_yoast_indexable_hierarchies.
     * @example
     * // Create many As_yoast_indexable_hierarchies
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_indexable_hierarchyCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_indexable_hierarchyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_indexable_hierarchy.
     * @param {as_yoast_indexable_hierarchyDeleteArgs} args - Arguments to delete one As_yoast_indexable_hierarchy.
     * @example
     * // Delete one As_yoast_indexable_hierarchy
     * const As_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_indexable_hierarchy
     *   }
     * })
     *
     */
    delete<T extends as_yoast_indexable_hierarchyDeleteArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_indexable_hierarchy.
     * @param {as_yoast_indexable_hierarchyUpdateArgs} args - Arguments to update one As_yoast_indexable_hierarchy.
     * @example
     * // Update one As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_indexable_hierarchyUpdateArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_indexable_hierarchies.
     * @param {as_yoast_indexable_hierarchyDeleteManyArgs} args - Arguments to filter As_yoast_indexable_hierarchies to delete.
     * @example
     * // Delete a few As_yoast_indexable_hierarchies
     * const { count } = await prisma.as_yoast_indexable_hierarchy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_indexable_hierarchyDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_indexable_hierarchyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_indexable_hierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_indexable_hierarchies
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_indexable_hierarchyUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_indexable_hierarchy.
     * @param {as_yoast_indexable_hierarchyUpsertArgs} args - Arguments to update or create a As_yoast_indexable_hierarchy.
     * @example
     * // Update or create a As_yoast_indexable_hierarchy
     * const as_yoast_indexable_hierarchy = await prisma.as_yoast_indexable_hierarchy.upsert({
     *   create: {
     *     // ... data to create a As_yoast_indexable_hierarchy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_indexable_hierarchy we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_indexable_hierarchyUpsertArgs>(
      args: SelectSubset<T, as_yoast_indexable_hierarchyUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_indexable_hierarchyClient<
      $Result.GetResult<
        Prisma.$as_yoast_indexable_hierarchyPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_indexable_hierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyCountArgs} args - Arguments to filter As_yoast_indexable_hierarchies to count.
     * @example
     * // Count the number of As_yoast_indexable_hierarchies
     * const count = await prisma.as_yoast_indexable_hierarchy.count({
     *   where: {
     *     // ... the filter for the As_yoast_indexable_hierarchies we want to count
     *   }
     * })
     */
    count<T extends as_yoast_indexable_hierarchyCountArgs>(
      args?: Subset<T, as_yoast_indexable_hierarchyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_indexable_hierarchyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_indexable_hierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_indexable_hierarchyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_indexable_hierarchyAggregateArgs>(
      args: Subset<T, As_yoast_indexable_hierarchyAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_indexable_hierarchyAggregateType<T>>

    /**
     * Group by As_yoast_indexable_hierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_indexable_hierarchyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_indexable_hierarchyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_indexable_hierarchyGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_indexable_hierarchyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_indexable_hierarchyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_indexable_hierarchyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_indexable_hierarchy model
     */
    readonly fields: as_yoast_indexable_hierarchyFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_indexable_hierarchy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_indexable_hierarchyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_indexable_hierarchy model
   */
  interface as_yoast_indexable_hierarchyFieldRefs {
    readonly indexable_id: FieldRef<'as_yoast_indexable_hierarchy', 'Int'>
    readonly ancestor_id: FieldRef<'as_yoast_indexable_hierarchy', 'Int'>
    readonly depth: FieldRef<'as_yoast_indexable_hierarchy', 'Int'>
    readonly blog_id: FieldRef<'as_yoast_indexable_hierarchy', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_yoast_indexable_hierarchy findUnique
   */
  export type as_yoast_indexable_hierarchyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable_hierarchy to fetch.
     */
    where: as_yoast_indexable_hierarchyWhereUniqueInput
  }

  /**
   * as_yoast_indexable_hierarchy findUniqueOrThrow
   */
  export type as_yoast_indexable_hierarchyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable_hierarchy to fetch.
     */
    where: as_yoast_indexable_hierarchyWhereUniqueInput
  }

  /**
   * as_yoast_indexable_hierarchy findFirst
   */
  export type as_yoast_indexable_hierarchyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable_hierarchy to fetch.
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexable_hierarchies to fetch.
     */
    orderBy?:
      | as_yoast_indexable_hierarchyOrderByWithRelationInput
      | as_yoast_indexable_hierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_indexable_hierarchies.
     */
    cursor?: as_yoast_indexable_hierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexable_hierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexable_hierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_indexable_hierarchies.
     */
    distinct?:
      | As_yoast_indexable_hierarchyScalarFieldEnum
      | As_yoast_indexable_hierarchyScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable_hierarchy findFirstOrThrow
   */
  export type as_yoast_indexable_hierarchyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable_hierarchy to fetch.
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexable_hierarchies to fetch.
     */
    orderBy?:
      | as_yoast_indexable_hierarchyOrderByWithRelationInput
      | as_yoast_indexable_hierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_indexable_hierarchies.
     */
    cursor?: as_yoast_indexable_hierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexable_hierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexable_hierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_indexable_hierarchies.
     */
    distinct?:
      | As_yoast_indexable_hierarchyScalarFieldEnum
      | As_yoast_indexable_hierarchyScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable_hierarchy findMany
   */
  export type as_yoast_indexable_hierarchyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_indexable_hierarchies to fetch.
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_indexable_hierarchies to fetch.
     */
    orderBy?:
      | as_yoast_indexable_hierarchyOrderByWithRelationInput
      | as_yoast_indexable_hierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_indexable_hierarchies.
     */
    cursor?: as_yoast_indexable_hierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_indexable_hierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_indexable_hierarchies.
     */
    skip?: number
    distinct?:
      | As_yoast_indexable_hierarchyScalarFieldEnum
      | As_yoast_indexable_hierarchyScalarFieldEnum[]
  }

  /**
   * as_yoast_indexable_hierarchy create
   */
  export type as_yoast_indexable_hierarchyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_indexable_hierarchy.
     */
    data: XOR<
      as_yoast_indexable_hierarchyCreateInput,
      as_yoast_indexable_hierarchyUncheckedCreateInput
    >
  }

  /**
   * as_yoast_indexable_hierarchy createMany
   */
  export type as_yoast_indexable_hierarchyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_indexable_hierarchies.
     */
    data:
      | as_yoast_indexable_hierarchyCreateManyInput
      | as_yoast_indexable_hierarchyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_indexable_hierarchy update
   */
  export type as_yoast_indexable_hierarchyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_indexable_hierarchy.
     */
    data: XOR<
      as_yoast_indexable_hierarchyUpdateInput,
      as_yoast_indexable_hierarchyUncheckedUpdateInput
    >
    /**
     * Choose, which as_yoast_indexable_hierarchy to update.
     */
    where: as_yoast_indexable_hierarchyWhereUniqueInput
  }

  /**
   * as_yoast_indexable_hierarchy updateMany
   */
  export type as_yoast_indexable_hierarchyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_indexable_hierarchies.
     */
    data: XOR<
      as_yoast_indexable_hierarchyUpdateManyMutationInput,
      as_yoast_indexable_hierarchyUncheckedUpdateManyInput
    >
    /**
     * Filter which as_yoast_indexable_hierarchies to update
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * Limit how many as_yoast_indexable_hierarchies to update.
     */
    limit?: number
  }

  /**
   * as_yoast_indexable_hierarchy upsert
   */
  export type as_yoast_indexable_hierarchyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_indexable_hierarchy to update in case it exists.
     */
    where: as_yoast_indexable_hierarchyWhereUniqueInput
    /**
     * In case the as_yoast_indexable_hierarchy found by the `where` argument doesn't exist, create a new as_yoast_indexable_hierarchy with this data.
     */
    create: XOR<
      as_yoast_indexable_hierarchyCreateInput,
      as_yoast_indexable_hierarchyUncheckedCreateInput
    >
    /**
     * In case the as_yoast_indexable_hierarchy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      as_yoast_indexable_hierarchyUpdateInput,
      as_yoast_indexable_hierarchyUncheckedUpdateInput
    >
  }

  /**
   * as_yoast_indexable_hierarchy delete
   */
  export type as_yoast_indexable_hierarchyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_indexable_hierarchy to delete.
     */
    where: as_yoast_indexable_hierarchyWhereUniqueInput
  }

  /**
   * as_yoast_indexable_hierarchy deleteMany
   */
  export type as_yoast_indexable_hierarchyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_indexable_hierarchies to delete
     */
    where?: as_yoast_indexable_hierarchyWhereInput
    /**
     * Limit how many as_yoast_indexable_hierarchies to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_indexable_hierarchy without action
   */
  export type as_yoast_indexable_hierarchyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_indexable_hierarchy
     */
    select?: as_yoast_indexable_hierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_indexable_hierarchy
     */
    omit?: as_yoast_indexable_hierarchyOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_migrations
   */

  export type AggregateAs_yoast_migrations = {
    _count: As_yoast_migrationsCountAggregateOutputType | null
    _avg: As_yoast_migrationsAvgAggregateOutputType | null
    _sum: As_yoast_migrationsSumAggregateOutputType | null
    _min: As_yoast_migrationsMinAggregateOutputType | null
    _max: As_yoast_migrationsMaxAggregateOutputType | null
  }

  export type As_yoast_migrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type As_yoast_migrationsSumAggregateOutputType = {
    id: number | null
  }

  export type As_yoast_migrationsMinAggregateOutputType = {
    id: number | null
    version: string | null
  }

  export type As_yoast_migrationsMaxAggregateOutputType = {
    id: number | null
    version: string | null
  }

  export type As_yoast_migrationsCountAggregateOutputType = {
    id: number
    version: number
    _all: number
  }

  export type As_yoast_migrationsAvgAggregateInputType = {
    id?: true
  }

  export type As_yoast_migrationsSumAggregateInputType = {
    id?: true
  }

  export type As_yoast_migrationsMinAggregateInputType = {
    id?: true
    version?: true
  }

  export type As_yoast_migrationsMaxAggregateInputType = {
    id?: true
    version?: true
  }

  export type As_yoast_migrationsCountAggregateInputType = {
    id?: true
    version?: true
    _all?: true
  }

  export type As_yoast_migrationsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_migrations to aggregate.
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_migrations to fetch.
     */
    orderBy?:
      | as_yoast_migrationsOrderByWithRelationInput
      | as_yoast_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_migrations
     */
    _count?: true | As_yoast_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_migrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_migrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_migrationsMaxAggregateInputType
  }

  export type GetAs_yoast_migrationsAggregateType<T extends As_yoast_migrationsAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_yoast_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_yoast_migrations[P]>
      : GetScalarType<T[P], AggregateAs_yoast_migrations[P]>
  }

  export type as_yoast_migrationsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_migrationsWhereInput
    orderBy?:
      | as_yoast_migrationsOrderByWithAggregationInput
      | as_yoast_migrationsOrderByWithAggregationInput[]
    by: As_yoast_migrationsScalarFieldEnum[] | As_yoast_migrationsScalarFieldEnum
    having?: as_yoast_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_migrationsCountAggregateInputType | true
    _avg?: As_yoast_migrationsAvgAggregateInputType
    _sum?: As_yoast_migrationsSumAggregateInputType
    _min?: As_yoast_migrationsMinAggregateInputType
    _max?: As_yoast_migrationsMaxAggregateInputType
  }

  export type As_yoast_migrationsGroupByOutputType = {
    id: number
    version: string | null
    _count: As_yoast_migrationsCountAggregateOutputType | null
    _avg: As_yoast_migrationsAvgAggregateOutputType | null
    _sum: As_yoast_migrationsSumAggregateOutputType | null
    _min: As_yoast_migrationsMinAggregateOutputType | null
    _max: As_yoast_migrationsMaxAggregateOutputType | null
  }

  type GetAs_yoast_migrationsGroupByPayload<T extends as_yoast_migrationsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_yoast_migrationsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_yoast_migrationsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_yoast_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], As_yoast_migrationsGroupByOutputType[P]>
        }
      >
    >

  export type as_yoast_migrationsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      version?: boolean
    },
    ExtArgs['result']['as_yoast_migrations']
  >

  export type as_yoast_migrationsSelectScalar = {
    id?: boolean
    version?: boolean
  }

  export type as_yoast_migrationsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<'id' | 'version', ExtArgs['result']['as_yoast_migrations']>

  export type $as_yoast_migrationsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_migrations'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        version: string | null
      },
      ExtArgs['result']['as_yoast_migrations']
    >
    composites: {}
  }

  type as_yoast_migrationsGetPayload<
    S extends boolean | null | undefined | as_yoast_migrationsDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_migrationsPayload, S>

  type as_yoast_migrationsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_migrationsCountAggregateInputType | true
  }

  export interface as_yoast_migrationsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_migrations']
      meta: { name: 'as_yoast_migrations' }
    }
    /**
     * Find zero or one As_yoast_migrations that matches the filter.
     * @param {as_yoast_migrationsFindUniqueArgs} args - Arguments to find a As_yoast_migrations
     * @example
     * // Get one As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_migrationsFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_migrationsFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_migrationsFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_migrations
     * @example
     * // Get one As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_migrationsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_migrationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsFindFirstArgs} args - Arguments to find a As_yoast_migrations
     * @example
     * // Get one As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_migrationsFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_migrationsFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsFindFirstOrThrowArgs} args - Arguments to find a As_yoast_migrations
     * @example
     * // Get one As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_migrationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_migrationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findMany()
     *
     * // Get first 10 As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_yoast_migrationsWithIdOnly = await prisma.as_yoast_migrations.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_yoast_migrationsFindManyArgs>(
      args?: SelectSubset<T, as_yoast_migrationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_yoast_migrations.
     * @param {as_yoast_migrationsCreateArgs} args - Arguments to create a As_yoast_migrations.
     * @example
     * // Create one As_yoast_migrations
     * const As_yoast_migrations = await prisma.as_yoast_migrations.create({
     *   data: {
     *     // ... data to create a As_yoast_migrations
     *   }
     * })
     *
     */
    create<T extends as_yoast_migrationsCreateArgs>(
      args: SelectSubset<T, as_yoast_migrationsCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_migrations.
     * @param {as_yoast_migrationsCreateManyArgs} args - Arguments to create many As_yoast_migrations.
     * @example
     * // Create many As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_migrationsCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_migrationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_migrations.
     * @param {as_yoast_migrationsDeleteArgs} args - Arguments to delete one As_yoast_migrations.
     * @example
     * // Delete one As_yoast_migrations
     * const As_yoast_migrations = await prisma.as_yoast_migrations.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_migrations
     *   }
     * })
     *
     */
    delete<T extends as_yoast_migrationsDeleteArgs>(
      args: SelectSubset<T, as_yoast_migrationsDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_migrations.
     * @param {as_yoast_migrationsUpdateArgs} args - Arguments to update one As_yoast_migrations.
     * @example
     * // Update one As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_migrationsUpdateArgs>(
      args: SelectSubset<T, as_yoast_migrationsUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_migrations.
     * @param {as_yoast_migrationsDeleteManyArgs} args - Arguments to filter As_yoast_migrations to delete.
     * @example
     * // Delete a few As_yoast_migrations
     * const { count } = await prisma.as_yoast_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_migrationsDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_migrationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_migrationsUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_migrationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_migrations.
     * @param {as_yoast_migrationsUpsertArgs} args - Arguments to update or create a As_yoast_migrations.
     * @example
     * // Update or create a As_yoast_migrations
     * const as_yoast_migrations = await prisma.as_yoast_migrations.upsert({
     *   create: {
     *     // ... data to create a As_yoast_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_migrations we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_migrationsUpsertArgs>(
      args: SelectSubset<T, as_yoast_migrationsUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_migrationsClient<
      $Result.GetResult<
        Prisma.$as_yoast_migrationsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsCountArgs} args - Arguments to filter As_yoast_migrations to count.
     * @example
     * // Count the number of As_yoast_migrations
     * const count = await prisma.as_yoast_migrations.count({
     *   where: {
     *     // ... the filter for the As_yoast_migrations we want to count
     *   }
     * })
     */
    count<T extends as_yoast_migrationsCountArgs>(
      args?: Subset<T, as_yoast_migrationsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_migrationsAggregateArgs>(
      args: Subset<T, As_yoast_migrationsAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_migrationsAggregateType<T>>

    /**
     * Group by As_yoast_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_migrationsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_migrationsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_migrationsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_migrations model
     */
    readonly fields: as_yoast_migrationsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_migrationsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_migrations model
   */
  interface as_yoast_migrationsFieldRefs {
    readonly id: FieldRef<'as_yoast_migrations', 'Int'>
    readonly version: FieldRef<'as_yoast_migrations', 'String'>
  }

  // Custom InputTypes
  /**
   * as_yoast_migrations findUnique
   */
  export type as_yoast_migrationsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_migrations to fetch.
     */
    where: as_yoast_migrationsWhereUniqueInput
  }

  /**
   * as_yoast_migrations findUniqueOrThrow
   */
  export type as_yoast_migrationsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_migrations to fetch.
     */
    where: as_yoast_migrationsWhereUniqueInput
  }

  /**
   * as_yoast_migrations findFirst
   */
  export type as_yoast_migrationsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_migrations to fetch.
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_migrations to fetch.
     */
    orderBy?:
      | as_yoast_migrationsOrderByWithRelationInput
      | as_yoast_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_migrations.
     */
    cursor?: as_yoast_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_migrations.
     */
    distinct?: As_yoast_migrationsScalarFieldEnum | As_yoast_migrationsScalarFieldEnum[]
  }

  /**
   * as_yoast_migrations findFirstOrThrow
   */
  export type as_yoast_migrationsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_migrations to fetch.
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_migrations to fetch.
     */
    orderBy?:
      | as_yoast_migrationsOrderByWithRelationInput
      | as_yoast_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_migrations.
     */
    cursor?: as_yoast_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_migrations.
     */
    distinct?: As_yoast_migrationsScalarFieldEnum | As_yoast_migrationsScalarFieldEnum[]
  }

  /**
   * as_yoast_migrations findMany
   */
  export type as_yoast_migrationsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_migrations to fetch.
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_migrations to fetch.
     */
    orderBy?:
      | as_yoast_migrationsOrderByWithRelationInput
      | as_yoast_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_migrations.
     */
    cursor?: as_yoast_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_migrations.
     */
    skip?: number
    distinct?: As_yoast_migrationsScalarFieldEnum | As_yoast_migrationsScalarFieldEnum[]
  }

  /**
   * as_yoast_migrations create
   */
  export type as_yoast_migrationsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_migrations.
     */
    data?: XOR<as_yoast_migrationsCreateInput, as_yoast_migrationsUncheckedCreateInput>
  }

  /**
   * as_yoast_migrations createMany
   */
  export type as_yoast_migrationsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_migrations.
     */
    data: as_yoast_migrationsCreateManyInput | as_yoast_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_migrations update
   */
  export type as_yoast_migrationsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_migrations.
     */
    data: XOR<as_yoast_migrationsUpdateInput, as_yoast_migrationsUncheckedUpdateInput>
    /**
     * Choose, which as_yoast_migrations to update.
     */
    where: as_yoast_migrationsWhereUniqueInput
  }

  /**
   * as_yoast_migrations updateMany
   */
  export type as_yoast_migrationsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_migrations.
     */
    data: XOR<
      as_yoast_migrationsUpdateManyMutationInput,
      as_yoast_migrationsUncheckedUpdateManyInput
    >
    /**
     * Filter which as_yoast_migrations to update
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * Limit how many as_yoast_migrations to update.
     */
    limit?: number
  }

  /**
   * as_yoast_migrations upsert
   */
  export type as_yoast_migrationsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_migrations to update in case it exists.
     */
    where: as_yoast_migrationsWhereUniqueInput
    /**
     * In case the as_yoast_migrations found by the `where` argument doesn't exist, create a new as_yoast_migrations with this data.
     */
    create: XOR<as_yoast_migrationsCreateInput, as_yoast_migrationsUncheckedCreateInput>
    /**
     * In case the as_yoast_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_yoast_migrationsUpdateInput, as_yoast_migrationsUncheckedUpdateInput>
  }

  /**
   * as_yoast_migrations delete
   */
  export type as_yoast_migrationsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_migrations to delete.
     */
    where: as_yoast_migrationsWhereUniqueInput
  }

  /**
   * as_yoast_migrations deleteMany
   */
  export type as_yoast_migrationsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_migrations to delete
     */
    where?: as_yoast_migrationsWhereInput
    /**
     * Limit how many as_yoast_migrations to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_migrations without action
   */
  export type as_yoast_migrationsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_migrations
     */
    select?: as_yoast_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_migrations
     */
    omit?: as_yoast_migrationsOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_primary_term
   */

  export type AggregateAs_yoast_primary_term = {
    _count: As_yoast_primary_termCountAggregateOutputType | null
    _avg: As_yoast_primary_termAvgAggregateOutputType | null
    _sum: As_yoast_primary_termSumAggregateOutputType | null
    _min: As_yoast_primary_termMinAggregateOutputType | null
    _max: As_yoast_primary_termMaxAggregateOutputType | null
  }

  export type As_yoast_primary_termAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    term_id: number | null
    blog_id: number | null
  }

  export type As_yoast_primary_termSumAggregateOutputType = {
    id: number | null
    post_id: bigint | null
    term_id: bigint | null
    blog_id: bigint | null
  }

  export type As_yoast_primary_termMinAggregateOutputType = {
    id: number | null
    post_id: bigint | null
    term_id: bigint | null
    taxonomy: string | null
    created_at: Date | null
    updated_at: Date | null
    blog_id: bigint | null
  }

  export type As_yoast_primary_termMaxAggregateOutputType = {
    id: number | null
    post_id: bigint | null
    term_id: bigint | null
    taxonomy: string | null
    created_at: Date | null
    updated_at: Date | null
    blog_id: bigint | null
  }

  export type As_yoast_primary_termCountAggregateOutputType = {
    id: number
    post_id: number
    term_id: number
    taxonomy: number
    created_at: number
    updated_at: number
    blog_id: number
    _all: number
  }

  export type As_yoast_primary_termAvgAggregateInputType = {
    id?: true
    post_id?: true
    term_id?: true
    blog_id?: true
  }

  export type As_yoast_primary_termSumAggregateInputType = {
    id?: true
    post_id?: true
    term_id?: true
    blog_id?: true
  }

  export type As_yoast_primary_termMinAggregateInputType = {
    id?: true
    post_id?: true
    term_id?: true
    taxonomy?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
  }

  export type As_yoast_primary_termMaxAggregateInputType = {
    id?: true
    post_id?: true
    term_id?: true
    taxonomy?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
  }

  export type As_yoast_primary_termCountAggregateInputType = {
    id?: true
    post_id?: true
    term_id?: true
    taxonomy?: true
    created_at?: true
    updated_at?: true
    blog_id?: true
    _all?: true
  }

  export type As_yoast_primary_termAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_primary_term to aggregate.
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_primary_terms to fetch.
     */
    orderBy?:
      | as_yoast_primary_termOrderByWithRelationInput
      | as_yoast_primary_termOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_primary_termWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_primary_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_primary_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_primary_terms
     */
    _count?: true | As_yoast_primary_termCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_primary_termAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_primary_termSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_primary_termMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_primary_termMaxAggregateInputType
  }

  export type GetAs_yoast_primary_termAggregateType<T extends As_yoast_primary_termAggregateArgs> =
    {
      [P in keyof T & keyof AggregateAs_yoast_primary_term]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateAs_yoast_primary_term[P]>
        : GetScalarType<T[P], AggregateAs_yoast_primary_term[P]>
    }

  export type as_yoast_primary_termGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_primary_termWhereInput
    orderBy?:
      | as_yoast_primary_termOrderByWithAggregationInput
      | as_yoast_primary_termOrderByWithAggregationInput[]
    by: As_yoast_primary_termScalarFieldEnum[] | As_yoast_primary_termScalarFieldEnum
    having?: as_yoast_primary_termScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_primary_termCountAggregateInputType | true
    _avg?: As_yoast_primary_termAvgAggregateInputType
    _sum?: As_yoast_primary_termSumAggregateInputType
    _min?: As_yoast_primary_termMinAggregateInputType
    _max?: As_yoast_primary_termMaxAggregateInputType
  }

  export type As_yoast_primary_termGroupByOutputType = {
    id: number
    post_id: bigint | null
    term_id: bigint | null
    taxonomy: string
    created_at: Date | null
    updated_at: Date
    blog_id: bigint
    _count: As_yoast_primary_termCountAggregateOutputType | null
    _avg: As_yoast_primary_termAvgAggregateOutputType | null
    _sum: As_yoast_primary_termSumAggregateOutputType | null
    _min: As_yoast_primary_termMinAggregateOutputType | null
    _max: As_yoast_primary_termMaxAggregateOutputType | null
  }

  type GetAs_yoast_primary_termGroupByPayload<T extends as_yoast_primary_termGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_yoast_primary_termGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_yoast_primary_termGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_yoast_primary_termGroupByOutputType[P]>
            : GetScalarType<T[P], As_yoast_primary_termGroupByOutputType[P]>
        }
      >
    >

  export type as_yoast_primary_termSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      post_id?: boolean
      term_id?: boolean
      taxonomy?: boolean
      created_at?: boolean
      updated_at?: boolean
      blog_id?: boolean
    },
    ExtArgs['result']['as_yoast_primary_term']
  >

  export type as_yoast_primary_termSelectScalar = {
    id?: boolean
    post_id?: boolean
    term_id?: boolean
    taxonomy?: boolean
    created_at?: boolean
    updated_at?: boolean
    blog_id?: boolean
  }

  export type as_yoast_primary_termOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'post_id' | 'term_id' | 'taxonomy' | 'created_at' | 'updated_at' | 'blog_id',
    ExtArgs['result']['as_yoast_primary_term']
  >

  export type $as_yoast_primary_termPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_primary_term'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        post_id: bigint | null
        term_id: bigint | null
        taxonomy: string
        created_at: Date | null
        updated_at: Date
        blog_id: bigint
      },
      ExtArgs['result']['as_yoast_primary_term']
    >
    composites: {}
  }

  type as_yoast_primary_termGetPayload<
    S extends boolean | null | undefined | as_yoast_primary_termDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_primary_termPayload, S>

  type as_yoast_primary_termCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_primary_termFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_primary_termCountAggregateInputType | true
  }

  export interface as_yoast_primary_termDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_primary_term']
      meta: { name: 'as_yoast_primary_term' }
    }
    /**
     * Find zero or one As_yoast_primary_term that matches the filter.
     * @param {as_yoast_primary_termFindUniqueArgs} args - Arguments to find a As_yoast_primary_term
     * @example
     * // Get one As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_primary_termFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_primary_termFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_primary_term that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_primary_termFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_primary_term
     * @example
     * // Get one As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_primary_termFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_primary_termFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_primary_term that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termFindFirstArgs} args - Arguments to find a As_yoast_primary_term
     * @example
     * // Get one As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_primary_termFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_primary_termFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_primary_term that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termFindFirstOrThrowArgs} args - Arguments to find a As_yoast_primary_term
     * @example
     * // Get one As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_primary_termFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_primary_termFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_primary_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_primary_terms
     * const as_yoast_primary_terms = await prisma.as_yoast_primary_term.findMany()
     *
     * // Get first 10 As_yoast_primary_terms
     * const as_yoast_primary_terms = await prisma.as_yoast_primary_term.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_yoast_primary_termWithIdOnly = await prisma.as_yoast_primary_term.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_yoast_primary_termFindManyArgs>(
      args?: SelectSubset<T, as_yoast_primary_termFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_yoast_primary_term.
     * @param {as_yoast_primary_termCreateArgs} args - Arguments to create a As_yoast_primary_term.
     * @example
     * // Create one As_yoast_primary_term
     * const As_yoast_primary_term = await prisma.as_yoast_primary_term.create({
     *   data: {
     *     // ... data to create a As_yoast_primary_term
     *   }
     * })
     *
     */
    create<T extends as_yoast_primary_termCreateArgs>(
      args: SelectSubset<T, as_yoast_primary_termCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_primary_terms.
     * @param {as_yoast_primary_termCreateManyArgs} args - Arguments to create many As_yoast_primary_terms.
     * @example
     * // Create many As_yoast_primary_terms
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_primary_termCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_primary_termCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_primary_term.
     * @param {as_yoast_primary_termDeleteArgs} args - Arguments to delete one As_yoast_primary_term.
     * @example
     * // Delete one As_yoast_primary_term
     * const As_yoast_primary_term = await prisma.as_yoast_primary_term.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_primary_term
     *   }
     * })
     *
     */
    delete<T extends as_yoast_primary_termDeleteArgs>(
      args: SelectSubset<T, as_yoast_primary_termDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_primary_term.
     * @param {as_yoast_primary_termUpdateArgs} args - Arguments to update one As_yoast_primary_term.
     * @example
     * // Update one As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_primary_termUpdateArgs>(
      args: SelectSubset<T, as_yoast_primary_termUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_primary_terms.
     * @param {as_yoast_primary_termDeleteManyArgs} args - Arguments to filter As_yoast_primary_terms to delete.
     * @example
     * // Delete a few As_yoast_primary_terms
     * const { count } = await prisma.as_yoast_primary_term.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_primary_termDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_primary_termDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_primary_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_primary_terms
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_primary_termUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_primary_termUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_primary_term.
     * @param {as_yoast_primary_termUpsertArgs} args - Arguments to update or create a As_yoast_primary_term.
     * @example
     * // Update or create a As_yoast_primary_term
     * const as_yoast_primary_term = await prisma.as_yoast_primary_term.upsert({
     *   create: {
     *     // ... data to create a As_yoast_primary_term
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_primary_term we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_primary_termUpsertArgs>(
      args: SelectSubset<T, as_yoast_primary_termUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_primary_termClient<
      $Result.GetResult<
        Prisma.$as_yoast_primary_termPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_primary_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termCountArgs} args - Arguments to filter As_yoast_primary_terms to count.
     * @example
     * // Count the number of As_yoast_primary_terms
     * const count = await prisma.as_yoast_primary_term.count({
     *   where: {
     *     // ... the filter for the As_yoast_primary_terms we want to count
     *   }
     * })
     */
    count<T extends as_yoast_primary_termCountArgs>(
      args?: Subset<T, as_yoast_primary_termCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_primary_termCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_primary_term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_primary_termAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_primary_termAggregateArgs>(
      args: Subset<T, As_yoast_primary_termAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_primary_termAggregateType<T>>

    /**
     * Group by As_yoast_primary_term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_primary_termGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_primary_termGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_primary_termGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_primary_termGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_primary_termGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_primary_termGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_primary_term model
     */
    readonly fields: as_yoast_primary_termFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_primary_term.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_primary_termClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_primary_term model
   */
  interface as_yoast_primary_termFieldRefs {
    readonly id: FieldRef<'as_yoast_primary_term', 'Int'>
    readonly post_id: FieldRef<'as_yoast_primary_term', 'BigInt'>
    readonly term_id: FieldRef<'as_yoast_primary_term', 'BigInt'>
    readonly taxonomy: FieldRef<'as_yoast_primary_term', 'String'>
    readonly created_at: FieldRef<'as_yoast_primary_term', 'DateTime'>
    readonly updated_at: FieldRef<'as_yoast_primary_term', 'DateTime'>
    readonly blog_id: FieldRef<'as_yoast_primary_term', 'BigInt'>
  }

  // Custom InputTypes
  /**
   * as_yoast_primary_term findUnique
   */
  export type as_yoast_primary_termFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_primary_term to fetch.
     */
    where: as_yoast_primary_termWhereUniqueInput
  }

  /**
   * as_yoast_primary_term findUniqueOrThrow
   */
  export type as_yoast_primary_termFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_primary_term to fetch.
     */
    where: as_yoast_primary_termWhereUniqueInput
  }

  /**
   * as_yoast_primary_term findFirst
   */
  export type as_yoast_primary_termFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_primary_term to fetch.
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_primary_terms to fetch.
     */
    orderBy?:
      | as_yoast_primary_termOrderByWithRelationInput
      | as_yoast_primary_termOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_primary_terms.
     */
    cursor?: as_yoast_primary_termWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_primary_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_primary_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_primary_terms.
     */
    distinct?: As_yoast_primary_termScalarFieldEnum | As_yoast_primary_termScalarFieldEnum[]
  }

  /**
   * as_yoast_primary_term findFirstOrThrow
   */
  export type as_yoast_primary_termFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_primary_term to fetch.
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_primary_terms to fetch.
     */
    orderBy?:
      | as_yoast_primary_termOrderByWithRelationInput
      | as_yoast_primary_termOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_primary_terms.
     */
    cursor?: as_yoast_primary_termWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_primary_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_primary_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_primary_terms.
     */
    distinct?: As_yoast_primary_termScalarFieldEnum | As_yoast_primary_termScalarFieldEnum[]
  }

  /**
   * as_yoast_primary_term findMany
   */
  export type as_yoast_primary_termFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_primary_terms to fetch.
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_primary_terms to fetch.
     */
    orderBy?:
      | as_yoast_primary_termOrderByWithRelationInput
      | as_yoast_primary_termOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_primary_terms.
     */
    cursor?: as_yoast_primary_termWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_primary_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_primary_terms.
     */
    skip?: number
    distinct?: As_yoast_primary_termScalarFieldEnum | As_yoast_primary_termScalarFieldEnum[]
  }

  /**
   * as_yoast_primary_term create
   */
  export type as_yoast_primary_termCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_primary_term.
     */
    data: XOR<as_yoast_primary_termCreateInput, as_yoast_primary_termUncheckedCreateInput>
  }

  /**
   * as_yoast_primary_term createMany
   */
  export type as_yoast_primary_termCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_primary_terms.
     */
    data: as_yoast_primary_termCreateManyInput | as_yoast_primary_termCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_primary_term update
   */
  export type as_yoast_primary_termUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_primary_term.
     */
    data: XOR<as_yoast_primary_termUpdateInput, as_yoast_primary_termUncheckedUpdateInput>
    /**
     * Choose, which as_yoast_primary_term to update.
     */
    where: as_yoast_primary_termWhereUniqueInput
  }

  /**
   * as_yoast_primary_term updateMany
   */
  export type as_yoast_primary_termUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_primary_terms.
     */
    data: XOR<
      as_yoast_primary_termUpdateManyMutationInput,
      as_yoast_primary_termUncheckedUpdateManyInput
    >
    /**
     * Filter which as_yoast_primary_terms to update
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * Limit how many as_yoast_primary_terms to update.
     */
    limit?: number
  }

  /**
   * as_yoast_primary_term upsert
   */
  export type as_yoast_primary_termUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_primary_term to update in case it exists.
     */
    where: as_yoast_primary_termWhereUniqueInput
    /**
     * In case the as_yoast_primary_term found by the `where` argument doesn't exist, create a new as_yoast_primary_term with this data.
     */
    create: XOR<as_yoast_primary_termCreateInput, as_yoast_primary_termUncheckedCreateInput>
    /**
     * In case the as_yoast_primary_term was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_yoast_primary_termUpdateInput, as_yoast_primary_termUncheckedUpdateInput>
  }

  /**
   * as_yoast_primary_term delete
   */
  export type as_yoast_primary_termDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_primary_term to delete.
     */
    where: as_yoast_primary_termWhereUniqueInput
  }

  /**
   * as_yoast_primary_term deleteMany
   */
  export type as_yoast_primary_termDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_primary_terms to delete
     */
    where?: as_yoast_primary_termWhereInput
    /**
     * Limit how many as_yoast_primary_terms to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_primary_term without action
   */
  export type as_yoast_primary_termDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_primary_term
     */
    select?: as_yoast_primary_termSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_primary_term
     */
    omit?: as_yoast_primary_termOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_seo_links
   */

  export type AggregateAs_yoast_seo_links = {
    _count: As_yoast_seo_linksCountAggregateOutputType | null
    _avg: As_yoast_seo_linksAvgAggregateOutputType | null
    _sum: As_yoast_seo_linksSumAggregateOutputType | null
    _min: As_yoast_seo_linksMinAggregateOutputType | null
    _max: As_yoast_seo_linksMaxAggregateOutputType | null
  }

  export type As_yoast_seo_linksAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    target_post_id: number | null
    indexable_id: number | null
    target_indexable_id: number | null
    height: number | null
    width: number | null
    size: number | null
  }

  export type As_yoast_seo_linksSumAggregateOutputType = {
    id: bigint | null
    post_id: bigint | null
    target_post_id: bigint | null
    indexable_id: number | null
    target_indexable_id: number | null
    height: number | null
    width: number | null
    size: number | null
  }

  export type As_yoast_seo_linksMinAggregateOutputType = {
    id: bigint | null
    url: string | null
    post_id: bigint | null
    target_post_id: bigint | null
    type: string | null
    indexable_id: number | null
    target_indexable_id: number | null
    height: number | null
    width: number | null
    size: number | null
    language: string | null
    region: string | null
  }

  export type As_yoast_seo_linksMaxAggregateOutputType = {
    id: bigint | null
    url: string | null
    post_id: bigint | null
    target_post_id: bigint | null
    type: string | null
    indexable_id: number | null
    target_indexable_id: number | null
    height: number | null
    width: number | null
    size: number | null
    language: string | null
    region: string | null
  }

  export type As_yoast_seo_linksCountAggregateOutputType = {
    id: number
    url: number
    post_id: number
    target_post_id: number
    type: number
    indexable_id: number
    target_indexable_id: number
    height: number
    width: number
    size: number
    language: number
    region: number
    _all: number
  }

  export type As_yoast_seo_linksAvgAggregateInputType = {
    id?: true
    post_id?: true
    target_post_id?: true
    indexable_id?: true
    target_indexable_id?: true
    height?: true
    width?: true
    size?: true
  }

  export type As_yoast_seo_linksSumAggregateInputType = {
    id?: true
    post_id?: true
    target_post_id?: true
    indexable_id?: true
    target_indexable_id?: true
    height?: true
    width?: true
    size?: true
  }

  export type As_yoast_seo_linksMinAggregateInputType = {
    id?: true
    url?: true
    post_id?: true
    target_post_id?: true
    type?: true
    indexable_id?: true
    target_indexable_id?: true
    height?: true
    width?: true
    size?: true
    language?: true
    region?: true
  }

  export type As_yoast_seo_linksMaxAggregateInputType = {
    id?: true
    url?: true
    post_id?: true
    target_post_id?: true
    type?: true
    indexable_id?: true
    target_indexable_id?: true
    height?: true
    width?: true
    size?: true
    language?: true
    region?: true
  }

  export type As_yoast_seo_linksCountAggregateInputType = {
    id?: true
    url?: true
    post_id?: true
    target_post_id?: true
    type?: true
    indexable_id?: true
    target_indexable_id?: true
    height?: true
    width?: true
    size?: true
    language?: true
    region?: true
    _all?: true
  }

  export type As_yoast_seo_linksAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_seo_links to aggregate.
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_links to fetch.
     */
    orderBy?:
      | as_yoast_seo_linksOrderByWithRelationInput
      | as_yoast_seo_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_seo_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_seo_links
     */
    _count?: true | As_yoast_seo_linksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_seo_linksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_seo_linksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_seo_linksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_seo_linksMaxAggregateInputType
  }

  export type GetAs_yoast_seo_linksAggregateType<T extends As_yoast_seo_linksAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_yoast_seo_links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_yoast_seo_links[P]>
      : GetScalarType<T[P], AggregateAs_yoast_seo_links[P]>
  }

  export type as_yoast_seo_linksGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_seo_linksWhereInput
    orderBy?:
      | as_yoast_seo_linksOrderByWithAggregationInput
      | as_yoast_seo_linksOrderByWithAggregationInput[]
    by: As_yoast_seo_linksScalarFieldEnum[] | As_yoast_seo_linksScalarFieldEnum
    having?: as_yoast_seo_linksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_seo_linksCountAggregateInputType | true
    _avg?: As_yoast_seo_linksAvgAggregateInputType
    _sum?: As_yoast_seo_linksSumAggregateInputType
    _min?: As_yoast_seo_linksMinAggregateInputType
    _max?: As_yoast_seo_linksMaxAggregateInputType
  }

  export type As_yoast_seo_linksGroupByOutputType = {
    id: bigint
    url: string
    post_id: bigint
    target_post_id: bigint
    type: string
    indexable_id: number | null
    target_indexable_id: number | null
    height: number | null
    width: number | null
    size: number | null
    language: string | null
    region: string | null
    _count: As_yoast_seo_linksCountAggregateOutputType | null
    _avg: As_yoast_seo_linksAvgAggregateOutputType | null
    _sum: As_yoast_seo_linksSumAggregateOutputType | null
    _min: As_yoast_seo_linksMinAggregateOutputType | null
    _max: As_yoast_seo_linksMaxAggregateOutputType | null
  }

  type GetAs_yoast_seo_linksGroupByPayload<T extends as_yoast_seo_linksGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_yoast_seo_linksGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_yoast_seo_linksGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_yoast_seo_linksGroupByOutputType[P]>
            : GetScalarType<T[P], As_yoast_seo_linksGroupByOutputType[P]>
        }
      >
    >

  export type as_yoast_seo_linksSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      url?: boolean
      post_id?: boolean
      target_post_id?: boolean
      type?: boolean
      indexable_id?: boolean
      target_indexable_id?: boolean
      height?: boolean
      width?: boolean
      size?: boolean
      language?: boolean
      region?: boolean
    },
    ExtArgs['result']['as_yoast_seo_links']
  >

  export type as_yoast_seo_linksSelectScalar = {
    id?: boolean
    url?: boolean
    post_id?: boolean
    target_post_id?: boolean
    type?: boolean
    indexable_id?: boolean
    target_indexable_id?: boolean
    height?: boolean
    width?: boolean
    size?: boolean
    language?: boolean
    region?: boolean
  }

  export type as_yoast_seo_linksOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    | 'id'
    | 'url'
    | 'post_id'
    | 'target_post_id'
    | 'type'
    | 'indexable_id'
    | 'target_indexable_id'
    | 'height'
    | 'width'
    | 'size'
    | 'language'
    | 'region',
    ExtArgs['result']['as_yoast_seo_links']
  >

  export type $as_yoast_seo_linksPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_seo_links'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        url: string
        post_id: bigint
        target_post_id: bigint
        type: string
        indexable_id: number | null
        target_indexable_id: number | null
        height: number | null
        width: number | null
        size: number | null
        language: string | null
        region: string | null
      },
      ExtArgs['result']['as_yoast_seo_links']
    >
    composites: {}
  }

  type as_yoast_seo_linksGetPayload<
    S extends boolean | null | undefined | as_yoast_seo_linksDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_seo_linksPayload, S>

  type as_yoast_seo_linksCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_seo_linksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_seo_linksCountAggregateInputType | true
  }

  export interface as_yoast_seo_linksDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_seo_links']
      meta: { name: 'as_yoast_seo_links' }
    }
    /**
     * Find zero or one As_yoast_seo_links that matches the filter.
     * @param {as_yoast_seo_linksFindUniqueArgs} args - Arguments to find a As_yoast_seo_links
     * @example
     * // Get one As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_seo_linksFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_seo_linksFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_linksPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_seo_links that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_seo_linksFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_seo_links
     * @example
     * // Get one As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_seo_linksFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_seo_linksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_linksPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_seo_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksFindFirstArgs} args - Arguments to find a As_yoast_seo_links
     * @example
     * // Get one As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_seo_linksFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_seo_linksFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_linksPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_seo_links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksFindFirstOrThrowArgs} args - Arguments to find a As_yoast_seo_links
     * @example
     * // Get one As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_seo_linksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_seo_linksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_linksPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_seo_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findMany()
     *
     * // Get first 10 As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const as_yoast_seo_linksWithIdOnly = await prisma.as_yoast_seo_links.findMany({ select: { id: true } })
     *
     */
    findMany<T extends as_yoast_seo_linksFindManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_linksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$as_yoast_seo_linksPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a As_yoast_seo_links.
     * @param {as_yoast_seo_linksCreateArgs} args - Arguments to create a As_yoast_seo_links.
     * @example
     * // Create one As_yoast_seo_links
     * const As_yoast_seo_links = await prisma.as_yoast_seo_links.create({
     *   data: {
     *     // ... data to create a As_yoast_seo_links
     *   }
     * })
     *
     */
    create<T extends as_yoast_seo_linksCreateArgs>(
      args: SelectSubset<T, as_yoast_seo_linksCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<Prisma.$as_yoast_seo_linksPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_seo_links.
     * @param {as_yoast_seo_linksCreateManyArgs} args - Arguments to create many As_yoast_seo_links.
     * @example
     * // Create many As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_seo_linksCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_linksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_seo_links.
     * @param {as_yoast_seo_linksDeleteArgs} args - Arguments to delete one As_yoast_seo_links.
     * @example
     * // Delete one As_yoast_seo_links
     * const As_yoast_seo_links = await prisma.as_yoast_seo_links.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_seo_links
     *   }
     * })
     *
     */
    delete<T extends as_yoast_seo_linksDeleteArgs>(
      args: SelectSubset<T, as_yoast_seo_linksDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<Prisma.$as_yoast_seo_linksPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_seo_links.
     * @param {as_yoast_seo_linksUpdateArgs} args - Arguments to update one As_yoast_seo_links.
     * @example
     * // Update one As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_seo_linksUpdateArgs>(
      args: SelectSubset<T, as_yoast_seo_linksUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<Prisma.$as_yoast_seo_linksPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_seo_links.
     * @param {as_yoast_seo_linksDeleteManyArgs} args - Arguments to filter As_yoast_seo_links to delete.
     * @example
     * // Delete a few As_yoast_seo_links
     * const { count } = await prisma.as_yoast_seo_links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_seo_linksDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_linksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_seo_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_seo_linksUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_seo_linksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_seo_links.
     * @param {as_yoast_seo_linksUpsertArgs} args - Arguments to update or create a As_yoast_seo_links.
     * @example
     * // Update or create a As_yoast_seo_links
     * const as_yoast_seo_links = await prisma.as_yoast_seo_links.upsert({
     *   create: {
     *     // ... data to create a As_yoast_seo_links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_seo_links we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_seo_linksUpsertArgs>(
      args: SelectSubset<T, as_yoast_seo_linksUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_linksClient<
      $Result.GetResult<Prisma.$as_yoast_seo_linksPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_seo_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksCountArgs} args - Arguments to filter As_yoast_seo_links to count.
     * @example
     * // Count the number of As_yoast_seo_links
     * const count = await prisma.as_yoast_seo_links.count({
     *   where: {
     *     // ... the filter for the As_yoast_seo_links we want to count
     *   }
     * })
     */
    count<T extends as_yoast_seo_linksCountArgs>(
      args?: Subset<T, as_yoast_seo_linksCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_seo_linksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_seo_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_seo_linksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_seo_linksAggregateArgs>(
      args: Subset<T, As_yoast_seo_linksAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_seo_linksAggregateType<T>>

    /**
     * Group by As_yoast_seo_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_linksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_seo_linksGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_seo_linksGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_seo_linksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_seo_linksGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_seo_linksGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_seo_links model
     */
    readonly fields: as_yoast_seo_linksFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_seo_links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_seo_linksClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_seo_links model
   */
  interface as_yoast_seo_linksFieldRefs {
    readonly id: FieldRef<'as_yoast_seo_links', 'BigInt'>
    readonly url: FieldRef<'as_yoast_seo_links', 'String'>
    readonly post_id: FieldRef<'as_yoast_seo_links', 'BigInt'>
    readonly target_post_id: FieldRef<'as_yoast_seo_links', 'BigInt'>
    readonly type: FieldRef<'as_yoast_seo_links', 'String'>
    readonly indexable_id: FieldRef<'as_yoast_seo_links', 'Int'>
    readonly target_indexable_id: FieldRef<'as_yoast_seo_links', 'Int'>
    readonly height: FieldRef<'as_yoast_seo_links', 'Int'>
    readonly width: FieldRef<'as_yoast_seo_links', 'Int'>
    readonly size: FieldRef<'as_yoast_seo_links', 'Int'>
    readonly language: FieldRef<'as_yoast_seo_links', 'String'>
    readonly region: FieldRef<'as_yoast_seo_links', 'String'>
  }

  // Custom InputTypes
  /**
   * as_yoast_seo_links findUnique
   */
  export type as_yoast_seo_linksFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_links to fetch.
     */
    where: as_yoast_seo_linksWhereUniqueInput
  }

  /**
   * as_yoast_seo_links findUniqueOrThrow
   */
  export type as_yoast_seo_linksFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_links to fetch.
     */
    where: as_yoast_seo_linksWhereUniqueInput
  }

  /**
   * as_yoast_seo_links findFirst
   */
  export type as_yoast_seo_linksFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_links to fetch.
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_links to fetch.
     */
    orderBy?:
      | as_yoast_seo_linksOrderByWithRelationInput
      | as_yoast_seo_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_seo_links.
     */
    cursor?: as_yoast_seo_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_seo_links.
     */
    distinct?: As_yoast_seo_linksScalarFieldEnum | As_yoast_seo_linksScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_links findFirstOrThrow
   */
  export type as_yoast_seo_linksFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_links to fetch.
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_links to fetch.
     */
    orderBy?:
      | as_yoast_seo_linksOrderByWithRelationInput
      | as_yoast_seo_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_seo_links.
     */
    cursor?: as_yoast_seo_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_seo_links.
     */
    distinct?: As_yoast_seo_linksScalarFieldEnum | As_yoast_seo_linksScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_links findMany
   */
  export type as_yoast_seo_linksFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_links to fetch.
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_links to fetch.
     */
    orderBy?:
      | as_yoast_seo_linksOrderByWithRelationInput
      | as_yoast_seo_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_seo_links.
     */
    cursor?: as_yoast_seo_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_links.
     */
    skip?: number
    distinct?: As_yoast_seo_linksScalarFieldEnum | As_yoast_seo_linksScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_links create
   */
  export type as_yoast_seo_linksCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_seo_links.
     */
    data: XOR<as_yoast_seo_linksCreateInput, as_yoast_seo_linksUncheckedCreateInput>
  }

  /**
   * as_yoast_seo_links createMany
   */
  export type as_yoast_seo_linksCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_seo_links.
     */
    data: as_yoast_seo_linksCreateManyInput | as_yoast_seo_linksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_seo_links update
   */
  export type as_yoast_seo_linksUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_seo_links.
     */
    data: XOR<as_yoast_seo_linksUpdateInput, as_yoast_seo_linksUncheckedUpdateInput>
    /**
     * Choose, which as_yoast_seo_links to update.
     */
    where: as_yoast_seo_linksWhereUniqueInput
  }

  /**
   * as_yoast_seo_links updateMany
   */
  export type as_yoast_seo_linksUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_seo_links.
     */
    data: XOR<as_yoast_seo_linksUpdateManyMutationInput, as_yoast_seo_linksUncheckedUpdateManyInput>
    /**
     * Filter which as_yoast_seo_links to update
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * Limit how many as_yoast_seo_links to update.
     */
    limit?: number
  }

  /**
   * as_yoast_seo_links upsert
   */
  export type as_yoast_seo_linksUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_seo_links to update in case it exists.
     */
    where: as_yoast_seo_linksWhereUniqueInput
    /**
     * In case the as_yoast_seo_links found by the `where` argument doesn't exist, create a new as_yoast_seo_links with this data.
     */
    create: XOR<as_yoast_seo_linksCreateInput, as_yoast_seo_linksUncheckedCreateInput>
    /**
     * In case the as_yoast_seo_links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_yoast_seo_linksUpdateInput, as_yoast_seo_linksUncheckedUpdateInput>
  }

  /**
   * as_yoast_seo_links delete
   */
  export type as_yoast_seo_linksDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_seo_links to delete.
     */
    where: as_yoast_seo_linksWhereUniqueInput
  }

  /**
   * as_yoast_seo_links deleteMany
   */
  export type as_yoast_seo_linksDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_seo_links to delete
     */
    where?: as_yoast_seo_linksWhereInput
    /**
     * Limit how many as_yoast_seo_links to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_seo_links without action
   */
  export type as_yoast_seo_linksDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_links
     */
    select?: as_yoast_seo_linksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_links
     */
    omit?: as_yoast_seo_linksOmit<ExtArgs> | null
  }

  /**
   * Model as_yoast_seo_meta
   */

  export type AggregateAs_yoast_seo_meta = {
    _count: As_yoast_seo_metaCountAggregateOutputType | null
    _avg: As_yoast_seo_metaAvgAggregateOutputType | null
    _sum: As_yoast_seo_metaSumAggregateOutputType | null
    _min: As_yoast_seo_metaMinAggregateOutputType | null
    _max: As_yoast_seo_metaMaxAggregateOutputType | null
  }

  export type As_yoast_seo_metaAvgAggregateOutputType = {
    object_id: number | null
    internal_link_count: number | null
    incoming_link_count: number | null
  }

  export type As_yoast_seo_metaSumAggregateOutputType = {
    object_id: bigint | null
    internal_link_count: number | null
    incoming_link_count: number | null
  }

  export type As_yoast_seo_metaMinAggregateOutputType = {
    object_id: bigint | null
    internal_link_count: number | null
    incoming_link_count: number | null
  }

  export type As_yoast_seo_metaMaxAggregateOutputType = {
    object_id: bigint | null
    internal_link_count: number | null
    incoming_link_count: number | null
  }

  export type As_yoast_seo_metaCountAggregateOutputType = {
    object_id: number
    internal_link_count: number
    incoming_link_count: number
    _all: number
  }

  export type As_yoast_seo_metaAvgAggregateInputType = {
    object_id?: true
    internal_link_count?: true
    incoming_link_count?: true
  }

  export type As_yoast_seo_metaSumAggregateInputType = {
    object_id?: true
    internal_link_count?: true
    incoming_link_count?: true
  }

  export type As_yoast_seo_metaMinAggregateInputType = {
    object_id?: true
    internal_link_count?: true
    incoming_link_count?: true
  }

  export type As_yoast_seo_metaMaxAggregateInputType = {
    object_id?: true
    internal_link_count?: true
    incoming_link_count?: true
  }

  export type As_yoast_seo_metaCountAggregateInputType = {
    object_id?: true
    internal_link_count?: true
    incoming_link_count?: true
    _all?: true
  }

  export type As_yoast_seo_metaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_seo_meta to aggregate.
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_metas to fetch.
     */
    orderBy?:
      | as_yoast_seo_metaOrderByWithRelationInput
      | as_yoast_seo_metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: as_yoast_seo_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned as_yoast_seo_metas
     */
    _count?: true | As_yoast_seo_metaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: As_yoast_seo_metaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: As_yoast_seo_metaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: As_yoast_seo_metaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: As_yoast_seo_metaMaxAggregateInputType
  }

  export type GetAs_yoast_seo_metaAggregateType<T extends As_yoast_seo_metaAggregateArgs> = {
    [P in keyof T & keyof AggregateAs_yoast_seo_meta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAs_yoast_seo_meta[P]>
      : GetScalarType<T[P], AggregateAs_yoast_seo_meta[P]>
  }

  export type as_yoast_seo_metaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: as_yoast_seo_metaWhereInput
    orderBy?:
      | as_yoast_seo_metaOrderByWithAggregationInput
      | as_yoast_seo_metaOrderByWithAggregationInput[]
    by: As_yoast_seo_metaScalarFieldEnum[] | As_yoast_seo_metaScalarFieldEnum
    having?: as_yoast_seo_metaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: As_yoast_seo_metaCountAggregateInputType | true
    _avg?: As_yoast_seo_metaAvgAggregateInputType
    _sum?: As_yoast_seo_metaSumAggregateInputType
    _min?: As_yoast_seo_metaMinAggregateInputType
    _max?: As_yoast_seo_metaMaxAggregateInputType
  }

  export type As_yoast_seo_metaGroupByOutputType = {
    object_id: bigint
    internal_link_count: number | null
    incoming_link_count: number | null
    _count: As_yoast_seo_metaCountAggregateOutputType | null
    _avg: As_yoast_seo_metaAvgAggregateOutputType | null
    _sum: As_yoast_seo_metaSumAggregateOutputType | null
    _min: As_yoast_seo_metaMinAggregateOutputType | null
    _max: As_yoast_seo_metaMaxAggregateOutputType | null
  }

  type GetAs_yoast_seo_metaGroupByPayload<T extends as_yoast_seo_metaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<As_yoast_seo_metaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof As_yoast_seo_metaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], As_yoast_seo_metaGroupByOutputType[P]>
            : GetScalarType<T[P], As_yoast_seo_metaGroupByOutputType[P]>
        }
      >
    >

  export type as_yoast_seo_metaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      object_id?: boolean
      internal_link_count?: boolean
      incoming_link_count?: boolean
    },
    ExtArgs['result']['as_yoast_seo_meta']
  >

  export type as_yoast_seo_metaSelectScalar = {
    object_id?: boolean
    internal_link_count?: boolean
    incoming_link_count?: boolean
  }

  export type as_yoast_seo_metaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'object_id' | 'internal_link_count' | 'incoming_link_count',
    ExtArgs['result']['as_yoast_seo_meta']
  >

  export type $as_yoast_seo_metaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'as_yoast_seo_meta'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        object_id: bigint
        internal_link_count: number | null
        incoming_link_count: number | null
      },
      ExtArgs['result']['as_yoast_seo_meta']
    >
    composites: {}
  }

  type as_yoast_seo_metaGetPayload<
    S extends boolean | null | undefined | as_yoast_seo_metaDefaultArgs
  > = $Result.GetResult<Prisma.$as_yoast_seo_metaPayload, S>

  type as_yoast_seo_metaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<as_yoast_seo_metaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: As_yoast_seo_metaCountAggregateInputType | true
  }

  export interface as_yoast_seo_metaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['as_yoast_seo_meta']
      meta: { name: 'as_yoast_seo_meta' }
    }
    /**
     * Find zero or one As_yoast_seo_meta that matches the filter.
     * @param {as_yoast_seo_metaFindUniqueArgs} args - Arguments to find a As_yoast_seo_meta
     * @example
     * // Get one As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends as_yoast_seo_metaFindUniqueArgs>(
      args: SelectSubset<T, as_yoast_seo_metaFindUniqueArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_metaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one As_yoast_seo_meta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {as_yoast_seo_metaFindUniqueOrThrowArgs} args - Arguments to find a As_yoast_seo_meta
     * @example
     * // Get one As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends as_yoast_seo_metaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, as_yoast_seo_metaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_metaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_seo_meta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaFindFirstArgs} args - Arguments to find a As_yoast_seo_meta
     * @example
     * // Get one As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends as_yoast_seo_metaFindFirstArgs>(
      args?: SelectSubset<T, as_yoast_seo_metaFindFirstArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_metaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first As_yoast_seo_meta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaFindFirstOrThrowArgs} args - Arguments to find a As_yoast_seo_meta
     * @example
     * // Get one As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends as_yoast_seo_metaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, as_yoast_seo_metaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<
        Prisma.$as_yoast_seo_metaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more As_yoast_seo_metas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As_yoast_seo_metas
     * const as_yoast_seo_metas = await prisma.as_yoast_seo_meta.findMany()
     *
     * // Get first 10 As_yoast_seo_metas
     * const as_yoast_seo_metas = await prisma.as_yoast_seo_meta.findMany({ take: 10 })
     *
     * // Only select the `object_id`
     * const as_yoast_seo_metaWithObject_idOnly = await prisma.as_yoast_seo_meta.findMany({ select: { object_id: true } })
     *
     */
    findMany<T extends as_yoast_seo_metaFindManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_metaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$as_yoast_seo_metaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a As_yoast_seo_meta.
     * @param {as_yoast_seo_metaCreateArgs} args - Arguments to create a As_yoast_seo_meta.
     * @example
     * // Create one As_yoast_seo_meta
     * const As_yoast_seo_meta = await prisma.as_yoast_seo_meta.create({
     *   data: {
     *     // ... data to create a As_yoast_seo_meta
     *   }
     * })
     *
     */
    create<T extends as_yoast_seo_metaCreateArgs>(
      args: SelectSubset<T, as_yoast_seo_metaCreateArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<Prisma.$as_yoast_seo_metaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many As_yoast_seo_metas.
     * @param {as_yoast_seo_metaCreateManyArgs} args - Arguments to create many As_yoast_seo_metas.
     * @example
     * // Create many As_yoast_seo_metas
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends as_yoast_seo_metaCreateManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_metaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a As_yoast_seo_meta.
     * @param {as_yoast_seo_metaDeleteArgs} args - Arguments to delete one As_yoast_seo_meta.
     * @example
     * // Delete one As_yoast_seo_meta
     * const As_yoast_seo_meta = await prisma.as_yoast_seo_meta.delete({
     *   where: {
     *     // ... filter to delete one As_yoast_seo_meta
     *   }
     * })
     *
     */
    delete<T extends as_yoast_seo_metaDeleteArgs>(
      args: SelectSubset<T, as_yoast_seo_metaDeleteArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<Prisma.$as_yoast_seo_metaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one As_yoast_seo_meta.
     * @param {as_yoast_seo_metaUpdateArgs} args - Arguments to update one As_yoast_seo_meta.
     * @example
     * // Update one As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends as_yoast_seo_metaUpdateArgs>(
      args: SelectSubset<T, as_yoast_seo_metaUpdateArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<Prisma.$as_yoast_seo_metaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more As_yoast_seo_metas.
     * @param {as_yoast_seo_metaDeleteManyArgs} args - Arguments to filter As_yoast_seo_metas to delete.
     * @example
     * // Delete a few As_yoast_seo_metas
     * const { count } = await prisma.as_yoast_seo_meta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends as_yoast_seo_metaDeleteManyArgs>(
      args?: SelectSubset<T, as_yoast_seo_metaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As_yoast_seo_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As_yoast_seo_metas
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends as_yoast_seo_metaUpdateManyArgs>(
      args: SelectSubset<T, as_yoast_seo_metaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one As_yoast_seo_meta.
     * @param {as_yoast_seo_metaUpsertArgs} args - Arguments to update or create a As_yoast_seo_meta.
     * @example
     * // Update or create a As_yoast_seo_meta
     * const as_yoast_seo_meta = await prisma.as_yoast_seo_meta.upsert({
     *   create: {
     *     // ... data to create a As_yoast_seo_meta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the As_yoast_seo_meta we want to update
     *   }
     * })
     */
    upsert<T extends as_yoast_seo_metaUpsertArgs>(
      args: SelectSubset<T, as_yoast_seo_metaUpsertArgs<ExtArgs>>
    ): Prisma__as_yoast_seo_metaClient<
      $Result.GetResult<Prisma.$as_yoast_seo_metaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of As_yoast_seo_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaCountArgs} args - Arguments to filter As_yoast_seo_metas to count.
     * @example
     * // Count the number of As_yoast_seo_metas
     * const count = await prisma.as_yoast_seo_meta.count({
     *   where: {
     *     // ... the filter for the As_yoast_seo_metas we want to count
     *   }
     * })
     */
    count<T extends as_yoast_seo_metaCountArgs>(
      args?: Subset<T, as_yoast_seo_metaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], As_yoast_seo_metaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a As_yoast_seo_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {As_yoast_seo_metaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends As_yoast_seo_metaAggregateArgs>(
      args: Subset<T, As_yoast_seo_metaAggregateArgs>
    ): Prisma.PrismaPromise<GetAs_yoast_seo_metaAggregateType<T>>

    /**
     * Group by As_yoast_seo_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {as_yoast_seo_metaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends as_yoast_seo_metaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: as_yoast_seo_metaGroupByArgs['orderBy'] }
        : { orderBy?: as_yoast_seo_metaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, as_yoast_seo_metaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAs_yoast_seo_metaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the as_yoast_seo_meta model
     */
    readonly fields: as_yoast_seo_metaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for as_yoast_seo_meta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__as_yoast_seo_metaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the as_yoast_seo_meta model
   */
  interface as_yoast_seo_metaFieldRefs {
    readonly object_id: FieldRef<'as_yoast_seo_meta', 'BigInt'>
    readonly internal_link_count: FieldRef<'as_yoast_seo_meta', 'Int'>
    readonly incoming_link_count: FieldRef<'as_yoast_seo_meta', 'Int'>
  }

  // Custom InputTypes
  /**
   * as_yoast_seo_meta findUnique
   */
  export type as_yoast_seo_metaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_meta to fetch.
     */
    where: as_yoast_seo_metaWhereUniqueInput
  }

  /**
   * as_yoast_seo_meta findUniqueOrThrow
   */
  export type as_yoast_seo_metaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_meta to fetch.
     */
    where: as_yoast_seo_metaWhereUniqueInput
  }

  /**
   * as_yoast_seo_meta findFirst
   */
  export type as_yoast_seo_metaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_meta to fetch.
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_metas to fetch.
     */
    orderBy?:
      | as_yoast_seo_metaOrderByWithRelationInput
      | as_yoast_seo_metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_seo_metas.
     */
    cursor?: as_yoast_seo_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_seo_metas.
     */
    distinct?: As_yoast_seo_metaScalarFieldEnum | As_yoast_seo_metaScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_meta findFirstOrThrow
   */
  export type as_yoast_seo_metaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_meta to fetch.
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_metas to fetch.
     */
    orderBy?:
      | as_yoast_seo_metaOrderByWithRelationInput
      | as_yoast_seo_metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for as_yoast_seo_metas.
     */
    cursor?: as_yoast_seo_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of as_yoast_seo_metas.
     */
    distinct?: As_yoast_seo_metaScalarFieldEnum | As_yoast_seo_metaScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_meta findMany
   */
  export type as_yoast_seo_metaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter, which as_yoast_seo_metas to fetch.
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of as_yoast_seo_metas to fetch.
     */
    orderBy?:
      | as_yoast_seo_metaOrderByWithRelationInput
      | as_yoast_seo_metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing as_yoast_seo_metas.
     */
    cursor?: as_yoast_seo_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` as_yoast_seo_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` as_yoast_seo_metas.
     */
    skip?: number
    distinct?: As_yoast_seo_metaScalarFieldEnum | As_yoast_seo_metaScalarFieldEnum[]
  }

  /**
   * as_yoast_seo_meta create
   */
  export type as_yoast_seo_metaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * The data needed to create a as_yoast_seo_meta.
     */
    data: XOR<as_yoast_seo_metaCreateInput, as_yoast_seo_metaUncheckedCreateInput>
  }

  /**
   * as_yoast_seo_meta createMany
   */
  export type as_yoast_seo_metaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many as_yoast_seo_metas.
     */
    data: as_yoast_seo_metaCreateManyInput | as_yoast_seo_metaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * as_yoast_seo_meta update
   */
  export type as_yoast_seo_metaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * The data needed to update a as_yoast_seo_meta.
     */
    data: XOR<as_yoast_seo_metaUpdateInput, as_yoast_seo_metaUncheckedUpdateInput>
    /**
     * Choose, which as_yoast_seo_meta to update.
     */
    where: as_yoast_seo_metaWhereUniqueInput
  }

  /**
   * as_yoast_seo_meta updateMany
   */
  export type as_yoast_seo_metaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update as_yoast_seo_metas.
     */
    data: XOR<as_yoast_seo_metaUpdateManyMutationInput, as_yoast_seo_metaUncheckedUpdateManyInput>
    /**
     * Filter which as_yoast_seo_metas to update
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * Limit how many as_yoast_seo_metas to update.
     */
    limit?: number
  }

  /**
   * as_yoast_seo_meta upsert
   */
  export type as_yoast_seo_metaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * The filter to search for the as_yoast_seo_meta to update in case it exists.
     */
    where: as_yoast_seo_metaWhereUniqueInput
    /**
     * In case the as_yoast_seo_meta found by the `where` argument doesn't exist, create a new as_yoast_seo_meta with this data.
     */
    create: XOR<as_yoast_seo_metaCreateInput, as_yoast_seo_metaUncheckedCreateInput>
    /**
     * In case the as_yoast_seo_meta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<as_yoast_seo_metaUpdateInput, as_yoast_seo_metaUncheckedUpdateInput>
  }

  /**
   * as_yoast_seo_meta delete
   */
  export type as_yoast_seo_metaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
    /**
     * Filter which as_yoast_seo_meta to delete.
     */
    where: as_yoast_seo_metaWhereUniqueInput
  }

  /**
   * as_yoast_seo_meta deleteMany
   */
  export type as_yoast_seo_metaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which as_yoast_seo_metas to delete
     */
    where?: as_yoast_seo_metaWhereInput
    /**
     * Limit how many as_yoast_seo_metas to delete.
     */
    limit?: number
  }

  /**
   * as_yoast_seo_meta without action
   */
  export type as_yoast_seo_metaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the as_yoast_seo_meta
     */
    select?: as_yoast_seo_metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the as_yoast_seo_meta
     */
    omit?: as_yoast_seo_metaOmit<ExtArgs> | null
  }

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted'
    ReadCommitted: 'ReadCommitted'
    RepeatableRead: 'RepeatableRead'
    Serializable: 'Serializable'
  }

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

  export const As_actionscheduler_actionsScalarFieldEnum: {
    action_id: 'action_id'
    hook: 'hook'
    status: 'status'
    scheduled_date_gmt: 'scheduled_date_gmt'
    scheduled_date_local: 'scheduled_date_local'
    args: 'args'
    schedule: 'schedule'
    group_id: 'group_id'
    attempts: 'attempts'
    last_attempt_gmt: 'last_attempt_gmt'
    last_attempt_local: 'last_attempt_local'
    claim_id: 'claim_id'
    extended_args: 'extended_args'
    priority: 'priority'
  }

  export type As_actionscheduler_actionsScalarFieldEnum =
    (typeof As_actionscheduler_actionsScalarFieldEnum)[keyof typeof As_actionscheduler_actionsScalarFieldEnum]

  export const As_actionscheduler_claimsScalarFieldEnum: {
    claim_id: 'claim_id'
    date_created_gmt: 'date_created_gmt'
  }

  export type As_actionscheduler_claimsScalarFieldEnum =
    (typeof As_actionscheduler_claimsScalarFieldEnum)[keyof typeof As_actionscheduler_claimsScalarFieldEnum]

  export const As_actionscheduler_groupsScalarFieldEnum: {
    group_id: 'group_id'
    slug: 'slug'
  }

  export type As_actionscheduler_groupsScalarFieldEnum =
    (typeof As_actionscheduler_groupsScalarFieldEnum)[keyof typeof As_actionscheduler_groupsScalarFieldEnum]

  export const As_actionscheduler_logsScalarFieldEnum: {
    log_id: 'log_id'
    action_id: 'action_id'
    message: 'message'
    log_date_gmt: 'log_date_gmt'
    log_date_local: 'log_date_local'
  }

  export type As_actionscheduler_logsScalarFieldEnum =
    (typeof As_actionscheduler_logsScalarFieldEnum)[keyof typeof As_actionscheduler_logsScalarFieldEnum]

  export const As_awb_critical_cssScalarFieldEnum: {
    id: 'id'
    css_key: 'css_key'
    mobile_css: 'mobile_css'
    desktop_css: 'desktop_css'
    mobile_preloads: 'mobile_preloads'
    desktop_preloads: 'desktop_preloads'
    updated_at: 'updated_at'
  }

  export type As_awb_critical_cssScalarFieldEnum =
    (typeof As_awb_critical_cssScalarFieldEnum)[keyof typeof As_awb_critical_cssScalarFieldEnum]

  export const As_cli_cookie_scanScalarFieldEnum: {
    id_cli_cookie_scan: 'id_cli_cookie_scan'
    status: 'status'
    created_at: 'created_at'
    total_url: 'total_url'
    total_cookies: 'total_cookies'
    current_action: 'current_action'
    current_offset: 'current_offset'
  }

  export type As_cli_cookie_scanScalarFieldEnum =
    (typeof As_cli_cookie_scanScalarFieldEnum)[keyof typeof As_cli_cookie_scanScalarFieldEnum]

  export const As_cli_cookie_scan_categoriesScalarFieldEnum: {
    id_cli_cookie_category: 'id_cli_cookie_category'
    cli_cookie_category_name: 'cli_cookie_category_name'
    cli_cookie_category_description: 'cli_cookie_category_description'
  }

  export type As_cli_cookie_scan_categoriesScalarFieldEnum =
    (typeof As_cli_cookie_scan_categoriesScalarFieldEnum)[keyof typeof As_cli_cookie_scan_categoriesScalarFieldEnum]

  export const As_cli_cookie_scan_cookiesScalarFieldEnum: {
    id_cli_cookie_scan_cookies: 'id_cli_cookie_scan_cookies'
    id_cli_cookie_scan: 'id_cli_cookie_scan'
    id_cli_cookie_scan_url: 'id_cli_cookie_scan_url'
    cookie_id: 'cookie_id'
    expiry: 'expiry'
    type: 'type'
    category: 'category'
    category_id: 'category_id'
    description: 'description'
  }

  export type As_cli_cookie_scan_cookiesScalarFieldEnum =
    (typeof As_cli_cookie_scan_cookiesScalarFieldEnum)[keyof typeof As_cli_cookie_scan_cookiesScalarFieldEnum]

  export const As_cli_cookie_scan_urlScalarFieldEnum: {
    id_cli_cookie_scan_url: 'id_cli_cookie_scan_url'
    id_cli_cookie_scan: 'id_cli_cookie_scan'
    url: 'url'
    scanned: 'scanned'
    total_cookies: 'total_cookies'
  }

  export type As_cli_cookie_scan_urlScalarFieldEnum =
    (typeof As_cli_cookie_scan_urlScalarFieldEnum)[keyof typeof As_cli_cookie_scan_urlScalarFieldEnum]

  export const As_cli_scriptsScalarFieldEnum: {
    id: 'id'
    cliscript_title: 'cliscript_title'
    cliscript_category: 'cliscript_category'
    cliscript_type: 'cliscript_type'
    cliscript_status: 'cliscript_status'
    cliscript_description: 'cliscript_description'
    cliscript_key: 'cliscript_key'
    type: 'type'
  }

  export type As_cli_scriptsScalarFieldEnum =
    (typeof As_cli_scriptsScalarFieldEnum)[keyof typeof As_cli_scriptsScalarFieldEnum]

  export const As_commentmetaScalarFieldEnum: {
    meta_id: 'meta_id'
    comment_id: 'comment_id'
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type As_commentmetaScalarFieldEnum =
    (typeof As_commentmetaScalarFieldEnum)[keyof typeof As_commentmetaScalarFieldEnum]

  export const As_commentsScalarFieldEnum: {
    comment_ID: 'comment_ID'
    comment_post_ID: 'comment_post_ID'
    comment_author: 'comment_author'
    comment_author_email: 'comment_author_email'
    comment_author_url: 'comment_author_url'
    comment_author_IP: 'comment_author_IP'
    comment_date: 'comment_date'
    comment_date_gmt: 'comment_date_gmt'
    comment_content: 'comment_content'
    comment_karma: 'comment_karma'
    comment_approved: 'comment_approved'
    comment_agent: 'comment_agent'
    comment_type: 'comment_type'
    comment_parent: 'comment_parent'
    user_id: 'user_id'
  }

  export type As_commentsScalarFieldEnum =
    (typeof As_commentsScalarFieldEnum)[keyof typeof As_commentsScalarFieldEnum]

  export const As_fusion_form_entriesScalarFieldEnum: {
    id: 'id'
    submission_id: 'submission_id'
    form_id: 'form_id'
    field_id: 'field_id'
    value: 'value'
    privacy: 'privacy'
    data: 'data'
  }

  export type As_fusion_form_entriesScalarFieldEnum =
    (typeof As_fusion_form_entriesScalarFieldEnum)[keyof typeof As_fusion_form_entriesScalarFieldEnum]

  export const As_fusion_form_fieldsScalarFieldEnum: {
    id: 'id'
    form_id: 'form_id'
    field_name: 'field_name'
    field_label: 'field_label'
    data: 'data'
  }

  export type As_fusion_form_fieldsScalarFieldEnum =
    (typeof As_fusion_form_fieldsScalarFieldEnum)[keyof typeof As_fusion_form_fieldsScalarFieldEnum]

  export const As_fusion_form_submissionsScalarFieldEnum: {
    id: 'id'
    form_id: 'form_id'
    time: 'time'
    source_url: 'source_url'
    post_id: 'post_id'
    user_id: 'user_id'
    user_agent: 'user_agent'
    ip: 'ip'
    is_read: 'is_read'
    privacy_scrub_date: 'privacy_scrub_date'
    on_privacy_scrub: 'on_privacy_scrub'
    data: 'data'
  }

  export type As_fusion_form_submissionsScalarFieldEnum =
    (typeof As_fusion_form_submissionsScalarFieldEnum)[keyof typeof As_fusion_form_submissionsScalarFieldEnum]

  export const As_fusion_formsScalarFieldEnum: {
    id: 'id'
    form_id: 'form_id'
    views: 'views'
    submissions_count: 'submissions_count'
    data: 'data'
  }

  export type As_fusion_formsScalarFieldEnum =
    (typeof As_fusion_formsScalarFieldEnum)[keyof typeof As_fusion_formsScalarFieldEnum]

  export const As_layersliderScalarFieldEnum: {
    id: 'id'
    group_id: 'group_id'
    author: 'author'
    name: 'name'
    slug: 'slug'
    data: 'data'
    date_c: 'date_c'
    date_m: 'date_m'
    schedule_start: 'schedule_start'
    schedule_end: 'schedule_end'
    flag_hidden: 'flag_hidden'
    flag_deleted: 'flag_deleted'
    flag_popup: 'flag_popup'
    flag_group: 'flag_group'
  }

  export type As_layersliderScalarFieldEnum =
    (typeof As_layersliderScalarFieldEnum)[keyof typeof As_layersliderScalarFieldEnum]

  export const As_layerslider_revisionsScalarFieldEnum: {
    id: 'id'
    slider_id: 'slider_id'
    author: 'author'
    data: 'data'
    date_c: 'date_c'
  }

  export type As_layerslider_revisionsScalarFieldEnum =
    (typeof As_layerslider_revisionsScalarFieldEnum)[keyof typeof As_layerslider_revisionsScalarFieldEnum]

  export const As_linksScalarFieldEnum: {
    link_id: 'link_id'
    link_url: 'link_url'
    link_name: 'link_name'
    link_image: 'link_image'
    link_target: 'link_target'
    link_description: 'link_description'
    link_visible: 'link_visible'
    link_owner: 'link_owner'
    link_rating: 'link_rating'
    link_updated: 'link_updated'
    link_rel: 'link_rel'
    link_notes: 'link_notes'
    link_rss: 'link_rss'
  }

  export type As_linksScalarFieldEnum =
    (typeof As_linksScalarFieldEnum)[keyof typeof As_linksScalarFieldEnum]

  export const As_loginizer_logsScalarFieldEnum: {
    username: 'username'
    time: 'time'
    count: 'count'
    lockout: 'lockout'
    ip: 'ip'
    url: 'url'
  }

  export type As_loginizer_logsScalarFieldEnum =
    (typeof As_loginizer_logsScalarFieldEnum)[keyof typeof As_loginizer_logsScalarFieldEnum]

  export const As_optionsScalarFieldEnum: {
    option_id: 'option_id'
    option_name: 'option_name'
    option_value: 'option_value'
    autoload: 'autoload'
  }

  export type As_optionsScalarFieldEnum =
    (typeof As_optionsScalarFieldEnum)[keyof typeof As_optionsScalarFieldEnum]

  export const As_postmetaScalarFieldEnum: {
    meta_id: 'meta_id'
    post_id: 'post_id'
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type As_postmetaScalarFieldEnum =
    (typeof As_postmetaScalarFieldEnum)[keyof typeof As_postmetaScalarFieldEnum]

  export const As_postsScalarFieldEnum: {
    ID: 'ID'
    post_author: 'post_author'
    post_date: 'post_date'
    post_date_gmt: 'post_date_gmt'
    post_content: 'post_content'
    post_title: 'post_title'
    post_excerpt: 'post_excerpt'
    post_status: 'post_status'
    comment_status: 'comment_status'
    ping_status: 'ping_status'
    post_password: 'post_password'
    post_name: 'post_name'
    to_ping: 'to_ping'
    pinged: 'pinged'
    post_modified: 'post_modified'
    post_modified_gmt: 'post_modified_gmt'
    post_content_filtered: 'post_content_filtered'
    post_parent: 'post_parent'
    guid: 'guid'
    menu_order: 'menu_order'
    post_type: 'post_type'
    post_mime_type: 'post_mime_type'
    comment_count: 'comment_count'
  }

  export type As_postsScalarFieldEnum =
    (typeof As_postsScalarFieldEnum)[keyof typeof As_postsScalarFieldEnum]

  export const As_term_relationshipsScalarFieldEnum: {
    object_id: 'object_id'
    term_taxonomy_id: 'term_taxonomy_id'
    term_order: 'term_order'
  }

  export type As_term_relationshipsScalarFieldEnum =
    (typeof As_term_relationshipsScalarFieldEnum)[keyof typeof As_term_relationshipsScalarFieldEnum]

  export const As_term_taxonomyScalarFieldEnum: {
    term_taxonomy_id: 'term_taxonomy_id'
    term_id: 'term_id'
    taxonomy: 'taxonomy'
    description: 'description'
    parent: 'parent'
    count: 'count'
  }

  export type As_term_taxonomyScalarFieldEnum =
    (typeof As_term_taxonomyScalarFieldEnum)[keyof typeof As_term_taxonomyScalarFieldEnum]

  export const As_termmetaScalarFieldEnum: {
    meta_id: 'meta_id'
    term_id: 'term_id'
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type As_termmetaScalarFieldEnum =
    (typeof As_termmetaScalarFieldEnum)[keyof typeof As_termmetaScalarFieldEnum]

  export const As_termsScalarFieldEnum: {
    term_id: 'term_id'
    name: 'name'
    slug: 'slug'
    term_group: 'term_group'
  }

  export type As_termsScalarFieldEnum =
    (typeof As_termsScalarFieldEnum)[keyof typeof As_termsScalarFieldEnum]

  export const As_tm_taskmetaScalarFieldEnum: {
    meta_id: 'meta_id'
    task_id: 'task_id'
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type As_tm_taskmetaScalarFieldEnum =
    (typeof As_tm_taskmetaScalarFieldEnum)[keyof typeof As_tm_taskmetaScalarFieldEnum]

  export const As_tm_tasksScalarFieldEnum: {
    id: 'id'
    user_id: 'user_id'
    type: 'type'
    class_identifier: 'class_identifier'
    attempts: 'attempts'
    description: 'description'
    time_created: 'time_created'
    last_locked_at: 'last_locked_at'
    status: 'status'
  }

  export type As_tm_tasksScalarFieldEnum =
    (typeof As_tm_tasksScalarFieldEnum)[keyof typeof As_tm_tasksScalarFieldEnum]

  export const As_usermetaScalarFieldEnum: {
    umeta_id: 'umeta_id'
    user_id: 'user_id'
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type As_usermetaScalarFieldEnum =
    (typeof As_usermetaScalarFieldEnum)[keyof typeof As_usermetaScalarFieldEnum]

  export const As_usersScalarFieldEnum: {
    ID: 'ID'
    user_login: 'user_login'
    user_pass: 'user_pass'
    user_nicename: 'user_nicename'
    user_email: 'user_email'
    user_url: 'user_url'
    user_registered: 'user_registered'
    user_activation_key: 'user_activation_key'
    user_status: 'user_status'
    display_name: 'display_name'
  }

  export type As_usersScalarFieldEnum =
    (typeof As_usersScalarFieldEnum)[keyof typeof As_usersScalarFieldEnum]

  export const As_wpo_404_detectorScalarFieldEnum: {
    ID: 'ID'
    url: 'url'
    request_timestamp: 'request_timestamp'
    request_count: 'request_count'
    referrer: 'referrer'
  }

  export type As_wpo_404_detectorScalarFieldEnum =
    (typeof As_wpo_404_detectorScalarFieldEnum)[keyof typeof As_wpo_404_detectorScalarFieldEnum]

  export const As_yoast_indexableScalarFieldEnum: {
    id: 'id'
    permalink: 'permalink'
    permalink_hash: 'permalink_hash'
    object_id: 'object_id'
    object_type: 'object_type'
    object_sub_type: 'object_sub_type'
    author_id: 'author_id'
    post_parent: 'post_parent'
    title: 'title'
    description: 'description'
    breadcrumb_title: 'breadcrumb_title'
    post_status: 'post_status'
    is_public: 'is_public'
    is_protected: 'is_protected'
    has_public_posts: 'has_public_posts'
    number_of_pages: 'number_of_pages'
    canonical: 'canonical'
    primary_focus_keyword: 'primary_focus_keyword'
    primary_focus_keyword_score: 'primary_focus_keyword_score'
    readability_score: 'readability_score'
    is_cornerstone: 'is_cornerstone'
    is_robots_noindex: 'is_robots_noindex'
    is_robots_nofollow: 'is_robots_nofollow'
    is_robots_noarchive: 'is_robots_noarchive'
    is_robots_noimageindex: 'is_robots_noimageindex'
    is_robots_nosnippet: 'is_robots_nosnippet'
    twitter_title: 'twitter_title'
    twitter_image: 'twitter_image'
    twitter_description: 'twitter_description'
    twitter_image_id: 'twitter_image_id'
    twitter_image_source: 'twitter_image_source'
    open_graph_title: 'open_graph_title'
    open_graph_description: 'open_graph_description'
    open_graph_image: 'open_graph_image'
    open_graph_image_id: 'open_graph_image_id'
    open_graph_image_source: 'open_graph_image_source'
    open_graph_image_meta: 'open_graph_image_meta'
    link_count: 'link_count'
    incoming_link_count: 'incoming_link_count'
    prominent_words_version: 'prominent_words_version'
    created_at: 'created_at'
    updated_at: 'updated_at'
    blog_id: 'blog_id'
    language: 'language'
    region: 'region'
    schema_page_type: 'schema_page_type'
    schema_article_type: 'schema_article_type'
    has_ancestors: 'has_ancestors'
    estimated_reading_time_minutes: 'estimated_reading_time_minutes'
    version: 'version'
    object_last_modified: 'object_last_modified'
    object_published_at: 'object_published_at'
    inclusive_language_score: 'inclusive_language_score'
  }

  export type As_yoast_indexableScalarFieldEnum =
    (typeof As_yoast_indexableScalarFieldEnum)[keyof typeof As_yoast_indexableScalarFieldEnum]

  export const As_yoast_indexable_hierarchyScalarFieldEnum: {
    indexable_id: 'indexable_id'
    ancestor_id: 'ancestor_id'
    depth: 'depth'
    blog_id: 'blog_id'
  }

  export type As_yoast_indexable_hierarchyScalarFieldEnum =
    (typeof As_yoast_indexable_hierarchyScalarFieldEnum)[keyof typeof As_yoast_indexable_hierarchyScalarFieldEnum]

  export const As_yoast_migrationsScalarFieldEnum: {
    id: 'id'
    version: 'version'
  }

  export type As_yoast_migrationsScalarFieldEnum =
    (typeof As_yoast_migrationsScalarFieldEnum)[keyof typeof As_yoast_migrationsScalarFieldEnum]

  export const As_yoast_primary_termScalarFieldEnum: {
    id: 'id'
    post_id: 'post_id'
    term_id: 'term_id'
    taxonomy: 'taxonomy'
    created_at: 'created_at'
    updated_at: 'updated_at'
    blog_id: 'blog_id'
  }

  export type As_yoast_primary_termScalarFieldEnum =
    (typeof As_yoast_primary_termScalarFieldEnum)[keyof typeof As_yoast_primary_termScalarFieldEnum]

  export const As_yoast_seo_linksScalarFieldEnum: {
    id: 'id'
    url: 'url'
    post_id: 'post_id'
    target_post_id: 'target_post_id'
    type: 'type'
    indexable_id: 'indexable_id'
    target_indexable_id: 'target_indexable_id'
    height: 'height'
    width: 'width'
    size: 'size'
    language: 'language'
    region: 'region'
  }

  export type As_yoast_seo_linksScalarFieldEnum =
    (typeof As_yoast_seo_linksScalarFieldEnum)[keyof typeof As_yoast_seo_linksScalarFieldEnum]

  export const As_yoast_seo_metaScalarFieldEnum: {
    object_id: 'object_id'
    internal_link_count: 'internal_link_count'
    incoming_link_count: 'incoming_link_count'
  }

  export type As_yoast_seo_metaScalarFieldEnum =
    (typeof As_yoast_seo_metaScalarFieldEnum)[keyof typeof As_yoast_seo_metaScalarFieldEnum]

  export const SortOrder: {
    asc: 'asc'
    desc: 'desc'
  }

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

  export const NullsOrder: {
    first: 'first'
    last: 'last'
  }

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]

  export const as_actionscheduler_actionsOrderByRelevanceFieldEnum: {
    hook: 'hook'
    status: 'status'
    args: 'args'
    schedule: 'schedule'
    extended_args: 'extended_args'
  }

  export type as_actionscheduler_actionsOrderByRelevanceFieldEnum =
    (typeof as_actionscheduler_actionsOrderByRelevanceFieldEnum)[keyof typeof as_actionscheduler_actionsOrderByRelevanceFieldEnum]

  export const as_actionscheduler_groupsOrderByRelevanceFieldEnum: {
    slug: 'slug'
  }

  export type as_actionscheduler_groupsOrderByRelevanceFieldEnum =
    (typeof as_actionscheduler_groupsOrderByRelevanceFieldEnum)[keyof typeof as_actionscheduler_groupsOrderByRelevanceFieldEnum]

  export const as_actionscheduler_logsOrderByRelevanceFieldEnum: {
    message: 'message'
  }

  export type as_actionscheduler_logsOrderByRelevanceFieldEnum =
    (typeof as_actionscheduler_logsOrderByRelevanceFieldEnum)[keyof typeof as_actionscheduler_logsOrderByRelevanceFieldEnum]

  export const as_awb_critical_cssOrderByRelevanceFieldEnum: {
    css_key: 'css_key'
    mobile_css: 'mobile_css'
    desktop_css: 'desktop_css'
    mobile_preloads: 'mobile_preloads'
    desktop_preloads: 'desktop_preloads'
    updated_at: 'updated_at'
  }

  export type as_awb_critical_cssOrderByRelevanceFieldEnum =
    (typeof as_awb_critical_cssOrderByRelevanceFieldEnum)[keyof typeof as_awb_critical_cssOrderByRelevanceFieldEnum]

  export const as_cli_cookie_scanOrderByRelevanceFieldEnum: {
    current_action: 'current_action'
  }

  export type as_cli_cookie_scanOrderByRelevanceFieldEnum =
    (typeof as_cli_cookie_scanOrderByRelevanceFieldEnum)[keyof typeof as_cli_cookie_scanOrderByRelevanceFieldEnum]

  export const as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum: {
    cli_cookie_category_name: 'cli_cookie_category_name'
    cli_cookie_category_description: 'cli_cookie_category_description'
  }

  export type as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum =
    (typeof as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum)[keyof typeof as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum]

  export const as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum: {
    cookie_id: 'cookie_id'
    expiry: 'expiry'
    type: 'type'
    category: 'category'
    description: 'description'
  }

  export type as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum =
    (typeof as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum)[keyof typeof as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum]

  export const as_cli_cookie_scan_urlOrderByRelevanceFieldEnum: {
    url: 'url'
  }

  export type as_cli_cookie_scan_urlOrderByRelevanceFieldEnum =
    (typeof as_cli_cookie_scan_urlOrderByRelevanceFieldEnum)[keyof typeof as_cli_cookie_scan_urlOrderByRelevanceFieldEnum]

  export const as_cli_scriptsOrderByRelevanceFieldEnum: {
    cliscript_title: 'cliscript_title'
    cliscript_category: 'cliscript_category'
    cliscript_status: 'cliscript_status'
    cliscript_description: 'cliscript_description'
    cliscript_key: 'cliscript_key'
  }

  export type as_cli_scriptsOrderByRelevanceFieldEnum =
    (typeof as_cli_scriptsOrderByRelevanceFieldEnum)[keyof typeof as_cli_scriptsOrderByRelevanceFieldEnum]

  export const as_commentmetaOrderByRelevanceFieldEnum: {
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type as_commentmetaOrderByRelevanceFieldEnum =
    (typeof as_commentmetaOrderByRelevanceFieldEnum)[keyof typeof as_commentmetaOrderByRelevanceFieldEnum]

  export const as_commentsOrderByRelevanceFieldEnum: {
    comment_author: 'comment_author'
    comment_author_email: 'comment_author_email'
    comment_author_url: 'comment_author_url'
    comment_author_IP: 'comment_author_IP'
    comment_content: 'comment_content'
    comment_approved: 'comment_approved'
    comment_agent: 'comment_agent'
    comment_type: 'comment_type'
  }

  export type as_commentsOrderByRelevanceFieldEnum =
    (typeof as_commentsOrderByRelevanceFieldEnum)[keyof typeof as_commentsOrderByRelevanceFieldEnum]

  export const as_fusion_form_entriesOrderByRelevanceFieldEnum: {
    value: 'value'
    data: 'data'
  }

  export type as_fusion_form_entriesOrderByRelevanceFieldEnum =
    (typeof as_fusion_form_entriesOrderByRelevanceFieldEnum)[keyof typeof as_fusion_form_entriesOrderByRelevanceFieldEnum]

  export const as_fusion_form_fieldsOrderByRelevanceFieldEnum: {
    field_name: 'field_name'
    field_label: 'field_label'
    data: 'data'
  }

  export type as_fusion_form_fieldsOrderByRelevanceFieldEnum =
    (typeof as_fusion_form_fieldsOrderByRelevanceFieldEnum)[keyof typeof as_fusion_form_fieldsOrderByRelevanceFieldEnum]

  export const as_fusion_form_submissionsOrderByRelevanceFieldEnum: {
    source_url: 'source_url'
    user_agent: 'user_agent'
    ip: 'ip'
    on_privacy_scrub: 'on_privacy_scrub'
    data: 'data'
  }

  export type as_fusion_form_submissionsOrderByRelevanceFieldEnum =
    (typeof as_fusion_form_submissionsOrderByRelevanceFieldEnum)[keyof typeof as_fusion_form_submissionsOrderByRelevanceFieldEnum]

  export const as_fusion_formsOrderByRelevanceFieldEnum: {
    data: 'data'
  }

  export type as_fusion_formsOrderByRelevanceFieldEnum =
    (typeof as_fusion_formsOrderByRelevanceFieldEnum)[keyof typeof as_fusion_formsOrderByRelevanceFieldEnum]

  export const as_layersliderOrderByRelevanceFieldEnum: {
    name: 'name'
    slug: 'slug'
    data: 'data'
  }

  export type as_layersliderOrderByRelevanceFieldEnum =
    (typeof as_layersliderOrderByRelevanceFieldEnum)[keyof typeof as_layersliderOrderByRelevanceFieldEnum]

  export const as_layerslider_revisionsOrderByRelevanceFieldEnum: {
    data: 'data'
  }

  export type as_layerslider_revisionsOrderByRelevanceFieldEnum =
    (typeof as_layerslider_revisionsOrderByRelevanceFieldEnum)[keyof typeof as_layerslider_revisionsOrderByRelevanceFieldEnum]

  export const as_linksOrderByRelevanceFieldEnum: {
    link_url: 'link_url'
    link_name: 'link_name'
    link_image: 'link_image'
    link_target: 'link_target'
    link_description: 'link_description'
    link_visible: 'link_visible'
    link_rel: 'link_rel'
    link_notes: 'link_notes'
    link_rss: 'link_rss'
  }

  export type as_linksOrderByRelevanceFieldEnum =
    (typeof as_linksOrderByRelevanceFieldEnum)[keyof typeof as_linksOrderByRelevanceFieldEnum]

  export const as_loginizer_logsOrderByRelevanceFieldEnum: {
    username: 'username'
    ip: 'ip'
    url: 'url'
  }

  export type as_loginizer_logsOrderByRelevanceFieldEnum =
    (typeof as_loginizer_logsOrderByRelevanceFieldEnum)[keyof typeof as_loginizer_logsOrderByRelevanceFieldEnum]

  export const as_optionsOrderByRelevanceFieldEnum: {
    option_name: 'option_name'
    option_value: 'option_value'
    autoload: 'autoload'
  }

  export type as_optionsOrderByRelevanceFieldEnum =
    (typeof as_optionsOrderByRelevanceFieldEnum)[keyof typeof as_optionsOrderByRelevanceFieldEnum]

  export const as_postmetaOrderByRelevanceFieldEnum: {
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type as_postmetaOrderByRelevanceFieldEnum =
    (typeof as_postmetaOrderByRelevanceFieldEnum)[keyof typeof as_postmetaOrderByRelevanceFieldEnum]

  export const as_postsOrderByRelevanceFieldEnum: {
    post_content: 'post_content'
    post_title: 'post_title'
    post_excerpt: 'post_excerpt'
    post_status: 'post_status'
    comment_status: 'comment_status'
    ping_status: 'ping_status'
    post_password: 'post_password'
    post_name: 'post_name'
    to_ping: 'to_ping'
    pinged: 'pinged'
    post_content_filtered: 'post_content_filtered'
    guid: 'guid'
    post_type: 'post_type'
    post_mime_type: 'post_mime_type'
  }

  export type as_postsOrderByRelevanceFieldEnum =
    (typeof as_postsOrderByRelevanceFieldEnum)[keyof typeof as_postsOrderByRelevanceFieldEnum]

  export const as_term_taxonomyOrderByRelevanceFieldEnum: {
    taxonomy: 'taxonomy'
    description: 'description'
  }

  export type as_term_taxonomyOrderByRelevanceFieldEnum =
    (typeof as_term_taxonomyOrderByRelevanceFieldEnum)[keyof typeof as_term_taxonomyOrderByRelevanceFieldEnum]

  export const as_termmetaOrderByRelevanceFieldEnum: {
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type as_termmetaOrderByRelevanceFieldEnum =
    (typeof as_termmetaOrderByRelevanceFieldEnum)[keyof typeof as_termmetaOrderByRelevanceFieldEnum]

  export const as_termsOrderByRelevanceFieldEnum: {
    name: 'name'
    slug: 'slug'
  }

  export type as_termsOrderByRelevanceFieldEnum =
    (typeof as_termsOrderByRelevanceFieldEnum)[keyof typeof as_termsOrderByRelevanceFieldEnum]

  export const as_tm_taskmetaOrderByRelevanceFieldEnum: {
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type as_tm_taskmetaOrderByRelevanceFieldEnum =
    (typeof as_tm_taskmetaOrderByRelevanceFieldEnum)[keyof typeof as_tm_taskmetaOrderByRelevanceFieldEnum]

  export const as_tm_tasksOrderByRelevanceFieldEnum: {
    type: 'type'
    class_identifier: 'class_identifier'
    description: 'description'
    status: 'status'
  }

  export type as_tm_tasksOrderByRelevanceFieldEnum =
    (typeof as_tm_tasksOrderByRelevanceFieldEnum)[keyof typeof as_tm_tasksOrderByRelevanceFieldEnum]

  export const as_usermetaOrderByRelevanceFieldEnum: {
    meta_key: 'meta_key'
    meta_value: 'meta_value'
  }

  export type as_usermetaOrderByRelevanceFieldEnum =
    (typeof as_usermetaOrderByRelevanceFieldEnum)[keyof typeof as_usermetaOrderByRelevanceFieldEnum]

  export const as_usersOrderByRelevanceFieldEnum: {
    user_login: 'user_login'
    user_pass: 'user_pass'
    user_nicename: 'user_nicename'
    user_email: 'user_email'
    user_url: 'user_url'
    user_activation_key: 'user_activation_key'
    display_name: 'display_name'
  }

  export type as_usersOrderByRelevanceFieldEnum =
    (typeof as_usersOrderByRelevanceFieldEnum)[keyof typeof as_usersOrderByRelevanceFieldEnum]

  export const as_wpo_404_detectorOrderByRelevanceFieldEnum: {
    url: 'url'
    referrer: 'referrer'
  }

  export type as_wpo_404_detectorOrderByRelevanceFieldEnum =
    (typeof as_wpo_404_detectorOrderByRelevanceFieldEnum)[keyof typeof as_wpo_404_detectorOrderByRelevanceFieldEnum]

  export const as_yoast_indexableOrderByRelevanceFieldEnum: {
    permalink: 'permalink'
    permalink_hash: 'permalink_hash'
    object_type: 'object_type'
    object_sub_type: 'object_sub_type'
    title: 'title'
    description: 'description'
    breadcrumb_title: 'breadcrumb_title'
    post_status: 'post_status'
    canonical: 'canonical'
    primary_focus_keyword: 'primary_focus_keyword'
    twitter_title: 'twitter_title'
    twitter_image: 'twitter_image'
    twitter_description: 'twitter_description'
    twitter_image_id: 'twitter_image_id'
    twitter_image_source: 'twitter_image_source'
    open_graph_title: 'open_graph_title'
    open_graph_description: 'open_graph_description'
    open_graph_image: 'open_graph_image'
    open_graph_image_id: 'open_graph_image_id'
    open_graph_image_source: 'open_graph_image_source'
    open_graph_image_meta: 'open_graph_image_meta'
    language: 'language'
    region: 'region'
    schema_page_type: 'schema_page_type'
    schema_article_type: 'schema_article_type'
  }

  export type as_yoast_indexableOrderByRelevanceFieldEnum =
    (typeof as_yoast_indexableOrderByRelevanceFieldEnum)[keyof typeof as_yoast_indexableOrderByRelevanceFieldEnum]

  export const as_yoast_migrationsOrderByRelevanceFieldEnum: {
    version: 'version'
  }

  export type as_yoast_migrationsOrderByRelevanceFieldEnum =
    (typeof as_yoast_migrationsOrderByRelevanceFieldEnum)[keyof typeof as_yoast_migrationsOrderByRelevanceFieldEnum]

  export const as_yoast_primary_termOrderByRelevanceFieldEnum: {
    taxonomy: 'taxonomy'
  }

  export type as_yoast_primary_termOrderByRelevanceFieldEnum =
    (typeof as_yoast_primary_termOrderByRelevanceFieldEnum)[keyof typeof as_yoast_primary_termOrderByRelevanceFieldEnum]

  export const as_yoast_seo_linksOrderByRelevanceFieldEnum: {
    url: 'url'
    type: 'type'
    language: 'language'
    region: 'region'
  }

  export type as_yoast_seo_linksOrderByRelevanceFieldEnum =
    (typeof as_yoast_seo_linksOrderByRelevanceFieldEnum)[keyof typeof as_yoast_seo_linksOrderByRelevanceFieldEnum]

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>

  /**
   * Deep Input Types
   */

  export type as_actionscheduler_actionsWhereInput = {
    AND?: as_actionscheduler_actionsWhereInput | as_actionscheduler_actionsWhereInput[]
    OR?: as_actionscheduler_actionsWhereInput[]
    NOT?: as_actionscheduler_actionsWhereInput | as_actionscheduler_actionsWhereInput[]
    action_id?: BigIntFilter<'as_actionscheduler_actions'> | bigint | number
    hook?: StringFilter<'as_actionscheduler_actions'> | string
    status?: StringFilter<'as_actionscheduler_actions'> | string
    scheduled_date_gmt?: DateTimeNullableFilter<'as_actionscheduler_actions'> | Date | string | null
    scheduled_date_local?:
      | DateTimeNullableFilter<'as_actionscheduler_actions'>
      | Date
      | string
      | null
    args?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
    schedule?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
    group_id?: BigIntFilter<'as_actionscheduler_actions'> | bigint | number
    attempts?: IntFilter<'as_actionscheduler_actions'> | number
    last_attempt_gmt?: DateTimeNullableFilter<'as_actionscheduler_actions'> | Date | string | null
    last_attempt_local?: DateTimeNullableFilter<'as_actionscheduler_actions'> | Date | string | null
    claim_id?: BigIntFilter<'as_actionscheduler_actions'> | bigint | number
    extended_args?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
    priority?: IntFilter<'as_actionscheduler_actions'> | number
  }

  export type as_actionscheduler_actionsOrderByWithRelationInput = {
    action_id?: SortOrder
    hook?: SortOrder
    status?: SortOrder
    scheduled_date_gmt?: SortOrderInput | SortOrder
    scheduled_date_local?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    last_attempt_gmt?: SortOrderInput | SortOrder
    last_attempt_local?: SortOrderInput | SortOrder
    claim_id?: SortOrder
    extended_args?: SortOrderInput | SortOrder
    priority?: SortOrder
    _relevance?: as_actionscheduler_actionsOrderByRelevanceInput
  }

  export type as_actionscheduler_actionsWhereUniqueInput = Prisma.AtLeast<
    {
      action_id?: bigint | number
      AND?: as_actionscheduler_actionsWhereInput | as_actionscheduler_actionsWhereInput[]
      OR?: as_actionscheduler_actionsWhereInput[]
      NOT?: as_actionscheduler_actionsWhereInput | as_actionscheduler_actionsWhereInput[]
      hook?: StringFilter<'as_actionscheduler_actions'> | string
      status?: StringFilter<'as_actionscheduler_actions'> | string
      scheduled_date_gmt?:
        | DateTimeNullableFilter<'as_actionscheduler_actions'>
        | Date
        | string
        | null
      scheduled_date_local?:
        | DateTimeNullableFilter<'as_actionscheduler_actions'>
        | Date
        | string
        | null
      args?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
      schedule?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
      group_id?: BigIntFilter<'as_actionscheduler_actions'> | bigint | number
      attempts?: IntFilter<'as_actionscheduler_actions'> | number
      last_attempt_gmt?: DateTimeNullableFilter<'as_actionscheduler_actions'> | Date | string | null
      last_attempt_local?:
        | DateTimeNullableFilter<'as_actionscheduler_actions'>
        | Date
        | string
        | null
      claim_id?: BigIntFilter<'as_actionscheduler_actions'> | bigint | number
      extended_args?: StringNullableFilter<'as_actionscheduler_actions'> | string | null
      priority?: IntFilter<'as_actionscheduler_actions'> | number
    },
    'action_id'
  >

  export type as_actionscheduler_actionsOrderByWithAggregationInput = {
    action_id?: SortOrder
    hook?: SortOrder
    status?: SortOrder
    scheduled_date_gmt?: SortOrderInput | SortOrder
    scheduled_date_local?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    last_attempt_gmt?: SortOrderInput | SortOrder
    last_attempt_local?: SortOrderInput | SortOrder
    claim_id?: SortOrder
    extended_args?: SortOrderInput | SortOrder
    priority?: SortOrder
    _count?: as_actionscheduler_actionsCountOrderByAggregateInput
    _avg?: as_actionscheduler_actionsAvgOrderByAggregateInput
    _max?: as_actionscheduler_actionsMaxOrderByAggregateInput
    _min?: as_actionscheduler_actionsMinOrderByAggregateInput
    _sum?: as_actionscheduler_actionsSumOrderByAggregateInput
  }

  export type as_actionscheduler_actionsScalarWhereWithAggregatesInput = {
    AND?:
      | as_actionscheduler_actionsScalarWhereWithAggregatesInput
      | as_actionscheduler_actionsScalarWhereWithAggregatesInput[]
    OR?: as_actionscheduler_actionsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_actionscheduler_actionsScalarWhereWithAggregatesInput
      | as_actionscheduler_actionsScalarWhereWithAggregatesInput[]
    action_id?: BigIntWithAggregatesFilter<'as_actionscheduler_actions'> | bigint | number
    hook?: StringWithAggregatesFilter<'as_actionscheduler_actions'> | string
    status?: StringWithAggregatesFilter<'as_actionscheduler_actions'> | string
    scheduled_date_gmt?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_actions'>
      | Date
      | string
      | null
    scheduled_date_local?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_actions'>
      | Date
      | string
      | null
    args?: StringNullableWithAggregatesFilter<'as_actionscheduler_actions'> | string | null
    schedule?: StringNullableWithAggregatesFilter<'as_actionscheduler_actions'> | string | null
    group_id?: BigIntWithAggregatesFilter<'as_actionscheduler_actions'> | bigint | number
    attempts?: IntWithAggregatesFilter<'as_actionscheduler_actions'> | number
    last_attempt_gmt?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_actions'>
      | Date
      | string
      | null
    last_attempt_local?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_actions'>
      | Date
      | string
      | null
    claim_id?: BigIntWithAggregatesFilter<'as_actionscheduler_actions'> | bigint | number
    extended_args?: StringNullableWithAggregatesFilter<'as_actionscheduler_actions'> | string | null
    priority?: IntWithAggregatesFilter<'as_actionscheduler_actions'> | number
  }

  export type as_actionscheduler_claimsWhereInput = {
    AND?: as_actionscheduler_claimsWhereInput | as_actionscheduler_claimsWhereInput[]
    OR?: as_actionscheduler_claimsWhereInput[]
    NOT?: as_actionscheduler_claimsWhereInput | as_actionscheduler_claimsWhereInput[]
    claim_id?: BigIntFilter<'as_actionscheduler_claims'> | bigint | number
    date_created_gmt?: DateTimeNullableFilter<'as_actionscheduler_claims'> | Date | string | null
  }

  export type as_actionscheduler_claimsOrderByWithRelationInput = {
    claim_id?: SortOrder
    date_created_gmt?: SortOrderInput | SortOrder
  }

  export type as_actionscheduler_claimsWhereUniqueInput = Prisma.AtLeast<
    {
      claim_id?: bigint | number
      AND?: as_actionscheduler_claimsWhereInput | as_actionscheduler_claimsWhereInput[]
      OR?: as_actionscheduler_claimsWhereInput[]
      NOT?: as_actionscheduler_claimsWhereInput | as_actionscheduler_claimsWhereInput[]
      date_created_gmt?: DateTimeNullableFilter<'as_actionscheduler_claims'> | Date | string | null
    },
    'claim_id'
  >

  export type as_actionscheduler_claimsOrderByWithAggregationInput = {
    claim_id?: SortOrder
    date_created_gmt?: SortOrderInput | SortOrder
    _count?: as_actionscheduler_claimsCountOrderByAggregateInput
    _avg?: as_actionscheduler_claimsAvgOrderByAggregateInput
    _max?: as_actionscheduler_claimsMaxOrderByAggregateInput
    _min?: as_actionscheduler_claimsMinOrderByAggregateInput
    _sum?: as_actionscheduler_claimsSumOrderByAggregateInput
  }

  export type as_actionscheduler_claimsScalarWhereWithAggregatesInput = {
    AND?:
      | as_actionscheduler_claimsScalarWhereWithAggregatesInput
      | as_actionscheduler_claimsScalarWhereWithAggregatesInput[]
    OR?: as_actionscheduler_claimsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_actionscheduler_claimsScalarWhereWithAggregatesInput
      | as_actionscheduler_claimsScalarWhereWithAggregatesInput[]
    claim_id?: BigIntWithAggregatesFilter<'as_actionscheduler_claims'> | bigint | number
    date_created_gmt?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_claims'>
      | Date
      | string
      | null
  }

  export type as_actionscheduler_groupsWhereInput = {
    AND?: as_actionscheduler_groupsWhereInput | as_actionscheduler_groupsWhereInput[]
    OR?: as_actionscheduler_groupsWhereInput[]
    NOT?: as_actionscheduler_groupsWhereInput | as_actionscheduler_groupsWhereInput[]
    group_id?: BigIntFilter<'as_actionscheduler_groups'> | bigint | number
    slug?: StringFilter<'as_actionscheduler_groups'> | string
  }

  export type as_actionscheduler_groupsOrderByWithRelationInput = {
    group_id?: SortOrder
    slug?: SortOrder
    _relevance?: as_actionscheduler_groupsOrderByRelevanceInput
  }

  export type as_actionscheduler_groupsWhereUniqueInput = Prisma.AtLeast<
    {
      group_id?: bigint | number
      AND?: as_actionscheduler_groupsWhereInput | as_actionscheduler_groupsWhereInput[]
      OR?: as_actionscheduler_groupsWhereInput[]
      NOT?: as_actionscheduler_groupsWhereInput | as_actionscheduler_groupsWhereInput[]
      slug?: StringFilter<'as_actionscheduler_groups'> | string
    },
    'group_id'
  >

  export type as_actionscheduler_groupsOrderByWithAggregationInput = {
    group_id?: SortOrder
    slug?: SortOrder
    _count?: as_actionscheduler_groupsCountOrderByAggregateInput
    _avg?: as_actionscheduler_groupsAvgOrderByAggregateInput
    _max?: as_actionscheduler_groupsMaxOrderByAggregateInput
    _min?: as_actionscheduler_groupsMinOrderByAggregateInput
    _sum?: as_actionscheduler_groupsSumOrderByAggregateInput
  }

  export type as_actionscheduler_groupsScalarWhereWithAggregatesInput = {
    AND?:
      | as_actionscheduler_groupsScalarWhereWithAggregatesInput
      | as_actionscheduler_groupsScalarWhereWithAggregatesInput[]
    OR?: as_actionscheduler_groupsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_actionscheduler_groupsScalarWhereWithAggregatesInput
      | as_actionscheduler_groupsScalarWhereWithAggregatesInput[]
    group_id?: BigIntWithAggregatesFilter<'as_actionscheduler_groups'> | bigint | number
    slug?: StringWithAggregatesFilter<'as_actionscheduler_groups'> | string
  }

  export type as_actionscheduler_logsWhereInput = {
    AND?: as_actionscheduler_logsWhereInput | as_actionscheduler_logsWhereInput[]
    OR?: as_actionscheduler_logsWhereInput[]
    NOT?: as_actionscheduler_logsWhereInput | as_actionscheduler_logsWhereInput[]
    log_id?: BigIntFilter<'as_actionscheduler_logs'> | bigint | number
    action_id?: BigIntFilter<'as_actionscheduler_logs'> | bigint | number
    message?: StringFilter<'as_actionscheduler_logs'> | string
    log_date_gmt?: DateTimeNullableFilter<'as_actionscheduler_logs'> | Date | string | null
    log_date_local?: DateTimeNullableFilter<'as_actionscheduler_logs'> | Date | string | null
  }

  export type as_actionscheduler_logsOrderByWithRelationInput = {
    log_id?: SortOrder
    action_id?: SortOrder
    message?: SortOrder
    log_date_gmt?: SortOrderInput | SortOrder
    log_date_local?: SortOrderInput | SortOrder
    _relevance?: as_actionscheduler_logsOrderByRelevanceInput
  }

  export type as_actionscheduler_logsWhereUniqueInput = Prisma.AtLeast<
    {
      log_id?: bigint | number
      AND?: as_actionscheduler_logsWhereInput | as_actionscheduler_logsWhereInput[]
      OR?: as_actionscheduler_logsWhereInput[]
      NOT?: as_actionscheduler_logsWhereInput | as_actionscheduler_logsWhereInput[]
      action_id?: BigIntFilter<'as_actionscheduler_logs'> | bigint | number
      message?: StringFilter<'as_actionscheduler_logs'> | string
      log_date_gmt?: DateTimeNullableFilter<'as_actionscheduler_logs'> | Date | string | null
      log_date_local?: DateTimeNullableFilter<'as_actionscheduler_logs'> | Date | string | null
    },
    'log_id'
  >

  export type as_actionscheduler_logsOrderByWithAggregationInput = {
    log_id?: SortOrder
    action_id?: SortOrder
    message?: SortOrder
    log_date_gmt?: SortOrderInput | SortOrder
    log_date_local?: SortOrderInput | SortOrder
    _count?: as_actionscheduler_logsCountOrderByAggregateInput
    _avg?: as_actionscheduler_logsAvgOrderByAggregateInput
    _max?: as_actionscheduler_logsMaxOrderByAggregateInput
    _min?: as_actionscheduler_logsMinOrderByAggregateInput
    _sum?: as_actionscheduler_logsSumOrderByAggregateInput
  }

  export type as_actionscheduler_logsScalarWhereWithAggregatesInput = {
    AND?:
      | as_actionscheduler_logsScalarWhereWithAggregatesInput
      | as_actionscheduler_logsScalarWhereWithAggregatesInput[]
    OR?: as_actionscheduler_logsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_actionscheduler_logsScalarWhereWithAggregatesInput
      | as_actionscheduler_logsScalarWhereWithAggregatesInput[]
    log_id?: BigIntWithAggregatesFilter<'as_actionscheduler_logs'> | bigint | number
    action_id?: BigIntWithAggregatesFilter<'as_actionscheduler_logs'> | bigint | number
    message?: StringWithAggregatesFilter<'as_actionscheduler_logs'> | string
    log_date_gmt?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_logs'>
      | Date
      | string
      | null
    log_date_local?:
      | DateTimeNullableWithAggregatesFilter<'as_actionscheduler_logs'>
      | Date
      | string
      | null
  }

  export type as_awb_critical_cssWhereInput = {
    AND?: as_awb_critical_cssWhereInput | as_awb_critical_cssWhereInput[]
    OR?: as_awb_critical_cssWhereInput[]
    NOT?: as_awb_critical_cssWhereInput | as_awb_critical_cssWhereInput[]
    id?: BigIntFilter<'as_awb_critical_css'> | bigint | number
    css_key?: StringFilter<'as_awb_critical_css'> | string
    mobile_css?: StringFilter<'as_awb_critical_css'> | string
    desktop_css?: StringFilter<'as_awb_critical_css'> | string
    mobile_preloads?: StringFilter<'as_awb_critical_css'> | string
    desktop_preloads?: StringFilter<'as_awb_critical_css'> | string
    updated_at?: StringFilter<'as_awb_critical_css'> | string
  }

  export type as_awb_critical_cssOrderByWithRelationInput = {
    id?: SortOrder
    css_key?: SortOrder
    mobile_css?: SortOrder
    desktop_css?: SortOrder
    mobile_preloads?: SortOrder
    desktop_preloads?: SortOrder
    updated_at?: SortOrder
    _relevance?: as_awb_critical_cssOrderByRelevanceInput
  }

  export type as_awb_critical_cssWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: as_awb_critical_cssWhereInput | as_awb_critical_cssWhereInput[]
      OR?: as_awb_critical_cssWhereInput[]
      NOT?: as_awb_critical_cssWhereInput | as_awb_critical_cssWhereInput[]
      css_key?: StringFilter<'as_awb_critical_css'> | string
      mobile_css?: StringFilter<'as_awb_critical_css'> | string
      desktop_css?: StringFilter<'as_awb_critical_css'> | string
      mobile_preloads?: StringFilter<'as_awb_critical_css'> | string
      desktop_preloads?: StringFilter<'as_awb_critical_css'> | string
      updated_at?: StringFilter<'as_awb_critical_css'> | string
    },
    'id' | 'id'
  >

  export type as_awb_critical_cssOrderByWithAggregationInput = {
    id?: SortOrder
    css_key?: SortOrder
    mobile_css?: SortOrder
    desktop_css?: SortOrder
    mobile_preloads?: SortOrder
    desktop_preloads?: SortOrder
    updated_at?: SortOrder
    _count?: as_awb_critical_cssCountOrderByAggregateInput
    _avg?: as_awb_critical_cssAvgOrderByAggregateInput
    _max?: as_awb_critical_cssMaxOrderByAggregateInput
    _min?: as_awb_critical_cssMinOrderByAggregateInput
    _sum?: as_awb_critical_cssSumOrderByAggregateInput
  }

  export type as_awb_critical_cssScalarWhereWithAggregatesInput = {
    AND?:
      | as_awb_critical_cssScalarWhereWithAggregatesInput
      | as_awb_critical_cssScalarWhereWithAggregatesInput[]
    OR?: as_awb_critical_cssScalarWhereWithAggregatesInput[]
    NOT?:
      | as_awb_critical_cssScalarWhereWithAggregatesInput
      | as_awb_critical_cssScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_awb_critical_css'> | bigint | number
    css_key?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
    mobile_css?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
    desktop_css?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
    mobile_preloads?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
    desktop_preloads?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
    updated_at?: StringWithAggregatesFilter<'as_awb_critical_css'> | string
  }

  export type as_cli_cookie_scanWhereInput = {
    AND?: as_cli_cookie_scanWhereInput | as_cli_cookie_scanWhereInput[]
    OR?: as_cli_cookie_scanWhereInput[]
    NOT?: as_cli_cookie_scanWhereInput | as_cli_cookie_scanWhereInput[]
    id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan'> | number
    status?: IntFilter<'as_cli_cookie_scan'> | number
    created_at?: IntFilter<'as_cli_cookie_scan'> | number
    total_url?: IntFilter<'as_cli_cookie_scan'> | number
    total_cookies?: IntFilter<'as_cli_cookie_scan'> | number
    current_action?: StringFilter<'as_cli_cookie_scan'> | string
    current_offset?: IntFilter<'as_cli_cookie_scan'> | number
  }

  export type as_cli_cookie_scanOrderByWithRelationInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_action?: SortOrder
    current_offset?: SortOrder
    _relevance?: as_cli_cookie_scanOrderByRelevanceInput
  }

  export type as_cli_cookie_scanWhereUniqueInput = Prisma.AtLeast<
    {
      id_cli_cookie_scan?: number
      AND?: as_cli_cookie_scanWhereInput | as_cli_cookie_scanWhereInput[]
      OR?: as_cli_cookie_scanWhereInput[]
      NOT?: as_cli_cookie_scanWhereInput | as_cli_cookie_scanWhereInput[]
      status?: IntFilter<'as_cli_cookie_scan'> | number
      created_at?: IntFilter<'as_cli_cookie_scan'> | number
      total_url?: IntFilter<'as_cli_cookie_scan'> | number
      total_cookies?: IntFilter<'as_cli_cookie_scan'> | number
      current_action?: StringFilter<'as_cli_cookie_scan'> | string
      current_offset?: IntFilter<'as_cli_cookie_scan'> | number
    },
    'id_cli_cookie_scan'
  >

  export type as_cli_cookie_scanOrderByWithAggregationInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_action?: SortOrder
    current_offset?: SortOrder
    _count?: as_cli_cookie_scanCountOrderByAggregateInput
    _avg?: as_cli_cookie_scanAvgOrderByAggregateInput
    _max?: as_cli_cookie_scanMaxOrderByAggregateInput
    _min?: as_cli_cookie_scanMinOrderByAggregateInput
    _sum?: as_cli_cookie_scanSumOrderByAggregateInput
  }

  export type as_cli_cookie_scanScalarWhereWithAggregatesInput = {
    AND?:
      | as_cli_cookie_scanScalarWhereWithAggregatesInput
      | as_cli_cookie_scanScalarWhereWithAggregatesInput[]
    OR?: as_cli_cookie_scanScalarWhereWithAggregatesInput[]
    NOT?:
      | as_cli_cookie_scanScalarWhereWithAggregatesInput
      | as_cli_cookie_scanScalarWhereWithAggregatesInput[]
    id_cli_cookie_scan?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
    status?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
    created_at?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
    total_url?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
    total_cookies?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
    current_action?: StringWithAggregatesFilter<'as_cli_cookie_scan'> | string
    current_offset?: IntWithAggregatesFilter<'as_cli_cookie_scan'> | number
  }

  export type as_cli_cookie_scan_categoriesWhereInput = {
    AND?: as_cli_cookie_scan_categoriesWhereInput | as_cli_cookie_scan_categoriesWhereInput[]
    OR?: as_cli_cookie_scan_categoriesWhereInput[]
    NOT?: as_cli_cookie_scan_categoriesWhereInput | as_cli_cookie_scan_categoriesWhereInput[]
    id_cli_cookie_category?: IntFilter<'as_cli_cookie_scan_categories'> | number
    cli_cookie_category_name?: StringFilter<'as_cli_cookie_scan_categories'> | string
    cli_cookie_category_description?:
      | StringNullableFilter<'as_cli_cookie_scan_categories'>
      | string
      | null
    as_cli_cookie_scan_cookies?: As_cli_cookie_scan_cookiesListRelationFilter
  }

  export type as_cli_cookie_scan_categoriesOrderByWithRelationInput = {
    id_cli_cookie_category?: SortOrder
    cli_cookie_category_name?: SortOrder
    cli_cookie_category_description?: SortOrderInput | SortOrder
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesOrderByRelationAggregateInput
    _relevance?: as_cli_cookie_scan_categoriesOrderByRelevanceInput
  }

  export type as_cli_cookie_scan_categoriesWhereUniqueInput = Prisma.AtLeast<
    {
      id_cli_cookie_category?: number
      cli_cookie_category_name?: string
      AND?: as_cli_cookie_scan_categoriesWhereInput | as_cli_cookie_scan_categoriesWhereInput[]
      OR?: as_cli_cookie_scan_categoriesWhereInput[]
      NOT?: as_cli_cookie_scan_categoriesWhereInput | as_cli_cookie_scan_categoriesWhereInput[]
      cli_cookie_category_description?:
        | StringNullableFilter<'as_cli_cookie_scan_categories'>
        | string
        | null
      as_cli_cookie_scan_cookies?: As_cli_cookie_scan_cookiesListRelationFilter
    },
    'id_cli_cookie_category' | 'cli_cookie_category_name'
  >

  export type as_cli_cookie_scan_categoriesOrderByWithAggregationInput = {
    id_cli_cookie_category?: SortOrder
    cli_cookie_category_name?: SortOrder
    cli_cookie_category_description?: SortOrderInput | SortOrder
    _count?: as_cli_cookie_scan_categoriesCountOrderByAggregateInput
    _avg?: as_cli_cookie_scan_categoriesAvgOrderByAggregateInput
    _max?: as_cli_cookie_scan_categoriesMaxOrderByAggregateInput
    _min?: as_cli_cookie_scan_categoriesMinOrderByAggregateInput
    _sum?: as_cli_cookie_scan_categoriesSumOrderByAggregateInput
  }

  export type as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput = {
    AND?:
      | as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput[]
    OR?: as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput[]
    NOT?:
      | as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_categoriesScalarWhereWithAggregatesInput[]
    id_cli_cookie_category?: IntWithAggregatesFilter<'as_cli_cookie_scan_categories'> | number
    cli_cookie_category_name?: StringWithAggregatesFilter<'as_cli_cookie_scan_categories'> | string
    cli_cookie_category_description?:
      | StringNullableWithAggregatesFilter<'as_cli_cookie_scan_categories'>
      | string
      | null
  }

  export type as_cli_cookie_scan_cookiesWhereInput = {
    AND?: as_cli_cookie_scan_cookiesWhereInput | as_cli_cookie_scan_cookiesWhereInput[]
    OR?: as_cli_cookie_scan_cookiesWhereInput[]
    NOT?: as_cli_cookie_scan_cookiesWhereInput | as_cli_cookie_scan_cookiesWhereInput[]
    id_cli_cookie_scan_cookies?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan_url?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    cookie_id?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    expiry?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    type?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    category?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    category_id?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    description?: StringNullableFilter<'as_cli_cookie_scan_cookies'> | string | null
    as_cli_cookie_scan_categories?: XOR<
      As_cli_cookie_scan_categoriesScalarRelationFilter,
      as_cli_cookie_scan_categoriesWhereInput
    >
  }

  export type as_cli_cookie_scan_cookiesOrderByWithRelationInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    cookie_id?: SortOrder
    expiry?: SortOrder
    type?: SortOrder
    category?: SortOrder
    category_id?: SortOrder
    description?: SortOrderInput | SortOrder
    as_cli_cookie_scan_categories?: as_cli_cookie_scan_categoriesOrderByWithRelationInput
    _relevance?: as_cli_cookie_scan_cookiesOrderByRelevanceInput
  }

  export type as_cli_cookie_scan_cookiesWhereUniqueInput = Prisma.AtLeast<
    {
      id_cli_cookie_scan_cookies?: number
      id_cli_cookie_scan_cookie_id?: as_cli_cookie_scan_cookiesId_cli_cookie_scanCookie_idCompoundUniqueInput
      AND?: as_cli_cookie_scan_cookiesWhereInput | as_cli_cookie_scan_cookiesWhereInput[]
      OR?: as_cli_cookie_scan_cookiesWhereInput[]
      NOT?: as_cli_cookie_scan_cookiesWhereInput | as_cli_cookie_scan_cookiesWhereInput[]
      id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan_cookies'> | number
      id_cli_cookie_scan_url?: IntFilter<'as_cli_cookie_scan_cookies'> | number
      cookie_id?: StringFilter<'as_cli_cookie_scan_cookies'> | string
      expiry?: StringFilter<'as_cli_cookie_scan_cookies'> | string
      type?: StringFilter<'as_cli_cookie_scan_cookies'> | string
      category?: StringFilter<'as_cli_cookie_scan_cookies'> | string
      category_id?: IntFilter<'as_cli_cookie_scan_cookies'> | number
      description?: StringNullableFilter<'as_cli_cookie_scan_cookies'> | string | null
      as_cli_cookie_scan_categories?: XOR<
        As_cli_cookie_scan_categoriesScalarRelationFilter,
        as_cli_cookie_scan_categoriesWhereInput
      >
    },
    'id_cli_cookie_scan_cookies' | 'id_cli_cookie_scan_cookie_id'
  >

  export type as_cli_cookie_scan_cookiesOrderByWithAggregationInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    cookie_id?: SortOrder
    expiry?: SortOrder
    type?: SortOrder
    category?: SortOrder
    category_id?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: as_cli_cookie_scan_cookiesCountOrderByAggregateInput
    _avg?: as_cli_cookie_scan_cookiesAvgOrderByAggregateInput
    _max?: as_cli_cookie_scan_cookiesMaxOrderByAggregateInput
    _min?: as_cli_cookie_scan_cookiesMinOrderByAggregateInput
    _sum?: as_cli_cookie_scan_cookiesSumOrderByAggregateInput
  }

  export type as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput = {
    AND?:
      | as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput[]
    OR?: as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput[]
    NOT?:
      | as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_cookiesScalarWhereWithAggregatesInput[]
    id_cli_cookie_scan_cookies?: IntWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan?: IntWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan_url?: IntWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | number
    cookie_id?: StringWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | string
    expiry?: StringWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | string
    type?: StringWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | string
    category?: StringWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | string
    category_id?: IntWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | number
    description?: StringNullableWithAggregatesFilter<'as_cli_cookie_scan_cookies'> | string | null
  }

  export type as_cli_cookie_scan_urlWhereInput = {
    AND?: as_cli_cookie_scan_urlWhereInput | as_cli_cookie_scan_urlWhereInput[]
    OR?: as_cli_cookie_scan_urlWhereInput[]
    NOT?: as_cli_cookie_scan_urlWhereInput | as_cli_cookie_scan_urlWhereInput[]
    id_cli_cookie_scan_url?: IntFilter<'as_cli_cookie_scan_url'> | number
    id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan_url'> | number
    url?: StringFilter<'as_cli_cookie_scan_url'> | string
    scanned?: IntFilter<'as_cli_cookie_scan_url'> | number
    total_cookies?: IntFilter<'as_cli_cookie_scan_url'> | number
  }

  export type as_cli_cookie_scan_urlOrderByWithRelationInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    url?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
    _relevance?: as_cli_cookie_scan_urlOrderByRelevanceInput
  }

  export type as_cli_cookie_scan_urlWhereUniqueInput = Prisma.AtLeast<
    {
      id_cli_cookie_scan_url?: number
      AND?: as_cli_cookie_scan_urlWhereInput | as_cli_cookie_scan_urlWhereInput[]
      OR?: as_cli_cookie_scan_urlWhereInput[]
      NOT?: as_cli_cookie_scan_urlWhereInput | as_cli_cookie_scan_urlWhereInput[]
      id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan_url'> | number
      url?: StringFilter<'as_cli_cookie_scan_url'> | string
      scanned?: IntFilter<'as_cli_cookie_scan_url'> | number
      total_cookies?: IntFilter<'as_cli_cookie_scan_url'> | number
    },
    'id_cli_cookie_scan_url'
  >

  export type as_cli_cookie_scan_urlOrderByWithAggregationInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    url?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
    _count?: as_cli_cookie_scan_urlCountOrderByAggregateInput
    _avg?: as_cli_cookie_scan_urlAvgOrderByAggregateInput
    _max?: as_cli_cookie_scan_urlMaxOrderByAggregateInput
    _min?: as_cli_cookie_scan_urlMinOrderByAggregateInput
    _sum?: as_cli_cookie_scan_urlSumOrderByAggregateInput
  }

  export type as_cli_cookie_scan_urlScalarWhereWithAggregatesInput = {
    AND?:
      | as_cli_cookie_scan_urlScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_urlScalarWhereWithAggregatesInput[]
    OR?: as_cli_cookie_scan_urlScalarWhereWithAggregatesInput[]
    NOT?:
      | as_cli_cookie_scan_urlScalarWhereWithAggregatesInput
      | as_cli_cookie_scan_urlScalarWhereWithAggregatesInput[]
    id_cli_cookie_scan_url?: IntWithAggregatesFilter<'as_cli_cookie_scan_url'> | number
    id_cli_cookie_scan?: IntWithAggregatesFilter<'as_cli_cookie_scan_url'> | number
    url?: StringWithAggregatesFilter<'as_cli_cookie_scan_url'> | string
    scanned?: IntWithAggregatesFilter<'as_cli_cookie_scan_url'> | number
    total_cookies?: IntWithAggregatesFilter<'as_cli_cookie_scan_url'> | number
  }

  export type as_cli_scriptsWhereInput = {
    AND?: as_cli_scriptsWhereInput | as_cli_scriptsWhereInput[]
    OR?: as_cli_scriptsWhereInput[]
    NOT?: as_cli_scriptsWhereInput | as_cli_scriptsWhereInput[]
    id?: IntFilter<'as_cli_scripts'> | number
    cliscript_title?: StringFilter<'as_cli_scripts'> | string
    cliscript_category?: StringFilter<'as_cli_scripts'> | string
    cliscript_type?: IntNullableFilter<'as_cli_scripts'> | number | null
    cliscript_status?: StringFilter<'as_cli_scripts'> | string
    cliscript_description?: StringFilter<'as_cli_scripts'> | string
    cliscript_key?: StringFilter<'as_cli_scripts'> | string
    type?: IntFilter<'as_cli_scripts'> | number
  }

  export type as_cli_scriptsOrderByWithRelationInput = {
    id?: SortOrder
    cliscript_title?: SortOrder
    cliscript_category?: SortOrder
    cliscript_type?: SortOrderInput | SortOrder
    cliscript_status?: SortOrder
    cliscript_description?: SortOrder
    cliscript_key?: SortOrder
    type?: SortOrder
    _relevance?: as_cli_scriptsOrderByRelevanceInput
  }

  export type as_cli_scriptsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_cli_scriptsWhereInput | as_cli_scriptsWhereInput[]
      OR?: as_cli_scriptsWhereInput[]
      NOT?: as_cli_scriptsWhereInput | as_cli_scriptsWhereInput[]
      cliscript_title?: StringFilter<'as_cli_scripts'> | string
      cliscript_category?: StringFilter<'as_cli_scripts'> | string
      cliscript_type?: IntNullableFilter<'as_cli_scripts'> | number | null
      cliscript_status?: StringFilter<'as_cli_scripts'> | string
      cliscript_description?: StringFilter<'as_cli_scripts'> | string
      cliscript_key?: StringFilter<'as_cli_scripts'> | string
      type?: IntFilter<'as_cli_scripts'> | number
    },
    'id'
  >

  export type as_cli_scriptsOrderByWithAggregationInput = {
    id?: SortOrder
    cliscript_title?: SortOrder
    cliscript_category?: SortOrder
    cliscript_type?: SortOrderInput | SortOrder
    cliscript_status?: SortOrder
    cliscript_description?: SortOrder
    cliscript_key?: SortOrder
    type?: SortOrder
    _count?: as_cli_scriptsCountOrderByAggregateInput
    _avg?: as_cli_scriptsAvgOrderByAggregateInput
    _max?: as_cli_scriptsMaxOrderByAggregateInput
    _min?: as_cli_scriptsMinOrderByAggregateInput
    _sum?: as_cli_scriptsSumOrderByAggregateInput
  }

  export type as_cli_scriptsScalarWhereWithAggregatesInput = {
    AND?:
      | as_cli_scriptsScalarWhereWithAggregatesInput
      | as_cli_scriptsScalarWhereWithAggregatesInput[]
    OR?: as_cli_scriptsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_cli_scriptsScalarWhereWithAggregatesInput
      | as_cli_scriptsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_cli_scripts'> | number
    cliscript_title?: StringWithAggregatesFilter<'as_cli_scripts'> | string
    cliscript_category?: StringWithAggregatesFilter<'as_cli_scripts'> | string
    cliscript_type?: IntNullableWithAggregatesFilter<'as_cli_scripts'> | number | null
    cliscript_status?: StringWithAggregatesFilter<'as_cli_scripts'> | string
    cliscript_description?: StringWithAggregatesFilter<'as_cli_scripts'> | string
    cliscript_key?: StringWithAggregatesFilter<'as_cli_scripts'> | string
    type?: IntWithAggregatesFilter<'as_cli_scripts'> | number
  }

  export type as_commentmetaWhereInput = {
    AND?: as_commentmetaWhereInput | as_commentmetaWhereInput[]
    OR?: as_commentmetaWhereInput[]
    NOT?: as_commentmetaWhereInput | as_commentmetaWhereInput[]
    meta_id?: BigIntFilter<'as_commentmeta'> | bigint | number
    comment_id?: BigIntFilter<'as_commentmeta'> | bigint | number
    meta_key?: StringNullableFilter<'as_commentmeta'> | string | null
    meta_value?: StringNullableFilter<'as_commentmeta'> | string | null
  }

  export type as_commentmetaOrderByWithRelationInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _relevance?: as_commentmetaOrderByRelevanceInput
  }

  export type as_commentmetaWhereUniqueInput = Prisma.AtLeast<
    {
      meta_id?: bigint | number
      AND?: as_commentmetaWhereInput | as_commentmetaWhereInput[]
      OR?: as_commentmetaWhereInput[]
      NOT?: as_commentmetaWhereInput | as_commentmetaWhereInput[]
      comment_id?: BigIntFilter<'as_commentmeta'> | bigint | number
      meta_key?: StringNullableFilter<'as_commentmeta'> | string | null
      meta_value?: StringNullableFilter<'as_commentmeta'> | string | null
    },
    'meta_id'
  >

  export type as_commentmetaOrderByWithAggregationInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _count?: as_commentmetaCountOrderByAggregateInput
    _avg?: as_commentmetaAvgOrderByAggregateInput
    _max?: as_commentmetaMaxOrderByAggregateInput
    _min?: as_commentmetaMinOrderByAggregateInput
    _sum?: as_commentmetaSumOrderByAggregateInput
  }

  export type as_commentmetaScalarWhereWithAggregatesInput = {
    AND?:
      | as_commentmetaScalarWhereWithAggregatesInput
      | as_commentmetaScalarWhereWithAggregatesInput[]
    OR?: as_commentmetaScalarWhereWithAggregatesInput[]
    NOT?:
      | as_commentmetaScalarWhereWithAggregatesInput
      | as_commentmetaScalarWhereWithAggregatesInput[]
    meta_id?: BigIntWithAggregatesFilter<'as_commentmeta'> | bigint | number
    comment_id?: BigIntWithAggregatesFilter<'as_commentmeta'> | bigint | number
    meta_key?: StringNullableWithAggregatesFilter<'as_commentmeta'> | string | null
    meta_value?: StringNullableWithAggregatesFilter<'as_commentmeta'> | string | null
  }

  export type as_commentsWhereInput = {
    AND?: as_commentsWhereInput | as_commentsWhereInput[]
    OR?: as_commentsWhereInput[]
    NOT?: as_commentsWhereInput | as_commentsWhereInput[]
    comment_ID?: BigIntFilter<'as_comments'> | bigint | number
    comment_post_ID?: BigIntFilter<'as_comments'> | bigint | number
    comment_author?: StringFilter<'as_comments'> | string
    comment_author_email?: StringFilter<'as_comments'> | string
    comment_author_url?: StringFilter<'as_comments'> | string
    comment_author_IP?: StringFilter<'as_comments'> | string
    comment_date?: DateTimeFilter<'as_comments'> | Date | string
    comment_date_gmt?: DateTimeFilter<'as_comments'> | Date | string
    comment_content?: StringFilter<'as_comments'> | string
    comment_karma?: IntFilter<'as_comments'> | number
    comment_approved?: StringFilter<'as_comments'> | string
    comment_agent?: StringFilter<'as_comments'> | string
    comment_type?: StringFilter<'as_comments'> | string
    comment_parent?: BigIntFilter<'as_comments'> | bigint | number
    user_id?: BigIntFilter<'as_comments'> | bigint | number
  }

  export type as_commentsOrderByWithRelationInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_author?: SortOrder
    comment_author_email?: SortOrder
    comment_author_url?: SortOrder
    comment_author_IP?: SortOrder
    comment_date?: SortOrder
    comment_date_gmt?: SortOrder
    comment_content?: SortOrder
    comment_karma?: SortOrder
    comment_approved?: SortOrder
    comment_agent?: SortOrder
    comment_type?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
    _relevance?: as_commentsOrderByRelevanceInput
  }

  export type as_commentsWhereUniqueInput = Prisma.AtLeast<
    {
      comment_ID?: bigint | number
      AND?: as_commentsWhereInput | as_commentsWhereInput[]
      OR?: as_commentsWhereInput[]
      NOT?: as_commentsWhereInput | as_commentsWhereInput[]
      comment_post_ID?: BigIntFilter<'as_comments'> | bigint | number
      comment_author?: StringFilter<'as_comments'> | string
      comment_author_email?: StringFilter<'as_comments'> | string
      comment_author_url?: StringFilter<'as_comments'> | string
      comment_author_IP?: StringFilter<'as_comments'> | string
      comment_date?: DateTimeFilter<'as_comments'> | Date | string
      comment_date_gmt?: DateTimeFilter<'as_comments'> | Date | string
      comment_content?: StringFilter<'as_comments'> | string
      comment_karma?: IntFilter<'as_comments'> | number
      comment_approved?: StringFilter<'as_comments'> | string
      comment_agent?: StringFilter<'as_comments'> | string
      comment_type?: StringFilter<'as_comments'> | string
      comment_parent?: BigIntFilter<'as_comments'> | bigint | number
      user_id?: BigIntFilter<'as_comments'> | bigint | number
    },
    'comment_ID'
  >

  export type as_commentsOrderByWithAggregationInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_author?: SortOrder
    comment_author_email?: SortOrder
    comment_author_url?: SortOrder
    comment_author_IP?: SortOrder
    comment_date?: SortOrder
    comment_date_gmt?: SortOrder
    comment_content?: SortOrder
    comment_karma?: SortOrder
    comment_approved?: SortOrder
    comment_agent?: SortOrder
    comment_type?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
    _count?: as_commentsCountOrderByAggregateInput
    _avg?: as_commentsAvgOrderByAggregateInput
    _max?: as_commentsMaxOrderByAggregateInput
    _min?: as_commentsMinOrderByAggregateInput
    _sum?: as_commentsSumOrderByAggregateInput
  }

  export type as_commentsScalarWhereWithAggregatesInput = {
    AND?: as_commentsScalarWhereWithAggregatesInput | as_commentsScalarWhereWithAggregatesInput[]
    OR?: as_commentsScalarWhereWithAggregatesInput[]
    NOT?: as_commentsScalarWhereWithAggregatesInput | as_commentsScalarWhereWithAggregatesInput[]
    comment_ID?: BigIntWithAggregatesFilter<'as_comments'> | bigint | number
    comment_post_ID?: BigIntWithAggregatesFilter<'as_comments'> | bigint | number
    comment_author?: StringWithAggregatesFilter<'as_comments'> | string
    comment_author_email?: StringWithAggregatesFilter<'as_comments'> | string
    comment_author_url?: StringWithAggregatesFilter<'as_comments'> | string
    comment_author_IP?: StringWithAggregatesFilter<'as_comments'> | string
    comment_date?: DateTimeWithAggregatesFilter<'as_comments'> | Date | string
    comment_date_gmt?: DateTimeWithAggregatesFilter<'as_comments'> | Date | string
    comment_content?: StringWithAggregatesFilter<'as_comments'> | string
    comment_karma?: IntWithAggregatesFilter<'as_comments'> | number
    comment_approved?: StringWithAggregatesFilter<'as_comments'> | string
    comment_agent?: StringWithAggregatesFilter<'as_comments'> | string
    comment_type?: StringWithAggregatesFilter<'as_comments'> | string
    comment_parent?: BigIntWithAggregatesFilter<'as_comments'> | bigint | number
    user_id?: BigIntWithAggregatesFilter<'as_comments'> | bigint | number
  }

  export type as_fusion_form_entriesWhereInput = {
    AND?: as_fusion_form_entriesWhereInput | as_fusion_form_entriesWhereInput[]
    OR?: as_fusion_form_entriesWhereInput[]
    NOT?: as_fusion_form_entriesWhereInput | as_fusion_form_entriesWhereInput[]
    id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
    submission_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
    form_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
    field_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
    value?: StringNullableFilter<'as_fusion_form_entries'> | string | null
    privacy?: BoolNullableFilter<'as_fusion_form_entries'> | boolean | null
    data?: StringNullableFilter<'as_fusion_form_entries'> | string | null
  }

  export type as_fusion_form_entriesOrderByWithRelationInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
    value?: SortOrderInput | SortOrder
    privacy?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _relevance?: as_fusion_form_entriesOrderByRelevanceInput
  }

  export type as_fusion_form_entriesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: as_fusion_form_entriesWhereInput | as_fusion_form_entriesWhereInput[]
      OR?: as_fusion_form_entriesWhereInput[]
      NOT?: as_fusion_form_entriesWhereInput | as_fusion_form_entriesWhereInput[]
      submission_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
      form_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
      field_id?: BigIntFilter<'as_fusion_form_entries'> | bigint | number
      value?: StringNullableFilter<'as_fusion_form_entries'> | string | null
      privacy?: BoolNullableFilter<'as_fusion_form_entries'> | boolean | null
      data?: StringNullableFilter<'as_fusion_form_entries'> | string | null
    },
    'id' | 'id'
  >

  export type as_fusion_form_entriesOrderByWithAggregationInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
    value?: SortOrderInput | SortOrder
    privacy?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: as_fusion_form_entriesCountOrderByAggregateInput
    _avg?: as_fusion_form_entriesAvgOrderByAggregateInput
    _max?: as_fusion_form_entriesMaxOrderByAggregateInput
    _min?: as_fusion_form_entriesMinOrderByAggregateInput
    _sum?: as_fusion_form_entriesSumOrderByAggregateInput
  }

  export type as_fusion_form_entriesScalarWhereWithAggregatesInput = {
    AND?:
      | as_fusion_form_entriesScalarWhereWithAggregatesInput
      | as_fusion_form_entriesScalarWhereWithAggregatesInput[]
    OR?: as_fusion_form_entriesScalarWhereWithAggregatesInput[]
    NOT?:
      | as_fusion_form_entriesScalarWhereWithAggregatesInput
      | as_fusion_form_entriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_fusion_form_entries'> | bigint | number
    submission_id?: BigIntWithAggregatesFilter<'as_fusion_form_entries'> | bigint | number
    form_id?: BigIntWithAggregatesFilter<'as_fusion_form_entries'> | bigint | number
    field_id?: BigIntWithAggregatesFilter<'as_fusion_form_entries'> | bigint | number
    value?: StringNullableWithAggregatesFilter<'as_fusion_form_entries'> | string | null
    privacy?: BoolNullableWithAggregatesFilter<'as_fusion_form_entries'> | boolean | null
    data?: StringNullableWithAggregatesFilter<'as_fusion_form_entries'> | string | null
  }

  export type as_fusion_form_fieldsWhereInput = {
    AND?: as_fusion_form_fieldsWhereInput | as_fusion_form_fieldsWhereInput[]
    OR?: as_fusion_form_fieldsWhereInput[]
    NOT?: as_fusion_form_fieldsWhereInput | as_fusion_form_fieldsWhereInput[]
    id?: BigIntFilter<'as_fusion_form_fields'> | bigint | number
    form_id?: BigIntFilter<'as_fusion_form_fields'> | bigint | number
    field_name?: StringFilter<'as_fusion_form_fields'> | string
    field_label?: StringNullableFilter<'as_fusion_form_fields'> | string | null
    data?: StringNullableFilter<'as_fusion_form_fields'> | string | null
  }

  export type as_fusion_form_fieldsOrderByWithRelationInput = {
    id?: SortOrder
    form_id?: SortOrder
    field_name?: SortOrder
    field_label?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _relevance?: as_fusion_form_fieldsOrderByRelevanceInput
  }

  export type as_fusion_form_fieldsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: as_fusion_form_fieldsWhereInput | as_fusion_form_fieldsWhereInput[]
      OR?: as_fusion_form_fieldsWhereInput[]
      NOT?: as_fusion_form_fieldsWhereInput | as_fusion_form_fieldsWhereInput[]
      form_id?: BigIntFilter<'as_fusion_form_fields'> | bigint | number
      field_name?: StringFilter<'as_fusion_form_fields'> | string
      field_label?: StringNullableFilter<'as_fusion_form_fields'> | string | null
      data?: StringNullableFilter<'as_fusion_form_fields'> | string | null
    },
    'id' | 'id'
  >

  export type as_fusion_form_fieldsOrderByWithAggregationInput = {
    id?: SortOrder
    form_id?: SortOrder
    field_name?: SortOrder
    field_label?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: as_fusion_form_fieldsCountOrderByAggregateInput
    _avg?: as_fusion_form_fieldsAvgOrderByAggregateInput
    _max?: as_fusion_form_fieldsMaxOrderByAggregateInput
    _min?: as_fusion_form_fieldsMinOrderByAggregateInput
    _sum?: as_fusion_form_fieldsSumOrderByAggregateInput
  }

  export type as_fusion_form_fieldsScalarWhereWithAggregatesInput = {
    AND?:
      | as_fusion_form_fieldsScalarWhereWithAggregatesInput
      | as_fusion_form_fieldsScalarWhereWithAggregatesInput[]
    OR?: as_fusion_form_fieldsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_fusion_form_fieldsScalarWhereWithAggregatesInput
      | as_fusion_form_fieldsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_fusion_form_fields'> | bigint | number
    form_id?: BigIntWithAggregatesFilter<'as_fusion_form_fields'> | bigint | number
    field_name?: StringWithAggregatesFilter<'as_fusion_form_fields'> | string
    field_label?: StringNullableWithAggregatesFilter<'as_fusion_form_fields'> | string | null
    data?: StringNullableWithAggregatesFilter<'as_fusion_form_fields'> | string | null
  }

  export type as_fusion_form_submissionsWhereInput = {
    AND?: as_fusion_form_submissionsWhereInput | as_fusion_form_submissionsWhereInput[]
    OR?: as_fusion_form_submissionsWhereInput[]
    NOT?: as_fusion_form_submissionsWhereInput | as_fusion_form_submissionsWhereInput[]
    id?: BigIntFilter<'as_fusion_form_submissions'> | bigint | number
    form_id?: BigIntFilter<'as_fusion_form_submissions'> | bigint | number
    time?: DateTimeFilter<'as_fusion_form_submissions'> | Date | string
    source_url?: StringFilter<'as_fusion_form_submissions'> | string
    post_id?: BigIntNullableFilter<'as_fusion_form_submissions'> | bigint | number | null
    user_id?: BigIntNullableFilter<'as_fusion_form_submissions'> | bigint | number | null
    user_agent?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
    ip?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
    is_read?: BoolNullableFilter<'as_fusion_form_submissions'> | boolean | null
    privacy_scrub_date?: DateTimeNullableFilter<'as_fusion_form_submissions'> | Date | string | null
    on_privacy_scrub?: StringFilter<'as_fusion_form_submissions'> | string
    data?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
  }

  export type as_fusion_form_submissionsOrderByWithRelationInput = {
    id?: SortOrder
    form_id?: SortOrder
    time?: SortOrder
    source_url?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    privacy_scrub_date?: SortOrderInput | SortOrder
    on_privacy_scrub?: SortOrder
    data?: SortOrderInput | SortOrder
    _relevance?: as_fusion_form_submissionsOrderByRelevanceInput
  }

  export type as_fusion_form_submissionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: as_fusion_form_submissionsWhereInput | as_fusion_form_submissionsWhereInput[]
      OR?: as_fusion_form_submissionsWhereInput[]
      NOT?: as_fusion_form_submissionsWhereInput | as_fusion_form_submissionsWhereInput[]
      form_id?: BigIntFilter<'as_fusion_form_submissions'> | bigint | number
      time?: DateTimeFilter<'as_fusion_form_submissions'> | Date | string
      source_url?: StringFilter<'as_fusion_form_submissions'> | string
      post_id?: BigIntNullableFilter<'as_fusion_form_submissions'> | bigint | number | null
      user_id?: BigIntNullableFilter<'as_fusion_form_submissions'> | bigint | number | null
      user_agent?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
      ip?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
      is_read?: BoolNullableFilter<'as_fusion_form_submissions'> | boolean | null
      privacy_scrub_date?:
        | DateTimeNullableFilter<'as_fusion_form_submissions'>
        | Date
        | string
        | null
      on_privacy_scrub?: StringFilter<'as_fusion_form_submissions'> | string
      data?: StringNullableFilter<'as_fusion_form_submissions'> | string | null
    },
    'id' | 'id'
  >

  export type as_fusion_form_submissionsOrderByWithAggregationInput = {
    id?: SortOrder
    form_id?: SortOrder
    time?: SortOrder
    source_url?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    privacy_scrub_date?: SortOrderInput | SortOrder
    on_privacy_scrub?: SortOrder
    data?: SortOrderInput | SortOrder
    _count?: as_fusion_form_submissionsCountOrderByAggregateInput
    _avg?: as_fusion_form_submissionsAvgOrderByAggregateInput
    _max?: as_fusion_form_submissionsMaxOrderByAggregateInput
    _min?: as_fusion_form_submissionsMinOrderByAggregateInput
    _sum?: as_fusion_form_submissionsSumOrderByAggregateInput
  }

  export type as_fusion_form_submissionsScalarWhereWithAggregatesInput = {
    AND?:
      | as_fusion_form_submissionsScalarWhereWithAggregatesInput
      | as_fusion_form_submissionsScalarWhereWithAggregatesInput[]
    OR?: as_fusion_form_submissionsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_fusion_form_submissionsScalarWhereWithAggregatesInput
      | as_fusion_form_submissionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_fusion_form_submissions'> | bigint | number
    form_id?: BigIntWithAggregatesFilter<'as_fusion_form_submissions'> | bigint | number
    time?: DateTimeWithAggregatesFilter<'as_fusion_form_submissions'> | Date | string
    source_url?: StringWithAggregatesFilter<'as_fusion_form_submissions'> | string
    post_id?:
      | BigIntNullableWithAggregatesFilter<'as_fusion_form_submissions'>
      | bigint
      | number
      | null
    user_id?:
      | BigIntNullableWithAggregatesFilter<'as_fusion_form_submissions'>
      | bigint
      | number
      | null
    user_agent?: StringNullableWithAggregatesFilter<'as_fusion_form_submissions'> | string | null
    ip?: StringNullableWithAggregatesFilter<'as_fusion_form_submissions'> | string | null
    is_read?: BoolNullableWithAggregatesFilter<'as_fusion_form_submissions'> | boolean | null
    privacy_scrub_date?:
      | DateTimeNullableWithAggregatesFilter<'as_fusion_form_submissions'>
      | Date
      | string
      | null
    on_privacy_scrub?: StringWithAggregatesFilter<'as_fusion_form_submissions'> | string
    data?: StringNullableWithAggregatesFilter<'as_fusion_form_submissions'> | string | null
  }

  export type as_fusion_formsWhereInput = {
    AND?: as_fusion_formsWhereInput | as_fusion_formsWhereInput[]
    OR?: as_fusion_formsWhereInput[]
    NOT?: as_fusion_formsWhereInput | as_fusion_formsWhereInput[]
    id?: BigIntFilter<'as_fusion_forms'> | bigint | number
    form_id?: BigIntFilter<'as_fusion_forms'> | bigint | number
    views?: BigIntNullableFilter<'as_fusion_forms'> | bigint | number | null
    submissions_count?: BigIntNullableFilter<'as_fusion_forms'> | bigint | number | null
    data?: StringNullableFilter<'as_fusion_forms'> | string | null
  }

  export type as_fusion_formsOrderByWithRelationInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrderInput | SortOrder
    submissions_count?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _relevance?: as_fusion_formsOrderByRelevanceInput
  }

  export type as_fusion_formsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      form_id?: bigint | number
      AND?: as_fusion_formsWhereInput | as_fusion_formsWhereInput[]
      OR?: as_fusion_formsWhereInput[]
      NOT?: as_fusion_formsWhereInput | as_fusion_formsWhereInput[]
      views?: BigIntNullableFilter<'as_fusion_forms'> | bigint | number | null
      submissions_count?: BigIntNullableFilter<'as_fusion_forms'> | bigint | number | null
      data?: StringNullableFilter<'as_fusion_forms'> | string | null
    },
    'id' | 'id' | 'form_id'
  >

  export type as_fusion_formsOrderByWithAggregationInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrderInput | SortOrder
    submissions_count?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: as_fusion_formsCountOrderByAggregateInput
    _avg?: as_fusion_formsAvgOrderByAggregateInput
    _max?: as_fusion_formsMaxOrderByAggregateInput
    _min?: as_fusion_formsMinOrderByAggregateInput
    _sum?: as_fusion_formsSumOrderByAggregateInput
  }

  export type as_fusion_formsScalarWhereWithAggregatesInput = {
    AND?:
      | as_fusion_formsScalarWhereWithAggregatesInput
      | as_fusion_formsScalarWhereWithAggregatesInput[]
    OR?: as_fusion_formsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_fusion_formsScalarWhereWithAggregatesInput
      | as_fusion_formsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_fusion_forms'> | bigint | number
    form_id?: BigIntWithAggregatesFilter<'as_fusion_forms'> | bigint | number
    views?: BigIntNullableWithAggregatesFilter<'as_fusion_forms'> | bigint | number | null
    submissions_count?:
      | BigIntNullableWithAggregatesFilter<'as_fusion_forms'>
      | bigint
      | number
      | null
    data?: StringNullableWithAggregatesFilter<'as_fusion_forms'> | string | null
  }

  export type as_layersliderWhereInput = {
    AND?: as_layersliderWhereInput | as_layersliderWhereInput[]
    OR?: as_layersliderWhereInput[]
    NOT?: as_layersliderWhereInput | as_layersliderWhereInput[]
    id?: IntFilter<'as_layerslider'> | number
    group_id?: IntNullableFilter<'as_layerslider'> | number | null
    author?: IntFilter<'as_layerslider'> | number
    name?: StringNullableFilter<'as_layerslider'> | string | null
    slug?: StringNullableFilter<'as_layerslider'> | string | null
    data?: StringFilter<'as_layerslider'> | string
    date_c?: IntFilter<'as_layerslider'> | number
    date_m?: IntFilter<'as_layerslider'> | number
    schedule_start?: IntFilter<'as_layerslider'> | number
    schedule_end?: IntFilter<'as_layerslider'> | number
    flag_hidden?: BoolFilter<'as_layerslider'> | boolean
    flag_deleted?: BoolFilter<'as_layerslider'> | boolean
    flag_popup?: BoolFilter<'as_layerslider'> | boolean
    flag_group?: BoolFilter<'as_layerslider'> | boolean
  }

  export type as_layersliderOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrderInput | SortOrder
    author?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    data?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
    flag_hidden?: SortOrder
    flag_deleted?: SortOrder
    flag_popup?: SortOrder
    flag_group?: SortOrder
    _relevance?: as_layersliderOrderByRelevanceInput
  }

  export type as_layersliderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_layersliderWhereInput | as_layersliderWhereInput[]
      OR?: as_layersliderWhereInput[]
      NOT?: as_layersliderWhereInput | as_layersliderWhereInput[]
      group_id?: IntNullableFilter<'as_layerslider'> | number | null
      author?: IntFilter<'as_layerslider'> | number
      name?: StringNullableFilter<'as_layerslider'> | string | null
      slug?: StringNullableFilter<'as_layerslider'> | string | null
      data?: StringFilter<'as_layerslider'> | string
      date_c?: IntFilter<'as_layerslider'> | number
      date_m?: IntFilter<'as_layerslider'> | number
      schedule_start?: IntFilter<'as_layerslider'> | number
      schedule_end?: IntFilter<'as_layerslider'> | number
      flag_hidden?: BoolFilter<'as_layerslider'> | boolean
      flag_deleted?: BoolFilter<'as_layerslider'> | boolean
      flag_popup?: BoolFilter<'as_layerslider'> | boolean
      flag_group?: BoolFilter<'as_layerslider'> | boolean
    },
    'id'
  >

  export type as_layersliderOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrderInput | SortOrder
    author?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    data?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
    flag_hidden?: SortOrder
    flag_deleted?: SortOrder
    flag_popup?: SortOrder
    flag_group?: SortOrder
    _count?: as_layersliderCountOrderByAggregateInput
    _avg?: as_layersliderAvgOrderByAggregateInput
    _max?: as_layersliderMaxOrderByAggregateInput
    _min?: as_layersliderMinOrderByAggregateInput
    _sum?: as_layersliderSumOrderByAggregateInput
  }

  export type as_layersliderScalarWhereWithAggregatesInput = {
    AND?:
      | as_layersliderScalarWhereWithAggregatesInput
      | as_layersliderScalarWhereWithAggregatesInput[]
    OR?: as_layersliderScalarWhereWithAggregatesInput[]
    NOT?:
      | as_layersliderScalarWhereWithAggregatesInput
      | as_layersliderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_layerslider'> | number
    group_id?: IntNullableWithAggregatesFilter<'as_layerslider'> | number | null
    author?: IntWithAggregatesFilter<'as_layerslider'> | number
    name?: StringNullableWithAggregatesFilter<'as_layerslider'> | string | null
    slug?: StringNullableWithAggregatesFilter<'as_layerslider'> | string | null
    data?: StringWithAggregatesFilter<'as_layerslider'> | string
    date_c?: IntWithAggregatesFilter<'as_layerslider'> | number
    date_m?: IntWithAggregatesFilter<'as_layerslider'> | number
    schedule_start?: IntWithAggregatesFilter<'as_layerslider'> | number
    schedule_end?: IntWithAggregatesFilter<'as_layerslider'> | number
    flag_hidden?: BoolWithAggregatesFilter<'as_layerslider'> | boolean
    flag_deleted?: BoolWithAggregatesFilter<'as_layerslider'> | boolean
    flag_popup?: BoolWithAggregatesFilter<'as_layerslider'> | boolean
    flag_group?: BoolWithAggregatesFilter<'as_layerslider'> | boolean
  }

  export type as_layerslider_revisionsWhereInput = {
    AND?: as_layerslider_revisionsWhereInput | as_layerslider_revisionsWhereInput[]
    OR?: as_layerslider_revisionsWhereInput[]
    NOT?: as_layerslider_revisionsWhereInput | as_layerslider_revisionsWhereInput[]
    id?: IntFilter<'as_layerslider_revisions'> | number
    slider_id?: IntFilter<'as_layerslider_revisions'> | number
    author?: IntFilter<'as_layerslider_revisions'> | number
    data?: StringFilter<'as_layerslider_revisions'> | string
    date_c?: IntFilter<'as_layerslider_revisions'> | number
  }

  export type as_layerslider_revisionsOrderByWithRelationInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
    _relevance?: as_layerslider_revisionsOrderByRelevanceInput
  }

  export type as_layerslider_revisionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_layerslider_revisionsWhereInput | as_layerslider_revisionsWhereInput[]
      OR?: as_layerslider_revisionsWhereInput[]
      NOT?: as_layerslider_revisionsWhereInput | as_layerslider_revisionsWhereInput[]
      slider_id?: IntFilter<'as_layerslider_revisions'> | number
      author?: IntFilter<'as_layerslider_revisions'> | number
      data?: StringFilter<'as_layerslider_revisions'> | string
      date_c?: IntFilter<'as_layerslider_revisions'> | number
    },
    'id'
  >

  export type as_layerslider_revisionsOrderByWithAggregationInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
    _count?: as_layerslider_revisionsCountOrderByAggregateInput
    _avg?: as_layerslider_revisionsAvgOrderByAggregateInput
    _max?: as_layerslider_revisionsMaxOrderByAggregateInput
    _min?: as_layerslider_revisionsMinOrderByAggregateInput
    _sum?: as_layerslider_revisionsSumOrderByAggregateInput
  }

  export type as_layerslider_revisionsScalarWhereWithAggregatesInput = {
    AND?:
      | as_layerslider_revisionsScalarWhereWithAggregatesInput
      | as_layerslider_revisionsScalarWhereWithAggregatesInput[]
    OR?: as_layerslider_revisionsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_layerslider_revisionsScalarWhereWithAggregatesInput
      | as_layerslider_revisionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_layerslider_revisions'> | number
    slider_id?: IntWithAggregatesFilter<'as_layerslider_revisions'> | number
    author?: IntWithAggregatesFilter<'as_layerslider_revisions'> | number
    data?: StringWithAggregatesFilter<'as_layerslider_revisions'> | string
    date_c?: IntWithAggregatesFilter<'as_layerslider_revisions'> | number
  }

  export type as_linksWhereInput = {
    AND?: as_linksWhereInput | as_linksWhereInput[]
    OR?: as_linksWhereInput[]
    NOT?: as_linksWhereInput | as_linksWhereInput[]
    link_id?: BigIntFilter<'as_links'> | bigint | number
    link_url?: StringFilter<'as_links'> | string
    link_name?: StringFilter<'as_links'> | string
    link_image?: StringFilter<'as_links'> | string
    link_target?: StringFilter<'as_links'> | string
    link_description?: StringFilter<'as_links'> | string
    link_visible?: StringFilter<'as_links'> | string
    link_owner?: BigIntFilter<'as_links'> | bigint | number
    link_rating?: IntFilter<'as_links'> | number
    link_updated?: DateTimeFilter<'as_links'> | Date | string
    link_rel?: StringFilter<'as_links'> | string
    link_notes?: StringFilter<'as_links'> | string
    link_rss?: StringFilter<'as_links'> | string
  }

  export type as_linksOrderByWithRelationInput = {
    link_id?: SortOrder
    link_url?: SortOrder
    link_name?: SortOrder
    link_image?: SortOrder
    link_target?: SortOrder
    link_description?: SortOrder
    link_visible?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
    link_updated?: SortOrder
    link_rel?: SortOrder
    link_notes?: SortOrder
    link_rss?: SortOrder
    _relevance?: as_linksOrderByRelevanceInput
  }

  export type as_linksWhereUniqueInput = Prisma.AtLeast<
    {
      link_id?: bigint | number
      AND?: as_linksWhereInput | as_linksWhereInput[]
      OR?: as_linksWhereInput[]
      NOT?: as_linksWhereInput | as_linksWhereInput[]
      link_url?: StringFilter<'as_links'> | string
      link_name?: StringFilter<'as_links'> | string
      link_image?: StringFilter<'as_links'> | string
      link_target?: StringFilter<'as_links'> | string
      link_description?: StringFilter<'as_links'> | string
      link_visible?: StringFilter<'as_links'> | string
      link_owner?: BigIntFilter<'as_links'> | bigint | number
      link_rating?: IntFilter<'as_links'> | number
      link_updated?: DateTimeFilter<'as_links'> | Date | string
      link_rel?: StringFilter<'as_links'> | string
      link_notes?: StringFilter<'as_links'> | string
      link_rss?: StringFilter<'as_links'> | string
    },
    'link_id'
  >

  export type as_linksOrderByWithAggregationInput = {
    link_id?: SortOrder
    link_url?: SortOrder
    link_name?: SortOrder
    link_image?: SortOrder
    link_target?: SortOrder
    link_description?: SortOrder
    link_visible?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
    link_updated?: SortOrder
    link_rel?: SortOrder
    link_notes?: SortOrder
    link_rss?: SortOrder
    _count?: as_linksCountOrderByAggregateInput
    _avg?: as_linksAvgOrderByAggregateInput
    _max?: as_linksMaxOrderByAggregateInput
    _min?: as_linksMinOrderByAggregateInput
    _sum?: as_linksSumOrderByAggregateInput
  }

  export type as_linksScalarWhereWithAggregatesInput = {
    AND?: as_linksScalarWhereWithAggregatesInput | as_linksScalarWhereWithAggregatesInput[]
    OR?: as_linksScalarWhereWithAggregatesInput[]
    NOT?: as_linksScalarWhereWithAggregatesInput | as_linksScalarWhereWithAggregatesInput[]
    link_id?: BigIntWithAggregatesFilter<'as_links'> | bigint | number
    link_url?: StringWithAggregatesFilter<'as_links'> | string
    link_name?: StringWithAggregatesFilter<'as_links'> | string
    link_image?: StringWithAggregatesFilter<'as_links'> | string
    link_target?: StringWithAggregatesFilter<'as_links'> | string
    link_description?: StringWithAggregatesFilter<'as_links'> | string
    link_visible?: StringWithAggregatesFilter<'as_links'> | string
    link_owner?: BigIntWithAggregatesFilter<'as_links'> | bigint | number
    link_rating?: IntWithAggregatesFilter<'as_links'> | number
    link_updated?: DateTimeWithAggregatesFilter<'as_links'> | Date | string
    link_rel?: StringWithAggregatesFilter<'as_links'> | string
    link_notes?: StringWithAggregatesFilter<'as_links'> | string
    link_rss?: StringWithAggregatesFilter<'as_links'> | string
  }

  export type as_loginizer_logsWhereInput = {
    AND?: as_loginizer_logsWhereInput | as_loginizer_logsWhereInput[]
    OR?: as_loginizer_logsWhereInput[]
    NOT?: as_loginizer_logsWhereInput | as_loginizer_logsWhereInput[]
    username?: StringFilter<'as_loginizer_logs'> | string
    time?: IntFilter<'as_loginizer_logs'> | number
    count?: IntFilter<'as_loginizer_logs'> | number
    lockout?: IntFilter<'as_loginizer_logs'> | number
    ip?: StringFilter<'as_loginizer_logs'> | string
    url?: StringFilter<'as_loginizer_logs'> | string
  }

  export type as_loginizer_logsOrderByWithRelationInput = {
    username?: SortOrder
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
    ip?: SortOrder
    url?: SortOrder
    _relevance?: as_loginizer_logsOrderByRelevanceInput
  }

  export type as_loginizer_logsWhereUniqueInput = Prisma.AtLeast<
    {
      ip?: string
      AND?: as_loginizer_logsWhereInput | as_loginizer_logsWhereInput[]
      OR?: as_loginizer_logsWhereInput[]
      NOT?: as_loginizer_logsWhereInput | as_loginizer_logsWhereInput[]
      username?: StringFilter<'as_loginizer_logs'> | string
      time?: IntFilter<'as_loginizer_logs'> | number
      count?: IntFilter<'as_loginizer_logs'> | number
      lockout?: IntFilter<'as_loginizer_logs'> | number
      url?: StringFilter<'as_loginizer_logs'> | string
    },
    'ip'
  >

  export type as_loginizer_logsOrderByWithAggregationInput = {
    username?: SortOrder
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
    ip?: SortOrder
    url?: SortOrder
    _count?: as_loginizer_logsCountOrderByAggregateInput
    _avg?: as_loginizer_logsAvgOrderByAggregateInput
    _max?: as_loginizer_logsMaxOrderByAggregateInput
    _min?: as_loginizer_logsMinOrderByAggregateInput
    _sum?: as_loginizer_logsSumOrderByAggregateInput
  }

  export type as_loginizer_logsScalarWhereWithAggregatesInput = {
    AND?:
      | as_loginizer_logsScalarWhereWithAggregatesInput
      | as_loginizer_logsScalarWhereWithAggregatesInput[]
    OR?: as_loginizer_logsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_loginizer_logsScalarWhereWithAggregatesInput
      | as_loginizer_logsScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<'as_loginizer_logs'> | string
    time?: IntWithAggregatesFilter<'as_loginizer_logs'> | number
    count?: IntWithAggregatesFilter<'as_loginizer_logs'> | number
    lockout?: IntWithAggregatesFilter<'as_loginizer_logs'> | number
    ip?: StringWithAggregatesFilter<'as_loginizer_logs'> | string
    url?: StringWithAggregatesFilter<'as_loginizer_logs'> | string
  }

  export type as_optionsWhereInput = {
    AND?: as_optionsWhereInput | as_optionsWhereInput[]
    OR?: as_optionsWhereInput[]
    NOT?: as_optionsWhereInput | as_optionsWhereInput[]
    option_id?: BigIntFilter<'as_options'> | bigint | number
    option_name?: StringFilter<'as_options'> | string
    option_value?: StringFilter<'as_options'> | string
    autoload?: StringFilter<'as_options'> | string
  }

  export type as_optionsOrderByWithRelationInput = {
    option_id?: SortOrder
    option_name?: SortOrder
    option_value?: SortOrder
    autoload?: SortOrder
    _relevance?: as_optionsOrderByRelevanceInput
  }

  export type as_optionsWhereUniqueInput = Prisma.AtLeast<
    {
      option_id?: bigint | number
      option_name?: string
      AND?: as_optionsWhereInput | as_optionsWhereInput[]
      OR?: as_optionsWhereInput[]
      NOT?: as_optionsWhereInput | as_optionsWhereInput[]
      option_value?: StringFilter<'as_options'> | string
      autoload?: StringFilter<'as_options'> | string
    },
    'option_id' | 'option_name'
  >

  export type as_optionsOrderByWithAggregationInput = {
    option_id?: SortOrder
    option_name?: SortOrder
    option_value?: SortOrder
    autoload?: SortOrder
    _count?: as_optionsCountOrderByAggregateInput
    _avg?: as_optionsAvgOrderByAggregateInput
    _max?: as_optionsMaxOrderByAggregateInput
    _min?: as_optionsMinOrderByAggregateInput
    _sum?: as_optionsSumOrderByAggregateInput
  }

  export type as_optionsScalarWhereWithAggregatesInput = {
    AND?: as_optionsScalarWhereWithAggregatesInput | as_optionsScalarWhereWithAggregatesInput[]
    OR?: as_optionsScalarWhereWithAggregatesInput[]
    NOT?: as_optionsScalarWhereWithAggregatesInput | as_optionsScalarWhereWithAggregatesInput[]
    option_id?: BigIntWithAggregatesFilter<'as_options'> | bigint | number
    option_name?: StringWithAggregatesFilter<'as_options'> | string
    option_value?: StringWithAggregatesFilter<'as_options'> | string
    autoload?: StringWithAggregatesFilter<'as_options'> | string
  }

  export type as_postmetaWhereInput = {
    AND?: as_postmetaWhereInput | as_postmetaWhereInput[]
    OR?: as_postmetaWhereInput[]
    NOT?: as_postmetaWhereInput | as_postmetaWhereInput[]
    meta_id?: BigIntFilter<'as_postmeta'> | bigint | number
    post_id?: BigIntFilter<'as_postmeta'> | bigint | number
    meta_key?: StringNullableFilter<'as_postmeta'> | string | null
    meta_value?: StringNullableFilter<'as_postmeta'> | string | null
  }

  export type as_postmetaOrderByWithRelationInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _relevance?: as_postmetaOrderByRelevanceInput
  }

  export type as_postmetaWhereUniqueInput = Prisma.AtLeast<
    {
      meta_id?: bigint | number
      AND?: as_postmetaWhereInput | as_postmetaWhereInput[]
      OR?: as_postmetaWhereInput[]
      NOT?: as_postmetaWhereInput | as_postmetaWhereInput[]
      post_id?: BigIntFilter<'as_postmeta'> | bigint | number
      meta_key?: StringNullableFilter<'as_postmeta'> | string | null
      meta_value?: StringNullableFilter<'as_postmeta'> | string | null
    },
    'meta_id'
  >

  export type as_postmetaOrderByWithAggregationInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _count?: as_postmetaCountOrderByAggregateInput
    _avg?: as_postmetaAvgOrderByAggregateInput
    _max?: as_postmetaMaxOrderByAggregateInput
    _min?: as_postmetaMinOrderByAggregateInput
    _sum?: as_postmetaSumOrderByAggregateInput
  }

  export type as_postmetaScalarWhereWithAggregatesInput = {
    AND?: as_postmetaScalarWhereWithAggregatesInput | as_postmetaScalarWhereWithAggregatesInput[]
    OR?: as_postmetaScalarWhereWithAggregatesInput[]
    NOT?: as_postmetaScalarWhereWithAggregatesInput | as_postmetaScalarWhereWithAggregatesInput[]
    meta_id?: BigIntWithAggregatesFilter<'as_postmeta'> | bigint | number
    post_id?: BigIntWithAggregatesFilter<'as_postmeta'> | bigint | number
    meta_key?: StringNullableWithAggregatesFilter<'as_postmeta'> | string | null
    meta_value?: StringNullableWithAggregatesFilter<'as_postmeta'> | string | null
  }

  export type as_postsWhereInput = {
    AND?: as_postsWhereInput | as_postsWhereInput[]
    OR?: as_postsWhereInput[]
    NOT?: as_postsWhereInput | as_postsWhereInput[]
    ID?: BigIntFilter<'as_posts'> | bigint | number
    post_author?: BigIntFilter<'as_posts'> | bigint | number
    post_date?: DateTimeFilter<'as_posts'> | Date | string
    post_date_gmt?: DateTimeFilter<'as_posts'> | Date | string
    post_content?: StringFilter<'as_posts'> | string
    post_title?: StringFilter<'as_posts'> | string
    post_excerpt?: StringFilter<'as_posts'> | string
    post_status?: StringFilter<'as_posts'> | string
    comment_status?: StringFilter<'as_posts'> | string
    ping_status?: StringFilter<'as_posts'> | string
    post_password?: StringFilter<'as_posts'> | string
    post_name?: StringFilter<'as_posts'> | string
    to_ping?: StringFilter<'as_posts'> | string
    pinged?: StringFilter<'as_posts'> | string
    post_modified?: DateTimeFilter<'as_posts'> | Date | string
    post_modified_gmt?: DateTimeFilter<'as_posts'> | Date | string
    post_content_filtered?: StringFilter<'as_posts'> | string
    post_parent?: BigIntFilter<'as_posts'> | bigint | number
    guid?: StringFilter<'as_posts'> | string
    menu_order?: IntFilter<'as_posts'> | number
    post_type?: StringFilter<'as_posts'> | string
    post_mime_type?: StringFilter<'as_posts'> | string
    comment_count?: BigIntFilter<'as_posts'> | bigint | number
  }

  export type as_postsOrderByWithRelationInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_date?: SortOrder
    post_date_gmt?: SortOrder
    post_content?: SortOrder
    post_title?: SortOrder
    post_excerpt?: SortOrder
    post_status?: SortOrder
    comment_status?: SortOrder
    ping_status?: SortOrder
    post_password?: SortOrder
    post_name?: SortOrder
    to_ping?: SortOrder
    pinged?: SortOrder
    post_modified?: SortOrder
    post_modified_gmt?: SortOrder
    post_content_filtered?: SortOrder
    post_parent?: SortOrder
    guid?: SortOrder
    menu_order?: SortOrder
    post_type?: SortOrder
    post_mime_type?: SortOrder
    comment_count?: SortOrder
    _relevance?: as_postsOrderByRelevanceInput
  }

  export type as_postsWhereUniqueInput = Prisma.AtLeast<
    {
      ID?: bigint | number
      AND?: as_postsWhereInput | as_postsWhereInput[]
      OR?: as_postsWhereInput[]
      NOT?: as_postsWhereInput | as_postsWhereInput[]
      post_author?: BigIntFilter<'as_posts'> | bigint | number
      post_date?: DateTimeFilter<'as_posts'> | Date | string
      post_date_gmt?: DateTimeFilter<'as_posts'> | Date | string
      post_content?: StringFilter<'as_posts'> | string
      post_title?: StringFilter<'as_posts'> | string
      post_excerpt?: StringFilter<'as_posts'> | string
      post_status?: StringFilter<'as_posts'> | string
      comment_status?: StringFilter<'as_posts'> | string
      ping_status?: StringFilter<'as_posts'> | string
      post_password?: StringFilter<'as_posts'> | string
      post_name?: StringFilter<'as_posts'> | string
      to_ping?: StringFilter<'as_posts'> | string
      pinged?: StringFilter<'as_posts'> | string
      post_modified?: DateTimeFilter<'as_posts'> | Date | string
      post_modified_gmt?: DateTimeFilter<'as_posts'> | Date | string
      post_content_filtered?: StringFilter<'as_posts'> | string
      post_parent?: BigIntFilter<'as_posts'> | bigint | number
      guid?: StringFilter<'as_posts'> | string
      menu_order?: IntFilter<'as_posts'> | number
      post_type?: StringFilter<'as_posts'> | string
      post_mime_type?: StringFilter<'as_posts'> | string
      comment_count?: BigIntFilter<'as_posts'> | bigint | number
    },
    'ID'
  >

  export type as_postsOrderByWithAggregationInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_date?: SortOrder
    post_date_gmt?: SortOrder
    post_content?: SortOrder
    post_title?: SortOrder
    post_excerpt?: SortOrder
    post_status?: SortOrder
    comment_status?: SortOrder
    ping_status?: SortOrder
    post_password?: SortOrder
    post_name?: SortOrder
    to_ping?: SortOrder
    pinged?: SortOrder
    post_modified?: SortOrder
    post_modified_gmt?: SortOrder
    post_content_filtered?: SortOrder
    post_parent?: SortOrder
    guid?: SortOrder
    menu_order?: SortOrder
    post_type?: SortOrder
    post_mime_type?: SortOrder
    comment_count?: SortOrder
    _count?: as_postsCountOrderByAggregateInput
    _avg?: as_postsAvgOrderByAggregateInput
    _max?: as_postsMaxOrderByAggregateInput
    _min?: as_postsMinOrderByAggregateInput
    _sum?: as_postsSumOrderByAggregateInput
  }

  export type as_postsScalarWhereWithAggregatesInput = {
    AND?: as_postsScalarWhereWithAggregatesInput | as_postsScalarWhereWithAggregatesInput[]
    OR?: as_postsScalarWhereWithAggregatesInput[]
    NOT?: as_postsScalarWhereWithAggregatesInput | as_postsScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<'as_posts'> | bigint | number
    post_author?: BigIntWithAggregatesFilter<'as_posts'> | bigint | number
    post_date?: DateTimeWithAggregatesFilter<'as_posts'> | Date | string
    post_date_gmt?: DateTimeWithAggregatesFilter<'as_posts'> | Date | string
    post_content?: StringWithAggregatesFilter<'as_posts'> | string
    post_title?: StringWithAggregatesFilter<'as_posts'> | string
    post_excerpt?: StringWithAggregatesFilter<'as_posts'> | string
    post_status?: StringWithAggregatesFilter<'as_posts'> | string
    comment_status?: StringWithAggregatesFilter<'as_posts'> | string
    ping_status?: StringWithAggregatesFilter<'as_posts'> | string
    post_password?: StringWithAggregatesFilter<'as_posts'> | string
    post_name?: StringWithAggregatesFilter<'as_posts'> | string
    to_ping?: StringWithAggregatesFilter<'as_posts'> | string
    pinged?: StringWithAggregatesFilter<'as_posts'> | string
    post_modified?: DateTimeWithAggregatesFilter<'as_posts'> | Date | string
    post_modified_gmt?: DateTimeWithAggregatesFilter<'as_posts'> | Date | string
    post_content_filtered?: StringWithAggregatesFilter<'as_posts'> | string
    post_parent?: BigIntWithAggregatesFilter<'as_posts'> | bigint | number
    guid?: StringWithAggregatesFilter<'as_posts'> | string
    menu_order?: IntWithAggregatesFilter<'as_posts'> | number
    post_type?: StringWithAggregatesFilter<'as_posts'> | string
    post_mime_type?: StringWithAggregatesFilter<'as_posts'> | string
    comment_count?: BigIntWithAggregatesFilter<'as_posts'> | bigint | number
  }

  export type as_term_relationshipsWhereInput = {
    AND?: as_term_relationshipsWhereInput | as_term_relationshipsWhereInput[]
    OR?: as_term_relationshipsWhereInput[]
    NOT?: as_term_relationshipsWhereInput | as_term_relationshipsWhereInput[]
    object_id?: BigIntFilter<'as_term_relationships'> | bigint | number
    term_taxonomy_id?: BigIntFilter<'as_term_relationships'> | bigint | number
    term_order?: IntFilter<'as_term_relationships'> | number
  }

  export type as_term_relationshipsOrderByWithRelationInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_relationshipsWhereUniqueInput = Prisma.AtLeast<
    {
      object_id_term_taxonomy_id?: as_term_relationshipsObject_idTerm_taxonomy_idCompoundUniqueInput
      AND?: as_term_relationshipsWhereInput | as_term_relationshipsWhereInput[]
      OR?: as_term_relationshipsWhereInput[]
      NOT?: as_term_relationshipsWhereInput | as_term_relationshipsWhereInput[]
      object_id?: BigIntFilter<'as_term_relationships'> | bigint | number
      term_taxonomy_id?: BigIntFilter<'as_term_relationships'> | bigint | number
      term_order?: IntFilter<'as_term_relationships'> | number
    },
    'object_id_term_taxonomy_id'
  >

  export type as_term_relationshipsOrderByWithAggregationInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
    _count?: as_term_relationshipsCountOrderByAggregateInput
    _avg?: as_term_relationshipsAvgOrderByAggregateInput
    _max?: as_term_relationshipsMaxOrderByAggregateInput
    _min?: as_term_relationshipsMinOrderByAggregateInput
    _sum?: as_term_relationshipsSumOrderByAggregateInput
  }

  export type as_term_relationshipsScalarWhereWithAggregatesInput = {
    AND?:
      | as_term_relationshipsScalarWhereWithAggregatesInput
      | as_term_relationshipsScalarWhereWithAggregatesInput[]
    OR?: as_term_relationshipsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_term_relationshipsScalarWhereWithAggregatesInput
      | as_term_relationshipsScalarWhereWithAggregatesInput[]
    object_id?: BigIntWithAggregatesFilter<'as_term_relationships'> | bigint | number
    term_taxonomy_id?: BigIntWithAggregatesFilter<'as_term_relationships'> | bigint | number
    term_order?: IntWithAggregatesFilter<'as_term_relationships'> | number
  }

  export type as_term_taxonomyWhereInput = {
    AND?: as_term_taxonomyWhereInput | as_term_taxonomyWhereInput[]
    OR?: as_term_taxonomyWhereInput[]
    NOT?: as_term_taxonomyWhereInput | as_term_taxonomyWhereInput[]
    term_taxonomy_id?: BigIntFilter<'as_term_taxonomy'> | bigint | number
    term_id?: BigIntFilter<'as_term_taxonomy'> | bigint | number
    taxonomy?: StringFilter<'as_term_taxonomy'> | string
    description?: StringFilter<'as_term_taxonomy'> | string
    parent?: BigIntFilter<'as_term_taxonomy'> | bigint | number
    count?: BigIntFilter<'as_term_taxonomy'> | bigint | number
  }

  export type as_term_taxonomyOrderByWithRelationInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parent?: SortOrder
    count?: SortOrder
    _relevance?: as_term_taxonomyOrderByRelevanceInput
  }

  export type as_term_taxonomyWhereUniqueInput = Prisma.AtLeast<
    {
      term_taxonomy_id?: bigint | number
      term_id_taxonomy?: as_term_taxonomyTerm_idTaxonomyCompoundUniqueInput
      AND?: as_term_taxonomyWhereInput | as_term_taxonomyWhereInput[]
      OR?: as_term_taxonomyWhereInput[]
      NOT?: as_term_taxonomyWhereInput | as_term_taxonomyWhereInput[]
      term_id?: BigIntFilter<'as_term_taxonomy'> | bigint | number
      taxonomy?: StringFilter<'as_term_taxonomy'> | string
      description?: StringFilter<'as_term_taxonomy'> | string
      parent?: BigIntFilter<'as_term_taxonomy'> | bigint | number
      count?: BigIntFilter<'as_term_taxonomy'> | bigint | number
    },
    'term_taxonomy_id' | 'term_id_taxonomy'
  >

  export type as_term_taxonomyOrderByWithAggregationInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parent?: SortOrder
    count?: SortOrder
    _count?: as_term_taxonomyCountOrderByAggregateInput
    _avg?: as_term_taxonomyAvgOrderByAggregateInput
    _max?: as_term_taxonomyMaxOrderByAggregateInput
    _min?: as_term_taxonomyMinOrderByAggregateInput
    _sum?: as_term_taxonomySumOrderByAggregateInput
  }

  export type as_term_taxonomyScalarWhereWithAggregatesInput = {
    AND?:
      | as_term_taxonomyScalarWhereWithAggregatesInput
      | as_term_taxonomyScalarWhereWithAggregatesInput[]
    OR?: as_term_taxonomyScalarWhereWithAggregatesInput[]
    NOT?:
      | as_term_taxonomyScalarWhereWithAggregatesInput
      | as_term_taxonomyScalarWhereWithAggregatesInput[]
    term_taxonomy_id?: BigIntWithAggregatesFilter<'as_term_taxonomy'> | bigint | number
    term_id?: BigIntWithAggregatesFilter<'as_term_taxonomy'> | bigint | number
    taxonomy?: StringWithAggregatesFilter<'as_term_taxonomy'> | string
    description?: StringWithAggregatesFilter<'as_term_taxonomy'> | string
    parent?: BigIntWithAggregatesFilter<'as_term_taxonomy'> | bigint | number
    count?: BigIntWithAggregatesFilter<'as_term_taxonomy'> | bigint | number
  }

  export type as_termmetaWhereInput = {
    AND?: as_termmetaWhereInput | as_termmetaWhereInput[]
    OR?: as_termmetaWhereInput[]
    NOT?: as_termmetaWhereInput | as_termmetaWhereInput[]
    meta_id?: BigIntFilter<'as_termmeta'> | bigint | number
    term_id?: BigIntFilter<'as_termmeta'> | bigint | number
    meta_key?: StringNullableFilter<'as_termmeta'> | string | null
    meta_value?: StringNullableFilter<'as_termmeta'> | string | null
  }

  export type as_termmetaOrderByWithRelationInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _relevance?: as_termmetaOrderByRelevanceInput
  }

  export type as_termmetaWhereUniqueInput = Prisma.AtLeast<
    {
      meta_id?: bigint | number
      AND?: as_termmetaWhereInput | as_termmetaWhereInput[]
      OR?: as_termmetaWhereInput[]
      NOT?: as_termmetaWhereInput | as_termmetaWhereInput[]
      term_id?: BigIntFilter<'as_termmeta'> | bigint | number
      meta_key?: StringNullableFilter<'as_termmeta'> | string | null
      meta_value?: StringNullableFilter<'as_termmeta'> | string | null
    },
    'meta_id'
  >

  export type as_termmetaOrderByWithAggregationInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _count?: as_termmetaCountOrderByAggregateInput
    _avg?: as_termmetaAvgOrderByAggregateInput
    _max?: as_termmetaMaxOrderByAggregateInput
    _min?: as_termmetaMinOrderByAggregateInput
    _sum?: as_termmetaSumOrderByAggregateInput
  }

  export type as_termmetaScalarWhereWithAggregatesInput = {
    AND?: as_termmetaScalarWhereWithAggregatesInput | as_termmetaScalarWhereWithAggregatesInput[]
    OR?: as_termmetaScalarWhereWithAggregatesInput[]
    NOT?: as_termmetaScalarWhereWithAggregatesInput | as_termmetaScalarWhereWithAggregatesInput[]
    meta_id?: BigIntWithAggregatesFilter<'as_termmeta'> | bigint | number
    term_id?: BigIntWithAggregatesFilter<'as_termmeta'> | bigint | number
    meta_key?: StringNullableWithAggregatesFilter<'as_termmeta'> | string | null
    meta_value?: StringNullableWithAggregatesFilter<'as_termmeta'> | string | null
  }

  export type as_termsWhereInput = {
    AND?: as_termsWhereInput | as_termsWhereInput[]
    OR?: as_termsWhereInput[]
    NOT?: as_termsWhereInput | as_termsWhereInput[]
    term_id?: BigIntFilter<'as_terms'> | bigint | number
    name?: StringFilter<'as_terms'> | string
    slug?: StringFilter<'as_terms'> | string
    term_group?: BigIntFilter<'as_terms'> | bigint | number
  }

  export type as_termsOrderByWithRelationInput = {
    term_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    term_group?: SortOrder
    _relevance?: as_termsOrderByRelevanceInput
  }

  export type as_termsWhereUniqueInput = Prisma.AtLeast<
    {
      term_id?: bigint | number
      AND?: as_termsWhereInput | as_termsWhereInput[]
      OR?: as_termsWhereInput[]
      NOT?: as_termsWhereInput | as_termsWhereInput[]
      name?: StringFilter<'as_terms'> | string
      slug?: StringFilter<'as_terms'> | string
      term_group?: BigIntFilter<'as_terms'> | bigint | number
    },
    'term_id'
  >

  export type as_termsOrderByWithAggregationInput = {
    term_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    term_group?: SortOrder
    _count?: as_termsCountOrderByAggregateInput
    _avg?: as_termsAvgOrderByAggregateInput
    _max?: as_termsMaxOrderByAggregateInput
    _min?: as_termsMinOrderByAggregateInput
    _sum?: as_termsSumOrderByAggregateInput
  }

  export type as_termsScalarWhereWithAggregatesInput = {
    AND?: as_termsScalarWhereWithAggregatesInput | as_termsScalarWhereWithAggregatesInput[]
    OR?: as_termsScalarWhereWithAggregatesInput[]
    NOT?: as_termsScalarWhereWithAggregatesInput | as_termsScalarWhereWithAggregatesInput[]
    term_id?: BigIntWithAggregatesFilter<'as_terms'> | bigint | number
    name?: StringWithAggregatesFilter<'as_terms'> | string
    slug?: StringWithAggregatesFilter<'as_terms'> | string
    term_group?: BigIntWithAggregatesFilter<'as_terms'> | bigint | number
  }

  export type as_tm_taskmetaWhereInput = {
    AND?: as_tm_taskmetaWhereInput | as_tm_taskmetaWhereInput[]
    OR?: as_tm_taskmetaWhereInput[]
    NOT?: as_tm_taskmetaWhereInput | as_tm_taskmetaWhereInput[]
    meta_id?: BigIntFilter<'as_tm_taskmeta'> | bigint | number
    task_id?: BigIntFilter<'as_tm_taskmeta'> | bigint | number
    meta_key?: StringNullableFilter<'as_tm_taskmeta'> | string | null
    meta_value?: StringNullableFilter<'as_tm_taskmeta'> | string | null
  }

  export type as_tm_taskmetaOrderByWithRelationInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _relevance?: as_tm_taskmetaOrderByRelevanceInput
  }

  export type as_tm_taskmetaWhereUniqueInput = Prisma.AtLeast<
    {
      meta_id?: bigint | number
      AND?: as_tm_taskmetaWhereInput | as_tm_taskmetaWhereInput[]
      OR?: as_tm_taskmetaWhereInput[]
      NOT?: as_tm_taskmetaWhereInput | as_tm_taskmetaWhereInput[]
      task_id?: BigIntFilter<'as_tm_taskmeta'> | bigint | number
      meta_key?: StringNullableFilter<'as_tm_taskmeta'> | string | null
      meta_value?: StringNullableFilter<'as_tm_taskmeta'> | string | null
    },
    'meta_id'
  >

  export type as_tm_taskmetaOrderByWithAggregationInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _count?: as_tm_taskmetaCountOrderByAggregateInput
    _avg?: as_tm_taskmetaAvgOrderByAggregateInput
    _max?: as_tm_taskmetaMaxOrderByAggregateInput
    _min?: as_tm_taskmetaMinOrderByAggregateInput
    _sum?: as_tm_taskmetaSumOrderByAggregateInput
  }

  export type as_tm_taskmetaScalarWhereWithAggregatesInput = {
    AND?:
      | as_tm_taskmetaScalarWhereWithAggregatesInput
      | as_tm_taskmetaScalarWhereWithAggregatesInput[]
    OR?: as_tm_taskmetaScalarWhereWithAggregatesInput[]
    NOT?:
      | as_tm_taskmetaScalarWhereWithAggregatesInput
      | as_tm_taskmetaScalarWhereWithAggregatesInput[]
    meta_id?: BigIntWithAggregatesFilter<'as_tm_taskmeta'> | bigint | number
    task_id?: BigIntWithAggregatesFilter<'as_tm_taskmeta'> | bigint | number
    meta_key?: StringNullableWithAggregatesFilter<'as_tm_taskmeta'> | string | null
    meta_value?: StringNullableWithAggregatesFilter<'as_tm_taskmeta'> | string | null
  }

  export type as_tm_tasksWhereInput = {
    AND?: as_tm_tasksWhereInput | as_tm_tasksWhereInput[]
    OR?: as_tm_tasksWhereInput[]
    NOT?: as_tm_tasksWhereInput | as_tm_tasksWhereInput[]
    id?: IntFilter<'as_tm_tasks'> | number
    user_id?: BigIntFilter<'as_tm_tasks'> | bigint | number
    type?: StringFilter<'as_tm_tasks'> | string
    class_identifier?: StringNullableFilter<'as_tm_tasks'> | string | null
    attempts?: IntNullableFilter<'as_tm_tasks'> | number | null
    description?: StringNullableFilter<'as_tm_tasks'> | string | null
    time_created?: DateTimeFilter<'as_tm_tasks'> | Date | string
    last_locked_at?: BigIntNullableFilter<'as_tm_tasks'> | bigint | number | null
    status?: StringNullableFilter<'as_tm_tasks'> | string | null
  }

  export type as_tm_tasksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    class_identifier?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    time_created?: SortOrder
    last_locked_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: as_tm_tasksOrderByRelevanceInput
  }

  export type as_tm_tasksWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_tm_tasksWhereInput | as_tm_tasksWhereInput[]
      OR?: as_tm_tasksWhereInput[]
      NOT?: as_tm_tasksWhereInput | as_tm_tasksWhereInput[]
      user_id?: BigIntFilter<'as_tm_tasks'> | bigint | number
      type?: StringFilter<'as_tm_tasks'> | string
      class_identifier?: StringNullableFilter<'as_tm_tasks'> | string | null
      attempts?: IntNullableFilter<'as_tm_tasks'> | number | null
      description?: StringNullableFilter<'as_tm_tasks'> | string | null
      time_created?: DateTimeFilter<'as_tm_tasks'> | Date | string
      last_locked_at?: BigIntNullableFilter<'as_tm_tasks'> | bigint | number | null
      status?: StringNullableFilter<'as_tm_tasks'> | string | null
    },
    'id'
  >

  export type as_tm_tasksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    class_identifier?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    time_created?: SortOrder
    last_locked_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: as_tm_tasksCountOrderByAggregateInput
    _avg?: as_tm_tasksAvgOrderByAggregateInput
    _max?: as_tm_tasksMaxOrderByAggregateInput
    _min?: as_tm_tasksMinOrderByAggregateInput
    _sum?: as_tm_tasksSumOrderByAggregateInput
  }

  export type as_tm_tasksScalarWhereWithAggregatesInput = {
    AND?: as_tm_tasksScalarWhereWithAggregatesInput | as_tm_tasksScalarWhereWithAggregatesInput[]
    OR?: as_tm_tasksScalarWhereWithAggregatesInput[]
    NOT?: as_tm_tasksScalarWhereWithAggregatesInput | as_tm_tasksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_tm_tasks'> | number
    user_id?: BigIntWithAggregatesFilter<'as_tm_tasks'> | bigint | number
    type?: StringWithAggregatesFilter<'as_tm_tasks'> | string
    class_identifier?: StringNullableWithAggregatesFilter<'as_tm_tasks'> | string | null
    attempts?: IntNullableWithAggregatesFilter<'as_tm_tasks'> | number | null
    description?: StringNullableWithAggregatesFilter<'as_tm_tasks'> | string | null
    time_created?: DateTimeWithAggregatesFilter<'as_tm_tasks'> | Date | string
    last_locked_at?: BigIntNullableWithAggregatesFilter<'as_tm_tasks'> | bigint | number | null
    status?: StringNullableWithAggregatesFilter<'as_tm_tasks'> | string | null
  }

  export type as_usermetaWhereInput = {
    AND?: as_usermetaWhereInput | as_usermetaWhereInput[]
    OR?: as_usermetaWhereInput[]
    NOT?: as_usermetaWhereInput | as_usermetaWhereInput[]
    umeta_id?: BigIntFilter<'as_usermeta'> | bigint | number
    user_id?: BigIntFilter<'as_usermeta'> | bigint | number
    meta_key?: StringNullableFilter<'as_usermeta'> | string | null
    meta_value?: StringNullableFilter<'as_usermeta'> | string | null
  }

  export type as_usermetaOrderByWithRelationInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _relevance?: as_usermetaOrderByRelevanceInput
  }

  export type as_usermetaWhereUniqueInput = Prisma.AtLeast<
    {
      umeta_id?: bigint | number
      AND?: as_usermetaWhereInput | as_usermetaWhereInput[]
      OR?: as_usermetaWhereInput[]
      NOT?: as_usermetaWhereInput | as_usermetaWhereInput[]
      user_id?: BigIntFilter<'as_usermeta'> | bigint | number
      meta_key?: StringNullableFilter<'as_usermeta'> | string | null
      meta_value?: StringNullableFilter<'as_usermeta'> | string | null
    },
    'umeta_id'
  >

  export type as_usermetaOrderByWithAggregationInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
    meta_key?: SortOrderInput | SortOrder
    meta_value?: SortOrderInput | SortOrder
    _count?: as_usermetaCountOrderByAggregateInput
    _avg?: as_usermetaAvgOrderByAggregateInput
    _max?: as_usermetaMaxOrderByAggregateInput
    _min?: as_usermetaMinOrderByAggregateInput
    _sum?: as_usermetaSumOrderByAggregateInput
  }

  export type as_usermetaScalarWhereWithAggregatesInput = {
    AND?: as_usermetaScalarWhereWithAggregatesInput | as_usermetaScalarWhereWithAggregatesInput[]
    OR?: as_usermetaScalarWhereWithAggregatesInput[]
    NOT?: as_usermetaScalarWhereWithAggregatesInput | as_usermetaScalarWhereWithAggregatesInput[]
    umeta_id?: BigIntWithAggregatesFilter<'as_usermeta'> | bigint | number
    user_id?: BigIntWithAggregatesFilter<'as_usermeta'> | bigint | number
    meta_key?: StringNullableWithAggregatesFilter<'as_usermeta'> | string | null
    meta_value?: StringNullableWithAggregatesFilter<'as_usermeta'> | string | null
  }

  export type as_usersWhereInput = {
    AND?: as_usersWhereInput | as_usersWhereInput[]
    OR?: as_usersWhereInput[]
    NOT?: as_usersWhereInput | as_usersWhereInput[]
    ID?: BigIntFilter<'as_users'> | bigint | number
    user_login?: StringFilter<'as_users'> | string
    user_pass?: StringFilter<'as_users'> | string
    user_nicename?: StringFilter<'as_users'> | string
    user_email?: StringFilter<'as_users'> | string
    user_url?: StringFilter<'as_users'> | string
    user_registered?: DateTimeFilter<'as_users'> | Date | string
    user_activation_key?: StringFilter<'as_users'> | string
    user_status?: IntFilter<'as_users'> | number
    display_name?: StringFilter<'as_users'> | string
  }

  export type as_usersOrderByWithRelationInput = {
    ID?: SortOrder
    user_login?: SortOrder
    user_pass?: SortOrder
    user_nicename?: SortOrder
    user_email?: SortOrder
    user_url?: SortOrder
    user_registered?: SortOrder
    user_activation_key?: SortOrder
    user_status?: SortOrder
    display_name?: SortOrder
    _relevance?: as_usersOrderByRelevanceInput
  }

  export type as_usersWhereUniqueInput = Prisma.AtLeast<
    {
      ID?: bigint | number
      AND?: as_usersWhereInput | as_usersWhereInput[]
      OR?: as_usersWhereInput[]
      NOT?: as_usersWhereInput | as_usersWhereInput[]
      user_login?: StringFilter<'as_users'> | string
      user_pass?: StringFilter<'as_users'> | string
      user_nicename?: StringFilter<'as_users'> | string
      user_email?: StringFilter<'as_users'> | string
      user_url?: StringFilter<'as_users'> | string
      user_registered?: DateTimeFilter<'as_users'> | Date | string
      user_activation_key?: StringFilter<'as_users'> | string
      user_status?: IntFilter<'as_users'> | number
      display_name?: StringFilter<'as_users'> | string
    },
    'ID'
  >

  export type as_usersOrderByWithAggregationInput = {
    ID?: SortOrder
    user_login?: SortOrder
    user_pass?: SortOrder
    user_nicename?: SortOrder
    user_email?: SortOrder
    user_url?: SortOrder
    user_registered?: SortOrder
    user_activation_key?: SortOrder
    user_status?: SortOrder
    display_name?: SortOrder
    _count?: as_usersCountOrderByAggregateInput
    _avg?: as_usersAvgOrderByAggregateInput
    _max?: as_usersMaxOrderByAggregateInput
    _min?: as_usersMinOrderByAggregateInput
    _sum?: as_usersSumOrderByAggregateInput
  }

  export type as_usersScalarWhereWithAggregatesInput = {
    AND?: as_usersScalarWhereWithAggregatesInput | as_usersScalarWhereWithAggregatesInput[]
    OR?: as_usersScalarWhereWithAggregatesInput[]
    NOT?: as_usersScalarWhereWithAggregatesInput | as_usersScalarWhereWithAggregatesInput[]
    ID?: BigIntWithAggregatesFilter<'as_users'> | bigint | number
    user_login?: StringWithAggregatesFilter<'as_users'> | string
    user_pass?: StringWithAggregatesFilter<'as_users'> | string
    user_nicename?: StringWithAggregatesFilter<'as_users'> | string
    user_email?: StringWithAggregatesFilter<'as_users'> | string
    user_url?: StringWithAggregatesFilter<'as_users'> | string
    user_registered?: DateTimeWithAggregatesFilter<'as_users'> | Date | string
    user_activation_key?: StringWithAggregatesFilter<'as_users'> | string
    user_status?: IntWithAggregatesFilter<'as_users'> | number
    display_name?: StringWithAggregatesFilter<'as_users'> | string
  }

  export type as_wpo_404_detectorWhereInput = {
    AND?: as_wpo_404_detectorWhereInput | as_wpo_404_detectorWhereInput[]
    OR?: as_wpo_404_detectorWhereInput[]
    NOT?: as_wpo_404_detectorWhereInput | as_wpo_404_detectorWhereInput[]
    ID?: IntFilter<'as_wpo_404_detector'> | number
    url?: StringFilter<'as_wpo_404_detector'> | string
    request_timestamp?: BigIntFilter<'as_wpo_404_detector'> | bigint | number
    request_count?: BigIntFilter<'as_wpo_404_detector'> | bigint | number
    referrer?: StringFilter<'as_wpo_404_detector'> | string
  }

  export type as_wpo_404_detectorOrderByWithRelationInput = {
    ID?: SortOrder
    url?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
    referrer?: SortOrder
    _relevance?: as_wpo_404_detectorOrderByRelevanceInput
  }

  export type as_wpo_404_detectorWhereUniqueInput = Prisma.AtLeast<
    {
      ID?: number
      url_request_timestamp_referrer?: as_wpo_404_detectorUrlRequest_timestampReferrerCompoundUniqueInput
      AND?: as_wpo_404_detectorWhereInput | as_wpo_404_detectorWhereInput[]
      OR?: as_wpo_404_detectorWhereInput[]
      NOT?: as_wpo_404_detectorWhereInput | as_wpo_404_detectorWhereInput[]
      url?: StringFilter<'as_wpo_404_detector'> | string
      request_timestamp?: BigIntFilter<'as_wpo_404_detector'> | bigint | number
      request_count?: BigIntFilter<'as_wpo_404_detector'> | bigint | number
      referrer?: StringFilter<'as_wpo_404_detector'> | string
    },
    'ID' | 'url_request_timestamp_referrer'
  >

  export type as_wpo_404_detectorOrderByWithAggregationInput = {
    ID?: SortOrder
    url?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
    referrer?: SortOrder
    _count?: as_wpo_404_detectorCountOrderByAggregateInput
    _avg?: as_wpo_404_detectorAvgOrderByAggregateInput
    _max?: as_wpo_404_detectorMaxOrderByAggregateInput
    _min?: as_wpo_404_detectorMinOrderByAggregateInput
    _sum?: as_wpo_404_detectorSumOrderByAggregateInput
  }

  export type as_wpo_404_detectorScalarWhereWithAggregatesInput = {
    AND?:
      | as_wpo_404_detectorScalarWhereWithAggregatesInput
      | as_wpo_404_detectorScalarWhereWithAggregatesInput[]
    OR?: as_wpo_404_detectorScalarWhereWithAggregatesInput[]
    NOT?:
      | as_wpo_404_detectorScalarWhereWithAggregatesInput
      | as_wpo_404_detectorScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<'as_wpo_404_detector'> | number
    url?: StringWithAggregatesFilter<'as_wpo_404_detector'> | string
    request_timestamp?: BigIntWithAggregatesFilter<'as_wpo_404_detector'> | bigint | number
    request_count?: BigIntWithAggregatesFilter<'as_wpo_404_detector'> | bigint | number
    referrer?: StringWithAggregatesFilter<'as_wpo_404_detector'> | string
  }

  export type as_yoast_indexableWhereInput = {
    AND?: as_yoast_indexableWhereInput | as_yoast_indexableWhereInput[]
    OR?: as_yoast_indexableWhereInput[]
    NOT?: as_yoast_indexableWhereInput | as_yoast_indexableWhereInput[]
    id?: IntFilter<'as_yoast_indexable'> | number
    permalink?: StringNullableFilter<'as_yoast_indexable'> | string | null
    permalink_hash?: StringNullableFilter<'as_yoast_indexable'> | string | null
    object_id?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
    object_type?: StringFilter<'as_yoast_indexable'> | string
    object_sub_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
    author_id?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
    post_parent?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
    title?: StringNullableFilter<'as_yoast_indexable'> | string | null
    description?: StringNullableFilter<'as_yoast_indexable'> | string | null
    breadcrumb_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
    post_status?: StringNullableFilter<'as_yoast_indexable'> | string | null
    is_public?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_protected?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    has_public_posts?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    number_of_pages?: IntNullableFilter<'as_yoast_indexable'> | number | null
    canonical?: StringNullableFilter<'as_yoast_indexable'> | string | null
    primary_focus_keyword?: StringNullableFilter<'as_yoast_indexable'> | string | null
    primary_focus_keyword_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
    readability_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
    is_cornerstone?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noindex?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_robots_nofollow?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noarchive?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noimageindex?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    is_robots_nosnippet?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    twitter_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
    twitter_image?: StringNullableFilter<'as_yoast_indexable'> | string | null
    twitter_description?: StringNullableFilter<'as_yoast_indexable'> | string | null
    twitter_image_id?: StringNullableFilter<'as_yoast_indexable'> | string | null
    twitter_image_source?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_description?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_image?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_image_id?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_image_source?: StringNullableFilter<'as_yoast_indexable'> | string | null
    open_graph_image_meta?: StringNullableFilter<'as_yoast_indexable'> | string | null
    link_count?: IntNullableFilter<'as_yoast_indexable'> | number | null
    incoming_link_count?: IntNullableFilter<'as_yoast_indexable'> | number | null
    prominent_words_version?: IntNullableFilter<'as_yoast_indexable'> | number | null
    created_at?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
    updated_at?: DateTimeFilter<'as_yoast_indexable'> | Date | string
    blog_id?: BigIntFilter<'as_yoast_indexable'> | bigint | number
    language?: StringNullableFilter<'as_yoast_indexable'> | string | null
    region?: StringNullableFilter<'as_yoast_indexable'> | string | null
    schema_page_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
    schema_article_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
    has_ancestors?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
    estimated_reading_time_minutes?: IntNullableFilter<'as_yoast_indexable'> | number | null
    version?: IntNullableFilter<'as_yoast_indexable'> | number | null
    object_last_modified?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
    object_published_at?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
    inclusive_language_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
  }

  export type as_yoast_indexableOrderByWithRelationInput = {
    id?: SortOrder
    permalink?: SortOrderInput | SortOrder
    permalink_hash?: SortOrderInput | SortOrder
    object_id?: SortOrderInput | SortOrder
    object_type?: SortOrder
    object_sub_type?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    post_parent?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    breadcrumb_title?: SortOrderInput | SortOrder
    post_status?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    is_protected?: SortOrderInput | SortOrder
    has_public_posts?: SortOrderInput | SortOrder
    number_of_pages?: SortOrderInput | SortOrder
    canonical?: SortOrderInput | SortOrder
    primary_focus_keyword?: SortOrderInput | SortOrder
    primary_focus_keyword_score?: SortOrderInput | SortOrder
    readability_score?: SortOrderInput | SortOrder
    is_cornerstone?: SortOrderInput | SortOrder
    is_robots_noindex?: SortOrderInput | SortOrder
    is_robots_nofollow?: SortOrderInput | SortOrder
    is_robots_noarchive?: SortOrderInput | SortOrder
    is_robots_noimageindex?: SortOrderInput | SortOrder
    is_robots_nosnippet?: SortOrderInput | SortOrder
    twitter_title?: SortOrderInput | SortOrder
    twitter_image?: SortOrderInput | SortOrder
    twitter_description?: SortOrderInput | SortOrder
    twitter_image_id?: SortOrderInput | SortOrder
    twitter_image_source?: SortOrderInput | SortOrder
    open_graph_title?: SortOrderInput | SortOrder
    open_graph_description?: SortOrderInput | SortOrder
    open_graph_image?: SortOrderInput | SortOrder
    open_graph_image_id?: SortOrderInput | SortOrder
    open_graph_image_source?: SortOrderInput | SortOrder
    open_graph_image_meta?: SortOrderInput | SortOrder
    link_count?: SortOrderInput | SortOrder
    incoming_link_count?: SortOrderInput | SortOrder
    prominent_words_version?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    language?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    schema_page_type?: SortOrderInput | SortOrder
    schema_article_type?: SortOrderInput | SortOrder
    has_ancestors?: SortOrderInput | SortOrder
    estimated_reading_time_minutes?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    object_last_modified?: SortOrderInput | SortOrder
    object_published_at?: SortOrderInput | SortOrder
    inclusive_language_score?: SortOrderInput | SortOrder
    _relevance?: as_yoast_indexableOrderByRelevanceInput
  }

  export type as_yoast_indexableWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_yoast_indexableWhereInput | as_yoast_indexableWhereInput[]
      OR?: as_yoast_indexableWhereInput[]
      NOT?: as_yoast_indexableWhereInput | as_yoast_indexableWhereInput[]
      permalink?: StringNullableFilter<'as_yoast_indexable'> | string | null
      permalink_hash?: StringNullableFilter<'as_yoast_indexable'> | string | null
      object_id?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
      object_type?: StringFilter<'as_yoast_indexable'> | string
      object_sub_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
      author_id?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
      post_parent?: BigIntNullableFilter<'as_yoast_indexable'> | bigint | number | null
      title?: StringNullableFilter<'as_yoast_indexable'> | string | null
      description?: StringNullableFilter<'as_yoast_indexable'> | string | null
      breadcrumb_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
      post_status?: StringNullableFilter<'as_yoast_indexable'> | string | null
      is_public?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_protected?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      has_public_posts?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      number_of_pages?: IntNullableFilter<'as_yoast_indexable'> | number | null
      canonical?: StringNullableFilter<'as_yoast_indexable'> | string | null
      primary_focus_keyword?: StringNullableFilter<'as_yoast_indexable'> | string | null
      primary_focus_keyword_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
      readability_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
      is_cornerstone?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_robots_noindex?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_robots_nofollow?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_robots_noarchive?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_robots_noimageindex?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      is_robots_nosnippet?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      twitter_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
      twitter_image?: StringNullableFilter<'as_yoast_indexable'> | string | null
      twitter_description?: StringNullableFilter<'as_yoast_indexable'> | string | null
      twitter_image_id?: StringNullableFilter<'as_yoast_indexable'> | string | null
      twitter_image_source?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_title?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_description?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_image?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_image_id?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_image_source?: StringNullableFilter<'as_yoast_indexable'> | string | null
      open_graph_image_meta?: StringNullableFilter<'as_yoast_indexable'> | string | null
      link_count?: IntNullableFilter<'as_yoast_indexable'> | number | null
      incoming_link_count?: IntNullableFilter<'as_yoast_indexable'> | number | null
      prominent_words_version?: IntNullableFilter<'as_yoast_indexable'> | number | null
      created_at?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
      updated_at?: DateTimeFilter<'as_yoast_indexable'> | Date | string
      blog_id?: BigIntFilter<'as_yoast_indexable'> | bigint | number
      language?: StringNullableFilter<'as_yoast_indexable'> | string | null
      region?: StringNullableFilter<'as_yoast_indexable'> | string | null
      schema_page_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
      schema_article_type?: StringNullableFilter<'as_yoast_indexable'> | string | null
      has_ancestors?: BoolNullableFilter<'as_yoast_indexable'> | boolean | null
      estimated_reading_time_minutes?: IntNullableFilter<'as_yoast_indexable'> | number | null
      version?: IntNullableFilter<'as_yoast_indexable'> | number | null
      object_last_modified?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
      object_published_at?: DateTimeNullableFilter<'as_yoast_indexable'> | Date | string | null
      inclusive_language_score?: IntNullableFilter<'as_yoast_indexable'> | number | null
    },
    'id'
  >

  export type as_yoast_indexableOrderByWithAggregationInput = {
    id?: SortOrder
    permalink?: SortOrderInput | SortOrder
    permalink_hash?: SortOrderInput | SortOrder
    object_id?: SortOrderInput | SortOrder
    object_type?: SortOrder
    object_sub_type?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    post_parent?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    breadcrumb_title?: SortOrderInput | SortOrder
    post_status?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    is_protected?: SortOrderInput | SortOrder
    has_public_posts?: SortOrderInput | SortOrder
    number_of_pages?: SortOrderInput | SortOrder
    canonical?: SortOrderInput | SortOrder
    primary_focus_keyword?: SortOrderInput | SortOrder
    primary_focus_keyword_score?: SortOrderInput | SortOrder
    readability_score?: SortOrderInput | SortOrder
    is_cornerstone?: SortOrderInput | SortOrder
    is_robots_noindex?: SortOrderInput | SortOrder
    is_robots_nofollow?: SortOrderInput | SortOrder
    is_robots_noarchive?: SortOrderInput | SortOrder
    is_robots_noimageindex?: SortOrderInput | SortOrder
    is_robots_nosnippet?: SortOrderInput | SortOrder
    twitter_title?: SortOrderInput | SortOrder
    twitter_image?: SortOrderInput | SortOrder
    twitter_description?: SortOrderInput | SortOrder
    twitter_image_id?: SortOrderInput | SortOrder
    twitter_image_source?: SortOrderInput | SortOrder
    open_graph_title?: SortOrderInput | SortOrder
    open_graph_description?: SortOrderInput | SortOrder
    open_graph_image?: SortOrderInput | SortOrder
    open_graph_image_id?: SortOrderInput | SortOrder
    open_graph_image_source?: SortOrderInput | SortOrder
    open_graph_image_meta?: SortOrderInput | SortOrder
    link_count?: SortOrderInput | SortOrder
    incoming_link_count?: SortOrderInput | SortOrder
    prominent_words_version?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    language?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    schema_page_type?: SortOrderInput | SortOrder
    schema_article_type?: SortOrderInput | SortOrder
    has_ancestors?: SortOrderInput | SortOrder
    estimated_reading_time_minutes?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    object_last_modified?: SortOrderInput | SortOrder
    object_published_at?: SortOrderInput | SortOrder
    inclusive_language_score?: SortOrderInput | SortOrder
    _count?: as_yoast_indexableCountOrderByAggregateInput
    _avg?: as_yoast_indexableAvgOrderByAggregateInput
    _max?: as_yoast_indexableMaxOrderByAggregateInput
    _min?: as_yoast_indexableMinOrderByAggregateInput
    _sum?: as_yoast_indexableSumOrderByAggregateInput
  }

  export type as_yoast_indexableScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_indexableScalarWhereWithAggregatesInput
      | as_yoast_indexableScalarWhereWithAggregatesInput[]
    OR?: as_yoast_indexableScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_indexableScalarWhereWithAggregatesInput
      | as_yoast_indexableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_yoast_indexable'> | number
    permalink?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    permalink_hash?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    object_id?: BigIntNullableWithAggregatesFilter<'as_yoast_indexable'> | bigint | number | null
    object_type?: StringWithAggregatesFilter<'as_yoast_indexable'> | string
    object_sub_type?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    author_id?: BigIntNullableWithAggregatesFilter<'as_yoast_indexable'> | bigint | number | null
    post_parent?: BigIntNullableWithAggregatesFilter<'as_yoast_indexable'> | bigint | number | null
    title?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    description?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    breadcrumb_title?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    post_status?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    is_public?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_protected?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    has_public_posts?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    number_of_pages?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    canonical?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    primary_focus_keyword?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    primary_focus_keyword_score?:
      | IntNullableWithAggregatesFilter<'as_yoast_indexable'>
      | number
      | null
    readability_score?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    is_cornerstone?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noindex?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_robots_nofollow?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noarchive?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_robots_noimageindex?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    is_robots_nosnippet?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    twitter_title?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    twitter_image?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    twitter_description?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    twitter_image_id?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    twitter_image_source?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    open_graph_title?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    open_graph_description?:
      | StringNullableWithAggregatesFilter<'as_yoast_indexable'>
      | string
      | null
    open_graph_image?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    open_graph_image_id?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    open_graph_image_source?:
      | StringNullableWithAggregatesFilter<'as_yoast_indexable'>
      | string
      | null
    open_graph_image_meta?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    link_count?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    incoming_link_count?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    prominent_words_version?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<'as_yoast_indexable'> | Date | string | null
    updated_at?: DateTimeWithAggregatesFilter<'as_yoast_indexable'> | Date | string
    blog_id?: BigIntWithAggregatesFilter<'as_yoast_indexable'> | bigint | number
    language?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    region?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    schema_page_type?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    schema_article_type?: StringNullableWithAggregatesFilter<'as_yoast_indexable'> | string | null
    has_ancestors?: BoolNullableWithAggregatesFilter<'as_yoast_indexable'> | boolean | null
    estimated_reading_time_minutes?:
      | IntNullableWithAggregatesFilter<'as_yoast_indexable'>
      | number
      | null
    version?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
    object_last_modified?:
      | DateTimeNullableWithAggregatesFilter<'as_yoast_indexable'>
      | Date
      | string
      | null
    object_published_at?:
      | DateTimeNullableWithAggregatesFilter<'as_yoast_indexable'>
      | Date
      | string
      | null
    inclusive_language_score?: IntNullableWithAggregatesFilter<'as_yoast_indexable'> | number | null
  }

  export type as_yoast_indexable_hierarchyWhereInput = {
    AND?: as_yoast_indexable_hierarchyWhereInput | as_yoast_indexable_hierarchyWhereInput[]
    OR?: as_yoast_indexable_hierarchyWhereInput[]
    NOT?: as_yoast_indexable_hierarchyWhereInput | as_yoast_indexable_hierarchyWhereInput[]
    indexable_id?: IntFilter<'as_yoast_indexable_hierarchy'> | number
    ancestor_id?: IntFilter<'as_yoast_indexable_hierarchy'> | number
    depth?: IntNullableFilter<'as_yoast_indexable_hierarchy'> | number | null
    blog_id?: BigIntFilter<'as_yoast_indexable_hierarchy'> | bigint | number
  }

  export type as_yoast_indexable_hierarchyOrderByWithRelationInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrderInput | SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_indexable_hierarchyWhereUniqueInput = Prisma.AtLeast<
    {
      indexable_id_ancestor_id?: as_yoast_indexable_hierarchyIndexable_idAncestor_idCompoundUniqueInput
      AND?: as_yoast_indexable_hierarchyWhereInput | as_yoast_indexable_hierarchyWhereInput[]
      OR?: as_yoast_indexable_hierarchyWhereInput[]
      NOT?: as_yoast_indexable_hierarchyWhereInput | as_yoast_indexable_hierarchyWhereInput[]
      indexable_id?: IntFilter<'as_yoast_indexable_hierarchy'> | number
      ancestor_id?: IntFilter<'as_yoast_indexable_hierarchy'> | number
      depth?: IntNullableFilter<'as_yoast_indexable_hierarchy'> | number | null
      blog_id?: BigIntFilter<'as_yoast_indexable_hierarchy'> | bigint | number
    },
    'indexable_id_ancestor_id'
  >

  export type as_yoast_indexable_hierarchyOrderByWithAggregationInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrderInput | SortOrder
    blog_id?: SortOrder
    _count?: as_yoast_indexable_hierarchyCountOrderByAggregateInput
    _avg?: as_yoast_indexable_hierarchyAvgOrderByAggregateInput
    _max?: as_yoast_indexable_hierarchyMaxOrderByAggregateInput
    _min?: as_yoast_indexable_hierarchyMinOrderByAggregateInput
    _sum?: as_yoast_indexable_hierarchySumOrderByAggregateInput
  }

  export type as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput
      | as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput[]
    OR?: as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput
      | as_yoast_indexable_hierarchyScalarWhereWithAggregatesInput[]
    indexable_id?: IntWithAggregatesFilter<'as_yoast_indexable_hierarchy'> | number
    ancestor_id?: IntWithAggregatesFilter<'as_yoast_indexable_hierarchy'> | number
    depth?: IntNullableWithAggregatesFilter<'as_yoast_indexable_hierarchy'> | number | null
    blog_id?: BigIntWithAggregatesFilter<'as_yoast_indexable_hierarchy'> | bigint | number
  }

  export type as_yoast_migrationsWhereInput = {
    AND?: as_yoast_migrationsWhereInput | as_yoast_migrationsWhereInput[]
    OR?: as_yoast_migrationsWhereInput[]
    NOT?: as_yoast_migrationsWhereInput | as_yoast_migrationsWhereInput[]
    id?: IntFilter<'as_yoast_migrations'> | number
    version?: StringNullableFilter<'as_yoast_migrations'> | string | null
  }

  export type as_yoast_migrationsOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrderInput | SortOrder
    _relevance?: as_yoast_migrationsOrderByRelevanceInput
  }

  export type as_yoast_migrationsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      version?: string
      AND?: as_yoast_migrationsWhereInput | as_yoast_migrationsWhereInput[]
      OR?: as_yoast_migrationsWhereInput[]
      NOT?: as_yoast_migrationsWhereInput | as_yoast_migrationsWhereInput[]
    },
    'id' | 'version'
  >

  export type as_yoast_migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrderInput | SortOrder
    _count?: as_yoast_migrationsCountOrderByAggregateInput
    _avg?: as_yoast_migrationsAvgOrderByAggregateInput
    _max?: as_yoast_migrationsMaxOrderByAggregateInput
    _min?: as_yoast_migrationsMinOrderByAggregateInput
    _sum?: as_yoast_migrationsSumOrderByAggregateInput
  }

  export type as_yoast_migrationsScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_migrationsScalarWhereWithAggregatesInput
      | as_yoast_migrationsScalarWhereWithAggregatesInput[]
    OR?: as_yoast_migrationsScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_migrationsScalarWhereWithAggregatesInput
      | as_yoast_migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_yoast_migrations'> | number
    version?: StringNullableWithAggregatesFilter<'as_yoast_migrations'> | string | null
  }

  export type as_yoast_primary_termWhereInput = {
    AND?: as_yoast_primary_termWhereInput | as_yoast_primary_termWhereInput[]
    OR?: as_yoast_primary_termWhereInput[]
    NOT?: as_yoast_primary_termWhereInput | as_yoast_primary_termWhereInput[]
    id?: IntFilter<'as_yoast_primary_term'> | number
    post_id?: BigIntNullableFilter<'as_yoast_primary_term'> | bigint | number | null
    term_id?: BigIntNullableFilter<'as_yoast_primary_term'> | bigint | number | null
    taxonomy?: StringFilter<'as_yoast_primary_term'> | string
    created_at?: DateTimeNullableFilter<'as_yoast_primary_term'> | Date | string | null
    updated_at?: DateTimeFilter<'as_yoast_primary_term'> | Date | string
    blog_id?: BigIntFilter<'as_yoast_primary_term'> | bigint | number
  }

  export type as_yoast_primary_termOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    term_id?: SortOrderInput | SortOrder
    taxonomy?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    _relevance?: as_yoast_primary_termOrderByRelevanceInput
  }

  export type as_yoast_primary_termWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: as_yoast_primary_termWhereInput | as_yoast_primary_termWhereInput[]
      OR?: as_yoast_primary_termWhereInput[]
      NOT?: as_yoast_primary_termWhereInput | as_yoast_primary_termWhereInput[]
      post_id?: BigIntNullableFilter<'as_yoast_primary_term'> | bigint | number | null
      term_id?: BigIntNullableFilter<'as_yoast_primary_term'> | bigint | number | null
      taxonomy?: StringFilter<'as_yoast_primary_term'> | string
      created_at?: DateTimeNullableFilter<'as_yoast_primary_term'> | Date | string | null
      updated_at?: DateTimeFilter<'as_yoast_primary_term'> | Date | string
      blog_id?: BigIntFilter<'as_yoast_primary_term'> | bigint | number
    },
    'id'
  >

  export type as_yoast_primary_termOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    term_id?: SortOrderInput | SortOrder
    taxonomy?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    _count?: as_yoast_primary_termCountOrderByAggregateInput
    _avg?: as_yoast_primary_termAvgOrderByAggregateInput
    _max?: as_yoast_primary_termMaxOrderByAggregateInput
    _min?: as_yoast_primary_termMinOrderByAggregateInput
    _sum?: as_yoast_primary_termSumOrderByAggregateInput
  }

  export type as_yoast_primary_termScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_primary_termScalarWhereWithAggregatesInput
      | as_yoast_primary_termScalarWhereWithAggregatesInput[]
    OR?: as_yoast_primary_termScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_primary_termScalarWhereWithAggregatesInput
      | as_yoast_primary_termScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'as_yoast_primary_term'> | number
    post_id?: BigIntNullableWithAggregatesFilter<'as_yoast_primary_term'> | bigint | number | null
    term_id?: BigIntNullableWithAggregatesFilter<'as_yoast_primary_term'> | bigint | number | null
    taxonomy?: StringWithAggregatesFilter<'as_yoast_primary_term'> | string
    created_at?:
      | DateTimeNullableWithAggregatesFilter<'as_yoast_primary_term'>
      | Date
      | string
      | null
    updated_at?: DateTimeWithAggregatesFilter<'as_yoast_primary_term'> | Date | string
    blog_id?: BigIntWithAggregatesFilter<'as_yoast_primary_term'> | bigint | number
  }

  export type as_yoast_seo_linksWhereInput = {
    AND?: as_yoast_seo_linksWhereInput | as_yoast_seo_linksWhereInput[]
    OR?: as_yoast_seo_linksWhereInput[]
    NOT?: as_yoast_seo_linksWhereInput | as_yoast_seo_linksWhereInput[]
    id?: BigIntFilter<'as_yoast_seo_links'> | bigint | number
    url?: StringFilter<'as_yoast_seo_links'> | string
    post_id?: BigIntFilter<'as_yoast_seo_links'> | bigint | number
    target_post_id?: BigIntFilter<'as_yoast_seo_links'> | bigint | number
    type?: StringFilter<'as_yoast_seo_links'> | string
    indexable_id?: IntNullableFilter<'as_yoast_seo_links'> | number | null
    target_indexable_id?: IntNullableFilter<'as_yoast_seo_links'> | number | null
    height?: IntNullableFilter<'as_yoast_seo_links'> | number | null
    width?: IntNullableFilter<'as_yoast_seo_links'> | number | null
    size?: IntNullableFilter<'as_yoast_seo_links'> | number | null
    language?: StringNullableFilter<'as_yoast_seo_links'> | string | null
    region?: StringNullableFilter<'as_yoast_seo_links'> | string | null
  }

  export type as_yoast_seo_linksOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    type?: SortOrder
    indexable_id?: SortOrderInput | SortOrder
    target_indexable_id?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    _relevance?: as_yoast_seo_linksOrderByRelevanceInput
  }

  export type as_yoast_seo_linksWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: as_yoast_seo_linksWhereInput | as_yoast_seo_linksWhereInput[]
      OR?: as_yoast_seo_linksWhereInput[]
      NOT?: as_yoast_seo_linksWhereInput | as_yoast_seo_linksWhereInput[]
      url?: StringFilter<'as_yoast_seo_links'> | string
      post_id?: BigIntFilter<'as_yoast_seo_links'> | bigint | number
      target_post_id?: BigIntFilter<'as_yoast_seo_links'> | bigint | number
      type?: StringFilter<'as_yoast_seo_links'> | string
      indexable_id?: IntNullableFilter<'as_yoast_seo_links'> | number | null
      target_indexable_id?: IntNullableFilter<'as_yoast_seo_links'> | number | null
      height?: IntNullableFilter<'as_yoast_seo_links'> | number | null
      width?: IntNullableFilter<'as_yoast_seo_links'> | number | null
      size?: IntNullableFilter<'as_yoast_seo_links'> | number | null
      language?: StringNullableFilter<'as_yoast_seo_links'> | string | null
      region?: StringNullableFilter<'as_yoast_seo_links'> | string | null
    },
    'id'
  >

  export type as_yoast_seo_linksOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    type?: SortOrder
    indexable_id?: SortOrderInput | SortOrder
    target_indexable_id?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    _count?: as_yoast_seo_linksCountOrderByAggregateInput
    _avg?: as_yoast_seo_linksAvgOrderByAggregateInput
    _max?: as_yoast_seo_linksMaxOrderByAggregateInput
    _min?: as_yoast_seo_linksMinOrderByAggregateInput
    _sum?: as_yoast_seo_linksSumOrderByAggregateInput
  }

  export type as_yoast_seo_linksScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_seo_linksScalarWhereWithAggregatesInput
      | as_yoast_seo_linksScalarWhereWithAggregatesInput[]
    OR?: as_yoast_seo_linksScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_seo_linksScalarWhereWithAggregatesInput
      | as_yoast_seo_linksScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'as_yoast_seo_links'> | bigint | number
    url?: StringWithAggregatesFilter<'as_yoast_seo_links'> | string
    post_id?: BigIntWithAggregatesFilter<'as_yoast_seo_links'> | bigint | number
    target_post_id?: BigIntWithAggregatesFilter<'as_yoast_seo_links'> | bigint | number
    type?: StringWithAggregatesFilter<'as_yoast_seo_links'> | string
    indexable_id?: IntNullableWithAggregatesFilter<'as_yoast_seo_links'> | number | null
    target_indexable_id?: IntNullableWithAggregatesFilter<'as_yoast_seo_links'> | number | null
    height?: IntNullableWithAggregatesFilter<'as_yoast_seo_links'> | number | null
    width?: IntNullableWithAggregatesFilter<'as_yoast_seo_links'> | number | null
    size?: IntNullableWithAggregatesFilter<'as_yoast_seo_links'> | number | null
    language?: StringNullableWithAggregatesFilter<'as_yoast_seo_links'> | string | null
    region?: StringNullableWithAggregatesFilter<'as_yoast_seo_links'> | string | null
  }

  export type as_yoast_seo_metaWhereInput = {
    AND?: as_yoast_seo_metaWhereInput | as_yoast_seo_metaWhereInput[]
    OR?: as_yoast_seo_metaWhereInput[]
    NOT?: as_yoast_seo_metaWhereInput | as_yoast_seo_metaWhereInput[]
    object_id?: BigIntFilter<'as_yoast_seo_meta'> | bigint | number
    internal_link_count?: IntNullableFilter<'as_yoast_seo_meta'> | number | null
    incoming_link_count?: IntNullableFilter<'as_yoast_seo_meta'> | number | null
  }

  export type as_yoast_seo_metaOrderByWithRelationInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrderInput | SortOrder
    incoming_link_count?: SortOrderInput | SortOrder
  }

  export type as_yoast_seo_metaWhereUniqueInput = Prisma.AtLeast<
    {
      object_id?: bigint | number
      AND?: as_yoast_seo_metaWhereInput | as_yoast_seo_metaWhereInput[]
      OR?: as_yoast_seo_metaWhereInput[]
      NOT?: as_yoast_seo_metaWhereInput | as_yoast_seo_metaWhereInput[]
      internal_link_count?: IntNullableFilter<'as_yoast_seo_meta'> | number | null
      incoming_link_count?: IntNullableFilter<'as_yoast_seo_meta'> | number | null
    },
    'object_id'
  >

  export type as_yoast_seo_metaOrderByWithAggregationInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrderInput | SortOrder
    incoming_link_count?: SortOrderInput | SortOrder
    _count?: as_yoast_seo_metaCountOrderByAggregateInput
    _avg?: as_yoast_seo_metaAvgOrderByAggregateInput
    _max?: as_yoast_seo_metaMaxOrderByAggregateInput
    _min?: as_yoast_seo_metaMinOrderByAggregateInput
    _sum?: as_yoast_seo_metaSumOrderByAggregateInput
  }

  export type as_yoast_seo_metaScalarWhereWithAggregatesInput = {
    AND?:
      | as_yoast_seo_metaScalarWhereWithAggregatesInput
      | as_yoast_seo_metaScalarWhereWithAggregatesInput[]
    OR?: as_yoast_seo_metaScalarWhereWithAggregatesInput[]
    NOT?:
      | as_yoast_seo_metaScalarWhereWithAggregatesInput
      | as_yoast_seo_metaScalarWhereWithAggregatesInput[]
    object_id?: BigIntWithAggregatesFilter<'as_yoast_seo_meta'> | bigint | number
    internal_link_count?: IntNullableWithAggregatesFilter<'as_yoast_seo_meta'> | number | null
    incoming_link_count?: IntNullableWithAggregatesFilter<'as_yoast_seo_meta'> | number | null
  }

  export type as_actionscheduler_actionsCreateInput = {
    action_id?: bigint | number
    hook: string
    status: string
    scheduled_date_gmt?: Date | string | null
    scheduled_date_local?: Date | string | null
    args?: string | null
    schedule?: string | null
    group_id?: bigint | number
    attempts?: number
    last_attempt_gmt?: Date | string | null
    last_attempt_local?: Date | string | null
    claim_id?: bigint | number
    extended_args?: string | null
    priority?: number
  }

  export type as_actionscheduler_actionsUncheckedCreateInput = {
    action_id?: bigint | number
    hook: string
    status: string
    scheduled_date_gmt?: Date | string | null
    scheduled_date_local?: Date | string | null
    args?: string | null
    schedule?: string | null
    group_id?: bigint | number
    attempts?: number
    last_attempt_gmt?: Date | string | null
    last_attempt_local?: Date | string | null
    claim_id?: bigint | number
    extended_args?: string | null
    priority?: number
  }

  export type as_actionscheduler_actionsUpdateInput = {
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hook?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduled_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduled_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    args?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempts?: IntFieldUpdateOperationsInput | number
    last_attempt_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_attempt_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extended_args?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type as_actionscheduler_actionsUncheckedUpdateInput = {
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hook?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduled_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduled_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    args?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempts?: IntFieldUpdateOperationsInput | number
    last_attempt_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_attempt_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extended_args?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type as_actionscheduler_actionsCreateManyInput = {
    action_id?: bigint | number
    hook: string
    status: string
    scheduled_date_gmt?: Date | string | null
    scheduled_date_local?: Date | string | null
    args?: string | null
    schedule?: string | null
    group_id?: bigint | number
    attempts?: number
    last_attempt_gmt?: Date | string | null
    last_attempt_local?: Date | string | null
    claim_id?: bigint | number
    extended_args?: string | null
    priority?: number
  }

  export type as_actionscheduler_actionsUpdateManyMutationInput = {
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hook?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduled_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduled_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    args?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempts?: IntFieldUpdateOperationsInput | number
    last_attempt_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_attempt_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extended_args?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type as_actionscheduler_actionsUncheckedUpdateManyInput = {
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hook?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduled_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduled_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    args?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempts?: IntFieldUpdateOperationsInput | number
    last_attempt_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_attempt_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extended_args?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type as_actionscheduler_claimsCreateInput = {
    claim_id?: bigint | number
    date_created_gmt?: Date | string | null
  }

  export type as_actionscheduler_claimsUncheckedCreateInput = {
    claim_id?: bigint | number
    date_created_gmt?: Date | string | null
  }

  export type as_actionscheduler_claimsUpdateInput = {
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_created_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_claimsUncheckedUpdateInput = {
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_created_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_claimsCreateManyInput = {
    claim_id?: bigint | number
    date_created_gmt?: Date | string | null
  }

  export type as_actionscheduler_claimsUpdateManyMutationInput = {
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_created_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_claimsUncheckedUpdateManyInput = {
    claim_id?: BigIntFieldUpdateOperationsInput | bigint | number
    date_created_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_groupsCreateInput = {
    group_id?: bigint | number
    slug: string
  }

  export type as_actionscheduler_groupsUncheckedCreateInput = {
    group_id?: bigint | number
    slug: string
  }

  export type as_actionscheduler_groupsUpdateInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type as_actionscheduler_groupsUncheckedUpdateInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type as_actionscheduler_groupsCreateManyInput = {
    group_id?: bigint | number
    slug: string
  }

  export type as_actionscheduler_groupsUpdateManyMutationInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type as_actionscheduler_groupsUncheckedUpdateManyInput = {
    group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type as_actionscheduler_logsCreateInput = {
    log_id?: bigint | number
    action_id: bigint | number
    message: string
    log_date_gmt?: Date | string | null
    log_date_local?: Date | string | null
  }

  export type as_actionscheduler_logsUncheckedCreateInput = {
    log_id?: bigint | number
    action_id: bigint | number
    message: string
    log_date_gmt?: Date | string | null
    log_date_local?: Date | string | null
  }

  export type as_actionscheduler_logsUpdateInput = {
    log_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    log_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    log_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_logsUncheckedUpdateInput = {
    log_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    log_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    log_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_logsCreateManyInput = {
    log_id?: bigint | number
    action_id: bigint | number
    message: string
    log_date_gmt?: Date | string | null
    log_date_local?: Date | string | null
  }

  export type as_actionscheduler_logsUpdateManyMutationInput = {
    log_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    log_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    log_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_actionscheduler_logsUncheckedUpdateManyInput = {
    log_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    log_date_gmt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    log_date_local?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type as_awb_critical_cssCreateInput = {
    id?: bigint | number
    css_key: string
    mobile_css: string
    desktop_css: string
    mobile_preloads: string
    desktop_preloads: string
    updated_at: string
  }

  export type as_awb_critical_cssUncheckedCreateInput = {
    id?: bigint | number
    css_key: string
    mobile_css: string
    desktop_css: string
    mobile_preloads: string
    desktop_preloads: string
    updated_at: string
  }

  export type as_awb_critical_cssUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    css_key?: StringFieldUpdateOperationsInput | string
    mobile_css?: StringFieldUpdateOperationsInput | string
    desktop_css?: StringFieldUpdateOperationsInput | string
    mobile_preloads?: StringFieldUpdateOperationsInput | string
    desktop_preloads?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type as_awb_critical_cssUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    css_key?: StringFieldUpdateOperationsInput | string
    mobile_css?: StringFieldUpdateOperationsInput | string
    desktop_css?: StringFieldUpdateOperationsInput | string
    mobile_preloads?: StringFieldUpdateOperationsInput | string
    desktop_preloads?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type as_awb_critical_cssCreateManyInput = {
    id?: bigint | number
    css_key: string
    mobile_css: string
    desktop_css: string
    mobile_preloads: string
    desktop_preloads: string
    updated_at: string
  }

  export type as_awb_critical_cssUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    css_key?: StringFieldUpdateOperationsInput | string
    mobile_css?: StringFieldUpdateOperationsInput | string
    desktop_css?: StringFieldUpdateOperationsInput | string
    mobile_preloads?: StringFieldUpdateOperationsInput | string
    desktop_preloads?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type as_awb_critical_cssUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    css_key?: StringFieldUpdateOperationsInput | string
    mobile_css?: StringFieldUpdateOperationsInput | string
    desktop_css?: StringFieldUpdateOperationsInput | string
    mobile_preloads?: StringFieldUpdateOperationsInput | string
    desktop_preloads?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type as_cli_cookie_scanCreateInput = {
    status?: number
    created_at?: number
    total_url?: number
    total_cookies?: number
    current_action: string
    current_offset?: number
  }

  export type as_cli_cookie_scanUncheckedCreateInput = {
    id_cli_cookie_scan?: number
    status?: number
    created_at?: number
    total_url?: number
    total_cookies?: number
    current_action: string
    current_offset?: number
  }

  export type as_cli_cookie_scanUpdateInput = {
    status?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
    total_url?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
    current_action?: StringFieldUpdateOperationsInput | string
    current_offset?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scanUncheckedUpdateInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
    total_url?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
    current_action?: StringFieldUpdateOperationsInput | string
    current_offset?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scanCreateManyInput = {
    id_cli_cookie_scan?: number
    status?: number
    created_at?: number
    total_url?: number
    total_cookies?: number
    current_action: string
    current_offset?: number
  }

  export type as_cli_cookie_scanUpdateManyMutationInput = {
    status?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
    total_url?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
    current_action?: StringFieldUpdateOperationsInput | string
    current_offset?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scanUncheckedUpdateManyInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
    total_url?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
    current_action?: StringFieldUpdateOperationsInput | string
    current_offset?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scan_categoriesCreateInput = {
    cli_cookie_category_name: string
    cli_cookie_category_description?: string | null
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesCreateNestedManyWithoutAs_cli_cookie_scan_categoriesInput
  }

  export type as_cli_cookie_scan_categoriesUncheckedCreateInput = {
    id_cli_cookie_category?: number
    cli_cookie_category_name: string
    cli_cookie_category_description?: string | null
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesUncheckedCreateNestedManyWithoutAs_cli_cookie_scan_categoriesInput
  }

  export type as_cli_cookie_scan_categoriesUpdateInput = {
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesUpdateManyWithoutAs_cli_cookie_scan_categoriesNestedInput
  }

  export type as_cli_cookie_scan_categoriesUncheckedUpdateInput = {
    id_cli_cookie_category?: IntFieldUpdateOperationsInput | number
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
    as_cli_cookie_scan_cookies?: as_cli_cookie_scan_cookiesUncheckedUpdateManyWithoutAs_cli_cookie_scan_categoriesNestedInput
  }

  export type as_cli_cookie_scan_categoriesCreateManyInput = {
    id_cli_cookie_category?: number
    cli_cookie_category_name: string
    cli_cookie_category_description?: string | null
  }

  export type as_cli_cookie_scan_categoriesUpdateManyMutationInput = {
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_categoriesUncheckedUpdateManyInput = {
    id_cli_cookie_category?: IntFieldUpdateOperationsInput | number
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesCreateInput = {
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    description?: string | null
    as_cli_cookie_scan_categories: as_cli_cookie_scan_categoriesCreateNestedOneWithoutAs_cli_cookie_scan_cookiesInput
  }

  export type as_cli_cookie_scan_cookiesUncheckedCreateInput = {
    id_cli_cookie_scan_cookies?: number
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    category_id: number
    description?: string | null
  }

  export type as_cli_cookie_scan_cookiesUpdateInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    as_cli_cookie_scan_categories?: as_cli_cookie_scan_categoriesUpdateOneRequiredWithoutAs_cli_cookie_scan_cookiesNestedInput
  }

  export type as_cli_cookie_scan_cookiesUncheckedUpdateInput = {
    id_cli_cookie_scan_cookies?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesCreateManyInput = {
    id_cli_cookie_scan_cookies?: number
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    category_id: number
    description?: string | null
  }

  export type as_cli_cookie_scan_cookiesUpdateManyMutationInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesUncheckedUpdateManyInput = {
    id_cli_cookie_scan_cookies?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_urlCreateInput = {
    id_cli_cookie_scan?: number
    url: string
    scanned?: number
    total_cookies?: number
  }

  export type as_cli_cookie_scan_urlUncheckedCreateInput = {
    id_cli_cookie_scan_url?: number
    id_cli_cookie_scan?: number
    url: string
    scanned?: number
    total_cookies?: number
  }

  export type as_cli_cookie_scan_urlUpdateInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    scanned?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scan_urlUncheckedUpdateInput = {
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    scanned?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scan_urlCreateManyInput = {
    id_cli_cookie_scan_url?: number
    id_cli_cookie_scan?: number
    url: string
    scanned?: number
    total_cookies?: number
  }

  export type as_cli_cookie_scan_urlUpdateManyMutationInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    scanned?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_cookie_scan_urlUncheckedUpdateManyInput = {
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    scanned?: IntFieldUpdateOperationsInput | number
    total_cookies?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_scriptsCreateInput = {
    cliscript_title: string
    cliscript_category: string
    cliscript_type?: number | null
    cliscript_status: string
    cliscript_description: string
    cliscript_key: string
    type?: number
  }

  export type as_cli_scriptsUncheckedCreateInput = {
    id?: number
    cliscript_title: string
    cliscript_category: string
    cliscript_type?: number | null
    cliscript_status: string
    cliscript_description: string
    cliscript_key: string
    type?: number
  }

  export type as_cli_scriptsUpdateInput = {
    cliscript_title?: StringFieldUpdateOperationsInput | string
    cliscript_category?: StringFieldUpdateOperationsInput | string
    cliscript_type?: NullableIntFieldUpdateOperationsInput | number | null
    cliscript_status?: StringFieldUpdateOperationsInput | string
    cliscript_description?: StringFieldUpdateOperationsInput | string
    cliscript_key?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_scriptsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliscript_title?: StringFieldUpdateOperationsInput | string
    cliscript_category?: StringFieldUpdateOperationsInput | string
    cliscript_type?: NullableIntFieldUpdateOperationsInput | number | null
    cliscript_status?: StringFieldUpdateOperationsInput | string
    cliscript_description?: StringFieldUpdateOperationsInput | string
    cliscript_key?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_scriptsCreateManyInput = {
    id?: number
    cliscript_title: string
    cliscript_category: string
    cliscript_type?: number | null
    cliscript_status: string
    cliscript_description: string
    cliscript_key: string
    type?: number
  }

  export type as_cli_scriptsUpdateManyMutationInput = {
    cliscript_title?: StringFieldUpdateOperationsInput | string
    cliscript_category?: StringFieldUpdateOperationsInput | string
    cliscript_type?: NullableIntFieldUpdateOperationsInput | number | null
    cliscript_status?: StringFieldUpdateOperationsInput | string
    cliscript_description?: StringFieldUpdateOperationsInput | string
    cliscript_key?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
  }

  export type as_cli_scriptsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliscript_title?: StringFieldUpdateOperationsInput | string
    cliscript_category?: StringFieldUpdateOperationsInput | string
    cliscript_type?: NullableIntFieldUpdateOperationsInput | number | null
    cliscript_status?: StringFieldUpdateOperationsInput | string
    cliscript_description?: StringFieldUpdateOperationsInput | string
    cliscript_key?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
  }

  export type as_commentmetaCreateInput = {
    meta_id?: bigint | number
    comment_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_commentmetaUncheckedCreateInput = {
    meta_id?: bigint | number
    comment_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_commentmetaUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_commentmetaUncheckedUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_commentmetaCreateManyInput = {
    meta_id?: bigint | number
    comment_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_commentmetaUpdateManyMutationInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_commentmetaUncheckedUpdateManyInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_commentsCreateInput = {
    comment_ID?: bigint | number
    comment_post_ID?: bigint | number
    comment_author: string
    comment_author_email?: string
    comment_author_url?: string
    comment_author_IP?: string
    comment_date?: Date | string
    comment_date_gmt?: Date | string
    comment_content: string
    comment_karma?: number
    comment_approved?: string
    comment_agent?: string
    comment_type?: string
    comment_parent?: bigint | number
    user_id?: bigint | number
  }

  export type as_commentsUncheckedCreateInput = {
    comment_ID?: bigint | number
    comment_post_ID?: bigint | number
    comment_author: string
    comment_author_email?: string
    comment_author_url?: string
    comment_author_IP?: string
    comment_date?: Date | string
    comment_date_gmt?: Date | string
    comment_content: string
    comment_karma?: number
    comment_approved?: string
    comment_agent?: string
    comment_type?: string
    comment_parent?: bigint | number
    user_id?: bigint | number
  }

  export type as_commentsUpdateInput = {
    comment_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_post_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_author?: StringFieldUpdateOperationsInput | string
    comment_author_email?: StringFieldUpdateOperationsInput | string
    comment_author_url?: StringFieldUpdateOperationsInput | string
    comment_author_IP?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_content?: StringFieldUpdateOperationsInput | string
    comment_karma?: IntFieldUpdateOperationsInput | number
    comment_approved?: StringFieldUpdateOperationsInput | string
    comment_agent?: StringFieldUpdateOperationsInput | string
    comment_type?: StringFieldUpdateOperationsInput | string
    comment_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_commentsUncheckedUpdateInput = {
    comment_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_post_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_author?: StringFieldUpdateOperationsInput | string
    comment_author_email?: StringFieldUpdateOperationsInput | string
    comment_author_url?: StringFieldUpdateOperationsInput | string
    comment_author_IP?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_content?: StringFieldUpdateOperationsInput | string
    comment_karma?: IntFieldUpdateOperationsInput | number
    comment_approved?: StringFieldUpdateOperationsInput | string
    comment_agent?: StringFieldUpdateOperationsInput | string
    comment_type?: StringFieldUpdateOperationsInput | string
    comment_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_commentsCreateManyInput = {
    comment_ID?: bigint | number
    comment_post_ID?: bigint | number
    comment_author: string
    comment_author_email?: string
    comment_author_url?: string
    comment_author_IP?: string
    comment_date?: Date | string
    comment_date_gmt?: Date | string
    comment_content: string
    comment_karma?: number
    comment_approved?: string
    comment_agent?: string
    comment_type?: string
    comment_parent?: bigint | number
    user_id?: bigint | number
  }

  export type as_commentsUpdateManyMutationInput = {
    comment_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_post_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_author?: StringFieldUpdateOperationsInput | string
    comment_author_email?: StringFieldUpdateOperationsInput | string
    comment_author_url?: StringFieldUpdateOperationsInput | string
    comment_author_IP?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_content?: StringFieldUpdateOperationsInput | string
    comment_karma?: IntFieldUpdateOperationsInput | number
    comment_approved?: StringFieldUpdateOperationsInput | string
    comment_agent?: StringFieldUpdateOperationsInput | string
    comment_type?: StringFieldUpdateOperationsInput | string
    comment_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_commentsUncheckedUpdateManyInput = {
    comment_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_post_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_author?: StringFieldUpdateOperationsInput | string
    comment_author_email?: StringFieldUpdateOperationsInput | string
    comment_author_url?: StringFieldUpdateOperationsInput | string
    comment_author_IP?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_content?: StringFieldUpdateOperationsInput | string
    comment_karma?: IntFieldUpdateOperationsInput | number
    comment_approved?: StringFieldUpdateOperationsInput | string
    comment_agent?: StringFieldUpdateOperationsInput | string
    comment_type?: StringFieldUpdateOperationsInput | string
    comment_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_fusion_form_entriesCreateInput = {
    id?: bigint | number
    submission_id: bigint | number
    form_id: bigint | number
    field_id: bigint | number
    value?: string | null
    privacy?: boolean | null
    data?: string | null
  }

  export type as_fusion_form_entriesUncheckedCreateInput = {
    id?: bigint | number
    submission_id: bigint | number
    form_id: bigint | number
    field_id: bigint | number
    value?: string | null
    privacy?: boolean | null
    data?: string | null
  }

  export type as_fusion_form_entriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    submission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    privacy?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_entriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    submission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    privacy?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_entriesCreateManyInput = {
    id?: bigint | number
    submission_id: bigint | number
    form_id: bigint | number
    field_id: bigint | number
    value?: string | null
    privacy?: boolean | null
    data?: string | null
  }

  export type as_fusion_form_entriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    submission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    privacy?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_entriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    submission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    privacy?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_fieldsCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    field_name: string
    field_label?: string | null
    data?: string | null
  }

  export type as_fusion_form_fieldsUncheckedCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    field_name: string
    field_label?: string | null
    data?: string | null
  }

  export type as_fusion_form_fieldsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_name?: StringFieldUpdateOperationsInput | string
    field_label?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_fieldsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_name?: StringFieldUpdateOperationsInput | string
    field_label?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_fieldsCreateManyInput = {
    id?: bigint | number
    form_id: bigint | number
    field_name: string
    field_label?: string | null
    data?: string | null
  }

  export type as_fusion_form_fieldsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_name?: StringFieldUpdateOperationsInput | string
    field_label?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_fieldsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    field_name?: StringFieldUpdateOperationsInput | string
    field_label?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_submissionsCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    time: Date | string
    source_url: string
    post_id?: bigint | number | null
    user_id?: bigint | number | null
    user_agent?: string | null
    ip?: string | null
    is_read?: boolean | null
    privacy_scrub_date?: Date | string | null
    on_privacy_scrub: string
    data?: string | null
  }

  export type as_fusion_form_submissionsUncheckedCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    time: Date | string
    source_url: string
    post_id?: bigint | number | null
    user_id?: bigint | number | null
    user_agent?: string | null
    ip?: string | null
    is_read?: boolean | null
    privacy_scrub_date?: Date | string | null
    on_privacy_scrub: string
    data?: string | null
  }

  export type as_fusion_form_submissionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: StringFieldUpdateOperationsInput | string
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privacy_scrub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_privacy_scrub?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_submissionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: StringFieldUpdateOperationsInput | string
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privacy_scrub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_privacy_scrub?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_submissionsCreateManyInput = {
    id?: bigint | number
    form_id: bigint | number
    time: Date | string
    source_url: string
    post_id?: bigint | number | null
    user_id?: bigint | number | null
    user_agent?: string | null
    ip?: string | null
    is_read?: boolean | null
    privacy_scrub_date?: Date | string | null
    on_privacy_scrub: string
    data?: string | null
  }

  export type as_fusion_form_submissionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: StringFieldUpdateOperationsInput | string
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privacy_scrub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_privacy_scrub?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_form_submissionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: StringFieldUpdateOperationsInput | string
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    privacy_scrub_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_privacy_scrub?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_formsCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    views?: bigint | number | null
    submissions_count?: bigint | number | null
    data?: string | null
  }

  export type as_fusion_formsUncheckedCreateInput = {
    id?: bigint | number
    form_id: bigint | number
    views?: bigint | number | null
    submissions_count?: bigint | number | null
    data?: string | null
  }

  export type as_fusion_formsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    submissions_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_formsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    submissions_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_formsCreateManyInput = {
    id?: bigint | number
    form_id: bigint | number
    views?: bigint | number | null
    submissions_count?: bigint | number | null
    data?: string | null
  }

  export type as_fusion_formsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    submissions_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_fusion_formsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    form_id?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    submissions_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_layersliderCreateInput = {
    group_id?: number | null
    author?: number
    name?: string | null
    slug?: string | null
    data: string
    date_c: number
    date_m: number
    schedule_start?: number
    schedule_end?: number
    flag_hidden?: boolean
    flag_deleted?: boolean
    flag_popup?: boolean
    flag_group?: boolean
  }

  export type as_layersliderUncheckedCreateInput = {
    id?: number
    group_id?: number | null
    author?: number
    name?: string | null
    slug?: string | null
    data: string
    date_c: number
    date_m: number
    schedule_start?: number
    schedule_end?: number
    flag_hidden?: boolean
    flag_deleted?: boolean
    flag_popup?: boolean
    flag_group?: boolean
  }

  export type as_layersliderUpdateInput = {
    group_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
    date_m?: IntFieldUpdateOperationsInput | number
    schedule_start?: IntFieldUpdateOperationsInput | number
    schedule_end?: IntFieldUpdateOperationsInput | number
    flag_hidden?: BoolFieldUpdateOperationsInput | boolean
    flag_deleted?: BoolFieldUpdateOperationsInput | boolean
    flag_popup?: BoolFieldUpdateOperationsInput | boolean
    flag_group?: BoolFieldUpdateOperationsInput | boolean
  }

  export type as_layersliderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
    date_m?: IntFieldUpdateOperationsInput | number
    schedule_start?: IntFieldUpdateOperationsInput | number
    schedule_end?: IntFieldUpdateOperationsInput | number
    flag_hidden?: BoolFieldUpdateOperationsInput | boolean
    flag_deleted?: BoolFieldUpdateOperationsInput | boolean
    flag_popup?: BoolFieldUpdateOperationsInput | boolean
    flag_group?: BoolFieldUpdateOperationsInput | boolean
  }

  export type as_layersliderCreateManyInput = {
    id?: number
    group_id?: number | null
    author?: number
    name?: string | null
    slug?: string | null
    data: string
    date_c: number
    date_m: number
    schedule_start?: number
    schedule_end?: number
    flag_hidden?: boolean
    flag_deleted?: boolean
    flag_popup?: boolean
    flag_group?: boolean
  }

  export type as_layersliderUpdateManyMutationInput = {
    group_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
    date_m?: IntFieldUpdateOperationsInput | number
    schedule_start?: IntFieldUpdateOperationsInput | number
    schedule_end?: IntFieldUpdateOperationsInput | number
    flag_hidden?: BoolFieldUpdateOperationsInput | boolean
    flag_deleted?: BoolFieldUpdateOperationsInput | boolean
    flag_popup?: BoolFieldUpdateOperationsInput | boolean
    flag_group?: BoolFieldUpdateOperationsInput | boolean
  }

  export type as_layersliderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: NullableIntFieldUpdateOperationsInput | number | null
    author?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
    date_m?: IntFieldUpdateOperationsInput | number
    schedule_start?: IntFieldUpdateOperationsInput | number
    schedule_end?: IntFieldUpdateOperationsInput | number
    flag_hidden?: BoolFieldUpdateOperationsInput | boolean
    flag_deleted?: BoolFieldUpdateOperationsInput | boolean
    flag_popup?: BoolFieldUpdateOperationsInput | boolean
    flag_group?: BoolFieldUpdateOperationsInput | boolean
  }

  export type as_layerslider_revisionsCreateInput = {
    slider_id: number
    author?: number
    data: string
    date_c: number
  }

  export type as_layerslider_revisionsUncheckedCreateInput = {
    id?: number
    slider_id: number
    author?: number
    data: string
    date_c: number
  }

  export type as_layerslider_revisionsUpdateInput = {
    slider_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
  }

  export type as_layerslider_revisionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slider_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
  }

  export type as_layerslider_revisionsCreateManyInput = {
    id?: number
    slider_id: number
    author?: number
    data: string
    date_c: number
  }

  export type as_layerslider_revisionsUpdateManyMutationInput = {
    slider_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
  }

  export type as_layerslider_revisionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slider_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    date_c?: IntFieldUpdateOperationsInput | number
  }

  export type as_linksCreateInput = {
    link_id?: bigint | number
    link_url?: string
    link_name?: string
    link_image?: string
    link_target?: string
    link_description?: string
    link_visible?: string
    link_owner?: bigint | number
    link_rating?: number
    link_updated?: Date | string
    link_rel?: string
    link_notes: string
    link_rss?: string
  }

  export type as_linksUncheckedCreateInput = {
    link_id?: bigint | number
    link_url?: string
    link_name?: string
    link_image?: string
    link_target?: string
    link_description?: string
    link_visible?: string
    link_owner?: bigint | number
    link_rating?: number
    link_updated?: Date | string
    link_rel?: string
    link_notes: string
    link_rss?: string
  }

  export type as_linksUpdateInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    link_url?: StringFieldUpdateOperationsInput | string
    link_name?: StringFieldUpdateOperationsInput | string
    link_image?: StringFieldUpdateOperationsInput | string
    link_target?: StringFieldUpdateOperationsInput | string
    link_description?: StringFieldUpdateOperationsInput | string
    link_visible?: StringFieldUpdateOperationsInput | string
    link_owner?: BigIntFieldUpdateOperationsInput | bigint | number
    link_rating?: IntFieldUpdateOperationsInput | number
    link_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    link_rel?: StringFieldUpdateOperationsInput | string
    link_notes?: StringFieldUpdateOperationsInput | string
    link_rss?: StringFieldUpdateOperationsInput | string
  }

  export type as_linksUncheckedUpdateInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    link_url?: StringFieldUpdateOperationsInput | string
    link_name?: StringFieldUpdateOperationsInput | string
    link_image?: StringFieldUpdateOperationsInput | string
    link_target?: StringFieldUpdateOperationsInput | string
    link_description?: StringFieldUpdateOperationsInput | string
    link_visible?: StringFieldUpdateOperationsInput | string
    link_owner?: BigIntFieldUpdateOperationsInput | bigint | number
    link_rating?: IntFieldUpdateOperationsInput | number
    link_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    link_rel?: StringFieldUpdateOperationsInput | string
    link_notes?: StringFieldUpdateOperationsInput | string
    link_rss?: StringFieldUpdateOperationsInput | string
  }

  export type as_linksCreateManyInput = {
    link_id?: bigint | number
    link_url?: string
    link_name?: string
    link_image?: string
    link_target?: string
    link_description?: string
    link_visible?: string
    link_owner?: bigint | number
    link_rating?: number
    link_updated?: Date | string
    link_rel?: string
    link_notes: string
    link_rss?: string
  }

  export type as_linksUpdateManyMutationInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    link_url?: StringFieldUpdateOperationsInput | string
    link_name?: StringFieldUpdateOperationsInput | string
    link_image?: StringFieldUpdateOperationsInput | string
    link_target?: StringFieldUpdateOperationsInput | string
    link_description?: StringFieldUpdateOperationsInput | string
    link_visible?: StringFieldUpdateOperationsInput | string
    link_owner?: BigIntFieldUpdateOperationsInput | bigint | number
    link_rating?: IntFieldUpdateOperationsInput | number
    link_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    link_rel?: StringFieldUpdateOperationsInput | string
    link_notes?: StringFieldUpdateOperationsInput | string
    link_rss?: StringFieldUpdateOperationsInput | string
  }

  export type as_linksUncheckedUpdateManyInput = {
    link_id?: BigIntFieldUpdateOperationsInput | bigint | number
    link_url?: StringFieldUpdateOperationsInput | string
    link_name?: StringFieldUpdateOperationsInput | string
    link_image?: StringFieldUpdateOperationsInput | string
    link_target?: StringFieldUpdateOperationsInput | string
    link_description?: StringFieldUpdateOperationsInput | string
    link_visible?: StringFieldUpdateOperationsInput | string
    link_owner?: BigIntFieldUpdateOperationsInput | bigint | number
    link_rating?: IntFieldUpdateOperationsInput | number
    link_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    link_rel?: StringFieldUpdateOperationsInput | string
    link_notes?: StringFieldUpdateOperationsInput | string
    link_rss?: StringFieldUpdateOperationsInput | string
  }

  export type as_loginizer_logsCreateInput = {
    username?: string
    time?: number
    count?: number
    lockout?: number
    ip?: string
    url?: string
  }

  export type as_loginizer_logsUncheckedCreateInput = {
    username?: string
    time?: number
    count?: number
    lockout?: number
    ip?: string
    url?: string
  }

  export type as_loginizer_logsUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    lockout?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type as_loginizer_logsUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    lockout?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type as_loginizer_logsCreateManyInput = {
    username?: string
    time?: number
    count?: number
    lockout?: number
    ip?: string
    url?: string
  }

  export type as_loginizer_logsUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    lockout?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type as_loginizer_logsUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    lockout?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type as_optionsCreateInput = {
    option_id?: bigint | number
    option_name?: string
    option_value: string
    autoload?: string
  }

  export type as_optionsUncheckedCreateInput = {
    option_id?: bigint | number
    option_name?: string
    option_value: string
    autoload?: string
  }

  export type as_optionsUpdateInput = {
    option_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_name?: StringFieldUpdateOperationsInput | string
    option_value?: StringFieldUpdateOperationsInput | string
    autoload?: StringFieldUpdateOperationsInput | string
  }

  export type as_optionsUncheckedUpdateInput = {
    option_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_name?: StringFieldUpdateOperationsInput | string
    option_value?: StringFieldUpdateOperationsInput | string
    autoload?: StringFieldUpdateOperationsInput | string
  }

  export type as_optionsCreateManyInput = {
    option_id?: bigint | number
    option_name?: string
    option_value: string
    autoload?: string
  }

  export type as_optionsUpdateManyMutationInput = {
    option_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_name?: StringFieldUpdateOperationsInput | string
    option_value?: StringFieldUpdateOperationsInput | string
    autoload?: StringFieldUpdateOperationsInput | string
  }

  export type as_optionsUncheckedUpdateManyInput = {
    option_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_name?: StringFieldUpdateOperationsInput | string
    option_value?: StringFieldUpdateOperationsInput | string
    autoload?: StringFieldUpdateOperationsInput | string
  }

  export type as_postmetaCreateInput = {
    meta_id?: bigint | number
    post_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_postmetaUncheckedCreateInput = {
    meta_id?: bigint | number
    post_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_postmetaUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_postmetaUncheckedUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_postmetaCreateManyInput = {
    meta_id?: bigint | number
    post_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_postmetaUpdateManyMutationInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_postmetaUncheckedUpdateManyInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_postsCreateInput = {
    ID?: bigint | number
    post_author?: bigint | number
    post_date?: Date | string
    post_date_gmt?: Date | string
    post_content: string
    post_title: string
    post_excerpt: string
    post_status?: string
    comment_status?: string
    ping_status?: string
    post_password?: string
    post_name?: string
    to_ping: string
    pinged: string
    post_modified?: Date | string
    post_modified_gmt?: Date | string
    post_content_filtered: string
    post_parent?: bigint | number
    guid?: string
    menu_order?: number
    post_type?: string
    post_mime_type?: string
    comment_count?: bigint | number
  }

  export type as_postsUncheckedCreateInput = {
    ID?: bigint | number
    post_author?: bigint | number
    post_date?: Date | string
    post_date_gmt?: Date | string
    post_content: string
    post_title: string
    post_excerpt: string
    post_status?: string
    comment_status?: string
    ping_status?: string
    post_password?: string
    post_name?: string
    to_ping: string
    pinged: string
    post_modified?: Date | string
    post_modified_gmt?: Date | string
    post_content_filtered: string
    post_parent?: bigint | number
    guid?: string
    menu_order?: number
    post_type?: string
    post_mime_type?: string
    comment_count?: bigint | number
  }

  export type as_postsUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    post_author?: BigIntFieldUpdateOperationsInput | bigint | number
    post_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content?: StringFieldUpdateOperationsInput | string
    post_title?: StringFieldUpdateOperationsInput | string
    post_excerpt?: StringFieldUpdateOperationsInput | string
    post_status?: StringFieldUpdateOperationsInput | string
    comment_status?: StringFieldUpdateOperationsInput | string
    ping_status?: StringFieldUpdateOperationsInput | string
    post_password?: StringFieldUpdateOperationsInput | string
    post_name?: StringFieldUpdateOperationsInput | string
    to_ping?: StringFieldUpdateOperationsInput | string
    pinged?: StringFieldUpdateOperationsInput | string
    post_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    post_modified_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content_filtered?: StringFieldUpdateOperationsInput | string
    post_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    guid?: StringFieldUpdateOperationsInput | string
    menu_order?: IntFieldUpdateOperationsInput | number
    post_type?: StringFieldUpdateOperationsInput | string
    post_mime_type?: StringFieldUpdateOperationsInput | string
    comment_count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_postsUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    post_author?: BigIntFieldUpdateOperationsInput | bigint | number
    post_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content?: StringFieldUpdateOperationsInput | string
    post_title?: StringFieldUpdateOperationsInput | string
    post_excerpt?: StringFieldUpdateOperationsInput | string
    post_status?: StringFieldUpdateOperationsInput | string
    comment_status?: StringFieldUpdateOperationsInput | string
    ping_status?: StringFieldUpdateOperationsInput | string
    post_password?: StringFieldUpdateOperationsInput | string
    post_name?: StringFieldUpdateOperationsInput | string
    to_ping?: StringFieldUpdateOperationsInput | string
    pinged?: StringFieldUpdateOperationsInput | string
    post_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    post_modified_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content_filtered?: StringFieldUpdateOperationsInput | string
    post_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    guid?: StringFieldUpdateOperationsInput | string
    menu_order?: IntFieldUpdateOperationsInput | number
    post_type?: StringFieldUpdateOperationsInput | string
    post_mime_type?: StringFieldUpdateOperationsInput | string
    comment_count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_postsCreateManyInput = {
    ID?: bigint | number
    post_author?: bigint | number
    post_date?: Date | string
    post_date_gmt?: Date | string
    post_content: string
    post_title: string
    post_excerpt: string
    post_status?: string
    comment_status?: string
    ping_status?: string
    post_password?: string
    post_name?: string
    to_ping: string
    pinged: string
    post_modified?: Date | string
    post_modified_gmt?: Date | string
    post_content_filtered: string
    post_parent?: bigint | number
    guid?: string
    menu_order?: number
    post_type?: string
    post_mime_type?: string
    comment_count?: bigint | number
  }

  export type as_postsUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    post_author?: BigIntFieldUpdateOperationsInput | bigint | number
    post_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content?: StringFieldUpdateOperationsInput | string
    post_title?: StringFieldUpdateOperationsInput | string
    post_excerpt?: StringFieldUpdateOperationsInput | string
    post_status?: StringFieldUpdateOperationsInput | string
    comment_status?: StringFieldUpdateOperationsInput | string
    ping_status?: StringFieldUpdateOperationsInput | string
    post_password?: StringFieldUpdateOperationsInput | string
    post_name?: StringFieldUpdateOperationsInput | string
    to_ping?: StringFieldUpdateOperationsInput | string
    pinged?: StringFieldUpdateOperationsInput | string
    post_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    post_modified_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content_filtered?: StringFieldUpdateOperationsInput | string
    post_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    guid?: StringFieldUpdateOperationsInput | string
    menu_order?: IntFieldUpdateOperationsInput | number
    post_type?: StringFieldUpdateOperationsInput | string
    post_mime_type?: StringFieldUpdateOperationsInput | string
    comment_count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_postsUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    post_author?: BigIntFieldUpdateOperationsInput | bigint | number
    post_date?: DateTimeFieldUpdateOperationsInput | Date | string
    post_date_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content?: StringFieldUpdateOperationsInput | string
    post_title?: StringFieldUpdateOperationsInput | string
    post_excerpt?: StringFieldUpdateOperationsInput | string
    post_status?: StringFieldUpdateOperationsInput | string
    comment_status?: StringFieldUpdateOperationsInput | string
    ping_status?: StringFieldUpdateOperationsInput | string
    post_password?: StringFieldUpdateOperationsInput | string
    post_name?: StringFieldUpdateOperationsInput | string
    to_ping?: StringFieldUpdateOperationsInput | string
    pinged?: StringFieldUpdateOperationsInput | string
    post_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    post_modified_gmt?: DateTimeFieldUpdateOperationsInput | Date | string
    post_content_filtered?: StringFieldUpdateOperationsInput | string
    post_parent?: BigIntFieldUpdateOperationsInput | bigint | number
    guid?: StringFieldUpdateOperationsInput | string
    menu_order?: IntFieldUpdateOperationsInput | number
    post_type?: StringFieldUpdateOperationsInput | string
    post_mime_type?: StringFieldUpdateOperationsInput | string
    comment_count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_term_relationshipsCreateInput = {
    object_id?: bigint | number
    term_taxonomy_id?: bigint | number
    term_order?: number
  }

  export type as_term_relationshipsUncheckedCreateInput = {
    object_id?: bigint | number
    term_taxonomy_id?: bigint | number
    term_order?: number
  }

  export type as_term_relationshipsUpdateInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_order?: IntFieldUpdateOperationsInput | number
  }

  export type as_term_relationshipsUncheckedUpdateInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_order?: IntFieldUpdateOperationsInput | number
  }

  export type as_term_relationshipsCreateManyInput = {
    object_id?: bigint | number
    term_taxonomy_id?: bigint | number
    term_order?: number
  }

  export type as_term_relationshipsUpdateManyMutationInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_order?: IntFieldUpdateOperationsInput | number
  }

  export type as_term_relationshipsUncheckedUpdateManyInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_order?: IntFieldUpdateOperationsInput | number
  }

  export type as_term_taxonomyCreateInput = {
    term_taxonomy_id?: bigint | number
    term_id?: bigint | number
    taxonomy?: string
    description: string
    parent?: bigint | number
    count?: bigint | number
  }

  export type as_term_taxonomyUncheckedCreateInput = {
    term_taxonomy_id?: bigint | number
    term_id?: bigint | number
    taxonomy?: string
    description: string
    parent?: bigint | number
    count?: bigint | number
  }

  export type as_term_taxonomyUpdateInput = {
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    parent?: BigIntFieldUpdateOperationsInput | bigint | number
    count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_term_taxonomyUncheckedUpdateInput = {
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    parent?: BigIntFieldUpdateOperationsInput | bigint | number
    count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_term_taxonomyCreateManyInput = {
    term_taxonomy_id?: bigint | number
    term_id?: bigint | number
    taxonomy?: string
    description: string
    parent?: bigint | number
    count?: bigint | number
  }

  export type as_term_taxonomyUpdateManyMutationInput = {
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    parent?: BigIntFieldUpdateOperationsInput | bigint | number
    count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_term_taxonomyUncheckedUpdateManyInput = {
    term_taxonomy_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    parent?: BigIntFieldUpdateOperationsInput | bigint | number
    count?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_termmetaCreateInput = {
    meta_id?: bigint | number
    term_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_termmetaUncheckedCreateInput = {
    meta_id?: bigint | number
    term_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_termmetaUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_termmetaUncheckedUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_termmetaCreateManyInput = {
    meta_id?: bigint | number
    term_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_termmetaUpdateManyMutationInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_termmetaUncheckedUpdateManyInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_termsCreateInput = {
    term_id?: bigint | number
    name?: string
    slug?: string
    term_group?: bigint | number
  }

  export type as_termsUncheckedCreateInput = {
    term_id?: bigint | number
    name?: string
    slug?: string
    term_group?: bigint | number
  }

  export type as_termsUpdateInput = {
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    term_group?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_termsUncheckedUpdateInput = {
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    term_group?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_termsCreateManyInput = {
    term_id?: bigint | number
    name?: string
    slug?: string
    term_group?: bigint | number
  }

  export type as_termsUpdateManyMutationInput = {
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    term_group?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_termsUncheckedUpdateManyInput = {
    term_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    term_group?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_tm_taskmetaCreateInput = {
    meta_id?: bigint | number
    task_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_tm_taskmetaUncheckedCreateInput = {
    meta_id?: bigint | number
    task_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_tm_taskmetaUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_taskmetaUncheckedUpdateInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_taskmetaCreateManyInput = {
    meta_id?: bigint | number
    task_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_tm_taskmetaUpdateManyMutationInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_taskmetaUncheckedUpdateManyInput = {
    meta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_tasksCreateInput = {
    user_id: bigint | number
    type: string
    class_identifier?: string | null
    attempts?: number | null
    description?: string | null
    time_created?: Date | string
    last_locked_at?: bigint | number | null
    status?: string | null
  }

  export type as_tm_tasksUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    type: string
    class_identifier?: string | null
    attempts?: number | null
    description?: string | null
    time_created?: Date | string
    last_locked_at?: bigint | number | null
    status?: string | null
  }

  export type as_tm_tasksUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    class_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    time_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_locked_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_tasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    class_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    time_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_locked_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_tasksCreateManyInput = {
    id?: number
    user_id: bigint | number
    type: string
    class_identifier?: string | null
    attempts?: number | null
    description?: string | null
    time_created?: Date | string
    last_locked_at?: bigint | number | null
    status?: string | null
  }

  export type as_tm_tasksUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    class_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    time_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_locked_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_tm_tasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    class_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    time_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_locked_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_usermetaCreateInput = {
    umeta_id?: bigint | number
    user_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_usermetaUncheckedCreateInput = {
    umeta_id?: bigint | number
    user_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_usermetaUpdateInput = {
    umeta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_usermetaUncheckedUpdateInput = {
    umeta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_usermetaCreateManyInput = {
    umeta_id?: bigint | number
    user_id?: bigint | number
    meta_key?: string | null
    meta_value?: string | null
  }

  export type as_usermetaUpdateManyMutationInput = {
    umeta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_usermetaUncheckedUpdateManyInput = {
    umeta_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_key?: NullableStringFieldUpdateOperationsInput | string | null
    meta_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_usersCreateInput = {
    ID?: bigint | number
    user_login?: string
    user_pass?: string
    user_nicename?: string
    user_email?: string
    user_url?: string
    user_registered?: Date | string
    user_activation_key?: string
    user_status?: number
    display_name?: string
  }

  export type as_usersUncheckedCreateInput = {
    ID?: bigint | number
    user_login?: string
    user_pass?: string
    user_nicename?: string
    user_email?: string
    user_url?: string
    user_registered?: Date | string
    user_activation_key?: string
    user_status?: number
    display_name?: string
  }

  export type as_usersUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    user_login?: StringFieldUpdateOperationsInput | string
    user_pass?: StringFieldUpdateOperationsInput | string
    user_nicename?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_url?: StringFieldUpdateOperationsInput | string
    user_registered?: DateTimeFieldUpdateOperationsInput | Date | string
    user_activation_key?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    display_name?: StringFieldUpdateOperationsInput | string
  }

  export type as_usersUncheckedUpdateInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    user_login?: StringFieldUpdateOperationsInput | string
    user_pass?: StringFieldUpdateOperationsInput | string
    user_nicename?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_url?: StringFieldUpdateOperationsInput | string
    user_registered?: DateTimeFieldUpdateOperationsInput | Date | string
    user_activation_key?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    display_name?: StringFieldUpdateOperationsInput | string
  }

  export type as_usersCreateManyInput = {
    ID?: bigint | number
    user_login?: string
    user_pass?: string
    user_nicename?: string
    user_email?: string
    user_url?: string
    user_registered?: Date | string
    user_activation_key?: string
    user_status?: number
    display_name?: string
  }

  export type as_usersUpdateManyMutationInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    user_login?: StringFieldUpdateOperationsInput | string
    user_pass?: StringFieldUpdateOperationsInput | string
    user_nicename?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_url?: StringFieldUpdateOperationsInput | string
    user_registered?: DateTimeFieldUpdateOperationsInput | Date | string
    user_activation_key?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    display_name?: StringFieldUpdateOperationsInput | string
  }

  export type as_usersUncheckedUpdateManyInput = {
    ID?: BigIntFieldUpdateOperationsInput | bigint | number
    user_login?: StringFieldUpdateOperationsInput | string
    user_pass?: StringFieldUpdateOperationsInput | string
    user_nicename?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_url?: StringFieldUpdateOperationsInput | string
    user_registered?: DateTimeFieldUpdateOperationsInput | Date | string
    user_activation_key?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    display_name?: StringFieldUpdateOperationsInput | string
  }

  export type as_wpo_404_detectorCreateInput = {
    url: string
    request_timestamp: bigint | number
    request_count: bigint | number
    referrer: string
  }

  export type as_wpo_404_detectorUncheckedCreateInput = {
    ID?: number
    url: string
    request_timestamp: bigint | number
    request_count: bigint | number
    referrer: string
  }

  export type as_wpo_404_detectorUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    request_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    request_count?: BigIntFieldUpdateOperationsInput | bigint | number
    referrer?: StringFieldUpdateOperationsInput | string
  }

  export type as_wpo_404_detectorUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    request_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    request_count?: BigIntFieldUpdateOperationsInput | bigint | number
    referrer?: StringFieldUpdateOperationsInput | string
  }

  export type as_wpo_404_detectorCreateManyInput = {
    ID?: number
    url: string
    request_timestamp: bigint | number
    request_count: bigint | number
    referrer: string
  }

  export type as_wpo_404_detectorUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    request_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    request_count?: BigIntFieldUpdateOperationsInput | bigint | number
    referrer?: StringFieldUpdateOperationsInput | string
  }

  export type as_wpo_404_detectorUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    request_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    request_count?: BigIntFieldUpdateOperationsInput | bigint | number
    referrer?: StringFieldUpdateOperationsInput | string
  }

  export type as_yoast_indexableCreateInput = {
    permalink?: string | null
    permalink_hash?: string | null
    object_id?: bigint | number | null
    object_type: string
    object_sub_type?: string | null
    author_id?: bigint | number | null
    post_parent?: bigint | number | null
    title?: string | null
    description?: string | null
    breadcrumb_title?: string | null
    post_status?: string | null
    is_public?: boolean | null
    is_protected?: boolean | null
    has_public_posts?: boolean | null
    number_of_pages?: number | null
    canonical?: string | null
    primary_focus_keyword?: string | null
    primary_focus_keyword_score?: number | null
    readability_score?: number | null
    is_cornerstone?: boolean | null
    is_robots_noindex?: boolean | null
    is_robots_nofollow?: boolean | null
    is_robots_noarchive?: boolean | null
    is_robots_noimageindex?: boolean | null
    is_robots_nosnippet?: boolean | null
    twitter_title?: string | null
    twitter_image?: string | null
    twitter_description?: string | null
    twitter_image_id?: string | null
    twitter_image_source?: string | null
    open_graph_title?: string | null
    open_graph_description?: string | null
    open_graph_image?: string | null
    open_graph_image_id?: string | null
    open_graph_image_source?: string | null
    open_graph_image_meta?: string | null
    link_count?: number | null
    incoming_link_count?: number | null
    prominent_words_version?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
    language?: string | null
    region?: string | null
    schema_page_type?: string | null
    schema_article_type?: string | null
    has_ancestors?: boolean | null
    estimated_reading_time_minutes?: number | null
    version?: number | null
    object_last_modified?: Date | string | null
    object_published_at?: Date | string | null
    inclusive_language_score?: number | null
  }

  export type as_yoast_indexableUncheckedCreateInput = {
    id?: number
    permalink?: string | null
    permalink_hash?: string | null
    object_id?: bigint | number | null
    object_type: string
    object_sub_type?: string | null
    author_id?: bigint | number | null
    post_parent?: bigint | number | null
    title?: string | null
    description?: string | null
    breadcrumb_title?: string | null
    post_status?: string | null
    is_public?: boolean | null
    is_protected?: boolean | null
    has_public_posts?: boolean | null
    number_of_pages?: number | null
    canonical?: string | null
    primary_focus_keyword?: string | null
    primary_focus_keyword_score?: number | null
    readability_score?: number | null
    is_cornerstone?: boolean | null
    is_robots_noindex?: boolean | null
    is_robots_nofollow?: boolean | null
    is_robots_noarchive?: boolean | null
    is_robots_noimageindex?: boolean | null
    is_robots_nosnippet?: boolean | null
    twitter_title?: string | null
    twitter_image?: string | null
    twitter_description?: string | null
    twitter_image_id?: string | null
    twitter_image_source?: string | null
    open_graph_title?: string | null
    open_graph_description?: string | null
    open_graph_image?: string | null
    open_graph_image_id?: string | null
    open_graph_image_source?: string | null
    open_graph_image_meta?: string | null
    link_count?: number | null
    incoming_link_count?: number | null
    prominent_words_version?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
    language?: string | null
    region?: string | null
    schema_page_type?: string | null
    schema_article_type?: string | null
    has_ancestors?: boolean | null
    estimated_reading_time_minutes?: number | null
    version?: number | null
    object_last_modified?: Date | string | null
    object_published_at?: Date | string | null
    inclusive_language_score?: number | null
  }

  export type as_yoast_indexableUpdateInput = {
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    permalink_hash?: NullableStringFieldUpdateOperationsInput | string | null
    object_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    object_type?: StringFieldUpdateOperationsInput | string
    object_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    post_parent?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    breadcrumb_title?: NullableStringFieldUpdateOperationsInput | string | null
    post_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_protected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_public_posts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    number_of_pages?: NullableIntFieldUpdateOperationsInput | number | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword_score?: NullableIntFieldUpdateOperationsInput | number | null
    readability_score?: NullableIntFieldUpdateOperationsInput | number | null
    is_cornerstone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nofollow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noarchive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noimageindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nosnippet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twitter_title?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_description?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_title?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_description?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_meta?: NullableStringFieldUpdateOperationsInput | string | null
    link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    prominent_words_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    schema_page_type?: NullableStringFieldUpdateOperationsInput | string | null
    schema_article_type?: NullableStringFieldUpdateOperationsInput | string | null
    has_ancestors?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_reading_time_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    object_last_modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    object_published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inclusive_language_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_indexableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    permalink_hash?: NullableStringFieldUpdateOperationsInput | string | null
    object_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    object_type?: StringFieldUpdateOperationsInput | string
    object_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    post_parent?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    breadcrumb_title?: NullableStringFieldUpdateOperationsInput | string | null
    post_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_protected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_public_posts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    number_of_pages?: NullableIntFieldUpdateOperationsInput | number | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword_score?: NullableIntFieldUpdateOperationsInput | number | null
    readability_score?: NullableIntFieldUpdateOperationsInput | number | null
    is_cornerstone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nofollow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noarchive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noimageindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nosnippet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twitter_title?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_description?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_title?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_description?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_meta?: NullableStringFieldUpdateOperationsInput | string | null
    link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    prominent_words_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    schema_page_type?: NullableStringFieldUpdateOperationsInput | string | null
    schema_article_type?: NullableStringFieldUpdateOperationsInput | string | null
    has_ancestors?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_reading_time_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    object_last_modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    object_published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inclusive_language_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_indexableCreateManyInput = {
    id?: number
    permalink?: string | null
    permalink_hash?: string | null
    object_id?: bigint | number | null
    object_type: string
    object_sub_type?: string | null
    author_id?: bigint | number | null
    post_parent?: bigint | number | null
    title?: string | null
    description?: string | null
    breadcrumb_title?: string | null
    post_status?: string | null
    is_public?: boolean | null
    is_protected?: boolean | null
    has_public_posts?: boolean | null
    number_of_pages?: number | null
    canonical?: string | null
    primary_focus_keyword?: string | null
    primary_focus_keyword_score?: number | null
    readability_score?: number | null
    is_cornerstone?: boolean | null
    is_robots_noindex?: boolean | null
    is_robots_nofollow?: boolean | null
    is_robots_noarchive?: boolean | null
    is_robots_noimageindex?: boolean | null
    is_robots_nosnippet?: boolean | null
    twitter_title?: string | null
    twitter_image?: string | null
    twitter_description?: string | null
    twitter_image_id?: string | null
    twitter_image_source?: string | null
    open_graph_title?: string | null
    open_graph_description?: string | null
    open_graph_image?: string | null
    open_graph_image_id?: string | null
    open_graph_image_source?: string | null
    open_graph_image_meta?: string | null
    link_count?: number | null
    incoming_link_count?: number | null
    prominent_words_version?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
    language?: string | null
    region?: string | null
    schema_page_type?: string | null
    schema_article_type?: string | null
    has_ancestors?: boolean | null
    estimated_reading_time_minutes?: number | null
    version?: number | null
    object_last_modified?: Date | string | null
    object_published_at?: Date | string | null
    inclusive_language_score?: number | null
  }

  export type as_yoast_indexableUpdateManyMutationInput = {
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    permalink_hash?: NullableStringFieldUpdateOperationsInput | string | null
    object_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    object_type?: StringFieldUpdateOperationsInput | string
    object_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    post_parent?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    breadcrumb_title?: NullableStringFieldUpdateOperationsInput | string | null
    post_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_protected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_public_posts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    number_of_pages?: NullableIntFieldUpdateOperationsInput | number | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword_score?: NullableIntFieldUpdateOperationsInput | number | null
    readability_score?: NullableIntFieldUpdateOperationsInput | number | null
    is_cornerstone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nofollow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noarchive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noimageindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nosnippet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twitter_title?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_description?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_title?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_description?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_meta?: NullableStringFieldUpdateOperationsInput | string | null
    link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    prominent_words_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    schema_page_type?: NullableStringFieldUpdateOperationsInput | string | null
    schema_article_type?: NullableStringFieldUpdateOperationsInput | string | null
    has_ancestors?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_reading_time_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    object_last_modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    object_published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inclusive_language_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_indexableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    permalink_hash?: NullableStringFieldUpdateOperationsInput | string | null
    object_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    object_type?: StringFieldUpdateOperationsInput | string
    object_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    author_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    post_parent?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    breadcrumb_title?: NullableStringFieldUpdateOperationsInput | string | null
    post_status?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_protected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_public_posts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    number_of_pages?: NullableIntFieldUpdateOperationsInput | number | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    primary_focus_keyword_score?: NullableIntFieldUpdateOperationsInput | number | null
    readability_score?: NullableIntFieldUpdateOperationsInput | number | null
    is_cornerstone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nofollow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noarchive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_noimageindex?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_robots_nosnippet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    twitter_title?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_description?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    twitter_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_title?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_description?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_id?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_source?: NullableStringFieldUpdateOperationsInput | string | null
    open_graph_image_meta?: NullableStringFieldUpdateOperationsInput | string | null
    link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    prominent_words_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    schema_page_type?: NullableStringFieldUpdateOperationsInput | string | null
    schema_article_type?: NullableStringFieldUpdateOperationsInput | string | null
    has_ancestors?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_reading_time_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    object_last_modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    object_published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inclusive_language_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_indexable_hierarchyCreateInput = {
    indexable_id: number
    ancestor_id: number
    depth?: number | null
    blog_id?: bigint | number
  }

  export type as_yoast_indexable_hierarchyUncheckedCreateInput = {
    indexable_id: number
    ancestor_id: number
    depth?: number | null
    blog_id?: bigint | number
  }

  export type as_yoast_indexable_hierarchyUpdateInput = {
    indexable_id?: IntFieldUpdateOperationsInput | number
    ancestor_id?: IntFieldUpdateOperationsInput | number
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_indexable_hierarchyUncheckedUpdateInput = {
    indexable_id?: IntFieldUpdateOperationsInput | number
    ancestor_id?: IntFieldUpdateOperationsInput | number
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_indexable_hierarchyCreateManyInput = {
    indexable_id: number
    ancestor_id: number
    depth?: number | null
    blog_id?: bigint | number
  }

  export type as_yoast_indexable_hierarchyUpdateManyMutationInput = {
    indexable_id?: IntFieldUpdateOperationsInput | number
    ancestor_id?: IntFieldUpdateOperationsInput | number
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_indexable_hierarchyUncheckedUpdateManyInput = {
    indexable_id?: IntFieldUpdateOperationsInput | number
    ancestor_id?: IntFieldUpdateOperationsInput | number
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_migrationsCreateInput = {
    version?: string | null
  }

  export type as_yoast_migrationsUncheckedCreateInput = {
    id?: number
    version?: string | null
  }

  export type as_yoast_migrationsUpdateInput = {
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_migrationsCreateManyInput = {
    id?: number
    version?: string | null
  }

  export type as_yoast_migrationsUpdateManyMutationInput = {
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_primary_termCreateInput = {
    post_id?: bigint | number | null
    term_id?: bigint | number | null
    taxonomy: string
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
  }

  export type as_yoast_primary_termUncheckedCreateInput = {
    id?: number
    post_id?: bigint | number | null
    term_id?: bigint | number | null
    taxonomy: string
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
  }

  export type as_yoast_primary_termUpdateInput = {
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    term_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    taxonomy?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_primary_termUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    term_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    taxonomy?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_primary_termCreateManyInput = {
    id?: number
    post_id?: bigint | number | null
    term_id?: bigint | number | null
    taxonomy: string
    created_at?: Date | string | null
    updated_at?: Date | string
    blog_id?: bigint | number
  }

  export type as_yoast_primary_termUpdateManyMutationInput = {
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    term_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    taxonomy?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_primary_termUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    term_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    taxonomy?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blog_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type as_yoast_seo_linksCreateInput = {
    id?: bigint | number
    url: string
    post_id: bigint | number
    target_post_id: bigint | number
    type: string
    indexable_id?: number | null
    target_indexable_id?: number | null
    height?: number | null
    width?: number | null
    size?: number | null
    language?: string | null
    region?: string | null
  }

  export type as_yoast_seo_linksUncheckedCreateInput = {
    id?: bigint | number
    url: string
    post_id: bigint | number
    target_post_id: bigint | number
    type: string
    indexable_id?: number | null
    target_indexable_id?: number | null
    height?: number | null
    width?: number | null
    size?: number | null
    language?: string | null
    region?: string | null
  }

  export type as_yoast_seo_linksUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_seo_linksUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_seo_linksCreateManyInput = {
    id?: bigint | number
    url: string
    post_id: bigint | number
    target_post_id: bigint | number
    type: string
    indexable_id?: number | null
    target_indexable_id?: number | null
    height?: number | null
    width?: number | null
    size?: number | null
    language?: string | null
    region?: string | null
  }

  export type as_yoast_seo_linksUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_seo_linksUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_indexable_id?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_yoast_seo_metaCreateInput = {
    object_id: bigint | number
    internal_link_count?: number | null
    incoming_link_count?: number | null
  }

  export type as_yoast_seo_metaUncheckedCreateInput = {
    object_id: bigint | number
    internal_link_count?: number | null
    incoming_link_count?: number | null
  }

  export type as_yoast_seo_metaUpdateInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    internal_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_seo_metaUncheckedUpdateInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    internal_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_seo_metaCreateManyInput = {
    object_id: bigint | number
    internal_link_count?: number | null
    incoming_link_count?: number | null
  }

  export type as_yoast_seo_metaUpdateManyMutationInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    internal_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type as_yoast_seo_metaUncheckedUpdateManyInput = {
    object_id?: BigIntFieldUpdateOperationsInput | bigint | number
    internal_link_count?: NullableIntFieldUpdateOperationsInput | number | null
    incoming_link_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type as_actionscheduler_actionsOrderByRelevanceInput = {
    fields:
      | as_actionscheduler_actionsOrderByRelevanceFieldEnum
      | as_actionscheduler_actionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_actionscheduler_actionsCountOrderByAggregateInput = {
    action_id?: SortOrder
    hook?: SortOrder
    status?: SortOrder
    scheduled_date_gmt?: SortOrder
    scheduled_date_local?: SortOrder
    args?: SortOrder
    schedule?: SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    last_attempt_gmt?: SortOrder
    last_attempt_local?: SortOrder
    claim_id?: SortOrder
    extended_args?: SortOrder
    priority?: SortOrder
  }

  export type as_actionscheduler_actionsAvgOrderByAggregateInput = {
    action_id?: SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    claim_id?: SortOrder
    priority?: SortOrder
  }

  export type as_actionscheduler_actionsMaxOrderByAggregateInput = {
    action_id?: SortOrder
    hook?: SortOrder
    status?: SortOrder
    scheduled_date_gmt?: SortOrder
    scheduled_date_local?: SortOrder
    args?: SortOrder
    schedule?: SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    last_attempt_gmt?: SortOrder
    last_attempt_local?: SortOrder
    claim_id?: SortOrder
    extended_args?: SortOrder
    priority?: SortOrder
  }

  export type as_actionscheduler_actionsMinOrderByAggregateInput = {
    action_id?: SortOrder
    hook?: SortOrder
    status?: SortOrder
    scheduled_date_gmt?: SortOrder
    scheduled_date_local?: SortOrder
    args?: SortOrder
    schedule?: SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    last_attempt_gmt?: SortOrder
    last_attempt_local?: SortOrder
    claim_id?: SortOrder
    extended_args?: SortOrder
    priority?: SortOrder
  }

  export type as_actionscheduler_actionsSumOrderByAggregateInput = {
    action_id?: SortOrder
    group_id?: SortOrder
    attempts?: SortOrder
    claim_id?: SortOrder
    priority?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type as_actionscheduler_claimsCountOrderByAggregateInput = {
    claim_id?: SortOrder
    date_created_gmt?: SortOrder
  }

  export type as_actionscheduler_claimsAvgOrderByAggregateInput = {
    claim_id?: SortOrder
  }

  export type as_actionscheduler_claimsMaxOrderByAggregateInput = {
    claim_id?: SortOrder
    date_created_gmt?: SortOrder
  }

  export type as_actionscheduler_claimsMinOrderByAggregateInput = {
    claim_id?: SortOrder
    date_created_gmt?: SortOrder
  }

  export type as_actionscheduler_claimsSumOrderByAggregateInput = {
    claim_id?: SortOrder
  }

  export type as_actionscheduler_groupsOrderByRelevanceInput = {
    fields:
      | as_actionscheduler_groupsOrderByRelevanceFieldEnum
      | as_actionscheduler_groupsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_actionscheduler_groupsCountOrderByAggregateInput = {
    group_id?: SortOrder
    slug?: SortOrder
  }

  export type as_actionscheduler_groupsAvgOrderByAggregateInput = {
    group_id?: SortOrder
  }

  export type as_actionscheduler_groupsMaxOrderByAggregateInput = {
    group_id?: SortOrder
    slug?: SortOrder
  }

  export type as_actionscheduler_groupsMinOrderByAggregateInput = {
    group_id?: SortOrder
    slug?: SortOrder
  }

  export type as_actionscheduler_groupsSumOrderByAggregateInput = {
    group_id?: SortOrder
  }

  export type as_actionscheduler_logsOrderByRelevanceInput = {
    fields:
      | as_actionscheduler_logsOrderByRelevanceFieldEnum
      | as_actionscheduler_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_actionscheduler_logsCountOrderByAggregateInput = {
    log_id?: SortOrder
    action_id?: SortOrder
    message?: SortOrder
    log_date_gmt?: SortOrder
    log_date_local?: SortOrder
  }

  export type as_actionscheduler_logsAvgOrderByAggregateInput = {
    log_id?: SortOrder
    action_id?: SortOrder
  }

  export type as_actionscheduler_logsMaxOrderByAggregateInput = {
    log_id?: SortOrder
    action_id?: SortOrder
    message?: SortOrder
    log_date_gmt?: SortOrder
    log_date_local?: SortOrder
  }

  export type as_actionscheduler_logsMinOrderByAggregateInput = {
    log_id?: SortOrder
    action_id?: SortOrder
    message?: SortOrder
    log_date_gmt?: SortOrder
    log_date_local?: SortOrder
  }

  export type as_actionscheduler_logsSumOrderByAggregateInput = {
    log_id?: SortOrder
    action_id?: SortOrder
  }

  export type as_awb_critical_cssOrderByRelevanceInput = {
    fields:
      | as_awb_critical_cssOrderByRelevanceFieldEnum
      | as_awb_critical_cssOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_awb_critical_cssCountOrderByAggregateInput = {
    id?: SortOrder
    css_key?: SortOrder
    mobile_css?: SortOrder
    desktop_css?: SortOrder
    mobile_preloads?: SortOrder
    desktop_preloads?: SortOrder
    updated_at?: SortOrder
  }

  export type as_awb_critical_cssAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type as_awb_critical_cssMaxOrderByAggregateInput = {
    id?: SortOrder
    css_key?: SortOrder
    mobile_css?: SortOrder
    desktop_css?: SortOrder
    mobile_preloads?: SortOrder
    desktop_preloads?: SortOrder
    updated_at?: SortOrder
  }

  export type as_awb_critical_cssMinOrderByAggregateInput = {
    id?: SortOrder
    css_key?: SortOrder
    mobile_css?: SortOrder
    desktop_css?: SortOrder
    mobile_preloads?: SortOrder
    desktop_preloads?: SortOrder
    updated_at?: SortOrder
  }

  export type as_awb_critical_cssSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type as_cli_cookie_scanOrderByRelevanceInput = {
    fields:
      | as_cli_cookie_scanOrderByRelevanceFieldEnum
      | as_cli_cookie_scanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_cli_cookie_scanCountOrderByAggregateInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_action?: SortOrder
    current_offset?: SortOrder
  }

  export type as_cli_cookie_scanAvgOrderByAggregateInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_offset?: SortOrder
  }

  export type as_cli_cookie_scanMaxOrderByAggregateInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_action?: SortOrder
    current_offset?: SortOrder
  }

  export type as_cli_cookie_scanMinOrderByAggregateInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_action?: SortOrder
    current_offset?: SortOrder
  }

  export type as_cli_cookie_scanSumOrderByAggregateInput = {
    id_cli_cookie_scan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    total_url?: SortOrder
    total_cookies?: SortOrder
    current_offset?: SortOrder
  }

  export type As_cli_cookie_scan_cookiesListRelationFilter = {
    every?: as_cli_cookie_scan_cookiesWhereInput
    some?: as_cli_cookie_scan_cookiesWhereInput
    none?: as_cli_cookie_scan_cookiesWhereInput
  }

  export type as_cli_cookie_scan_cookiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type as_cli_cookie_scan_categoriesOrderByRelevanceInput = {
    fields:
      | as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum
      | as_cli_cookie_scan_categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_cli_cookie_scan_categoriesCountOrderByAggregateInput = {
    id_cli_cookie_category?: SortOrder
    cli_cookie_category_name?: SortOrder
    cli_cookie_category_description?: SortOrder
  }

  export type as_cli_cookie_scan_categoriesAvgOrderByAggregateInput = {
    id_cli_cookie_category?: SortOrder
  }

  export type as_cli_cookie_scan_categoriesMaxOrderByAggregateInput = {
    id_cli_cookie_category?: SortOrder
    cli_cookie_category_name?: SortOrder
    cli_cookie_category_description?: SortOrder
  }

  export type as_cli_cookie_scan_categoriesMinOrderByAggregateInput = {
    id_cli_cookie_category?: SortOrder
    cli_cookie_category_name?: SortOrder
    cli_cookie_category_description?: SortOrder
  }

  export type as_cli_cookie_scan_categoriesSumOrderByAggregateInput = {
    id_cli_cookie_category?: SortOrder
  }

  export type As_cli_cookie_scan_categoriesScalarRelationFilter = {
    is?: as_cli_cookie_scan_categoriesWhereInput
    isNot?: as_cli_cookie_scan_categoriesWhereInput
  }

  export type as_cli_cookie_scan_cookiesOrderByRelevanceInput = {
    fields:
      | as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum
      | as_cli_cookie_scan_cookiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_cli_cookie_scan_cookiesId_cli_cookie_scanCookie_idCompoundUniqueInput = {
    id_cli_cookie_scan: number
    cookie_id: string
  }

  export type as_cli_cookie_scan_cookiesCountOrderByAggregateInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    cookie_id?: SortOrder
    expiry?: SortOrder
    type?: SortOrder
    category?: SortOrder
    category_id?: SortOrder
    description?: SortOrder
  }

  export type as_cli_cookie_scan_cookiesAvgOrderByAggregateInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    category_id?: SortOrder
  }

  export type as_cli_cookie_scan_cookiesMaxOrderByAggregateInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    cookie_id?: SortOrder
    expiry?: SortOrder
    type?: SortOrder
    category?: SortOrder
    category_id?: SortOrder
    description?: SortOrder
  }

  export type as_cli_cookie_scan_cookiesMinOrderByAggregateInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    cookie_id?: SortOrder
    expiry?: SortOrder
    type?: SortOrder
    category?: SortOrder
    category_id?: SortOrder
    description?: SortOrder
  }

  export type as_cli_cookie_scan_cookiesSumOrderByAggregateInput = {
    id_cli_cookie_scan_cookies?: SortOrder
    id_cli_cookie_scan?: SortOrder
    id_cli_cookie_scan_url?: SortOrder
    category_id?: SortOrder
  }

  export type as_cli_cookie_scan_urlOrderByRelevanceInput = {
    fields:
      | as_cli_cookie_scan_urlOrderByRelevanceFieldEnum
      | as_cli_cookie_scan_urlOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_cli_cookie_scan_urlCountOrderByAggregateInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    url?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
  }

  export type as_cli_cookie_scan_urlAvgOrderByAggregateInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
  }

  export type as_cli_cookie_scan_urlMaxOrderByAggregateInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    url?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
  }

  export type as_cli_cookie_scan_urlMinOrderByAggregateInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    url?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
  }

  export type as_cli_cookie_scan_urlSumOrderByAggregateInput = {
    id_cli_cookie_scan_url?: SortOrder
    id_cli_cookie_scan?: SortOrder
    scanned?: SortOrder
    total_cookies?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type as_cli_scriptsOrderByRelevanceInput = {
    fields: as_cli_scriptsOrderByRelevanceFieldEnum | as_cli_scriptsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_cli_scriptsCountOrderByAggregateInput = {
    id?: SortOrder
    cliscript_title?: SortOrder
    cliscript_category?: SortOrder
    cliscript_type?: SortOrder
    cliscript_status?: SortOrder
    cliscript_description?: SortOrder
    cliscript_key?: SortOrder
    type?: SortOrder
  }

  export type as_cli_scriptsAvgOrderByAggregateInput = {
    id?: SortOrder
    cliscript_type?: SortOrder
    type?: SortOrder
  }

  export type as_cli_scriptsMaxOrderByAggregateInput = {
    id?: SortOrder
    cliscript_title?: SortOrder
    cliscript_category?: SortOrder
    cliscript_type?: SortOrder
    cliscript_status?: SortOrder
    cliscript_description?: SortOrder
    cliscript_key?: SortOrder
    type?: SortOrder
  }

  export type as_cli_scriptsMinOrderByAggregateInput = {
    id?: SortOrder
    cliscript_title?: SortOrder
    cliscript_category?: SortOrder
    cliscript_type?: SortOrder
    cliscript_status?: SortOrder
    cliscript_description?: SortOrder
    cliscript_key?: SortOrder
    type?: SortOrder
  }

  export type as_cli_scriptsSumOrderByAggregateInput = {
    id?: SortOrder
    cliscript_type?: SortOrder
    type?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type as_commentmetaOrderByRelevanceInput = {
    fields: as_commentmetaOrderByRelevanceFieldEnum | as_commentmetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_commentmetaCountOrderByAggregateInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_commentmetaAvgOrderByAggregateInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
  }

  export type as_commentmetaMaxOrderByAggregateInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_commentmetaMinOrderByAggregateInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_commentmetaSumOrderByAggregateInput = {
    meta_id?: SortOrder
    comment_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type as_commentsOrderByRelevanceInput = {
    fields: as_commentsOrderByRelevanceFieldEnum | as_commentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_commentsCountOrderByAggregateInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_author?: SortOrder
    comment_author_email?: SortOrder
    comment_author_url?: SortOrder
    comment_author_IP?: SortOrder
    comment_date?: SortOrder
    comment_date_gmt?: SortOrder
    comment_content?: SortOrder
    comment_karma?: SortOrder
    comment_approved?: SortOrder
    comment_agent?: SortOrder
    comment_type?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
  }

  export type as_commentsAvgOrderByAggregateInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_karma?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
  }

  export type as_commentsMaxOrderByAggregateInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_author?: SortOrder
    comment_author_email?: SortOrder
    comment_author_url?: SortOrder
    comment_author_IP?: SortOrder
    comment_date?: SortOrder
    comment_date_gmt?: SortOrder
    comment_content?: SortOrder
    comment_karma?: SortOrder
    comment_approved?: SortOrder
    comment_agent?: SortOrder
    comment_type?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
  }

  export type as_commentsMinOrderByAggregateInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_author?: SortOrder
    comment_author_email?: SortOrder
    comment_author_url?: SortOrder
    comment_author_IP?: SortOrder
    comment_date?: SortOrder
    comment_date_gmt?: SortOrder
    comment_content?: SortOrder
    comment_karma?: SortOrder
    comment_approved?: SortOrder
    comment_agent?: SortOrder
    comment_type?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
  }

  export type as_commentsSumOrderByAggregateInput = {
    comment_ID?: SortOrder
    comment_post_ID?: SortOrder
    comment_karma?: SortOrder
    comment_parent?: SortOrder
    user_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type as_fusion_form_entriesOrderByRelevanceInput = {
    fields:
      | as_fusion_form_entriesOrderByRelevanceFieldEnum
      | as_fusion_form_entriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_fusion_form_entriesCountOrderByAggregateInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
    value?: SortOrder
    privacy?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_entriesAvgOrderByAggregateInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
  }

  export type as_fusion_form_entriesMaxOrderByAggregateInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
    value?: SortOrder
    privacy?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_entriesMinOrderByAggregateInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
    value?: SortOrder
    privacy?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_entriesSumOrderByAggregateInput = {
    id?: SortOrder
    submission_id?: SortOrder
    form_id?: SortOrder
    field_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type as_fusion_form_fieldsOrderByRelevanceInput = {
    fields:
      | as_fusion_form_fieldsOrderByRelevanceFieldEnum
      | as_fusion_form_fieldsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_fusion_form_fieldsCountOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    field_name?: SortOrder
    field_label?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_fieldsAvgOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
  }

  export type as_fusion_form_fieldsMaxOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    field_name?: SortOrder
    field_label?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_fieldsMinOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    field_name?: SortOrder
    field_label?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_fieldsSumOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type as_fusion_form_submissionsOrderByRelevanceInput = {
    fields:
      | as_fusion_form_submissionsOrderByRelevanceFieldEnum
      | as_fusion_form_submissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_fusion_form_submissionsCountOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    time?: SortOrder
    source_url?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    is_read?: SortOrder
    privacy_scrub_date?: SortOrder
    on_privacy_scrub?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_submissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type as_fusion_form_submissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    time?: SortOrder
    source_url?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    is_read?: SortOrder
    privacy_scrub_date?: SortOrder
    on_privacy_scrub?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_submissionsMinOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    time?: SortOrder
    source_url?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip?: SortOrder
    is_read?: SortOrder
    privacy_scrub_date?: SortOrder
    on_privacy_scrub?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_form_submissionsSumOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type as_fusion_formsOrderByRelevanceInput = {
    fields: as_fusion_formsOrderByRelevanceFieldEnum | as_fusion_formsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_fusion_formsCountOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrder
    submissions_count?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_formsAvgOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrder
    submissions_count?: SortOrder
  }

  export type as_fusion_formsMaxOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrder
    submissions_count?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_formsMinOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrder
    submissions_count?: SortOrder
    data?: SortOrder
  }

  export type as_fusion_formsSumOrderByAggregateInput = {
    id?: SortOrder
    form_id?: SortOrder
    views?: SortOrder
    submissions_count?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type as_layersliderOrderByRelevanceInput = {
    fields: as_layersliderOrderByRelevanceFieldEnum | as_layersliderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_layersliderCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    author?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
    flag_hidden?: SortOrder
    flag_deleted?: SortOrder
    flag_popup?: SortOrder
    flag_group?: SortOrder
  }

  export type as_layersliderAvgOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    author?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
  }

  export type as_layersliderMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    author?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
    flag_hidden?: SortOrder
    flag_deleted?: SortOrder
    flag_popup?: SortOrder
    flag_group?: SortOrder
  }

  export type as_layersliderMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    author?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
    flag_hidden?: SortOrder
    flag_deleted?: SortOrder
    flag_popup?: SortOrder
    flag_group?: SortOrder
  }

  export type as_layersliderSumOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    author?: SortOrder
    date_c?: SortOrder
    date_m?: SortOrder
    schedule_start?: SortOrder
    schedule_end?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type as_layerslider_revisionsOrderByRelevanceInput = {
    fields:
      | as_layerslider_revisionsOrderByRelevanceFieldEnum
      | as_layerslider_revisionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_layerslider_revisionsCountOrderByAggregateInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
  }

  export type as_layerslider_revisionsAvgOrderByAggregateInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    date_c?: SortOrder
  }

  export type as_layerslider_revisionsMaxOrderByAggregateInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
  }

  export type as_layerslider_revisionsMinOrderByAggregateInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    data?: SortOrder
    date_c?: SortOrder
  }

  export type as_layerslider_revisionsSumOrderByAggregateInput = {
    id?: SortOrder
    slider_id?: SortOrder
    author?: SortOrder
    date_c?: SortOrder
  }

  export type as_linksOrderByRelevanceInput = {
    fields: as_linksOrderByRelevanceFieldEnum | as_linksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_linksCountOrderByAggregateInput = {
    link_id?: SortOrder
    link_url?: SortOrder
    link_name?: SortOrder
    link_image?: SortOrder
    link_target?: SortOrder
    link_description?: SortOrder
    link_visible?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
    link_updated?: SortOrder
    link_rel?: SortOrder
    link_notes?: SortOrder
    link_rss?: SortOrder
  }

  export type as_linksAvgOrderByAggregateInput = {
    link_id?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
  }

  export type as_linksMaxOrderByAggregateInput = {
    link_id?: SortOrder
    link_url?: SortOrder
    link_name?: SortOrder
    link_image?: SortOrder
    link_target?: SortOrder
    link_description?: SortOrder
    link_visible?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
    link_updated?: SortOrder
    link_rel?: SortOrder
    link_notes?: SortOrder
    link_rss?: SortOrder
  }

  export type as_linksMinOrderByAggregateInput = {
    link_id?: SortOrder
    link_url?: SortOrder
    link_name?: SortOrder
    link_image?: SortOrder
    link_target?: SortOrder
    link_description?: SortOrder
    link_visible?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
    link_updated?: SortOrder
    link_rel?: SortOrder
    link_notes?: SortOrder
    link_rss?: SortOrder
  }

  export type as_linksSumOrderByAggregateInput = {
    link_id?: SortOrder
    link_owner?: SortOrder
    link_rating?: SortOrder
  }

  export type as_loginizer_logsOrderByRelevanceInput = {
    fields:
      | as_loginizer_logsOrderByRelevanceFieldEnum
      | as_loginizer_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_loginizer_logsCountOrderByAggregateInput = {
    username?: SortOrder
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
    ip?: SortOrder
    url?: SortOrder
  }

  export type as_loginizer_logsAvgOrderByAggregateInput = {
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
  }

  export type as_loginizer_logsMaxOrderByAggregateInput = {
    username?: SortOrder
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
    ip?: SortOrder
    url?: SortOrder
  }

  export type as_loginizer_logsMinOrderByAggregateInput = {
    username?: SortOrder
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
    ip?: SortOrder
    url?: SortOrder
  }

  export type as_loginizer_logsSumOrderByAggregateInput = {
    time?: SortOrder
    count?: SortOrder
    lockout?: SortOrder
  }

  export type as_optionsOrderByRelevanceInput = {
    fields: as_optionsOrderByRelevanceFieldEnum | as_optionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_optionsCountOrderByAggregateInput = {
    option_id?: SortOrder
    option_name?: SortOrder
    option_value?: SortOrder
    autoload?: SortOrder
  }

  export type as_optionsAvgOrderByAggregateInput = {
    option_id?: SortOrder
  }

  export type as_optionsMaxOrderByAggregateInput = {
    option_id?: SortOrder
    option_name?: SortOrder
    option_value?: SortOrder
    autoload?: SortOrder
  }

  export type as_optionsMinOrderByAggregateInput = {
    option_id?: SortOrder
    option_name?: SortOrder
    option_value?: SortOrder
    autoload?: SortOrder
  }

  export type as_optionsSumOrderByAggregateInput = {
    option_id?: SortOrder
  }

  export type as_postmetaOrderByRelevanceInput = {
    fields: as_postmetaOrderByRelevanceFieldEnum | as_postmetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_postmetaCountOrderByAggregateInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_postmetaAvgOrderByAggregateInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
  }

  export type as_postmetaMaxOrderByAggregateInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_postmetaMinOrderByAggregateInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_postmetaSumOrderByAggregateInput = {
    meta_id?: SortOrder
    post_id?: SortOrder
  }

  export type as_postsOrderByRelevanceInput = {
    fields: as_postsOrderByRelevanceFieldEnum | as_postsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_postsCountOrderByAggregateInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_date?: SortOrder
    post_date_gmt?: SortOrder
    post_content?: SortOrder
    post_title?: SortOrder
    post_excerpt?: SortOrder
    post_status?: SortOrder
    comment_status?: SortOrder
    ping_status?: SortOrder
    post_password?: SortOrder
    post_name?: SortOrder
    to_ping?: SortOrder
    pinged?: SortOrder
    post_modified?: SortOrder
    post_modified_gmt?: SortOrder
    post_content_filtered?: SortOrder
    post_parent?: SortOrder
    guid?: SortOrder
    menu_order?: SortOrder
    post_type?: SortOrder
    post_mime_type?: SortOrder
    comment_count?: SortOrder
  }

  export type as_postsAvgOrderByAggregateInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_parent?: SortOrder
    menu_order?: SortOrder
    comment_count?: SortOrder
  }

  export type as_postsMaxOrderByAggregateInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_date?: SortOrder
    post_date_gmt?: SortOrder
    post_content?: SortOrder
    post_title?: SortOrder
    post_excerpt?: SortOrder
    post_status?: SortOrder
    comment_status?: SortOrder
    ping_status?: SortOrder
    post_password?: SortOrder
    post_name?: SortOrder
    to_ping?: SortOrder
    pinged?: SortOrder
    post_modified?: SortOrder
    post_modified_gmt?: SortOrder
    post_content_filtered?: SortOrder
    post_parent?: SortOrder
    guid?: SortOrder
    menu_order?: SortOrder
    post_type?: SortOrder
    post_mime_type?: SortOrder
    comment_count?: SortOrder
  }

  export type as_postsMinOrderByAggregateInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_date?: SortOrder
    post_date_gmt?: SortOrder
    post_content?: SortOrder
    post_title?: SortOrder
    post_excerpt?: SortOrder
    post_status?: SortOrder
    comment_status?: SortOrder
    ping_status?: SortOrder
    post_password?: SortOrder
    post_name?: SortOrder
    to_ping?: SortOrder
    pinged?: SortOrder
    post_modified?: SortOrder
    post_modified_gmt?: SortOrder
    post_content_filtered?: SortOrder
    post_parent?: SortOrder
    guid?: SortOrder
    menu_order?: SortOrder
    post_type?: SortOrder
    post_mime_type?: SortOrder
    comment_count?: SortOrder
  }

  export type as_postsSumOrderByAggregateInput = {
    ID?: SortOrder
    post_author?: SortOrder
    post_parent?: SortOrder
    menu_order?: SortOrder
    comment_count?: SortOrder
  }

  export type as_term_relationshipsObject_idTerm_taxonomy_idCompoundUniqueInput = {
    object_id: bigint | number
    term_taxonomy_id: bigint | number
  }

  export type as_term_relationshipsCountOrderByAggregateInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_relationshipsAvgOrderByAggregateInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_relationshipsMaxOrderByAggregateInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_relationshipsMinOrderByAggregateInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_relationshipsSumOrderByAggregateInput = {
    object_id?: SortOrder
    term_taxonomy_id?: SortOrder
    term_order?: SortOrder
  }

  export type as_term_taxonomyOrderByRelevanceInput = {
    fields: as_term_taxonomyOrderByRelevanceFieldEnum | as_term_taxonomyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_term_taxonomyTerm_idTaxonomyCompoundUniqueInput = {
    term_id: bigint | number
    taxonomy: string
  }

  export type as_term_taxonomyCountOrderByAggregateInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parent?: SortOrder
    count?: SortOrder
  }

  export type as_term_taxonomyAvgOrderByAggregateInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    parent?: SortOrder
    count?: SortOrder
  }

  export type as_term_taxonomyMaxOrderByAggregateInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parent?: SortOrder
    count?: SortOrder
  }

  export type as_term_taxonomyMinOrderByAggregateInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parent?: SortOrder
    count?: SortOrder
  }

  export type as_term_taxonomySumOrderByAggregateInput = {
    term_taxonomy_id?: SortOrder
    term_id?: SortOrder
    parent?: SortOrder
    count?: SortOrder
  }

  export type as_termmetaOrderByRelevanceInput = {
    fields: as_termmetaOrderByRelevanceFieldEnum | as_termmetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_termmetaCountOrderByAggregateInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_termmetaAvgOrderByAggregateInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
  }

  export type as_termmetaMaxOrderByAggregateInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_termmetaMinOrderByAggregateInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_termmetaSumOrderByAggregateInput = {
    meta_id?: SortOrder
    term_id?: SortOrder
  }

  export type as_termsOrderByRelevanceInput = {
    fields: as_termsOrderByRelevanceFieldEnum | as_termsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_termsCountOrderByAggregateInput = {
    term_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    term_group?: SortOrder
  }

  export type as_termsAvgOrderByAggregateInput = {
    term_id?: SortOrder
    term_group?: SortOrder
  }

  export type as_termsMaxOrderByAggregateInput = {
    term_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    term_group?: SortOrder
  }

  export type as_termsMinOrderByAggregateInput = {
    term_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    term_group?: SortOrder
  }

  export type as_termsSumOrderByAggregateInput = {
    term_id?: SortOrder
    term_group?: SortOrder
  }

  export type as_tm_taskmetaOrderByRelevanceInput = {
    fields: as_tm_taskmetaOrderByRelevanceFieldEnum | as_tm_taskmetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_tm_taskmetaCountOrderByAggregateInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_tm_taskmetaAvgOrderByAggregateInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
  }

  export type as_tm_taskmetaMaxOrderByAggregateInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_tm_taskmetaMinOrderByAggregateInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_tm_taskmetaSumOrderByAggregateInput = {
    meta_id?: SortOrder
    task_id?: SortOrder
  }

  export type as_tm_tasksOrderByRelevanceInput = {
    fields: as_tm_tasksOrderByRelevanceFieldEnum | as_tm_tasksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_tm_tasksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    class_identifier?: SortOrder
    attempts?: SortOrder
    description?: SortOrder
    time_created?: SortOrder
    last_locked_at?: SortOrder
    status?: SortOrder
  }

  export type as_tm_tasksAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    attempts?: SortOrder
    last_locked_at?: SortOrder
  }

  export type as_tm_tasksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    class_identifier?: SortOrder
    attempts?: SortOrder
    description?: SortOrder
    time_created?: SortOrder
    last_locked_at?: SortOrder
    status?: SortOrder
  }

  export type as_tm_tasksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    class_identifier?: SortOrder
    attempts?: SortOrder
    description?: SortOrder
    time_created?: SortOrder
    last_locked_at?: SortOrder
    status?: SortOrder
  }

  export type as_tm_tasksSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    attempts?: SortOrder
    last_locked_at?: SortOrder
  }

  export type as_usermetaOrderByRelevanceInput = {
    fields: as_usermetaOrderByRelevanceFieldEnum | as_usermetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_usermetaCountOrderByAggregateInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_usermetaAvgOrderByAggregateInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
  }

  export type as_usermetaMaxOrderByAggregateInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_usermetaMinOrderByAggregateInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
    meta_key?: SortOrder
    meta_value?: SortOrder
  }

  export type as_usermetaSumOrderByAggregateInput = {
    umeta_id?: SortOrder
    user_id?: SortOrder
  }

  export type as_usersOrderByRelevanceInput = {
    fields: as_usersOrderByRelevanceFieldEnum | as_usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_usersCountOrderByAggregateInput = {
    ID?: SortOrder
    user_login?: SortOrder
    user_pass?: SortOrder
    user_nicename?: SortOrder
    user_email?: SortOrder
    user_url?: SortOrder
    user_registered?: SortOrder
    user_activation_key?: SortOrder
    user_status?: SortOrder
    display_name?: SortOrder
  }

  export type as_usersAvgOrderByAggregateInput = {
    ID?: SortOrder
    user_status?: SortOrder
  }

  export type as_usersMaxOrderByAggregateInput = {
    ID?: SortOrder
    user_login?: SortOrder
    user_pass?: SortOrder
    user_nicename?: SortOrder
    user_email?: SortOrder
    user_url?: SortOrder
    user_registered?: SortOrder
    user_activation_key?: SortOrder
    user_status?: SortOrder
    display_name?: SortOrder
  }

  export type as_usersMinOrderByAggregateInput = {
    ID?: SortOrder
    user_login?: SortOrder
    user_pass?: SortOrder
    user_nicename?: SortOrder
    user_email?: SortOrder
    user_url?: SortOrder
    user_registered?: SortOrder
    user_activation_key?: SortOrder
    user_status?: SortOrder
    display_name?: SortOrder
  }

  export type as_usersSumOrderByAggregateInput = {
    ID?: SortOrder
    user_status?: SortOrder
  }

  export type as_wpo_404_detectorOrderByRelevanceInput = {
    fields:
      | as_wpo_404_detectorOrderByRelevanceFieldEnum
      | as_wpo_404_detectorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_wpo_404_detectorUrlRequest_timestampReferrerCompoundUniqueInput = {
    url: string
    request_timestamp: bigint | number
    referrer: string
  }

  export type as_wpo_404_detectorCountOrderByAggregateInput = {
    ID?: SortOrder
    url?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
    referrer?: SortOrder
  }

  export type as_wpo_404_detectorAvgOrderByAggregateInput = {
    ID?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
  }

  export type as_wpo_404_detectorMaxOrderByAggregateInput = {
    ID?: SortOrder
    url?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
    referrer?: SortOrder
  }

  export type as_wpo_404_detectorMinOrderByAggregateInput = {
    ID?: SortOrder
    url?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
    referrer?: SortOrder
  }

  export type as_wpo_404_detectorSumOrderByAggregateInput = {
    ID?: SortOrder
    request_timestamp?: SortOrder
    request_count?: SortOrder
  }

  export type as_yoast_indexableOrderByRelevanceInput = {
    fields:
      | as_yoast_indexableOrderByRelevanceFieldEnum
      | as_yoast_indexableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_yoast_indexableCountOrderByAggregateInput = {
    id?: SortOrder
    permalink?: SortOrder
    permalink_hash?: SortOrder
    object_id?: SortOrder
    object_type?: SortOrder
    object_sub_type?: SortOrder
    author_id?: SortOrder
    post_parent?: SortOrder
    title?: SortOrder
    description?: SortOrder
    breadcrumb_title?: SortOrder
    post_status?: SortOrder
    is_public?: SortOrder
    is_protected?: SortOrder
    has_public_posts?: SortOrder
    number_of_pages?: SortOrder
    canonical?: SortOrder
    primary_focus_keyword?: SortOrder
    primary_focus_keyword_score?: SortOrder
    readability_score?: SortOrder
    is_cornerstone?: SortOrder
    is_robots_noindex?: SortOrder
    is_robots_nofollow?: SortOrder
    is_robots_noarchive?: SortOrder
    is_robots_noimageindex?: SortOrder
    is_robots_nosnippet?: SortOrder
    twitter_title?: SortOrder
    twitter_image?: SortOrder
    twitter_description?: SortOrder
    twitter_image_id?: SortOrder
    twitter_image_source?: SortOrder
    open_graph_title?: SortOrder
    open_graph_description?: SortOrder
    open_graph_image?: SortOrder
    open_graph_image_id?: SortOrder
    open_graph_image_source?: SortOrder
    open_graph_image_meta?: SortOrder
    link_count?: SortOrder
    incoming_link_count?: SortOrder
    prominent_words_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    language?: SortOrder
    region?: SortOrder
    schema_page_type?: SortOrder
    schema_article_type?: SortOrder
    has_ancestors?: SortOrder
    estimated_reading_time_minutes?: SortOrder
    version?: SortOrder
    object_last_modified?: SortOrder
    object_published_at?: SortOrder
    inclusive_language_score?: SortOrder
  }

  export type as_yoast_indexableAvgOrderByAggregateInput = {
    id?: SortOrder
    object_id?: SortOrder
    author_id?: SortOrder
    post_parent?: SortOrder
    number_of_pages?: SortOrder
    primary_focus_keyword_score?: SortOrder
    readability_score?: SortOrder
    link_count?: SortOrder
    incoming_link_count?: SortOrder
    prominent_words_version?: SortOrder
    blog_id?: SortOrder
    estimated_reading_time_minutes?: SortOrder
    version?: SortOrder
    inclusive_language_score?: SortOrder
  }

  export type as_yoast_indexableMaxOrderByAggregateInput = {
    id?: SortOrder
    permalink?: SortOrder
    permalink_hash?: SortOrder
    object_id?: SortOrder
    object_type?: SortOrder
    object_sub_type?: SortOrder
    author_id?: SortOrder
    post_parent?: SortOrder
    title?: SortOrder
    description?: SortOrder
    breadcrumb_title?: SortOrder
    post_status?: SortOrder
    is_public?: SortOrder
    is_protected?: SortOrder
    has_public_posts?: SortOrder
    number_of_pages?: SortOrder
    canonical?: SortOrder
    primary_focus_keyword?: SortOrder
    primary_focus_keyword_score?: SortOrder
    readability_score?: SortOrder
    is_cornerstone?: SortOrder
    is_robots_noindex?: SortOrder
    is_robots_nofollow?: SortOrder
    is_robots_noarchive?: SortOrder
    is_robots_noimageindex?: SortOrder
    is_robots_nosnippet?: SortOrder
    twitter_title?: SortOrder
    twitter_image?: SortOrder
    twitter_description?: SortOrder
    twitter_image_id?: SortOrder
    twitter_image_source?: SortOrder
    open_graph_title?: SortOrder
    open_graph_description?: SortOrder
    open_graph_image?: SortOrder
    open_graph_image_id?: SortOrder
    open_graph_image_source?: SortOrder
    open_graph_image_meta?: SortOrder
    link_count?: SortOrder
    incoming_link_count?: SortOrder
    prominent_words_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    language?: SortOrder
    region?: SortOrder
    schema_page_type?: SortOrder
    schema_article_type?: SortOrder
    has_ancestors?: SortOrder
    estimated_reading_time_minutes?: SortOrder
    version?: SortOrder
    object_last_modified?: SortOrder
    object_published_at?: SortOrder
    inclusive_language_score?: SortOrder
  }

  export type as_yoast_indexableMinOrderByAggregateInput = {
    id?: SortOrder
    permalink?: SortOrder
    permalink_hash?: SortOrder
    object_id?: SortOrder
    object_type?: SortOrder
    object_sub_type?: SortOrder
    author_id?: SortOrder
    post_parent?: SortOrder
    title?: SortOrder
    description?: SortOrder
    breadcrumb_title?: SortOrder
    post_status?: SortOrder
    is_public?: SortOrder
    is_protected?: SortOrder
    has_public_posts?: SortOrder
    number_of_pages?: SortOrder
    canonical?: SortOrder
    primary_focus_keyword?: SortOrder
    primary_focus_keyword_score?: SortOrder
    readability_score?: SortOrder
    is_cornerstone?: SortOrder
    is_robots_noindex?: SortOrder
    is_robots_nofollow?: SortOrder
    is_robots_noarchive?: SortOrder
    is_robots_noimageindex?: SortOrder
    is_robots_nosnippet?: SortOrder
    twitter_title?: SortOrder
    twitter_image?: SortOrder
    twitter_description?: SortOrder
    twitter_image_id?: SortOrder
    twitter_image_source?: SortOrder
    open_graph_title?: SortOrder
    open_graph_description?: SortOrder
    open_graph_image?: SortOrder
    open_graph_image_id?: SortOrder
    open_graph_image_source?: SortOrder
    open_graph_image_meta?: SortOrder
    link_count?: SortOrder
    incoming_link_count?: SortOrder
    prominent_words_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
    language?: SortOrder
    region?: SortOrder
    schema_page_type?: SortOrder
    schema_article_type?: SortOrder
    has_ancestors?: SortOrder
    estimated_reading_time_minutes?: SortOrder
    version?: SortOrder
    object_last_modified?: SortOrder
    object_published_at?: SortOrder
    inclusive_language_score?: SortOrder
  }

  export type as_yoast_indexableSumOrderByAggregateInput = {
    id?: SortOrder
    object_id?: SortOrder
    author_id?: SortOrder
    post_parent?: SortOrder
    number_of_pages?: SortOrder
    primary_focus_keyword_score?: SortOrder
    readability_score?: SortOrder
    link_count?: SortOrder
    incoming_link_count?: SortOrder
    prominent_words_version?: SortOrder
    blog_id?: SortOrder
    estimated_reading_time_minutes?: SortOrder
    version?: SortOrder
    inclusive_language_score?: SortOrder
  }

  export type as_yoast_indexable_hierarchyIndexable_idAncestor_idCompoundUniqueInput = {
    indexable_id: number
    ancestor_id: number
  }

  export type as_yoast_indexable_hierarchyCountOrderByAggregateInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_indexable_hierarchyAvgOrderByAggregateInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_indexable_hierarchyMaxOrderByAggregateInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_indexable_hierarchyMinOrderByAggregateInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_indexable_hierarchySumOrderByAggregateInput = {
    indexable_id?: SortOrder
    ancestor_id?: SortOrder
    depth?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_migrationsOrderByRelevanceInput = {
    fields:
      | as_yoast_migrationsOrderByRelevanceFieldEnum
      | as_yoast_migrationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_yoast_migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type as_yoast_migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type as_yoast_migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type as_yoast_migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type as_yoast_migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type as_yoast_primary_termOrderByRelevanceInput = {
    fields:
      | as_yoast_primary_termOrderByRelevanceFieldEnum
      | as_yoast_primary_termOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_yoast_primary_termCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_primary_termAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    term_id?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_primary_termMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_primary_termMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    term_id?: SortOrder
    taxonomy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_primary_termSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    term_id?: SortOrder
    blog_id?: SortOrder
  }

  export type as_yoast_seo_linksOrderByRelevanceInput = {
    fields:
      | as_yoast_seo_linksOrderByRelevanceFieldEnum
      | as_yoast_seo_linksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type as_yoast_seo_linksCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    type?: SortOrder
    indexable_id?: SortOrder
    target_indexable_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    size?: SortOrder
    language?: SortOrder
    region?: SortOrder
  }

  export type as_yoast_seo_linksAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    indexable_id?: SortOrder
    target_indexable_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    size?: SortOrder
  }

  export type as_yoast_seo_linksMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    type?: SortOrder
    indexable_id?: SortOrder
    target_indexable_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    size?: SortOrder
    language?: SortOrder
    region?: SortOrder
  }

  export type as_yoast_seo_linksMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    type?: SortOrder
    indexable_id?: SortOrder
    target_indexable_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    size?: SortOrder
    language?: SortOrder
    region?: SortOrder
  }

  export type as_yoast_seo_linksSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    target_post_id?: SortOrder
    indexable_id?: SortOrder
    target_indexable_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    size?: SortOrder
  }

  export type as_yoast_seo_metaCountOrderByAggregateInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrder
    incoming_link_count?: SortOrder
  }

  export type as_yoast_seo_metaAvgOrderByAggregateInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrder
    incoming_link_count?: SortOrder
  }

  export type as_yoast_seo_metaMaxOrderByAggregateInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrder
    incoming_link_count?: SortOrder
  }

  export type as_yoast_seo_metaMinOrderByAggregateInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrder
    incoming_link_count?: SortOrder
  }

  export type as_yoast_seo_metaSumOrderByAggregateInput = {
    object_id?: SortOrder
    internal_link_count?: SortOrder
    incoming_link_count?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type as_cli_cookie_scan_cookiesCreateNestedManyWithoutAs_cli_cookie_scan_categoriesInput =
    {
      create?:
        | XOR<
            as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
            as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
          >
        | as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput[]
        | as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput[]
      connectOrCreate?:
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput[]
      createMany?: as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInputEnvelope
      connect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
    }

  export type as_cli_cookie_scan_cookiesUncheckedCreateNestedManyWithoutAs_cli_cookie_scan_categoriesInput =
    {
      create?:
        | XOR<
            as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
            as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
          >
        | as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput[]
        | as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput[]
      connectOrCreate?:
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput[]
      createMany?: as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInputEnvelope
      connect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
    }

  export type as_cli_cookie_scan_cookiesUpdateManyWithoutAs_cli_cookie_scan_categoriesNestedInput =
    {
      create?:
        | XOR<
            as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
            as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
          >
        | as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput[]
        | as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput[]
      connectOrCreate?:
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput[]
      upsert?:
        | as_cli_cookie_scan_cookiesUpsertWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpsertWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput[]
      createMany?: as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInputEnvelope
      set?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      disconnect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      delete?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      connect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      update?:
        | as_cli_cookie_scan_cookiesUpdateWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpdateWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput[]
      updateMany?:
        | as_cli_cookie_scan_cookiesUpdateManyWithWhereWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpdateManyWithWhereWithoutAs_cli_cookie_scan_categoriesInput[]
      deleteMany?:
        | as_cli_cookie_scan_cookiesScalarWhereInput
        | as_cli_cookie_scan_cookiesScalarWhereInput[]
    }

  export type as_cli_cookie_scan_cookiesUncheckedUpdateManyWithoutAs_cli_cookie_scan_categoriesNestedInput =
    {
      create?:
        | XOR<
            as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
            as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
          >
        | as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput[]
        | as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput[]
      connectOrCreate?:
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput[]
      upsert?:
        | as_cli_cookie_scan_cookiesUpsertWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpsertWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput[]
      createMany?: as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInputEnvelope
      set?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      disconnect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      delete?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      connect?:
        | as_cli_cookie_scan_cookiesWhereUniqueInput
        | as_cli_cookie_scan_cookiesWhereUniqueInput[]
      update?:
        | as_cli_cookie_scan_cookiesUpdateWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpdateWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput[]
      updateMany?:
        | as_cli_cookie_scan_cookiesUpdateManyWithWhereWithoutAs_cli_cookie_scan_categoriesInput
        | as_cli_cookie_scan_cookiesUpdateManyWithWhereWithoutAs_cli_cookie_scan_categoriesInput[]
      deleteMany?:
        | as_cli_cookie_scan_cookiesScalarWhereInput
        | as_cli_cookie_scan_cookiesScalarWhereInput[]
    }

  export type as_cli_cookie_scan_categoriesCreateNestedOneWithoutAs_cli_cookie_scan_cookiesInput = {
    create?: XOR<
      as_cli_cookie_scan_categoriesCreateWithoutAs_cli_cookie_scan_cookiesInput,
      as_cli_cookie_scan_categoriesUncheckedCreateWithoutAs_cli_cookie_scan_cookiesInput
    >
    connectOrCreate?: as_cli_cookie_scan_categoriesCreateOrConnectWithoutAs_cli_cookie_scan_cookiesInput
    connect?: as_cli_cookie_scan_categoriesWhereUniqueInput
  }

  export type as_cli_cookie_scan_categoriesUpdateOneRequiredWithoutAs_cli_cookie_scan_cookiesNestedInput =
    {
      create?: XOR<
        as_cli_cookie_scan_categoriesCreateWithoutAs_cli_cookie_scan_cookiesInput,
        as_cli_cookie_scan_categoriesUncheckedCreateWithoutAs_cli_cookie_scan_cookiesInput
      >
      connectOrCreate?: as_cli_cookie_scan_categoriesCreateOrConnectWithoutAs_cli_cookie_scan_cookiesInput
      upsert?: as_cli_cookie_scan_categoriesUpsertWithoutAs_cli_cookie_scan_cookiesInput
      connect?: as_cli_cookie_scan_categoriesWhereUniqueInput
      update?: XOR<
        XOR<
          as_cli_cookie_scan_categoriesUpdateToOneWithWhereWithoutAs_cli_cookie_scan_cookiesInput,
          as_cli_cookie_scan_categoriesUpdateWithoutAs_cli_cookie_scan_cookiesInput
        >,
        as_cli_cookie_scan_categoriesUncheckedUpdateWithoutAs_cli_cookie_scan_cookiesInput
      >
    }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput = {
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    description?: string | null
  }

  export type as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput = {
    id_cli_cookie_scan_cookies?: number
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    description?: string | null
  }

  export type as_cli_cookie_scan_cookiesCreateOrConnectWithoutAs_cli_cookie_scan_categoriesInput = {
    where: as_cli_cookie_scan_cookiesWhereUniqueInput
    create: XOR<
      as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
      as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
    >
  }

  export type as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInputEnvelope = {
    data:
      | as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInput
      | as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type as_cli_cookie_scan_cookiesUpsertWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput =
    {
      where: as_cli_cookie_scan_cookiesWhereUniqueInput
      update: XOR<
        as_cli_cookie_scan_cookiesUpdateWithoutAs_cli_cookie_scan_categoriesInput,
        as_cli_cookie_scan_cookiesUncheckedUpdateWithoutAs_cli_cookie_scan_categoriesInput
      >
      create: XOR<
        as_cli_cookie_scan_cookiesCreateWithoutAs_cli_cookie_scan_categoriesInput,
        as_cli_cookie_scan_cookiesUncheckedCreateWithoutAs_cli_cookie_scan_categoriesInput
      >
    }

  export type as_cli_cookie_scan_cookiesUpdateWithWhereUniqueWithoutAs_cli_cookie_scan_categoriesInput =
    {
      where: as_cli_cookie_scan_cookiesWhereUniqueInput
      data: XOR<
        as_cli_cookie_scan_cookiesUpdateWithoutAs_cli_cookie_scan_categoriesInput,
        as_cli_cookie_scan_cookiesUncheckedUpdateWithoutAs_cli_cookie_scan_categoriesInput
      >
    }

  export type as_cli_cookie_scan_cookiesUpdateManyWithWhereWithoutAs_cli_cookie_scan_categoriesInput =
    {
      where: as_cli_cookie_scan_cookiesScalarWhereInput
      data: XOR<
        as_cli_cookie_scan_cookiesUpdateManyMutationInput,
        as_cli_cookie_scan_cookiesUncheckedUpdateManyWithoutAs_cli_cookie_scan_categoriesInput
      >
    }

  export type as_cli_cookie_scan_cookiesScalarWhereInput = {
    AND?: as_cli_cookie_scan_cookiesScalarWhereInput | as_cli_cookie_scan_cookiesScalarWhereInput[]
    OR?: as_cli_cookie_scan_cookiesScalarWhereInput[]
    NOT?: as_cli_cookie_scan_cookiesScalarWhereInput | as_cli_cookie_scan_cookiesScalarWhereInput[]
    id_cli_cookie_scan_cookies?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    id_cli_cookie_scan_url?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    cookie_id?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    expiry?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    type?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    category?: StringFilter<'as_cli_cookie_scan_cookies'> | string
    category_id?: IntFilter<'as_cli_cookie_scan_cookies'> | number
    description?: StringNullableFilter<'as_cli_cookie_scan_cookies'> | string | null
  }

  export type as_cli_cookie_scan_categoriesCreateWithoutAs_cli_cookie_scan_cookiesInput = {
    cli_cookie_category_name: string
    cli_cookie_category_description?: string | null
  }

  export type as_cli_cookie_scan_categoriesUncheckedCreateWithoutAs_cli_cookie_scan_cookiesInput = {
    id_cli_cookie_category?: number
    cli_cookie_category_name: string
    cli_cookie_category_description?: string | null
  }

  export type as_cli_cookie_scan_categoriesCreateOrConnectWithoutAs_cli_cookie_scan_cookiesInput = {
    where: as_cli_cookie_scan_categoriesWhereUniqueInput
    create: XOR<
      as_cli_cookie_scan_categoriesCreateWithoutAs_cli_cookie_scan_cookiesInput,
      as_cli_cookie_scan_categoriesUncheckedCreateWithoutAs_cli_cookie_scan_cookiesInput
    >
  }

  export type as_cli_cookie_scan_categoriesUpsertWithoutAs_cli_cookie_scan_cookiesInput = {
    update: XOR<
      as_cli_cookie_scan_categoriesUpdateWithoutAs_cli_cookie_scan_cookiesInput,
      as_cli_cookie_scan_categoriesUncheckedUpdateWithoutAs_cli_cookie_scan_cookiesInput
    >
    create: XOR<
      as_cli_cookie_scan_categoriesCreateWithoutAs_cli_cookie_scan_cookiesInput,
      as_cli_cookie_scan_categoriesUncheckedCreateWithoutAs_cli_cookie_scan_cookiesInput
    >
    where?: as_cli_cookie_scan_categoriesWhereInput
  }

  export type as_cli_cookie_scan_categoriesUpdateToOneWithWhereWithoutAs_cli_cookie_scan_cookiesInput =
    {
      where?: as_cli_cookie_scan_categoriesWhereInput
      data: XOR<
        as_cli_cookie_scan_categoriesUpdateWithoutAs_cli_cookie_scan_cookiesInput,
        as_cli_cookie_scan_categoriesUncheckedUpdateWithoutAs_cli_cookie_scan_cookiesInput
      >
    }

  export type as_cli_cookie_scan_categoriesUpdateWithoutAs_cli_cookie_scan_cookiesInput = {
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_categoriesUncheckedUpdateWithoutAs_cli_cookie_scan_cookiesInput = {
    id_cli_cookie_category?: IntFieldUpdateOperationsInput | number
    cli_cookie_category_name?: StringFieldUpdateOperationsInput | string
    cli_cookie_category_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesCreateManyAs_cli_cookie_scan_categoriesInput = {
    id_cli_cookie_scan_cookies?: number
    id_cli_cookie_scan?: number
    id_cli_cookie_scan_url?: number
    cookie_id: string
    expiry: string
    type: string
    category: string
    description?: string | null
  }

  export type as_cli_cookie_scan_cookiesUpdateWithoutAs_cli_cookie_scan_categoriesInput = {
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesUncheckedUpdateWithoutAs_cli_cookie_scan_categoriesInput = {
    id_cli_cookie_scan_cookies?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
    id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
    cookie_id?: StringFieldUpdateOperationsInput | string
    expiry?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type as_cli_cookie_scan_cookiesUncheckedUpdateManyWithoutAs_cli_cookie_scan_categoriesInput =
    {
      id_cli_cookie_scan_cookies?: IntFieldUpdateOperationsInput | number
      id_cli_cookie_scan?: IntFieldUpdateOperationsInput | number
      id_cli_cookie_scan_url?: IntFieldUpdateOperationsInput | number
      cookie_id?: StringFieldUpdateOperationsInput | string
      expiry?: StringFieldUpdateOperationsInput | string
      type?: StringFieldUpdateOperationsInput | string
      category?: StringFieldUpdateOperationsInput | string
      description?: NullableStringFieldUpdateOperationsInput | string | null
    }

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}

/**
 * Client
 */

import * as runtime from './runtime/library.js'
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserMeta
 *
 */
export type UserMeta = $Result.DefaultSelection<Prisma.$UserMetaPayload>
/**
 * Model Page
 *
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model PageTranslation
 *
 */
export type PageTranslation = $Result.DefaultSelection<Prisma.$PageTranslationPayload>
/**
 * Model PageMeta
 *
 */
export type PageMeta = $Result.DefaultSelection<Prisma.$PageMetaPayload>
/**
 * Model Article
 *
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model ArticleTranslation
 *
 */
export type ArticleTranslation = $Result.DefaultSelection<Prisma.$ArticleTranslationPayload>
/**
 * Model ArticleMeta
 *
 */
export type ArticleMeta = $Result.DefaultSelection<Prisma.$ArticleMetaPayload>
/**
 * Model Portfolio
 *
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model PortfolioTranslation
 *
 */
export type PortfolioTranslation = $Result.DefaultSelection<Prisma.$PortfolioTranslationPayload>
/**
 * Model PortfolioMeta
 *
 */
export type PortfolioMeta = $Result.DefaultSelection<Prisma.$PortfolioMetaPayload>
/**
 * Model Product
 *
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductTranslation
 *
 */
export type ProductTranslation = $Result.DefaultSelection<Prisma.$ProductTranslationPayload>
/**
 * Model ProductMeta
 *
 */
export type ProductMeta = $Result.DefaultSelection<Prisma.$ProductMetaPayload>
/**
 * Model Comment
 *
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentMeta
 *
 */
export type CommentMeta = $Result.DefaultSelection<Prisma.$CommentMetaPayload>
/**
 * Model Term
 *
 */
export type Term = $Result.DefaultSelection<Prisma.$TermPayload>
/**
 * Model TermTaxonomy
 *
 */
export type TermTaxonomy = $Result.DefaultSelection<Prisma.$TermTaxonomyPayload>
/**
 * Model TermRelationship
 *
 */
export type TermRelationship = $Result.DefaultSelection<Prisma.$TermRelationshipPayload>
/**
 * Model Menu
 *
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model Setting
 *
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
    GUEST: 'GUEST'
    SUBSCRIBER: 'SUBSCRIBER'
    CONTRIBUTOR: 'CONTRIBUTOR'
    AUTHOR: 'AUTHOR'
    EDITOR: 'EDITOR'
    ADMIN: 'ADMIN'
    SUPERADMIN: 'SUPERADMIN'
  }

  export type Role = (typeof Role)[keyof typeof Role]

  export const Status: {
    DRAFT: 'DRAFT'
    PENDING: 'PENDING'
    PUBLISHED: 'PUBLISHED'
    ARCHIVED: 'ARCHIVED'
    TRASH: 'TRASH'
  }

  export type Status = (typeof Status)[keyof typeof Status]
}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>)
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  ): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs
      }
    >
  >

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.userMeta`: Exposes CRUD operations for the **UserMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserMetas
   * const userMetas = await prisma.userMeta.findMany()
   * ```
   */
  get userMeta(): Prisma.UserMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Pages
   * const pages = await prisma.page.findMany()
   * ```
   */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.pageTranslation`: Exposes CRUD operations for the **PageTranslation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PageTranslations
   * const pageTranslations = await prisma.pageTranslation.findMany()
   * ```
   */
  get pageTranslation(): Prisma.PageTranslationDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.pageMeta`: Exposes CRUD operations for the **PageMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PageMetas
   * const pageMetas = await prisma.pageMeta.findMany()
   * ```
   */
  get pageMeta(): Prisma.PageMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Articles
   * const articles = await prisma.article.findMany()
   * ```
   */
  get article(): Prisma.ArticleDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.articleTranslation`: Exposes CRUD operations for the **ArticleTranslation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ArticleTranslations
   * const articleTranslations = await prisma.articleTranslation.findMany()
   * ```
   */
  get articleTranslation(): Prisma.ArticleTranslationDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.articleMeta`: Exposes CRUD operations for the **ArticleMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ArticleMetas
   * const articleMetas = await prisma.articleMeta.findMany()
   * ```
   */
  get articleMeta(): Prisma.ArticleMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Portfolios
   * const portfolios = await prisma.portfolio.findMany()
   * ```
   */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.portfolioTranslation`: Exposes CRUD operations for the **PortfolioTranslation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PortfolioTranslations
   * const portfolioTranslations = await prisma.portfolioTranslation.findMany()
   * ```
   */
  get portfolioTranslation(): Prisma.PortfolioTranslationDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.portfolioMeta`: Exposes CRUD operations for the **PortfolioMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PortfolioMetas
   * const portfolioMetas = await prisma.portfolioMeta.findMany()
   * ```
   */
  get portfolioMeta(): Prisma.PortfolioMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.productTranslation`: Exposes CRUD operations for the **ProductTranslation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductTranslations
   * const productTranslations = await prisma.productTranslation.findMany()
   * ```
   */
  get productTranslation(): Prisma.ProductTranslationDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.productMeta`: Exposes CRUD operations for the **ProductMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductMetas
   * const productMetas = await prisma.productMeta.findMany()
   * ```
   */
  get productMeta(): Prisma.ProductMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Comments
   * const comments = await prisma.comment.findMany()
   * ```
   */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.commentMeta`: Exposes CRUD operations for the **CommentMeta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CommentMetas
   * const commentMetas = await prisma.commentMeta.findMany()
   * ```
   */
  get commentMeta(): Prisma.CommentMetaDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.term`: Exposes CRUD operations for the **Term** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Terms
   * const terms = await prisma.term.findMany()
   * ```
   */
  get term(): Prisma.TermDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.termTaxonomy`: Exposes CRUD operations for the **TermTaxonomy** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TermTaxonomies
   * const termTaxonomies = await prisma.termTaxonomy.findMany()
   * ```
   */
  get termTaxonomy(): Prisma.TermTaxonomyDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.termRelationship`: Exposes CRUD operations for the **TermRelationship** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TermRelationships
   * const termRelationships = await prisma.termRelationship.findMany()
   * ```
   */
  get termRelationship(): Prisma.TermRelationshipDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Menus
   * const menus = await prisma.menu.findMany()
   * ```
   */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Settings
   * const settings = await prisma.setting.findMany()
   * ```
   */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }

  export type Enumerable<T> = T | Array<T>

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  }

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends bigint
            ? False
            : T extends object
              ? True
              : False

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" */
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
  } & {}

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>
      }
    >
  >

  type Key = string | number | symbol
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never
  type AtStrict<O extends object, K extends Key> = O[K & keyof O]
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>
    0: AtLoose<O, K>
  }[strict]

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K]
      } & {}

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K]
  } & {}

  type _Record<K extends keyof any, T> = {
    [P in K]: T
  }

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>
  /** End Helper Types for "Merge" */

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B

  export const type: unique symbol

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never
      }
    : never

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>

  export const ModelName: {
    User: 'User'
    UserMeta: 'UserMeta'
    Page: 'Page'
    PageTranslation: 'PageTranslation'
    PageMeta: 'PageMeta'
    Article: 'Article'
    ArticleTranslation: 'ArticleTranslation'
    ArticleMeta: 'ArticleMeta'
    Portfolio: 'Portfolio'
    PortfolioTranslation: 'PortfolioTranslation'
    PortfolioMeta: 'PortfolioMeta'
    Product: 'Product'
    ProductTranslation: 'ProductTranslation'
    ProductMeta: 'ProductMeta'
    Comment: 'Comment'
    CommentMeta: 'CommentMeta'
    Term: 'Term'
    TermTaxonomy: 'TermTaxonomy'
    TermRelationship: 'TermRelationship'
    Menu: 'Menu'
    Setting: 'Setting'
  }

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]

  export type Datasources = {
    pgCMSdb?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps:
        | 'user'
        | 'userMeta'
        | 'page'
        | 'pageTranslation'
        | 'pageMeta'
        | 'article'
        | 'articleTranslation'
        | 'articleMeta'
        | 'portfolio'
        | 'portfolioTranslation'
        | 'portfolioMeta'
        | 'product'
        | 'productTranslation'
        | 'productMeta'
        | 'comment'
        | 'commentMeta'
        | 'term'
        | 'termTaxonomy'
        | 'termRelationship'
        | 'menu'
        | 'setting'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserMeta: {
        payload: Prisma.$UserMetaPayload<ExtArgs>
        fields: Prisma.UserMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          findFirst: {
            args: Prisma.UserMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          findMany: {
            args: Prisma.UserMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>[]
          }
          create: {
            args: Prisma.UserMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          createMany: {
            args: Prisma.UserMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>[]
          }
          delete: {
            args: Prisma.UserMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          update: {
            args: Prisma.UserMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          deleteMany: {
            args: Prisma.UserMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>[]
          }
          upsert: {
            args: Prisma.UserMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetaPayload>
          }
          aggregate: {
            args: Prisma.UserMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMeta>
          }
          groupBy: {
            args: Prisma.UserMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMetaCountArgs<ExtArgs>
            result: $Utils.Optional<UserMetaCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      PageTranslation: {
        payload: Prisma.$PageTranslationPayload<ExtArgs>
        fields: Prisma.PageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          findFirst: {
            args: Prisma.PageTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          findMany: {
            args: Prisma.PageTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
          }
          create: {
            args: Prisma.PageTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          createMany: {
            args: Prisma.PageTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
          }
          delete: {
            args: Prisma.PageTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          update: {
            args: Prisma.PageTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PageTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
          }
          upsert: {
            args: Prisma.PageTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTranslationPayload>
          }
          aggregate: {
            args: Prisma.PageTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageTranslation>
          }
          groupBy: {
            args: Prisma.PageTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<PageTranslationCountAggregateOutputType> | number
          }
        }
      }
      PageMeta: {
        payload: Prisma.$PageMetaPayload<ExtArgs>
        fields: Prisma.PageMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          findFirst: {
            args: Prisma.PageMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          findMany: {
            args: Prisma.PageMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>[]
          }
          create: {
            args: Prisma.PageMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          createMany: {
            args: Prisma.PageMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>[]
          }
          delete: {
            args: Prisma.PageMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          update: {
            args: Prisma.PageMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          deleteMany: {
            args: Prisma.PageMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>[]
          }
          upsert: {
            args: Prisma.PageMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageMetaPayload>
          }
          aggregate: {
            args: Prisma.PageMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageMeta>
          }
          groupBy: {
            args: Prisma.PageMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageMetaCountArgs<ExtArgs>
            result: $Utils.Optional<PageMetaCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      ArticleTranslation: {
        payload: Prisma.$ArticleTranslationPayload<ExtArgs>
        fields: Prisma.ArticleTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          findFirst: {
            args: Prisma.ArticleTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          findMany: {
            args: Prisma.ArticleTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>[]
          }
          create: {
            args: Prisma.ArticleTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          createMany: {
            args: Prisma.ArticleTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>[]
          }
          delete: {
            args: Prisma.ArticleTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          update: {
            args: Prisma.ArticleTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ArticleTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ArticleTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTranslationPayload>
          }
          aggregate: {
            args: Prisma.ArticleTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleTranslation>
          }
          groupBy: {
            args: Prisma.ArticleTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleTranslationCountAggregateOutputType> | number
          }
        }
      }
      ArticleMeta: {
        payload: Prisma.$ArticleMetaPayload<ExtArgs>
        fields: Prisma.ArticleMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          findFirst: {
            args: Prisma.ArticleMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          findMany: {
            args: Prisma.ArticleMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>[]
          }
          create: {
            args: Prisma.ArticleMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          createMany: {
            args: Prisma.ArticleMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>[]
          }
          delete: {
            args: Prisma.ArticleMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          update: {
            args: Prisma.ArticleMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          deleteMany: {
            args: Prisma.ArticleMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>[]
          }
          upsert: {
            args: Prisma.ArticleMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleMetaPayload>
          }
          aggregate: {
            args: Prisma.ArticleMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleMeta>
          }
          groupBy: {
            args: Prisma.ArticleMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleMetaCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleMetaCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      PortfolioTranslation: {
        payload: Prisma.$PortfolioTranslationPayload<ExtArgs>
        fields: Prisma.PortfolioTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          findFirst: {
            args: Prisma.PortfolioTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          findMany: {
            args: Prisma.PortfolioTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>[]
          }
          create: {
            args: Prisma.PortfolioTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          createMany: {
            args: Prisma.PortfolioTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>[]
          }
          delete: {
            args: Prisma.PortfolioTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          update: {
            args: Prisma.PortfolioTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTranslationPayload>
          }
          aggregate: {
            args: Prisma.PortfolioTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioTranslation>
          }
          groupBy: {
            args: Prisma.PortfolioTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioTranslationCountAggregateOutputType> | number
          }
        }
      }
      PortfolioMeta: {
        payload: Prisma.$PortfolioMetaPayload<ExtArgs>
        fields: Prisma.PortfolioMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          findFirst: {
            args: Prisma.PortfolioMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          findMany: {
            args: Prisma.PortfolioMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>[]
          }
          create: {
            args: Prisma.PortfolioMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          createMany: {
            args: Prisma.PortfolioMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>[]
          }
          delete: {
            args: Prisma.PortfolioMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          update: {
            args: Prisma.PortfolioMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioMetaPayload>
          }
          aggregate: {
            args: Prisma.PortfolioMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioMeta>
          }
          groupBy: {
            args: Prisma.PortfolioMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioMetaCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioMetaCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductTranslation: {
        payload: Prisma.$ProductTranslationPayload<ExtArgs>
        fields: Prisma.ProductTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findFirst: {
            args: Prisma.ProductTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findMany: {
            args: Prisma.ProductTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          create: {
            args: Prisma.ProductTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          createMany: {
            args: Prisma.ProductTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          delete: {
            args: Prisma.ProductTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          update: {
            args: Prisma.ProductTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ProductTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ProductTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          aggregate: {
            args: Prisma.ProductTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTranslation>
          }
          groupBy: {
            args: Prisma.ProductTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationCountAggregateOutputType> | number
          }
        }
      }
      ProductMeta: {
        payload: Prisma.$ProductMetaPayload<ExtArgs>
        fields: Prisma.ProductMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          findFirst: {
            args: Prisma.ProductMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          findMany: {
            args: Prisma.ProductMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>[]
          }
          create: {
            args: Prisma.ProductMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          createMany: {
            args: Prisma.ProductMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>[]
          }
          delete: {
            args: Prisma.ProductMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          update: {
            args: Prisma.ProductMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          deleteMany: {
            args: Prisma.ProductMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>[]
          }
          upsert: {
            args: Prisma.ProductMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMetaPayload>
          }
          aggregate: {
            args: Prisma.ProductMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductMeta>
          }
          groupBy: {
            args: Prisma.ProductMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductMetaCountArgs<ExtArgs>
            result: $Utils.Optional<ProductMetaCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentMeta: {
        payload: Prisma.$CommentMetaPayload<ExtArgs>
        fields: Prisma.CommentMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          findFirst: {
            args: Prisma.CommentMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          findMany: {
            args: Prisma.CommentMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>[]
          }
          create: {
            args: Prisma.CommentMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          createMany: {
            args: Prisma.CommentMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>[]
          }
          delete: {
            args: Prisma.CommentMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          update: {
            args: Prisma.CommentMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          deleteMany: {
            args: Prisma.CommentMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>[]
          }
          upsert: {
            args: Prisma.CommentMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMetaPayload>
          }
          aggregate: {
            args: Prisma.CommentMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentMeta>
          }
          groupBy: {
            args: Prisma.CommentMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentMetaCountArgs<ExtArgs>
            result: $Utils.Optional<CommentMetaCountAggregateOutputType> | number
          }
        }
      }
      Term: {
        payload: Prisma.$TermPayload<ExtArgs>
        fields: Prisma.TermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          findFirst: {
            args: Prisma.TermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          findMany: {
            args: Prisma.TermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          create: {
            args: Prisma.TermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          createMany: {
            args: Prisma.TermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          delete: {
            args: Prisma.TermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          update: {
            args: Prisma.TermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          deleteMany: {
            args: Prisma.TermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          upsert: {
            args: Prisma.TermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          aggregate: {
            args: Prisma.TermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerm>
          }
          groupBy: {
            args: Prisma.TermGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermCountArgs<ExtArgs>
            result: $Utils.Optional<TermCountAggregateOutputType> | number
          }
        }
      }
      TermTaxonomy: {
        payload: Prisma.$TermTaxonomyPayload<ExtArgs>
        fields: Prisma.TermTaxonomyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermTaxonomyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermTaxonomyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          findFirst: {
            args: Prisma.TermTaxonomyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermTaxonomyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          findMany: {
            args: Prisma.TermTaxonomyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>[]
          }
          create: {
            args: Prisma.TermTaxonomyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          createMany: {
            args: Prisma.TermTaxonomyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermTaxonomyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>[]
          }
          delete: {
            args: Prisma.TermTaxonomyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          update: {
            args: Prisma.TermTaxonomyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          deleteMany: {
            args: Prisma.TermTaxonomyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermTaxonomyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TermTaxonomyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>[]
          }
          upsert: {
            args: Prisma.TermTaxonomyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermTaxonomyPayload>
          }
          aggregate: {
            args: Prisma.TermTaxonomyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermTaxonomy>
          }
          groupBy: {
            args: Prisma.TermTaxonomyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermTaxonomyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermTaxonomyCountArgs<ExtArgs>
            result: $Utils.Optional<TermTaxonomyCountAggregateOutputType> | number
          }
        }
      }
      TermRelationship: {
        payload: Prisma.$TermRelationshipPayload<ExtArgs>
        fields: Prisma.TermRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          findFirst: {
            args: Prisma.TermRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          findMany: {
            args: Prisma.TermRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>[]
          }
          create: {
            args: Prisma.TermRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          createMany: {
            args: Prisma.TermRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermRelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>[]
          }
          delete: {
            args: Prisma.TermRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          update: {
            args: Prisma.TermRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.TermRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TermRelationshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>[]
          }
          upsert: {
            args: Prisma.TermRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermRelationshipPayload>
          }
          aggregate: {
            args: Prisma.TermRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermRelationship>
          }
          groupBy: {
            args: Prisma.TermRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<TermRelationshipCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userMeta?: UserMetaOmit
    page?: PageOmit
    pageTranslation?: PageTranslationOmit
    pageMeta?: PageMetaOmit
    article?: ArticleOmit
    articleTranslation?: ArticleTranslationOmit
    articleMeta?: ArticleMetaOmit
    portfolio?: PortfolioOmit
    portfolioTranslation?: PortfolioTranslationOmit
    portfolioMeta?: PortfolioMetaOmit
    product?: ProductOmit
    productTranslation?: ProductTranslationOmit
    productMeta?: ProductMetaOmit
    comment?: CommentOmit
    commentMeta?: CommentMetaOmit
    term?: TermOmit
    termTaxonomy?: TermTaxonomyOmit
    termRelationship?: TermRelationshipOmit
    menu?: MenuOmit
    setting?: SettingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    metas: number
    articles: number
    pages: number
    portfolios: number
    products: number
    comments: number
  }

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    metas?: boolean | UserCountOutputTypeCountMetasArgs
    articles?: boolean | UserCountOutputTypeCountArticlesArgs
    pages?: boolean | UserCountOutputTypeCountPagesArgs
    portfolios?: boolean | UserCountOutputTypeCountPortfoliosArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserMetaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPortfoliosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
  }

  /**
   * Count Type PageCountOutputType
   */

  export type PageCountOutputType = {
    children: number
    translations: number
    metas: number
    comments: number
    terms: number
  }

  export type PageCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    children?: boolean | PageCountOutputTypeCountChildrenArgs
    translations?: boolean | PageCountOutputTypeCountTranslationsArgs
    metas?: boolean | PageCountOutputTypeCountMetasArgs
    comments?: boolean | PageCountOutputTypeCountCommentsArgs
    terms?: boolean | PageCountOutputTypeCountTermsArgs
  }

  // Custom InputTypes
  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageCountOutputType
     */
    select?: PageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountTranslationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageTranslationWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageMetaWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
  }

  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    children: number
    translations: number
    metas: number
    comments: number
    terms: number
  }

  export type ArticleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    children?: boolean | ArticleCountOutputTypeCountChildrenArgs
    translations?: boolean | ArticleCountOutputTypeCountTranslationsArgs
    metas?: boolean | ArticleCountOutputTypeCountMetasArgs
    comments?: boolean | ArticleCountOutputTypeCountCommentsArgs
    terms?: boolean | ArticleCountOutputTypeCountTermsArgs
  }

  // Custom InputTypes
  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountTranslationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleTranslationWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleMetaWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
  }

  /**
   * Count Type PortfolioCountOutputType
   */

  export type PortfolioCountOutputType = {
    translations: number
    metas: number
    comments: number
    terms: number
  }

  export type PortfolioCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    translations?: boolean | PortfolioCountOutputTypeCountTranslationsArgs
    metas?: boolean | PortfolioCountOutputTypeCountMetasArgs
    comments?: boolean | PortfolioCountOutputTypeCountCommentsArgs
    terms?: boolean | PortfolioCountOutputTypeCountTermsArgs
  }

  // Custom InputTypes
  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioCountOutputType
     */
    select?: PortfolioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountTranslationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioTranslationWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioMetaWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
  }

  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    translations: number
    metas: number
    comments: number
    terms: number
  }

  export type ProductCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    translations?: boolean | ProductCountOutputTypeCountTranslationsArgs
    metas?: boolean | ProductCountOutputTypeCountMetasArgs
    comments?: boolean | ProductCountOutputTypeCountCommentsArgs
    terms?: boolean | ProductCountOutputTypeCountTermsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTranslationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductTranslationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductMetaWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
  }

  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    metas: number
  }

  export type CommentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    metas?: boolean | CommentCountOutputTypeCountMetasArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountMetasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentMetaWhereInput
  }

  /**
   * Count Type TermCountOutputType
   */

  export type TermCountOutputType = {
    taxonomies: number
  }

  export type TermCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    taxonomies?: boolean | TermCountOutputTypeCountTaxonomiesArgs
  }

  // Custom InputTypes
  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermCountOutputType
     */
    select?: TermCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeCountTaxonomiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermTaxonomyWhereInput
  }

  /**
   * Count Type TermTaxonomyCountOutputType
   */

  export type TermTaxonomyCountOutputType = {
    children: number
    relationships: number
  }

  export type TermTaxonomyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    children?: boolean | TermTaxonomyCountOutputTypeCountChildrenArgs
    relationships?: boolean | TermTaxonomyCountOutputTypeCountRelationshipsArgs
  }

  // Custom InputTypes
  /**
   * TermTaxonomyCountOutputType without action
   */
  export type TermTaxonomyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomyCountOutputType
     */
    select?: TermTaxonomyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TermTaxonomyCountOutputType without action
   */
  export type TermTaxonomyCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermTaxonomyWhereInput
  }

  /**
   * TermTaxonomyCountOutputType without action
   */
  export type TermTaxonomyCountOutputTypeCountRelationshipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
  }

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    login: string | null
    email: string | null
    password: string | null
    displayName: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    registeredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    login: string | null
    email: string | null
    password: string | null
    displayName: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    registeredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    login: number
    email: number
    password: number
    displayName: number
    role: number
    isActive: number
    registeredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    login?: true
    email?: true
    password?: true
    displayName?: true
    role?: true
    isActive?: true
    registeredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    login?: true
    email?: true
    password?: true
    displayName?: true
    role?: true
    isActive?: true
    registeredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    login?: true
    email?: true
    password?: true
    displayName?: true
    role?: true
    isActive?: true
    registeredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     */
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
      by: UserScalarFieldEnum[] | UserScalarFieldEnum
      having?: UserScalarWhereWithAggregatesInput
      take?: number
      skip?: number
      _count?: UserCountAggregateInputType | true
      _avg?: UserAvgAggregateInputType
      _sum?: UserSumAggregateInputType
      _min?: UserMinAggregateInputType
      _max?: UserMaxAggregateInputType
    }

  export type UserGroupByOutputType = {
    id: number
    login: string
    email: string
    password: string
    displayName: string
    role: $Enums.Role
    isActive: boolean
    registeredAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>
      }
    >
  >

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        login?: boolean
        email?: boolean
        password?: boolean
        displayName?: boolean
        role?: boolean
        isActive?: boolean
        registeredAt?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        metas?: boolean | User$metasArgs<ExtArgs>
        articles?: boolean | User$articlesArgs<ExtArgs>
        pages?: boolean | User$pagesArgs<ExtArgs>
        portfolios?: boolean | User$portfoliosArgs<ExtArgs>
        products?: boolean | User$productsArgs<ExtArgs>
        comments?: boolean | User$commentsArgs<ExtArgs>
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['user']
    >

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      login?: boolean
      email?: boolean
      password?: boolean
      displayName?: boolean
      role?: boolean
      isActive?: boolean
      registeredAt?: boolean
      createdAt?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['user']
  >

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      login?: boolean
      email?: boolean
      password?: boolean
      displayName?: boolean
      role?: boolean
      isActive?: boolean
      registeredAt?: boolean
      createdAt?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['user']
  >

  export type UserSelectScalar = {
    id?: boolean
    login?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    role?: boolean
    isActive?: boolean
    registeredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'login'
      | 'email'
      | 'password'
      | 'displayName'
      | 'role'
      | 'isActive'
      | 'registeredAt'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['user']
    >
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metas?: boolean | User$metasArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    pages?: boolean | User$pagesArgs<ExtArgs>
    portfolios?: boolean | User$portfoliosArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {}
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User'
    objects: {
      metas: Prisma.$UserMetaPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
      portfolios: Prisma.$PortfolioPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        login: string
        email: string
        password: string
        displayName: string
        role: $Enums.Role
        isActive: boolean
        registeredAt: Date
        createdAt: Date
        updatedAt: Date
      },
      ExtArgs['result']['user']
    >
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true
  }

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     */
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    metas<T extends User$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, User$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    articles<T extends User$articlesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$articlesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    pages<T extends User$pagesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$pagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    portfolios<T extends User$portfoliosArgs<ExtArgs> = {}>(
      args?: Subset<T, User$portfoliosArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    products<T extends User$productsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$productsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    comments<T extends User$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'Int'>
    readonly login: FieldRef<'User', 'String'>
    readonly email: FieldRef<'User', 'String'>
    readonly password: FieldRef<'User', 'String'>
    readonly displayName: FieldRef<'User', 'String'>
    readonly role: FieldRef<'User', 'Role'>
    readonly isActive: FieldRef<'User', 'Boolean'>
    readonly registeredAt: FieldRef<'User', 'DateTime'>
    readonly createdAt: FieldRef<'User', 'DateTime'>
    readonly updatedAt: FieldRef<'User', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.metas
   */
  export type User$metasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    where?: UserMetaWhereInput
    orderBy?: UserMetaOrderByWithRelationInput | UserMetaOrderByWithRelationInput[]
    cursor?: UserMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMetaScalarFieldEnum | UserMetaScalarFieldEnum[]
  }

  /**
   * User.articles
   */
  export type User$articlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * User.pages
   */
  export type User$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.portfolios
   */
  export type User$portfoliosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * User.products
   */
  export type User$productsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null
    }

  /**
   * Model UserMeta
   */

  export type AggregateUserMeta = {
    _count: UserMetaCountAggregateOutputType | null
    _avg: UserMetaAvgAggregateOutputType | null
    _sum: UserMetaSumAggregateOutputType | null
    _min: UserMetaMinAggregateOutputType | null
    _max: UserMetaMaxAggregateOutputType | null
  }

  export type UserMetaAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserMetaSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserMetaMinAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
  }

  export type UserMetaMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
  }

  export type UserMetaCountAggregateOutputType = {
    id: number
    userId: number
    key: number
    value: number
    _all: number
  }

  export type UserMetaAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserMetaSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserMetaMinAggregateInputType = {
    id?: true
    userId?: true
    key?: true
  }

  export type UserMetaMaxAggregateInputType = {
    id?: true
    userId?: true
    key?: true
  }

  export type UserMetaCountAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type UserMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserMeta to aggregate.
     */
    where?: UserMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserMetas to fetch.
     */
    orderBy?: UserMetaOrderByWithRelationInput | UserMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserMetas
     */
    _count?: true | UserMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: UserMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: UserMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: UserMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: UserMetaMaxAggregateInputType
  }

  export type GetUserMetaAggregateType<T extends UserMetaAggregateArgs> = {
    [P in keyof T & keyof AggregateUserMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMeta[P]>
      : GetScalarType<T[P], AggregateUserMeta[P]>
  }

  export type UserMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UserMetaWhereInput
    orderBy?: UserMetaOrderByWithAggregationInput | UserMetaOrderByWithAggregationInput[]
    by: UserMetaScalarFieldEnum[] | UserMetaScalarFieldEnum
    having?: UserMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMetaCountAggregateInputType | true
    _avg?: UserMetaAvgAggregateInputType
    _sum?: UserMetaSumAggregateInputType
    _min?: UserMetaMinAggregateInputType
    _max?: UserMetaMaxAggregateInputType
  }

  export type UserMetaGroupByOutputType = {
    id: number
    userId: number
    key: string
    value: JsonValue
    _count: UserMetaCountAggregateOutputType | null
    _avg: UserMetaAvgAggregateOutputType | null
    _sum: UserMetaSumAggregateOutputType | null
    _min: UserMetaMinAggregateOutputType | null
    _max: UserMetaMaxAggregateOutputType | null
  }

  type GetUserMetaGroupByPayload<T extends UserMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserMetaGroupByOutputType[P]>
          : GetScalarType<T[P], UserMetaGroupByOutputType[P]>
      }
    >
  >

  export type UserMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        userId?: boolean
        key?: boolean
        value?: boolean
        user?: boolean | UserDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['userMeta']
    >

  export type UserMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      userId?: boolean
      key?: boolean
      value?: boolean
      user?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['userMeta']
  >

  export type UserMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      userId?: boolean
      key?: boolean
      value?: boolean
      user?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['userMeta']
  >

  export type UserMetaSelectScalar = {
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
  }

  export type UserMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'userId' | 'key' | 'value', ExtArgs['result']['userMeta']>
  export type UserMetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | UserDefaultArgs<ExtArgs>
    }
  export type UserMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'UserMeta'
      objects: {
        user: Prisma.$UserPayload<ExtArgs>
      }
      scalars: $Extensions.GetPayloadResult<
        {
          id: number
          userId: number
          key: string
          value: Prisma.JsonValue
        },
        ExtArgs['result']['userMeta']
      >
      composites: {}
    }

  type UserMetaGetPayload<S extends boolean | null | undefined | UserMetaDefaultArgs> =
    $Result.GetResult<Prisma.$UserMetaPayload, S>

  type UserMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserMetaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserMetaCountAggregateInputType | true
  }

  export interface UserMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMeta']; meta: { name: 'UserMeta' } }
    /**
     * Find zero or one UserMeta that matches the filter.
     * @param {UserMetaFindUniqueArgs} args - Arguments to find a UserMeta
     * @example
     * // Get one UserMeta
     * const userMeta = await prisma.userMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMetaFindUniqueArgs>(
      args: SelectSubset<T, UserMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<
        Prisma.$UserMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one UserMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMetaFindUniqueOrThrowArgs} args - Arguments to find a UserMeta
     * @example
     * // Get one UserMeta
     * const userMeta = await prisma.userMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<
        Prisma.$UserMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first UserMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaFindFirstArgs} args - Arguments to find a UserMeta
     * @example
     * // Get one UserMeta
     * const userMeta = await prisma.userMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMetaFindFirstArgs>(
      args?: SelectSubset<T, UserMetaFindFirstArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first UserMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaFindFirstOrThrowArgs} args - Arguments to find a UserMeta
     * @example
     * // Get one UserMeta
     * const userMeta = await prisma.userMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more UserMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMetas
     * const userMetas = await prisma.userMeta.findMany()
     *
     * // Get first 10 UserMetas
     * const userMetas = await prisma.userMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userMetaWithIdOnly = await prisma.userMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserMetaFindManyArgs>(
      args?: SelectSubset<T, UserMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a UserMeta.
     * @param {UserMetaCreateArgs} args - Arguments to create a UserMeta.
     * @example
     * // Create one UserMeta
     * const UserMeta = await prisma.userMeta.create({
     *   data: {
     *     // ... data to create a UserMeta
     *   }
     * })
     *
     */
    create<T extends UserMetaCreateArgs>(
      args: SelectSubset<T, UserMetaCreateArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many UserMetas.
     * @param {UserMetaCreateManyArgs} args - Arguments to create many UserMetas.
     * @example
     * // Create many UserMetas
     * const userMeta = await prisma.userMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserMetaCreateManyArgs>(
      args?: SelectSubset<T, UserMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMetas and returns the data saved in the database.
     * @param {UserMetaCreateManyAndReturnArgs} args - Arguments to create many UserMetas.
     * @example
     * // Create many UserMetas
     * const userMeta = await prisma.userMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserMetas and only return the `id`
     * const userMetaWithIdOnly = await prisma.userMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a UserMeta.
     * @param {UserMetaDeleteArgs} args - Arguments to delete one UserMeta.
     * @example
     * // Delete one UserMeta
     * const UserMeta = await prisma.userMeta.delete({
     *   where: {
     *     // ... filter to delete one UserMeta
     *   }
     * })
     *
     */
    delete<T extends UserMetaDeleteArgs>(
      args: SelectSubset<T, UserMetaDeleteArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one UserMeta.
     * @param {UserMetaUpdateArgs} args - Arguments to update one UserMeta.
     * @example
     * // Update one UserMeta
     * const userMeta = await prisma.userMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserMetaUpdateArgs>(
      args: SelectSubset<T, UserMetaUpdateArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more UserMetas.
     * @param {UserMetaDeleteManyArgs} args - Arguments to filter UserMetas to delete.
     * @example
     * // Delete a few UserMetas
     * const { count } = await prisma.userMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserMetaDeleteManyArgs>(
      args?: SelectSubset<T, UserMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMetas
     * const userMeta = await prisma.userMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserMetaUpdateManyArgs>(
      args: SelectSubset<T, UserMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMetas and returns the data updated in the database.
     * @param {UserMetaUpdateManyAndReturnArgs} args - Arguments to update many UserMetas.
     * @example
     * // Update many UserMetas
     * const userMeta = await prisma.userMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserMetas and only return the `id`
     * const userMetaWithIdOnly = await prisma.userMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one UserMeta.
     * @param {UserMetaUpsertArgs} args - Arguments to update or create a UserMeta.
     * @example
     * // Update or create a UserMeta
     * const userMeta = await prisma.userMeta.upsert({
     *   create: {
     *     // ... data to create a UserMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMeta we want to update
     *   }
     * })
     */
    upsert<T extends UserMetaUpsertArgs>(
      args: SelectSubset<T, UserMetaUpsertArgs<ExtArgs>>
    ): Prisma__UserMetaClient<
      $Result.GetResult<Prisma.$UserMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of UserMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaCountArgs} args - Arguments to filter UserMetas to count.
     * @example
     * // Count the number of UserMetas
     * const count = await prisma.userMeta.count({
     *   where: {
     *     // ... the filter for the UserMetas we want to count
     *   }
     * })
     */
    count<T extends UserMetaCountArgs>(
      args?: Subset<T, UserMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends UserMetaAggregateArgs>(
      args: Subset<T, UserMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetUserMetaAggregateType<T>>

    /**
     * Group by UserMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends UserMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMetaGroupByArgs['orderBy'] }
        : { orderBy?: UserMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, UserMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the UserMeta model
     */
    readonly fields: UserMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the UserMeta model
   */
  interface UserMetaFieldRefs {
    readonly id: FieldRef<'UserMeta', 'Int'>
    readonly userId: FieldRef<'UserMeta', 'Int'>
    readonly key: FieldRef<'UserMeta', 'String'>
    readonly value: FieldRef<'UserMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * UserMeta findUnique
   */
  export type UserMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter, which UserMeta to fetch.
     */
    where: UserMetaWhereUniqueInput
  }

  /**
   * UserMeta findUniqueOrThrow
   */
  export type UserMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter, which UserMeta to fetch.
     */
    where: UserMetaWhereUniqueInput
  }

  /**
   * UserMeta findFirst
   */
  export type UserMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter, which UserMeta to fetch.
     */
    where?: UserMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserMetas to fetch.
     */
    orderBy?: UserMetaOrderByWithRelationInput | UserMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserMetas.
     */
    cursor?: UserMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserMetas.
     */
    distinct?: UserMetaScalarFieldEnum | UserMetaScalarFieldEnum[]
  }

  /**
   * UserMeta findFirstOrThrow
   */
  export type UserMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter, which UserMeta to fetch.
     */
    where?: UserMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserMetas to fetch.
     */
    orderBy?: UserMetaOrderByWithRelationInput | UserMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserMetas.
     */
    cursor?: UserMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserMetas.
     */
    distinct?: UserMetaScalarFieldEnum | UserMetaScalarFieldEnum[]
  }

  /**
   * UserMeta findMany
   */
  export type UserMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter, which UserMetas to fetch.
     */
    where?: UserMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserMetas to fetch.
     */
    orderBy?: UserMetaOrderByWithRelationInput | UserMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserMetas.
     */
    cursor?: UserMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserMetas.
     */
    skip?: number
    distinct?: UserMetaScalarFieldEnum | UserMetaScalarFieldEnum[]
  }

  /**
   * UserMeta create
   */
  export type UserMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMeta.
     */
    data: XOR<UserMetaCreateInput, UserMetaUncheckedCreateInput>
  }

  /**
   * UserMeta createMany
   */
  export type UserMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many UserMetas.
     */
    data: UserMetaCreateManyInput | UserMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMeta createManyAndReturn
   */
  export type UserMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * The data used to create many UserMetas.
     */
    data: UserMetaCreateManyInput | UserMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMeta update
   */
  export type UserMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMeta.
     */
    data: XOR<UserMetaUpdateInput, UserMetaUncheckedUpdateInput>
    /**
     * Choose, which UserMeta to update.
     */
    where: UserMetaWhereUniqueInput
  }

  /**
   * UserMeta updateMany
   */
  export type UserMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update UserMetas.
     */
    data: XOR<UserMetaUpdateManyMutationInput, UserMetaUncheckedUpdateManyInput>
    /**
     * Filter which UserMetas to update
     */
    where?: UserMetaWhereInput
    /**
     * Limit how many UserMetas to update.
     */
    limit?: number
  }

  /**
   * UserMeta updateManyAndReturn
   */
  export type UserMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * The data used to update UserMetas.
     */
    data: XOR<UserMetaUpdateManyMutationInput, UserMetaUncheckedUpdateManyInput>
    /**
     * Filter which UserMetas to update
     */
    where?: UserMetaWhereInput
    /**
     * Limit how many UserMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMeta upsert
   */
  export type UserMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMeta to update in case it exists.
     */
    where: UserMetaWhereUniqueInput
    /**
     * In case the UserMeta found by the `where` argument doesn't exist, create a new UserMeta with this data.
     */
    create: XOR<UserMetaCreateInput, UserMetaUncheckedCreateInput>
    /**
     * In case the UserMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMetaUpdateInput, UserMetaUncheckedUpdateInput>
  }

  /**
   * UserMeta delete
   */
  export type UserMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
    /**
     * Filter which UserMeta to delete.
     */
    where: UserMetaWhereUniqueInput
  }

  /**
   * UserMeta deleteMany
   */
  export type UserMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which UserMetas to delete
     */
    where?: UserMetaWhereInput
    /**
     * Limit how many UserMetas to delete.
     */
    limit?: number
  }

  /**
   * UserMeta without action
   */
  export type UserMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UserMeta
     */
    select?: UserMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMeta
     */
    omit?: UserMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetaInclude<ExtArgs> | null
  }

  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    parentId: number | null
    menuOrder: number | null
  }

  export type PageSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    parentId: number | null
    menuOrder: number | null
  }

  export type PageMinAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    parentId: number | null
    menuOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    parentId: number | null
    menuOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    slug: number
    status: number
    authorId: number
    parentId: number
    menuOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type PageAvgAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
    menuOrder?: true
  }

  export type PageSumAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
    menuOrder?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    menuOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    menuOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    menuOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Pages
     */
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
    [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }

  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: PageWhereInput
      orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
      by: PageScalarFieldEnum[] | PageScalarFieldEnum
      having?: PageScalarWhereWithAggregatesInput
      take?: number
      skip?: number
      _count?: PageCountAggregateInputType | true
      _avg?: PageAvgAggregateInputType
      _sum?: PageSumAggregateInputType
      _min?: PageMinAggregateInputType
      _max?: PageMaxAggregateInputType
    }

  export type PageGroupByOutputType = {
    id: number
    slug: string
    status: $Enums.Status
    authorId: number
    parentId: number | null
    menuOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PageGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PageGroupByOutputType[P]>
          : GetScalarType<T[P], PageGroupByOutputType[P]>
      }
    >
  >

  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        status?: boolean
        authorId?: boolean
        parentId?: boolean
        menuOrder?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        author?: boolean | UserDefaultArgs<ExtArgs>
        parent?: boolean | Page$parentArgs<ExtArgs>
        children?: boolean | Page$childrenArgs<ExtArgs>
        translations?: boolean | Page$translationsArgs<ExtArgs>
        metas?: boolean | Page$metasArgs<ExtArgs>
        comments?: boolean | Page$commentsArgs<ExtArgs>
        terms?: boolean | Page$termsArgs<ExtArgs>
        _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['page']
    >

  export type PageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      parentId?: boolean
      menuOrder?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
      parent?: boolean | Page$parentArgs<ExtArgs>
    },
    ExtArgs['result']['page']
  >

  export type PageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      parentId?: boolean
      menuOrder?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
      parent?: boolean | Page$parentArgs<ExtArgs>
    },
    ExtArgs['result']['page']
  >

  export type PageSelectScalar = {
    id?: boolean
    slug?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    menuOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'slug' | 'status' | 'authorId' | 'parentId' | 'menuOrder' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['page']
    >
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    children?: boolean | Page$childrenArgs<ExtArgs>
    translations?: boolean | Page$translationsArgs<ExtArgs>
    metas?: boolean | Page$metasArgs<ExtArgs>
    comments?: boolean | Page$commentsArgs<ExtArgs>
    terms?: boolean | Page$termsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
  }
  export type PageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Page'
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$PagePayload<ExtArgs> | null
      children: Prisma.$PagePayload<ExtArgs>[]
      translations: Prisma.$PageTranslationPayload<ExtArgs>[]
      metas: Prisma.$PageMetaPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      terms: Prisma.$TermRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        slug: string
        status: $Enums.Status
        authorId: number
        parentId: number | null
        menuOrder: number
        createdAt: Date
        updatedAt: Date
      },
      ExtArgs['result']['page']
    >
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<
    Prisma.$PagePayload,
    S
  >

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    PageFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PageCountAggregateInputType | true
  }

  export interface PageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page']; meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(
      args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(
      args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     *
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PageFindManyArgs>(
      args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     *
     */
    create<T extends PageCreateArgs>(
      args: SelectSubset<T, PageCreateArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PageCreateManyArgs>(
      args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     *
     */
    delete<T extends PageDeleteArgs>(
      args: SelectSubset<T, PageDeleteArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PageUpdateArgs>(
      args: SelectSubset<T, PageUpdateArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PageDeleteManyArgs>(
      args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PageUpdateManyArgs>(
      args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(
      args: SelectSubset<T, PageUpsertArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
     */
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PageAggregateArgs>(
      args: Subset<T, PageAggregateArgs>
    ): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Page model
     */
    readonly fields: PageFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    parent<T extends Page$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$parentArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<
        Prisma.$PagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    children<T extends Page$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$childrenArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    translations<T extends Page$translationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$translationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    metas<T extends Page$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    comments<T extends Page$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    terms<T extends Page$termsArgs<ExtArgs> = {}>(
      args?: Subset<T, Page$termsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TermRelationshipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<'Page', 'Int'>
    readonly slug: FieldRef<'Page', 'String'>
    readonly status: FieldRef<'Page', 'Status'>
    readonly authorId: FieldRef<'Page', 'Int'>
    readonly parentId: FieldRef<'Page', 'Int'>
    readonly menuOrder: FieldRef<'Page', 'Int'>
    readonly createdAt: FieldRef<'Page', 'DateTime'>
    readonly updatedAt: FieldRef<'Page', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Page
       */
      select?: PageSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Page
       */
      omit?: PageOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: PageInclude<ExtArgs> | null
      /**
       * Filter, which Pages to fetch.
       */
      where?: PageWhereInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Pages to fetch.
       */
      orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Pages.
       */
      cursor?: PageWhereUniqueInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Pages from the position of the cursor.
       */
      take?: number
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Pages.
       */
      skip?: number
      distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
    }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page.parent
   */
  export type Page$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Page
       */
      select?: PageSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Page
       */
      omit?: PageOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: PageInclude<ExtArgs> | null
      where?: PageWhereInput
    }

  /**
   * Page.children
   */
  export type Page$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page.translations
   */
  export type Page$translationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    where?: PageTranslationWhereInput
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    cursor?: PageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }

  /**
   * Page.metas
   */
  export type Page$metasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    where?: PageMetaWhereInput
    orderBy?: PageMetaOrderByWithRelationInput | PageMetaOrderByWithRelationInput[]
    cursor?: PageMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageMetaScalarFieldEnum | PageMetaScalarFieldEnum[]
  }

  /**
   * Page.comments
   */
  export type Page$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Page.terms
   */
  export type Page$termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    where?: TermRelationshipWhereInput
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    cursor?: TermRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Page
       */
      select?: PageSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Page
       */
      omit?: PageOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: PageInclude<ExtArgs> | null
    }

  /**
   * Model PageTranslation
   */

  export type AggregatePageTranslation = {
    _count: PageTranslationCountAggregateOutputType | null
    _avg: PageTranslationAvgAggregateOutputType | null
    _sum: PageTranslationSumAggregateOutputType | null
    _min: PageTranslationMinAggregateOutputType | null
    _max: PageTranslationMaxAggregateOutputType | null
  }

  export type PageTranslationAvgAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageTranslationSumAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageTranslationMinAggregateOutputType = {
    id: number | null
    pageId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type PageTranslationMaxAggregateOutputType = {
    id: number | null
    pageId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type PageTranslationCountAggregateOutputType = {
    id: number
    pageId: number
    lang: number
    title: number
    content: number
    excerpt: number
    _all: number
  }

  export type PageTranslationAvgAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageTranslationSumAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageTranslationMinAggregateInputType = {
    id?: true
    pageId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type PageTranslationMaxAggregateInputType = {
    id?: true
    pageId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type PageTranslationCountAggregateInputType = {
    id?: true
    pageId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
    _all?: true
  }

  export type PageTranslationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PageTranslation to aggregate.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PageTranslations
     */
    _count?: true | PageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PageTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PageTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PageTranslationMaxAggregateInputType
  }

  export type GetPageTranslationAggregateType<T extends PageTranslationAggregateArgs> = {
    [P in keyof T & keyof AggregatePageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageTranslation[P]>
      : GetScalarType<T[P], AggregatePageTranslation[P]>
  }

  export type PageTranslationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageTranslationWhereInput
    orderBy?:
      | PageTranslationOrderByWithAggregationInput
      | PageTranslationOrderByWithAggregationInput[]
    by: PageTranslationScalarFieldEnum[] | PageTranslationScalarFieldEnum
    having?: PageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageTranslationCountAggregateInputType | true
    _avg?: PageTranslationAvgAggregateInputType
    _sum?: PageTranslationSumAggregateInputType
    _min?: PageTranslationMinAggregateInputType
    _max?: PageTranslationMaxAggregateInputType
  }

  export type PageTranslationGroupByOutputType = {
    id: number
    pageId: number
    lang: string
    title: string
    content: string
    excerpt: string | null
    _count: PageTranslationCountAggregateOutputType | null
    _avg: PageTranslationAvgAggregateOutputType | null
    _sum: PageTranslationSumAggregateOutputType | null
    _min: PageTranslationMinAggregateOutputType | null
    _max: PageTranslationMaxAggregateOutputType | null
  }

  type GetPageTranslationGroupByPayload<T extends PageTranslationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PageTranslationGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PageTranslationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PageTranslationGroupByOutputType[P]>
        }
      >
    >

  export type PageTranslationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      pageId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      page?: boolean | PageDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['pageTranslation']
  >

  export type PageTranslationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      pageId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      page?: boolean | PageDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['pageTranslation']
  >

  export type PageTranslationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      pageId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      page?: boolean | PageDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['pageTranslation']
  >

  export type PageTranslationSelectScalar = {
    id?: boolean
    pageId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
  }

  export type PageTranslationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'pageId' | 'lang' | 'title' | 'content' | 'excerpt',
    ExtArgs['result']['pageTranslation']
  >
  export type PageTranslationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }
  export type PageTranslationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }
  export type PageTranslationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }

  export type $PageTranslationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'PageTranslation'
    objects: {
      page: Prisma.$PagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        pageId: number
        lang: string
        title: string
        content: string
        excerpt: string | null
      },
      ExtArgs['result']['pageTranslation']
    >
    composites: {}
  }

  type PageTranslationGetPayload<
    S extends boolean | null | undefined | PageTranslationDefaultArgs
  > = $Result.GetResult<Prisma.$PageTranslationPayload, S>

  type PageTranslationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<PageTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PageTranslationCountAggregateInputType | true
  }

  export interface PageTranslationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PageTranslation']
      meta: { name: 'PageTranslation' }
    }
    /**
     * Find zero or one PageTranslation that matches the filter.
     * @param {PageTranslationFindUniqueArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageTranslationFindUniqueArgs>(
      args: SelectSubset<T, PageTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one PageTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageTranslationFindUniqueOrThrowArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageTranslationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PageTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindFirstArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageTranslationFindFirstArgs>(
      args?: SelectSubset<T, PageTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindFirstOrThrowArgs} args - Arguments to find a PageTranslation
     * @example
     * // Get one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageTranslationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PageTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more PageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageTranslations
     * const pageTranslations = await prisma.pageTranslation.findMany()
     *
     * // Get first 10 PageTranslations
     * const pageTranslations = await prisma.pageTranslation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pageTranslationWithIdOnly = await prisma.pageTranslation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PageTranslationFindManyArgs>(
      args?: SelectSubset<T, PageTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a PageTranslation.
     * @param {PageTranslationCreateArgs} args - Arguments to create a PageTranslation.
     * @example
     * // Create one PageTranslation
     * const PageTranslation = await prisma.pageTranslation.create({
     *   data: {
     *     // ... data to create a PageTranslation
     *   }
     * })
     *
     */
    create<T extends PageTranslationCreateArgs>(
      args: SelectSubset<T, PageTranslationCreateArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many PageTranslations.
     * @param {PageTranslationCreateManyArgs} args - Arguments to create many PageTranslations.
     * @example
     * // Create many PageTranslations
     * const pageTranslation = await prisma.pageTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PageTranslationCreateManyArgs>(
      args?: SelectSubset<T, PageTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageTranslations and returns the data saved in the database.
     * @param {PageTranslationCreateManyAndReturnArgs} args - Arguments to create many PageTranslations.
     * @example
     * // Create many PageTranslations
     * const pageTranslation = await prisma.pageTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PageTranslations and only return the `id`
     * const pageTranslationWithIdOnly = await prisma.pageTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PageTranslationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PageTranslationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a PageTranslation.
     * @param {PageTranslationDeleteArgs} args - Arguments to delete one PageTranslation.
     * @example
     * // Delete one PageTranslation
     * const PageTranslation = await prisma.pageTranslation.delete({
     *   where: {
     *     // ... filter to delete one PageTranslation
     *   }
     * })
     *
     */
    delete<T extends PageTranslationDeleteArgs>(
      args: SelectSubset<T, PageTranslationDeleteArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one PageTranslation.
     * @param {PageTranslationUpdateArgs} args - Arguments to update one PageTranslation.
     * @example
     * // Update one PageTranslation
     * const pageTranslation = await prisma.pageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PageTranslationUpdateArgs>(
      args: SelectSubset<T, PageTranslationUpdateArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more PageTranslations.
     * @param {PageTranslationDeleteManyArgs} args - Arguments to filter PageTranslations to delete.
     * @example
     * // Delete a few PageTranslations
     * const { count } = await prisma.pageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PageTranslationDeleteManyArgs>(
      args?: SelectSubset<T, PageTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageTranslations
     * const pageTranslation = await prisma.pageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PageTranslationUpdateManyArgs>(
      args: SelectSubset<T, PageTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTranslations and returns the data updated in the database.
     * @param {PageTranslationUpdateManyAndReturnArgs} args - Arguments to update many PageTranslations.
     * @example
     * // Update many PageTranslations
     * const pageTranslation = await prisma.pageTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PageTranslations and only return the `id`
     * const pageTranslationWithIdOnly = await prisma.pageTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PageTranslationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PageTranslationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PageTranslationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one PageTranslation.
     * @param {PageTranslationUpsertArgs} args - Arguments to update or create a PageTranslation.
     * @example
     * // Update or create a PageTranslation
     * const pageTranslation = await prisma.pageTranslation.upsert({
     *   create: {
     *     // ... data to create a PageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageTranslation we want to update
     *   }
     * })
     */
    upsert<T extends PageTranslationUpsertArgs>(
      args: SelectSubset<T, PageTranslationUpsertArgs<ExtArgs>>
    ): Prisma__PageTranslationClient<
      $Result.GetResult<Prisma.$PageTranslationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of PageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationCountArgs} args - Arguments to filter PageTranslations to count.
     * @example
     * // Count the number of PageTranslations
     * const count = await prisma.pageTranslation.count({
     *   where: {
     *     // ... the filter for the PageTranslations we want to count
     *   }
     * })
     */
    count<T extends PageTranslationCountArgs>(
      args?: Subset<T, PageTranslationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PageTranslationAggregateArgs>(
      args: Subset<T, PageTranslationAggregateArgs>
    ): Prisma.PrismaPromise<GetPageTranslationAggregateType<T>>

    /**
     * Group by PageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PageTranslationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PageTranslationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPageTranslationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the PageTranslation model
     */
    readonly fields: PageTranslationFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageTranslationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    page<T extends PageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PageDefaultArgs<ExtArgs>>
    ): Prisma__PageClient<
      | $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the PageTranslation model
   */
  interface PageTranslationFieldRefs {
    readonly id: FieldRef<'PageTranslation', 'Int'>
    readonly pageId: FieldRef<'PageTranslation', 'Int'>
    readonly lang: FieldRef<'PageTranslation', 'String'>
    readonly title: FieldRef<'PageTranslation', 'String'>
    readonly content: FieldRef<'PageTranslation', 'String'>
    readonly excerpt: FieldRef<'PageTranslation', 'String'>
  }

  // Custom InputTypes
  /**
   * PageTranslation findUnique
   */
  export type PageTranslationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where: PageTranslationWhereUniqueInput
  }

  /**
   * PageTranslation findUniqueOrThrow
   */
  export type PageTranslationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where: PageTranslationWhereUniqueInput
  }

  /**
   * PageTranslation findFirst
   */
  export type PageTranslationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PageTranslations.
     */
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }

  /**
   * PageTranslation findFirstOrThrow
   */
  export type PageTranslationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslation to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PageTranslations.
     */
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }

  /**
   * PageTranslation findMany
   */
  export type PageTranslationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTranslations to fetch.
     */
    where?: PageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageTranslations to fetch.
     */
    orderBy?: PageTranslationOrderByWithRelationInput | PageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PageTranslations.
     */
    cursor?: PageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageTranslations.
     */
    skip?: number
    distinct?: PageTranslationScalarFieldEnum | PageTranslationScalarFieldEnum[]
  }

  /**
   * PageTranslation create
   */
  export type PageTranslationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a PageTranslation.
     */
    data: XOR<PageTranslationCreateInput, PageTranslationUncheckedCreateInput>
  }

  /**
   * PageTranslation createMany
   */
  export type PageTranslationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many PageTranslations.
     */
    data: PageTranslationCreateManyInput | PageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageTranslation createManyAndReturn
   */
  export type PageTranslationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many PageTranslations.
     */
    data: PageTranslationCreateManyInput | PageTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageTranslation update
   */
  export type PageTranslationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a PageTranslation.
     */
    data: XOR<PageTranslationUpdateInput, PageTranslationUncheckedUpdateInput>
    /**
     * Choose, which PageTranslation to update.
     */
    where: PageTranslationWhereUniqueInput
  }

  /**
   * PageTranslation updateMany
   */
  export type PageTranslationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update PageTranslations.
     */
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PageTranslations to update
     */
    where?: PageTranslationWhereInput
    /**
     * Limit how many PageTranslations to update.
     */
    limit?: number
  }

  /**
   * PageTranslation updateManyAndReturn
   */
  export type PageTranslationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * The data used to update PageTranslations.
     */
    data: XOR<PageTranslationUpdateManyMutationInput, PageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PageTranslations to update
     */
    where?: PageTranslationWhereInput
    /**
     * Limit how many PageTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageTranslation upsert
   */
  export type PageTranslationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the PageTranslation to update in case it exists.
     */
    where: PageTranslationWhereUniqueInput
    /**
     * In case the PageTranslation found by the `where` argument doesn't exist, create a new PageTranslation with this data.
     */
    create: XOR<PageTranslationCreateInput, PageTranslationUncheckedCreateInput>
    /**
     * In case the PageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageTranslationUpdateInput, PageTranslationUncheckedUpdateInput>
  }

  /**
   * PageTranslation delete
   */
  export type PageTranslationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
    /**
     * Filter which PageTranslation to delete.
     */
    where: PageTranslationWhereUniqueInput
  }

  /**
   * PageTranslation deleteMany
   */
  export type PageTranslationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PageTranslations to delete
     */
    where?: PageTranslationWhereInput
    /**
     * Limit how many PageTranslations to delete.
     */
    limit?: number
  }

  /**
   * PageTranslation without action
   */
  export type PageTranslationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageTranslation
     */
    select?: PageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTranslation
     */
    omit?: PageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTranslationInclude<ExtArgs> | null
  }

  /**
   * Model PageMeta
   */

  export type AggregatePageMeta = {
    _count: PageMetaCountAggregateOutputType | null
    _avg: PageMetaAvgAggregateOutputType | null
    _sum: PageMetaSumAggregateOutputType | null
    _min: PageMetaMinAggregateOutputType | null
    _max: PageMetaMaxAggregateOutputType | null
  }

  export type PageMetaAvgAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageMetaSumAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageMetaMinAggregateOutputType = {
    id: number | null
    pageId: number | null
    key: string | null
  }

  export type PageMetaMaxAggregateOutputType = {
    id: number | null
    pageId: number | null
    key: string | null
  }

  export type PageMetaCountAggregateOutputType = {
    id: number
    pageId: number
    key: number
    value: number
    _all: number
  }

  export type PageMetaAvgAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageMetaSumAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageMetaMinAggregateInputType = {
    id?: true
    pageId?: true
    key?: true
  }

  export type PageMetaMaxAggregateInputType = {
    id?: true
    pageId?: true
    key?: true
  }

  export type PageMetaCountAggregateInputType = {
    id?: true
    pageId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type PageMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PageMeta to aggregate.
     */
    where?: PageMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageMetas to fetch.
     */
    orderBy?: PageMetaOrderByWithRelationInput | PageMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PageMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PageMetas
     */
    _count?: true | PageMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PageMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PageMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PageMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PageMetaMaxAggregateInputType
  }

  export type GetPageMetaAggregateType<T extends PageMetaAggregateArgs> = {
    [P in keyof T & keyof AggregatePageMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageMeta[P]>
      : GetScalarType<T[P], AggregatePageMeta[P]>
  }

  export type PageMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PageMetaWhereInput
    orderBy?: PageMetaOrderByWithAggregationInput | PageMetaOrderByWithAggregationInput[]
    by: PageMetaScalarFieldEnum[] | PageMetaScalarFieldEnum
    having?: PageMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageMetaCountAggregateInputType | true
    _avg?: PageMetaAvgAggregateInputType
    _sum?: PageMetaSumAggregateInputType
    _min?: PageMetaMinAggregateInputType
    _max?: PageMetaMaxAggregateInputType
  }

  export type PageMetaGroupByOutputType = {
    id: number
    pageId: number
    key: string
    value: JsonValue
    _count: PageMetaCountAggregateOutputType | null
    _avg: PageMetaAvgAggregateOutputType | null
    _sum: PageMetaSumAggregateOutputType | null
    _min: PageMetaMinAggregateOutputType | null
    _max: PageMetaMaxAggregateOutputType | null
  }

  type GetPageMetaGroupByPayload<T extends PageMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PageMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PageMetaGroupByOutputType[P]>
          : GetScalarType<T[P], PageMetaGroupByOutputType[P]>
      }
    >
  >

  export type PageMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        pageId?: boolean
        key?: boolean
        value?: boolean
        page?: boolean | PageDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['pageMeta']
    >

  export type PageMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      pageId?: boolean
      key?: boolean
      value?: boolean
      page?: boolean | PageDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['pageMeta']
  >

  export type PageMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      pageId?: boolean
      key?: boolean
      value?: boolean
      page?: boolean | PageDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['pageMeta']
  >

  export type PageMetaSelectScalar = {
    id?: boolean
    pageId?: boolean
    key?: boolean
    value?: boolean
  }

  export type PageMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'pageId' | 'key' | 'value', ExtArgs['result']['pageMeta']>
  export type PageMetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      page?: boolean | PageDefaultArgs<ExtArgs>
    }
  export type PageMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }
  export type PageMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }

  export type $PageMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'PageMeta'
      objects: {
        page: Prisma.$PagePayload<ExtArgs>
      }
      scalars: $Extensions.GetPayloadResult<
        {
          id: number
          pageId: number
          key: string
          value: Prisma.JsonValue
        },
        ExtArgs['result']['pageMeta']
      >
      composites: {}
    }

  type PageMetaGetPayload<S extends boolean | null | undefined | PageMetaDefaultArgs> =
    $Result.GetResult<Prisma.$PageMetaPayload, S>

  type PageMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    PageMetaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PageMetaCountAggregateInputType | true
  }

  export interface PageMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageMeta']; meta: { name: 'PageMeta' } }
    /**
     * Find zero or one PageMeta that matches the filter.
     * @param {PageMetaFindUniqueArgs} args - Arguments to find a PageMeta
     * @example
     * // Get one PageMeta
     * const pageMeta = await prisma.pageMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageMetaFindUniqueArgs>(
      args: SelectSubset<T, PageMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<
        Prisma.$PageMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one PageMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageMetaFindUniqueOrThrowArgs} args - Arguments to find a PageMeta
     * @example
     * // Get one PageMeta
     * const pageMeta = await prisma.pageMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PageMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<
        Prisma.$PageMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PageMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaFindFirstArgs} args - Arguments to find a PageMeta
     * @example
     * // Get one PageMeta
     * const pageMeta = await prisma.pageMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageMetaFindFirstArgs>(
      args?: SelectSubset<T, PageMetaFindFirstArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PageMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaFindFirstOrThrowArgs} args - Arguments to find a PageMeta
     * @example
     * // Get one PageMeta
     * const pageMeta = await prisma.pageMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PageMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more PageMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageMetas
     * const pageMetas = await prisma.pageMeta.findMany()
     *
     * // Get first 10 PageMetas
     * const pageMetas = await prisma.pageMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pageMetaWithIdOnly = await prisma.pageMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PageMetaFindManyArgs>(
      args?: SelectSubset<T, PageMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a PageMeta.
     * @param {PageMetaCreateArgs} args - Arguments to create a PageMeta.
     * @example
     * // Create one PageMeta
     * const PageMeta = await prisma.pageMeta.create({
     *   data: {
     *     // ... data to create a PageMeta
     *   }
     * })
     *
     */
    create<T extends PageMetaCreateArgs>(
      args: SelectSubset<T, PageMetaCreateArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many PageMetas.
     * @param {PageMetaCreateManyArgs} args - Arguments to create many PageMetas.
     * @example
     * // Create many PageMetas
     * const pageMeta = await prisma.pageMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PageMetaCreateManyArgs>(
      args?: SelectSubset<T, PageMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageMetas and returns the data saved in the database.
     * @param {PageMetaCreateManyAndReturnArgs} args - Arguments to create many PageMetas.
     * @example
     * // Create many PageMetas
     * const pageMeta = await prisma.pageMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PageMetas and only return the `id`
     * const pageMetaWithIdOnly = await prisma.pageMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PageMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PageMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PageMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a PageMeta.
     * @param {PageMetaDeleteArgs} args - Arguments to delete one PageMeta.
     * @example
     * // Delete one PageMeta
     * const PageMeta = await prisma.pageMeta.delete({
     *   where: {
     *     // ... filter to delete one PageMeta
     *   }
     * })
     *
     */
    delete<T extends PageMetaDeleteArgs>(
      args: SelectSubset<T, PageMetaDeleteArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one PageMeta.
     * @param {PageMetaUpdateArgs} args - Arguments to update one PageMeta.
     * @example
     * // Update one PageMeta
     * const pageMeta = await prisma.pageMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PageMetaUpdateArgs>(
      args: SelectSubset<T, PageMetaUpdateArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more PageMetas.
     * @param {PageMetaDeleteManyArgs} args - Arguments to filter PageMetas to delete.
     * @example
     * // Delete a few PageMetas
     * const { count } = await prisma.pageMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PageMetaDeleteManyArgs>(
      args?: SelectSubset<T, PageMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageMetas
     * const pageMeta = await prisma.pageMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PageMetaUpdateManyArgs>(
      args: SelectSubset<T, PageMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageMetas and returns the data updated in the database.
     * @param {PageMetaUpdateManyAndReturnArgs} args - Arguments to update many PageMetas.
     * @example
     * // Update many PageMetas
     * const pageMeta = await prisma.pageMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PageMetas and only return the `id`
     * const pageMetaWithIdOnly = await prisma.pageMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PageMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PageMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PageMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one PageMeta.
     * @param {PageMetaUpsertArgs} args - Arguments to update or create a PageMeta.
     * @example
     * // Update or create a PageMeta
     * const pageMeta = await prisma.pageMeta.upsert({
     *   create: {
     *     // ... data to create a PageMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageMeta we want to update
     *   }
     * })
     */
    upsert<T extends PageMetaUpsertArgs>(
      args: SelectSubset<T, PageMetaUpsertArgs<ExtArgs>>
    ): Prisma__PageMetaClient<
      $Result.GetResult<Prisma.$PageMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of PageMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaCountArgs} args - Arguments to filter PageMetas to count.
     * @example
     * // Count the number of PageMetas
     * const count = await prisma.pageMeta.count({
     *   where: {
     *     // ... the filter for the PageMetas we want to count
     *   }
     * })
     */
    count<T extends PageMetaCountArgs>(
      args?: Subset<T, PageMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PageMetaAggregateArgs>(
      args: Subset<T, PageMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetPageMetaAggregateType<T>>

    /**
     * Group by PageMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PageMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageMetaGroupByArgs['orderBy'] }
        : { orderBy?: PageMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PageMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPageMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the PageMeta model
     */
    readonly fields: PageMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    page<T extends PageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PageDefaultArgs<ExtArgs>>
    ): Prisma__PageClient<
      | $Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the PageMeta model
   */
  interface PageMetaFieldRefs {
    readonly id: FieldRef<'PageMeta', 'Int'>
    readonly pageId: FieldRef<'PageMeta', 'Int'>
    readonly key: FieldRef<'PageMeta', 'String'>
    readonly value: FieldRef<'PageMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * PageMeta findUnique
   */
  export type PageMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter, which PageMeta to fetch.
     */
    where: PageMetaWhereUniqueInput
  }

  /**
   * PageMeta findUniqueOrThrow
   */
  export type PageMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter, which PageMeta to fetch.
     */
    where: PageMetaWhereUniqueInput
  }

  /**
   * PageMeta findFirst
   */
  export type PageMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter, which PageMeta to fetch.
     */
    where?: PageMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageMetas to fetch.
     */
    orderBy?: PageMetaOrderByWithRelationInput | PageMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PageMetas.
     */
    cursor?: PageMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PageMetas.
     */
    distinct?: PageMetaScalarFieldEnum | PageMetaScalarFieldEnum[]
  }

  /**
   * PageMeta findFirstOrThrow
   */
  export type PageMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter, which PageMeta to fetch.
     */
    where?: PageMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageMetas to fetch.
     */
    orderBy?: PageMetaOrderByWithRelationInput | PageMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PageMetas.
     */
    cursor?: PageMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PageMetas.
     */
    distinct?: PageMetaScalarFieldEnum | PageMetaScalarFieldEnum[]
  }

  /**
   * PageMeta findMany
   */
  export type PageMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter, which PageMetas to fetch.
     */
    where?: PageMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PageMetas to fetch.
     */
    orderBy?: PageMetaOrderByWithRelationInput | PageMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PageMetas.
     */
    cursor?: PageMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PageMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PageMetas.
     */
    skip?: number
    distinct?: PageMetaScalarFieldEnum | PageMetaScalarFieldEnum[]
  }

  /**
   * PageMeta create
   */
  export type PageMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a PageMeta.
     */
    data: XOR<PageMetaCreateInput, PageMetaUncheckedCreateInput>
  }

  /**
   * PageMeta createMany
   */
  export type PageMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many PageMetas.
     */
    data: PageMetaCreateManyInput | PageMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageMeta createManyAndReturn
   */
  export type PageMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * The data used to create many PageMetas.
     */
    data: PageMetaCreateManyInput | PageMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageMeta update
   */
  export type PageMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a PageMeta.
     */
    data: XOR<PageMetaUpdateInput, PageMetaUncheckedUpdateInput>
    /**
     * Choose, which PageMeta to update.
     */
    where: PageMetaWhereUniqueInput
  }

  /**
   * PageMeta updateMany
   */
  export type PageMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update PageMetas.
     */
    data: XOR<PageMetaUpdateManyMutationInput, PageMetaUncheckedUpdateManyInput>
    /**
     * Filter which PageMetas to update
     */
    where?: PageMetaWhereInput
    /**
     * Limit how many PageMetas to update.
     */
    limit?: number
  }

  /**
   * PageMeta updateManyAndReturn
   */
  export type PageMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * The data used to update PageMetas.
     */
    data: XOR<PageMetaUpdateManyMutationInput, PageMetaUncheckedUpdateManyInput>
    /**
     * Filter which PageMetas to update
     */
    where?: PageMetaWhereInput
    /**
     * Limit how many PageMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageMeta upsert
   */
  export type PageMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the PageMeta to update in case it exists.
     */
    where: PageMetaWhereUniqueInput
    /**
     * In case the PageMeta found by the `where` argument doesn't exist, create a new PageMeta with this data.
     */
    create: XOR<PageMetaCreateInput, PageMetaUncheckedCreateInput>
    /**
     * In case the PageMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageMetaUpdateInput, PageMetaUncheckedUpdateInput>
  }

  /**
   * PageMeta delete
   */
  export type PageMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
    /**
     * Filter which PageMeta to delete.
     */
    where: PageMetaWhereUniqueInput
  }

  /**
   * PageMeta deleteMany
   */
  export type PageMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PageMetas to delete
     */
    where?: PageMetaWhereInput
    /**
     * Limit how many PageMetas to delete.
     */
    limit?: number
  }

  /**
   * PageMeta without action
   */
  export type PageMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PageMeta
     */
    select?: PageMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageMeta
     */
    omit?: PageMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageMetaInclude<ExtArgs> | null
  }

  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    parentId: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    parentId: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    slug: number
    status: number
    authorId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type ArticleAvgAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Articles
     */
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
    [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }

  export type ArticleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: number
    slug: string
    status: $Enums.Status
    authorId: number
    parentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ArticleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
          : GetScalarType<T[P], ArticleGroupByOutputType[P]>
      }
    >
  >

  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        status?: boolean
        authorId?: boolean
        parentId?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        author?: boolean | UserDefaultArgs<ExtArgs>
        parent?: boolean | Article$parentArgs<ExtArgs>
        children?: boolean | Article$childrenArgs<ExtArgs>
        translations?: boolean | Article$translationsArgs<ExtArgs>
        metas?: boolean | Article$metasArgs<ExtArgs>
        comments?: boolean | Article$commentsArgs<ExtArgs>
        terms?: boolean | Article$termsArgs<ExtArgs>
        _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['article']
    >

  export type ArticleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      parentId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
      parent?: boolean | Article$parentArgs<ExtArgs>
    },
    ExtArgs['result']['article']
  >

  export type ArticleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      parentId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
      parent?: boolean | Article$parentArgs<ExtArgs>
    },
    ExtArgs['result']['article']
  >

  export type ArticleSelectScalar = {
    id?: boolean
    slug?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'slug' | 'status' | 'authorId' | 'parentId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['article']
    >
  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Article$parentArgs<ExtArgs>
    children?: boolean | Article$childrenArgs<ExtArgs>
    translations?: boolean | Article$translationsArgs<ExtArgs>
    metas?: boolean | Article$metasArgs<ExtArgs>
    comments?: boolean | Article$commentsArgs<ExtArgs>
    terms?: boolean | Article$termsArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArticleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Article$parentArgs<ExtArgs>
  }
  export type ArticleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Article$parentArgs<ExtArgs>
  }

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Article'
      objects: {
        author: Prisma.$UserPayload<ExtArgs>
        parent: Prisma.$ArticlePayload<ExtArgs> | null
        children: Prisma.$ArticlePayload<ExtArgs>[]
        translations: Prisma.$ArticleTranslationPayload<ExtArgs>[]
        metas: Prisma.$ArticleMetaPayload<ExtArgs>[]
        comments: Prisma.$CommentPayload<ExtArgs>[]
        terms: Prisma.$TermRelationshipPayload<ExtArgs>[]
      }
      scalars: $Extensions.GetPayloadResult<
        {
          id: number
          slug: string
          status: $Enums.Status
          authorId: number
          parentId: number | null
          createdAt: Date
          updatedAt: Date
        },
        ExtArgs['result']['article']
      >
      composites: {}
    }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> =
    $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ArticleFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ArticleCountAggregateInputType | true
  }

  export interface ArticleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article']; meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(
      args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(
      args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     *
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ArticleFindManyArgs>(
      args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     *
     */
    create<T extends ArticleCreateArgs>(
      args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArticleCreateManyArgs>(
      args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {ArticleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArticleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ArticleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticlePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     *
     */
    delete<T extends ArticleDeleteArgs>(
      args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArticleUpdateArgs>(
      args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArticleDeleteManyArgs>(
      args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArticleUpdateManyArgs>(
      args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles and returns the data updated in the database.
     * @param {ArticleUpdateManyAndReturnArgs} args - Arguments to update many Articles.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArticleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ArticleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticlePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(
      args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
     */
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ArticleAggregateArgs>(
      args: Subset<T, ArticleAggregateArgs>
    ): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Article model
     */
    readonly fields: ArticleFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    parent<T extends Article$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$parentArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<
        Prisma.$ArticlePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    children<T extends Article$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$childrenArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    translations<T extends Article$translationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$translationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ArticleTranslationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    metas<T extends Article$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    comments<T extends Article$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    terms<T extends Article$termsArgs<ExtArgs> = {}>(
      args?: Subset<T, Article$termsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TermRelationshipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Article model
   */
  interface ArticleFieldRefs {
    readonly id: FieldRef<'Article', 'Int'>
    readonly slug: FieldRef<'Article', 'String'>
    readonly status: FieldRef<'Article', 'Status'>
    readonly authorId: FieldRef<'Article', 'Int'>
    readonly parentId: FieldRef<'Article', 'Int'>
    readonly createdAt: FieldRef<'Article', 'DateTime'>
    readonly updatedAt: FieldRef<'Article', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article createManyAndReturn
   */
  export type ArticleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
  }

  /**
   * Article updateManyAndReturn
   */
  export type ArticleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to delete.
     */
    limit?: number
  }

  /**
   * Article.parent
   */
  export type Article$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }

  /**
   * Article.children
   */
  export type Article$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article.translations
   */
  export type Article$translationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    where?: ArticleTranslationWhereInput
    orderBy?:
      | ArticleTranslationOrderByWithRelationInput
      | ArticleTranslationOrderByWithRelationInput[]
    cursor?: ArticleTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }

  /**
   * Article.metas
   */
  export type Article$metasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    where?: ArticleMetaWhereInput
    orderBy?: ArticleMetaOrderByWithRelationInput | ArticleMetaOrderByWithRelationInput[]
    cursor?: ArticleMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleMetaScalarFieldEnum | ArticleMetaScalarFieldEnum[]
  }

  /**
   * Article.comments
   */
  export type Article$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Article.terms
   */
  export type Article$termsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    where?: TermRelationshipWhereInput
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    cursor?: TermRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
  }

  /**
   * Model ArticleTranslation
   */

  export type AggregateArticleTranslation = {
    _count: ArticleTranslationCountAggregateOutputType | null
    _avg: ArticleTranslationAvgAggregateOutputType | null
    _sum: ArticleTranslationSumAggregateOutputType | null
    _min: ArticleTranslationMinAggregateOutputType | null
    _max: ArticleTranslationMaxAggregateOutputType | null
  }

  export type ArticleTranslationAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type ArticleTranslationSumAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type ArticleTranslationMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type ArticleTranslationMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type ArticleTranslationCountAggregateOutputType = {
    id: number
    articleId: number
    lang: number
    title: number
    content: number
    excerpt: number
    _all: number
  }

  export type ArticleTranslationAvgAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type ArticleTranslationSumAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type ArticleTranslationMinAggregateInputType = {
    id?: true
    articleId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type ArticleTranslationMaxAggregateInputType = {
    id?: true
    articleId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type ArticleTranslationCountAggregateInputType = {
    id?: true
    articleId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
    _all?: true
  }

  export type ArticleTranslationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ArticleTranslation to aggregate.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?:
      | ArticleTranslationOrderByWithRelationInput
      | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ArticleTranslations
     */
    _count?: true | ArticleTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ArticleTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ArticleTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ArticleTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ArticleTranslationMaxAggregateInputType
  }

  export type GetArticleTranslationAggregateType<T extends ArticleTranslationAggregateArgs> = {
    [P in keyof T & keyof AggregateArticleTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleTranslation[P]>
      : GetScalarType<T[P], AggregateArticleTranslation[P]>
  }

  export type ArticleTranslationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleTranslationWhereInput
    orderBy?:
      | ArticleTranslationOrderByWithAggregationInput
      | ArticleTranslationOrderByWithAggregationInput[]
    by: ArticleTranslationScalarFieldEnum[] | ArticleTranslationScalarFieldEnum
    having?: ArticleTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleTranslationCountAggregateInputType | true
    _avg?: ArticleTranslationAvgAggregateInputType
    _sum?: ArticleTranslationSumAggregateInputType
    _min?: ArticleTranslationMinAggregateInputType
    _max?: ArticleTranslationMaxAggregateInputType
  }

  export type ArticleTranslationGroupByOutputType = {
    id: number
    articleId: number
    lang: string
    title: string
    content: string
    excerpt: string | null
    _count: ArticleTranslationCountAggregateOutputType | null
    _avg: ArticleTranslationAvgAggregateOutputType | null
    _sum: ArticleTranslationSumAggregateOutputType | null
    _min: ArticleTranslationMinAggregateOutputType | null
    _max: ArticleTranslationMaxAggregateOutputType | null
  }

  type GetArticleTranslationGroupByPayload<T extends ArticleTranslationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ArticleTranslationGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ArticleTranslationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleTranslationGroupByOutputType[P]>
        }
      >
    >

  export type ArticleTranslationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleTranslation']
  >

  export type ArticleTranslationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleTranslation']
  >

  export type ArticleTranslationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleTranslation']
  >

  export type ArticleTranslationSelectScalar = {
    id?: boolean
    articleId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
  }

  export type ArticleTranslationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'articleId' | 'lang' | 'title' | 'content' | 'excerpt',
    ExtArgs['result']['articleTranslation']
  >
  export type ArticleTranslationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type ArticleTranslationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type ArticleTranslationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $ArticleTranslationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ArticleTranslation'
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        articleId: number
        lang: string
        title: string
        content: string
        excerpt: string | null
      },
      ExtArgs['result']['articleTranslation']
    >
    composites: {}
  }

  type ArticleTranslationGetPayload<
    S extends boolean | null | undefined | ArticleTranslationDefaultArgs
  > = $Result.GetResult<Prisma.$ArticleTranslationPayload, S>

  type ArticleTranslationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ArticleTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ArticleTranslationCountAggregateInputType | true
  }

  export interface ArticleTranslationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ArticleTranslation']
      meta: { name: 'ArticleTranslation' }
    }
    /**
     * Find zero or one ArticleTranslation that matches the filter.
     * @param {ArticleTranslationFindUniqueArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleTranslationFindUniqueArgs>(
      args: SelectSubset<T, ArticleTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one ArticleTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleTranslationFindUniqueOrThrowArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleTranslationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ArticleTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ArticleTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindFirstArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleTranslationFindFirstArgs>(
      args?: SelectSubset<T, ArticleTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ArticleTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindFirstOrThrowArgs} args - Arguments to find a ArticleTranslation
     * @example
     * // Get one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleTranslationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more ArticleTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleTranslations
     * const articleTranslations = await prisma.articleTranslation.findMany()
     *
     * // Get first 10 ArticleTranslations
     * const articleTranslations = await prisma.articleTranslation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const articleTranslationWithIdOnly = await prisma.articleTranslation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ArticleTranslationFindManyArgs>(
      args?: SelectSubset<T, ArticleTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a ArticleTranslation.
     * @param {ArticleTranslationCreateArgs} args - Arguments to create a ArticleTranslation.
     * @example
     * // Create one ArticleTranslation
     * const ArticleTranslation = await prisma.articleTranslation.create({
     *   data: {
     *     // ... data to create a ArticleTranslation
     *   }
     * })
     *
     */
    create<T extends ArticleTranslationCreateArgs>(
      args: SelectSubset<T, ArticleTranslationCreateArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many ArticleTranslations.
     * @param {ArticleTranslationCreateManyArgs} args - Arguments to create many ArticleTranslations.
     * @example
     * // Create many ArticleTranslations
     * const articleTranslation = await prisma.articleTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArticleTranslationCreateManyArgs>(
      args?: SelectSubset<T, ArticleTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleTranslations and returns the data saved in the database.
     * @param {ArticleTranslationCreateManyAndReturnArgs} args - Arguments to create many ArticleTranslations.
     * @example
     * // Create many ArticleTranslations
     * const articleTranslation = await prisma.articleTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ArticleTranslations and only return the `id`
     * const articleTranslationWithIdOnly = await prisma.articleTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArticleTranslationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ArticleTranslationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a ArticleTranslation.
     * @param {ArticleTranslationDeleteArgs} args - Arguments to delete one ArticleTranslation.
     * @example
     * // Delete one ArticleTranslation
     * const ArticleTranslation = await prisma.articleTranslation.delete({
     *   where: {
     *     // ... filter to delete one ArticleTranslation
     *   }
     * })
     *
     */
    delete<T extends ArticleTranslationDeleteArgs>(
      args: SelectSubset<T, ArticleTranslationDeleteArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one ArticleTranslation.
     * @param {ArticleTranslationUpdateArgs} args - Arguments to update one ArticleTranslation.
     * @example
     * // Update one ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArticleTranslationUpdateArgs>(
      args: SelectSubset<T, ArticleTranslationUpdateArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more ArticleTranslations.
     * @param {ArticleTranslationDeleteManyArgs} args - Arguments to filter ArticleTranslations to delete.
     * @example
     * // Delete a few ArticleTranslations
     * const { count } = await prisma.articleTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArticleTranslationDeleteManyArgs>(
      args?: SelectSubset<T, ArticleTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleTranslations
     * const articleTranslation = await prisma.articleTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArticleTranslationUpdateManyArgs>(
      args: SelectSubset<T, ArticleTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTranslations and returns the data updated in the database.
     * @param {ArticleTranslationUpdateManyAndReturnArgs} args - Arguments to update many ArticleTranslations.
     * @example
     * // Update many ArticleTranslations
     * const articleTranslation = await prisma.articleTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ArticleTranslations and only return the `id`
     * const articleTranslationWithIdOnly = await prisma.articleTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArticleTranslationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ArticleTranslationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticleTranslationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one ArticleTranslation.
     * @param {ArticleTranslationUpsertArgs} args - Arguments to update or create a ArticleTranslation.
     * @example
     * // Update or create a ArticleTranslation
     * const articleTranslation = await prisma.articleTranslation.upsert({
     *   create: {
     *     // ... data to create a ArticleTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ArticleTranslationUpsertArgs>(
      args: SelectSubset<T, ArticleTranslationUpsertArgs<ExtArgs>>
    ): Prisma__ArticleTranslationClient<
      $Result.GetResult<Prisma.$ArticleTranslationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of ArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationCountArgs} args - Arguments to filter ArticleTranslations to count.
     * @example
     * // Count the number of ArticleTranslations
     * const count = await prisma.articleTranslation.count({
     *   where: {
     *     // ... the filter for the ArticleTranslations we want to count
     *   }
     * })
     */
    count<T extends ArticleTranslationCountArgs>(
      args?: Subset<T, ArticleTranslationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ArticleTranslationAggregateArgs>(
      args: Subset<T, ArticleTranslationAggregateArgs>
    ): Prisma.PrismaPromise<GetArticleTranslationAggregateType<T>>

    /**
     * Group by ArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ArticleTranslationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ArticleTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ArticleTranslationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetArticleTranslationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the ArticleTranslation model
     */
    readonly fields: ArticleTranslationFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleTranslationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ArticleDefaultArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      | $Result.GetResult<
          Prisma.$ArticlePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the ArticleTranslation model
   */
  interface ArticleTranslationFieldRefs {
    readonly id: FieldRef<'ArticleTranslation', 'Int'>
    readonly articleId: FieldRef<'ArticleTranslation', 'Int'>
    readonly lang: FieldRef<'ArticleTranslation', 'String'>
    readonly title: FieldRef<'ArticleTranslation', 'String'>
    readonly content: FieldRef<'ArticleTranslation', 'String'>
    readonly excerpt: FieldRef<'ArticleTranslation', 'String'>
  }

  // Custom InputTypes
  /**
   * ArticleTranslation findUnique
   */
  export type ArticleTranslationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where: ArticleTranslationWhereUniqueInput
  }

  /**
   * ArticleTranslation findUniqueOrThrow
   */
  export type ArticleTranslationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where: ArticleTranslationWhereUniqueInput
  }

  /**
   * ArticleTranslation findFirst
   */
  export type ArticleTranslationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?:
      | ArticleTranslationOrderByWithRelationInput
      | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArticleTranslations.
     */
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }

  /**
   * ArticleTranslation findFirstOrThrow
   */
  export type ArticleTranslationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslation to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?:
      | ArticleTranslationOrderByWithRelationInput
      | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArticleTranslations.
     */
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }

  /**
   * ArticleTranslation findMany
   */
  export type ArticleTranslationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTranslations to fetch.
     */
    where?: ArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleTranslations to fetch.
     */
    orderBy?:
      | ArticleTranslationOrderByWithRelationInput
      | ArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ArticleTranslations.
     */
    cursor?: ArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleTranslations.
     */
    skip?: number
    distinct?: ArticleTranslationScalarFieldEnum | ArticleTranslationScalarFieldEnum[]
  }

  /**
   * ArticleTranslation create
   */
  export type ArticleTranslationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleTranslation.
     */
    data: XOR<ArticleTranslationCreateInput, ArticleTranslationUncheckedCreateInput>
  }

  /**
   * ArticleTranslation createMany
   */
  export type ArticleTranslationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ArticleTranslations.
     */
    data: ArticleTranslationCreateManyInput | ArticleTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleTranslation createManyAndReturn
   */
  export type ArticleTranslationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ArticleTranslations.
     */
    data: ArticleTranslationCreateManyInput | ArticleTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleTranslation update
   */
  export type ArticleTranslationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleTranslation.
     */
    data: XOR<ArticleTranslationUpdateInput, ArticleTranslationUncheckedUpdateInput>
    /**
     * Choose, which ArticleTranslation to update.
     */
    where: ArticleTranslationWhereUniqueInput
  }

  /**
   * ArticleTranslation updateMany
   */
  export type ArticleTranslationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ArticleTranslations.
     */
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTranslations to update
     */
    where?: ArticleTranslationWhereInput
    /**
     * Limit how many ArticleTranslations to update.
     */
    limit?: number
  }

  /**
   * ArticleTranslation updateManyAndReturn
   */
  export type ArticleTranslationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ArticleTranslations.
     */
    data: XOR<ArticleTranslationUpdateManyMutationInput, ArticleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTranslations to update
     */
    where?: ArticleTranslationWhereInput
    /**
     * Limit how many ArticleTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleTranslation upsert
   */
  export type ArticleTranslationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleTranslation to update in case it exists.
     */
    where: ArticleTranslationWhereUniqueInput
    /**
     * In case the ArticleTranslation found by the `where` argument doesn't exist, create a new ArticleTranslation with this data.
     */
    create: XOR<ArticleTranslationCreateInput, ArticleTranslationUncheckedCreateInput>
    /**
     * In case the ArticleTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleTranslationUpdateInput, ArticleTranslationUncheckedUpdateInput>
  }

  /**
   * ArticleTranslation delete
   */
  export type ArticleTranslationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter which ArticleTranslation to delete.
     */
    where: ArticleTranslationWhereUniqueInput
  }

  /**
   * ArticleTranslation deleteMany
   */
  export type ArticleTranslationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ArticleTranslations to delete
     */
    where?: ArticleTranslationWhereInput
    /**
     * Limit how many ArticleTranslations to delete.
     */
    limit?: number
  }

  /**
   * ArticleTranslation without action
   */
  export type ArticleTranslationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleTranslation
     */
    select?: ArticleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTranslation
     */
    omit?: ArticleTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTranslationInclude<ExtArgs> | null
  }

  /**
   * Model ArticleMeta
   */

  export type AggregateArticleMeta = {
    _count: ArticleMetaCountAggregateOutputType | null
    _avg: ArticleMetaAvgAggregateOutputType | null
    _sum: ArticleMetaSumAggregateOutputType | null
    _min: ArticleMetaMinAggregateOutputType | null
    _max: ArticleMetaMaxAggregateOutputType | null
  }

  export type ArticleMetaAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type ArticleMetaSumAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type ArticleMetaMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    key: string | null
  }

  export type ArticleMetaMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    key: string | null
  }

  export type ArticleMetaCountAggregateOutputType = {
    id: number
    articleId: number
    key: number
    value: number
    _all: number
  }

  export type ArticleMetaAvgAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type ArticleMetaSumAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type ArticleMetaMinAggregateInputType = {
    id?: true
    articleId?: true
    key?: true
  }

  export type ArticleMetaMaxAggregateInputType = {
    id?: true
    articleId?: true
    key?: true
  }

  export type ArticleMetaCountAggregateInputType = {
    id?: true
    articleId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type ArticleMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ArticleMeta to aggregate.
     */
    where?: ArticleMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleMetas to fetch.
     */
    orderBy?: ArticleMetaOrderByWithRelationInput | ArticleMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ArticleMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ArticleMetas
     */
    _count?: true | ArticleMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ArticleMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ArticleMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ArticleMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ArticleMetaMaxAggregateInputType
  }

  export type GetArticleMetaAggregateType<T extends ArticleMetaAggregateArgs> = {
    [P in keyof T & keyof AggregateArticleMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleMeta[P]>
      : GetScalarType<T[P], AggregateArticleMeta[P]>
  }

  export type ArticleMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ArticleMetaWhereInput
    orderBy?: ArticleMetaOrderByWithAggregationInput | ArticleMetaOrderByWithAggregationInput[]
    by: ArticleMetaScalarFieldEnum[] | ArticleMetaScalarFieldEnum
    having?: ArticleMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleMetaCountAggregateInputType | true
    _avg?: ArticleMetaAvgAggregateInputType
    _sum?: ArticleMetaSumAggregateInputType
    _min?: ArticleMetaMinAggregateInputType
    _max?: ArticleMetaMaxAggregateInputType
  }

  export type ArticleMetaGroupByOutputType = {
    id: number
    articleId: number
    key: string
    value: JsonValue
    _count: ArticleMetaCountAggregateOutputType | null
    _avg: ArticleMetaAvgAggregateOutputType | null
    _sum: ArticleMetaSumAggregateOutputType | null
    _min: ArticleMetaMinAggregateOutputType | null
    _max: ArticleMetaMaxAggregateOutputType | null
  }

  type GetArticleMetaGroupByPayload<T extends ArticleMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ArticleMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ArticleMetaGroupByOutputType[P]>
          : GetScalarType<T[P], ArticleMetaGroupByOutputType[P]>
      }
    >
  >

  export type ArticleMetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      key?: boolean
      value?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleMeta']
  >

  export type ArticleMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      key?: boolean
      value?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleMeta']
  >

  export type ArticleMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      key?: boolean
      value?: boolean
      article?: boolean | ArticleDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['articleMeta']
  >

  export type ArticleMetaSelectScalar = {
    id?: boolean
    articleId?: boolean
    key?: boolean
    value?: boolean
  }

  export type ArticleMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'articleId' | 'key' | 'value', ExtArgs['result']['articleMeta']>
  export type ArticleMetaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type ArticleMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type ArticleMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $ArticleMetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ArticleMeta'
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        articleId: number
        key: string
        value: Prisma.JsonValue
      },
      ExtArgs['result']['articleMeta']
    >
    composites: {}
  }

  type ArticleMetaGetPayload<S extends boolean | null | undefined | ArticleMetaDefaultArgs> =
    $Result.GetResult<Prisma.$ArticleMetaPayload, S>

  type ArticleMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleMetaCountAggregateInputType | true
    }

  export interface ArticleMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ArticleMeta']
      meta: { name: 'ArticleMeta' }
    }
    /**
     * Find zero or one ArticleMeta that matches the filter.
     * @param {ArticleMetaFindUniqueArgs} args - Arguments to find a ArticleMeta
     * @example
     * // Get one ArticleMeta
     * const articleMeta = await prisma.articleMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleMetaFindUniqueArgs>(
      args: SelectSubset<T, ArticleMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one ArticleMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleMetaFindUniqueOrThrowArgs} args - Arguments to find a ArticleMeta
     * @example
     * // Get one ArticleMeta
     * const articleMeta = await prisma.articleMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ArticleMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ArticleMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaFindFirstArgs} args - Arguments to find a ArticleMeta
     * @example
     * // Get one ArticleMeta
     * const articleMeta = await prisma.articleMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleMetaFindFirstArgs>(
      args?: SelectSubset<T, ArticleMetaFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ArticleMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaFindFirstOrThrowArgs} args - Arguments to find a ArticleMeta
     * @example
     * // Get one ArticleMeta
     * const articleMeta = await prisma.articleMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more ArticleMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleMetas
     * const articleMetas = await prisma.articleMeta.findMany()
     *
     * // Get first 10 ArticleMetas
     * const articleMetas = await prisma.articleMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const articleMetaWithIdOnly = await prisma.articleMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ArticleMetaFindManyArgs>(
      args?: SelectSubset<T, ArticleMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a ArticleMeta.
     * @param {ArticleMetaCreateArgs} args - Arguments to create a ArticleMeta.
     * @example
     * // Create one ArticleMeta
     * const ArticleMeta = await prisma.articleMeta.create({
     *   data: {
     *     // ... data to create a ArticleMeta
     *   }
     * })
     *
     */
    create<T extends ArticleMetaCreateArgs>(
      args: SelectSubset<T, ArticleMetaCreateArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many ArticleMetas.
     * @param {ArticleMetaCreateManyArgs} args - Arguments to create many ArticleMetas.
     * @example
     * // Create many ArticleMetas
     * const articleMeta = await prisma.articleMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArticleMetaCreateManyArgs>(
      args?: SelectSubset<T, ArticleMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleMetas and returns the data saved in the database.
     * @param {ArticleMetaCreateManyAndReturnArgs} args - Arguments to create many ArticleMetas.
     * @example
     * // Create many ArticleMetas
     * const articleMeta = await prisma.articleMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ArticleMetas and only return the `id`
     * const articleMetaWithIdOnly = await prisma.articleMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArticleMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ArticleMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a ArticleMeta.
     * @param {ArticleMetaDeleteArgs} args - Arguments to delete one ArticleMeta.
     * @example
     * // Delete one ArticleMeta
     * const ArticleMeta = await prisma.articleMeta.delete({
     *   where: {
     *     // ... filter to delete one ArticleMeta
     *   }
     * })
     *
     */
    delete<T extends ArticleMetaDeleteArgs>(
      args: SelectSubset<T, ArticleMetaDeleteArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one ArticleMeta.
     * @param {ArticleMetaUpdateArgs} args - Arguments to update one ArticleMeta.
     * @example
     * // Update one ArticleMeta
     * const articleMeta = await prisma.articleMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArticleMetaUpdateArgs>(
      args: SelectSubset<T, ArticleMetaUpdateArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more ArticleMetas.
     * @param {ArticleMetaDeleteManyArgs} args - Arguments to filter ArticleMetas to delete.
     * @example
     * // Delete a few ArticleMetas
     * const { count } = await prisma.articleMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArticleMetaDeleteManyArgs>(
      args?: SelectSubset<T, ArticleMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleMetas
     * const articleMeta = await prisma.articleMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArticleMetaUpdateManyArgs>(
      args: SelectSubset<T, ArticleMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleMetas and returns the data updated in the database.
     * @param {ArticleMetaUpdateManyAndReturnArgs} args - Arguments to update many ArticleMetas.
     * @example
     * // Update many ArticleMetas
     * const articleMeta = await prisma.articleMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ArticleMetas and only return the `id`
     * const articleMetaWithIdOnly = await prisma.articleMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArticleMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ArticleMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArticleMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one ArticleMeta.
     * @param {ArticleMetaUpsertArgs} args - Arguments to update or create a ArticleMeta.
     * @example
     * // Update or create a ArticleMeta
     * const articleMeta = await prisma.articleMeta.upsert({
     *   create: {
     *     // ... data to create a ArticleMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleMeta we want to update
     *   }
     * })
     */
    upsert<T extends ArticleMetaUpsertArgs>(
      args: SelectSubset<T, ArticleMetaUpsertArgs<ExtArgs>>
    ): Prisma__ArticleMetaClient<
      $Result.GetResult<Prisma.$ArticleMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of ArticleMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaCountArgs} args - Arguments to filter ArticleMetas to count.
     * @example
     * // Count the number of ArticleMetas
     * const count = await prisma.articleMeta.count({
     *   where: {
     *     // ... the filter for the ArticleMetas we want to count
     *   }
     * })
     */
    count<T extends ArticleMetaCountArgs>(
      args?: Subset<T, ArticleMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ArticleMetaAggregateArgs>(
      args: Subset<T, ArticleMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetArticleMetaAggregateType<T>>

    /**
     * Group by ArticleMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ArticleMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleMetaGroupByArgs['orderBy'] }
        : { orderBy?: ArticleMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ArticleMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetArticleMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the ArticleMeta model
     */
    readonly fields: ArticleMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ArticleDefaultArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      | $Result.GetResult<
          Prisma.$ArticlePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the ArticleMeta model
   */
  interface ArticleMetaFieldRefs {
    readonly id: FieldRef<'ArticleMeta', 'Int'>
    readonly articleId: FieldRef<'ArticleMeta', 'Int'>
    readonly key: FieldRef<'ArticleMeta', 'String'>
    readonly value: FieldRef<'ArticleMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * ArticleMeta findUnique
   */
  export type ArticleMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter, which ArticleMeta to fetch.
     */
    where: ArticleMetaWhereUniqueInput
  }

  /**
   * ArticleMeta findUniqueOrThrow
   */
  export type ArticleMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter, which ArticleMeta to fetch.
     */
    where: ArticleMetaWhereUniqueInput
  }

  /**
   * ArticleMeta findFirst
   */
  export type ArticleMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter, which ArticleMeta to fetch.
     */
    where?: ArticleMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleMetas to fetch.
     */
    orderBy?: ArticleMetaOrderByWithRelationInput | ArticleMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArticleMetas.
     */
    cursor?: ArticleMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArticleMetas.
     */
    distinct?: ArticleMetaScalarFieldEnum | ArticleMetaScalarFieldEnum[]
  }

  /**
   * ArticleMeta findFirstOrThrow
   */
  export type ArticleMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter, which ArticleMeta to fetch.
     */
    where?: ArticleMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleMetas to fetch.
     */
    orderBy?: ArticleMetaOrderByWithRelationInput | ArticleMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArticleMetas.
     */
    cursor?: ArticleMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArticleMetas.
     */
    distinct?: ArticleMetaScalarFieldEnum | ArticleMetaScalarFieldEnum[]
  }

  /**
   * ArticleMeta findMany
   */
  export type ArticleMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter, which ArticleMetas to fetch.
     */
    where?: ArticleMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArticleMetas to fetch.
     */
    orderBy?: ArticleMetaOrderByWithRelationInput | ArticleMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ArticleMetas.
     */
    cursor?: ArticleMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArticleMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArticleMetas.
     */
    skip?: number
    distinct?: ArticleMetaScalarFieldEnum | ArticleMetaScalarFieldEnum[]
  }

  /**
   * ArticleMeta create
   */
  export type ArticleMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleMeta.
     */
    data: XOR<ArticleMetaCreateInput, ArticleMetaUncheckedCreateInput>
  }

  /**
   * ArticleMeta createMany
   */
  export type ArticleMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ArticleMetas.
     */
    data: ArticleMetaCreateManyInput | ArticleMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleMeta createManyAndReturn
   */
  export type ArticleMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * The data used to create many ArticleMetas.
     */
    data: ArticleMetaCreateManyInput | ArticleMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleMeta update
   */
  export type ArticleMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleMeta.
     */
    data: XOR<ArticleMetaUpdateInput, ArticleMetaUncheckedUpdateInput>
    /**
     * Choose, which ArticleMeta to update.
     */
    where: ArticleMetaWhereUniqueInput
  }

  /**
   * ArticleMeta updateMany
   */
  export type ArticleMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ArticleMetas.
     */
    data: XOR<ArticleMetaUpdateManyMutationInput, ArticleMetaUncheckedUpdateManyInput>
    /**
     * Filter which ArticleMetas to update
     */
    where?: ArticleMetaWhereInput
    /**
     * Limit how many ArticleMetas to update.
     */
    limit?: number
  }

  /**
   * ArticleMeta updateManyAndReturn
   */
  export type ArticleMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * The data used to update ArticleMetas.
     */
    data: XOR<ArticleMetaUpdateManyMutationInput, ArticleMetaUncheckedUpdateManyInput>
    /**
     * Filter which ArticleMetas to update
     */
    where?: ArticleMetaWhereInput
    /**
     * Limit how many ArticleMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleMeta upsert
   */
  export type ArticleMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleMeta to update in case it exists.
     */
    where: ArticleMetaWhereUniqueInput
    /**
     * In case the ArticleMeta found by the `where` argument doesn't exist, create a new ArticleMeta with this data.
     */
    create: XOR<ArticleMetaCreateInput, ArticleMetaUncheckedCreateInput>
    /**
     * In case the ArticleMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleMetaUpdateInput, ArticleMetaUncheckedUpdateInput>
  }

  /**
   * ArticleMeta delete
   */
  export type ArticleMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
    /**
     * Filter which ArticleMeta to delete.
     */
    where: ArticleMetaWhereUniqueInput
  }

  /**
   * ArticleMeta deleteMany
   */
  export type ArticleMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ArticleMetas to delete
     */
    where?: ArticleMetaWhereInput
    /**
     * Limit how many ArticleMetas to delete.
     */
    limit?: number
  }

  /**
   * ArticleMeta without action
   */
  export type ArticleMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ArticleMeta
     */
    select?: ArticleMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleMeta
     */
    omit?: ArticleMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleMetaInclude<ExtArgs> | null
  }

  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PortfolioSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    status: $Enums.Status | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    slug: number
    status: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type PortfolioAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PortfolioSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PortfolioMinAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Portfolios
     */
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PortfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PortfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
    [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }

  export type PortfolioGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _avg?: PortfolioAvgAggregateInputType
    _sum?: PortfolioSumAggregateInputType
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: number
    slug: string
    status: $Enums.Status
    authorId: number
    createdAt: Date
    updatedAt: Date
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PortfolioGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
          : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
      }
    >
  >

  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        status?: boolean
        authorId?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        author?: boolean | UserDefaultArgs<ExtArgs>
        translations?: boolean | Portfolio$translationsArgs<ExtArgs>
        metas?: boolean | Portfolio$metasArgs<ExtArgs>
        comments?: boolean | Portfolio$commentsArgs<ExtArgs>
        terms?: boolean | Portfolio$termsArgs<ExtArgs>
        _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['portfolio']
    >

  export type PortfolioSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolio']
  >

  export type PortfolioSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      status?: boolean
      authorId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      author?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolio']
  >

  export type PortfolioSelectScalar = {
    id?: boolean
    slug?: boolean
    status?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'slug' | 'status' | 'authorId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['portfolio']
    >
  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      author?: boolean | UserDefaultArgs<ExtArgs>
      translations?: boolean | Portfolio$translationsArgs<ExtArgs>
      metas?: boolean | Portfolio$metasArgs<ExtArgs>
      comments?: boolean | Portfolio$commentsArgs<ExtArgs>
      terms?: boolean | Portfolio$termsArgs<ExtArgs>
      _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
    }
  export type PortfolioIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PortfolioPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'Portfolio'
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      translations: Prisma.$PortfolioTranslationPayload<ExtArgs>[]
      metas: Prisma.$PortfolioMetaPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      terms: Prisma.$TermRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        slug: string
        status: $Enums.Status
        authorId: number
        createdAt: Date
        updatedAt: Date
      },
      ExtArgs['result']['portfolio']
    >
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> =
    $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Portfolio']
      meta: { name: 'Portfolio' }
    }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(
      args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(
      args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     *
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PortfolioFindManyArgs>(
      args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     *
     */
    create<T extends PortfolioCreateArgs>(
      args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PortfolioCreateManyArgs>(
      args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     *
     */
    delete<T extends PortfolioDeleteArgs>(
      args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PortfolioUpdateArgs>(
      args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(
      args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PortfolioUpdateManyArgs>(
      args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios and returns the data updated in the database.
     * @param {PortfolioUpdateManyAndReturnArgs} args - Arguments to update many Portfolios.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PortfolioUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PortfolioUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(
      args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
     */
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PortfolioAggregateArgs>(
      args: Subset<T, PortfolioAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Portfolio model
     */
    readonly fields: PortfolioFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    translations<T extends Portfolio$translationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Portfolio$translationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PortfolioTranslationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    metas<T extends Portfolio$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, Portfolio$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    comments<T extends Portfolio$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Portfolio$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    terms<T extends Portfolio$termsArgs<ExtArgs> = {}>(
      args?: Subset<T, Portfolio$termsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TermRelationshipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Portfolio model
   */
  interface PortfolioFieldRefs {
    readonly id: FieldRef<'Portfolio', 'Int'>
    readonly slug: FieldRef<'Portfolio', 'String'>
    readonly status: FieldRef<'Portfolio', 'Status'>
    readonly authorId: FieldRef<'Portfolio', 'Int'>
    readonly createdAt: FieldRef<'Portfolio', 'DateTime'>
    readonly updatedAt: FieldRef<'Portfolio', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
  }

  /**
   * Portfolio updateManyAndReturn
   */
  export type PortfolioUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to delete.
     */
    limit?: number
  }

  /**
   * Portfolio.translations
   */
  export type Portfolio$translationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    where?: PortfolioTranslationWhereInput
    orderBy?:
      | PortfolioTranslationOrderByWithRelationInput
      | PortfolioTranslationOrderByWithRelationInput[]
    cursor?: PortfolioTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioTranslationScalarFieldEnum | PortfolioTranslationScalarFieldEnum[]
  }

  /**
   * Portfolio.metas
   */
  export type Portfolio$metasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    where?: PortfolioMetaWhereInput
    orderBy?: PortfolioMetaOrderByWithRelationInput | PortfolioMetaOrderByWithRelationInput[]
    cursor?: PortfolioMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioMetaScalarFieldEnum | PortfolioMetaScalarFieldEnum[]
  }

  /**
   * Portfolio.comments
   */
  export type Portfolio$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Portfolio.terms
   */
  export type Portfolio$termsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    where?: TermRelationshipWhereInput
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    cursor?: TermRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }

  /**
   * Model PortfolioTranslation
   */

  export type AggregatePortfolioTranslation = {
    _count: PortfolioTranslationCountAggregateOutputType | null
    _avg: PortfolioTranslationAvgAggregateOutputType | null
    _sum: PortfolioTranslationSumAggregateOutputType | null
    _min: PortfolioTranslationMinAggregateOutputType | null
    _max: PortfolioTranslationMaxAggregateOutputType | null
  }

  export type PortfolioTranslationAvgAggregateOutputType = {
    id: number | null
    portfolioId: number | null
  }

  export type PortfolioTranslationSumAggregateOutputType = {
    id: number | null
    portfolioId: number | null
  }

  export type PortfolioTranslationMinAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type PortfolioTranslationMaxAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    lang: string | null
    title: string | null
    content: string | null
    excerpt: string | null
  }

  export type PortfolioTranslationCountAggregateOutputType = {
    id: number
    portfolioId: number
    lang: number
    title: number
    content: number
    excerpt: number
    _all: number
  }

  export type PortfolioTranslationAvgAggregateInputType = {
    id?: true
    portfolioId?: true
  }

  export type PortfolioTranslationSumAggregateInputType = {
    id?: true
    portfolioId?: true
  }

  export type PortfolioTranslationMinAggregateInputType = {
    id?: true
    portfolioId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type PortfolioTranslationMaxAggregateInputType = {
    id?: true
    portfolioId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
  }

  export type PortfolioTranslationCountAggregateInputType = {
    id?: true
    portfolioId?: true
    lang?: true
    title?: true
    content?: true
    excerpt?: true
    _all?: true
  }

  export type PortfolioTranslationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PortfolioTranslation to aggregate.
     */
    where?: PortfolioTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioTranslations to fetch.
     */
    orderBy?:
      | PortfolioTranslationOrderByWithRelationInput
      | PortfolioTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PortfolioTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PortfolioTranslations
     */
    _count?: true | PortfolioTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PortfolioTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PortfolioTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PortfolioTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PortfolioTranslationMaxAggregateInputType
  }

  export type GetPortfolioTranslationAggregateType<T extends PortfolioTranslationAggregateArgs> = {
    [P in keyof T & keyof AggregatePortfolioTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioTranslation[P]>
      : GetScalarType<T[P], AggregatePortfolioTranslation[P]>
  }

  export type PortfolioTranslationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioTranslationWhereInput
    orderBy?:
      | PortfolioTranslationOrderByWithAggregationInput
      | PortfolioTranslationOrderByWithAggregationInput[]
    by: PortfolioTranslationScalarFieldEnum[] | PortfolioTranslationScalarFieldEnum
    having?: PortfolioTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioTranslationCountAggregateInputType | true
    _avg?: PortfolioTranslationAvgAggregateInputType
    _sum?: PortfolioTranslationSumAggregateInputType
    _min?: PortfolioTranslationMinAggregateInputType
    _max?: PortfolioTranslationMaxAggregateInputType
  }

  export type PortfolioTranslationGroupByOutputType = {
    id: number
    portfolioId: number
    lang: string
    title: string
    content: string
    excerpt: string | null
    _count: PortfolioTranslationCountAggregateOutputType | null
    _avg: PortfolioTranslationAvgAggregateOutputType | null
    _sum: PortfolioTranslationSumAggregateOutputType | null
    _min: PortfolioTranslationMinAggregateOutputType | null
    _max: PortfolioTranslationMaxAggregateOutputType | null
  }

  type GetPortfolioTranslationGroupByPayload<T extends PortfolioTranslationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PortfolioTranslationGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PortfolioTranslationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioTranslationGroupByOutputType[P]>
        }
      >
    >

  export type PortfolioTranslationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioTranslation']
  >

  export type PortfolioTranslationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioTranslation']
  >

  export type PortfolioTranslationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      lang?: boolean
      title?: boolean
      content?: boolean
      excerpt?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioTranslation']
  >

  export type PortfolioTranslationSelectScalar = {
    id?: boolean
    portfolioId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
  }

  export type PortfolioTranslationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'portfolioId' | 'lang' | 'title' | 'content' | 'excerpt',
    ExtArgs['result']['portfolioTranslation']
  >
  export type PortfolioTranslationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioTranslationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioTranslationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }

  export type $PortfolioTranslationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'PortfolioTranslation'
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        portfolioId: number
        lang: string
        title: string
        content: string
        excerpt: string | null
      },
      ExtArgs['result']['portfolioTranslation']
    >
    composites: {}
  }

  type PortfolioTranslationGetPayload<
    S extends boolean | null | undefined | PortfolioTranslationDefaultArgs
  > = $Result.GetResult<Prisma.$PortfolioTranslationPayload, S>

  type PortfolioTranslationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<PortfolioTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PortfolioTranslationCountAggregateInputType | true
  }

  export interface PortfolioTranslationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PortfolioTranslation']
      meta: { name: 'PortfolioTranslation' }
    }
    /**
     * Find zero or one PortfolioTranslation that matches the filter.
     * @param {PortfolioTranslationFindUniqueArgs} args - Arguments to find a PortfolioTranslation
     * @example
     * // Get one PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioTranslationFindUniqueArgs>(
      args: SelectSubset<T, PortfolioTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one PortfolioTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioTranslationFindUniqueOrThrowArgs} args - Arguments to find a PortfolioTranslation
     * @example
     * // Get one PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioTranslationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PortfolioTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PortfolioTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationFindFirstArgs} args - Arguments to find a PortfolioTranslation
     * @example
     * // Get one PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioTranslationFindFirstArgs>(
      args?: SelectSubset<T, PortfolioTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PortfolioTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationFindFirstOrThrowArgs} args - Arguments to find a PortfolioTranslation
     * @example
     * // Get one PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioTranslationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PortfolioTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more PortfolioTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioTranslations
     * const portfolioTranslations = await prisma.portfolioTranslation.findMany()
     *
     * // Get first 10 PortfolioTranslations
     * const portfolioTranslations = await prisma.portfolioTranslation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const portfolioTranslationWithIdOnly = await prisma.portfolioTranslation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PortfolioTranslationFindManyArgs>(
      args?: SelectSubset<T, PortfolioTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a PortfolioTranslation.
     * @param {PortfolioTranslationCreateArgs} args - Arguments to create a PortfolioTranslation.
     * @example
     * // Create one PortfolioTranslation
     * const PortfolioTranslation = await prisma.portfolioTranslation.create({
     *   data: {
     *     // ... data to create a PortfolioTranslation
     *   }
     * })
     *
     */
    create<T extends PortfolioTranslationCreateArgs>(
      args: SelectSubset<T, PortfolioTranslationCreateArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many PortfolioTranslations.
     * @param {PortfolioTranslationCreateManyArgs} args - Arguments to create many PortfolioTranslations.
     * @example
     * // Create many PortfolioTranslations
     * const portfolioTranslation = await prisma.portfolioTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PortfolioTranslationCreateManyArgs>(
      args?: SelectSubset<T, PortfolioTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioTranslations and returns the data saved in the database.
     * @param {PortfolioTranslationCreateManyAndReturnArgs} args - Arguments to create many PortfolioTranslations.
     * @example
     * // Create many PortfolioTranslations
     * const portfolioTranslation = await prisma.portfolioTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PortfolioTranslations and only return the `id`
     * const portfolioTranslationWithIdOnly = await prisma.portfolioTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PortfolioTranslationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PortfolioTranslationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a PortfolioTranslation.
     * @param {PortfolioTranslationDeleteArgs} args - Arguments to delete one PortfolioTranslation.
     * @example
     * // Delete one PortfolioTranslation
     * const PortfolioTranslation = await prisma.portfolioTranslation.delete({
     *   where: {
     *     // ... filter to delete one PortfolioTranslation
     *   }
     * })
     *
     */
    delete<T extends PortfolioTranslationDeleteArgs>(
      args: SelectSubset<T, PortfolioTranslationDeleteArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one PortfolioTranslation.
     * @param {PortfolioTranslationUpdateArgs} args - Arguments to update one PortfolioTranslation.
     * @example
     * // Update one PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PortfolioTranslationUpdateArgs>(
      args: SelectSubset<T, PortfolioTranslationUpdateArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more PortfolioTranslations.
     * @param {PortfolioTranslationDeleteManyArgs} args - Arguments to filter PortfolioTranslations to delete.
     * @example
     * // Delete a few PortfolioTranslations
     * const { count } = await prisma.portfolioTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PortfolioTranslationDeleteManyArgs>(
      args?: SelectSubset<T, PortfolioTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioTranslations
     * const portfolioTranslation = await prisma.portfolioTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PortfolioTranslationUpdateManyArgs>(
      args: SelectSubset<T, PortfolioTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioTranslations and returns the data updated in the database.
     * @param {PortfolioTranslationUpdateManyAndReturnArgs} args - Arguments to update many PortfolioTranslations.
     * @example
     * // Update many PortfolioTranslations
     * const portfolioTranslation = await prisma.portfolioTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PortfolioTranslations and only return the `id`
     * const portfolioTranslationWithIdOnly = await prisma.portfolioTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PortfolioTranslationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PortfolioTranslationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one PortfolioTranslation.
     * @param {PortfolioTranslationUpsertArgs} args - Arguments to update or create a PortfolioTranslation.
     * @example
     * // Update or create a PortfolioTranslation
     * const portfolioTranslation = await prisma.portfolioTranslation.upsert({
     *   create: {
     *     // ... data to create a PortfolioTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioTranslation we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioTranslationUpsertArgs>(
      args: SelectSubset<T, PortfolioTranslationUpsertArgs<ExtArgs>>
    ): Prisma__PortfolioTranslationClient<
      $Result.GetResult<
        Prisma.$PortfolioTranslationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of PortfolioTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationCountArgs} args - Arguments to filter PortfolioTranslations to count.
     * @example
     * // Count the number of PortfolioTranslations
     * const count = await prisma.portfolioTranslation.count({
     *   where: {
     *     // ... the filter for the PortfolioTranslations we want to count
     *   }
     * })
     */
    count<T extends PortfolioTranslationCountArgs>(
      args?: Subset<T, PortfolioTranslationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PortfolioTranslationAggregateArgs>(
      args: Subset<T, PortfolioTranslationAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolioTranslationAggregateType<T>>

    /**
     * Group by PortfolioTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PortfolioTranslationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PortfolioTranslationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPortfolioTranslationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the PortfolioTranslation model
     */
    readonly fields: PortfolioTranslationFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioTranslationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      | $Result.GetResult<
          Prisma.$PortfolioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the PortfolioTranslation model
   */
  interface PortfolioTranslationFieldRefs {
    readonly id: FieldRef<'PortfolioTranslation', 'Int'>
    readonly portfolioId: FieldRef<'PortfolioTranslation', 'Int'>
    readonly lang: FieldRef<'PortfolioTranslation', 'String'>
    readonly title: FieldRef<'PortfolioTranslation', 'String'>
    readonly content: FieldRef<'PortfolioTranslation', 'String'>
    readonly excerpt: FieldRef<'PortfolioTranslation', 'String'>
  }

  // Custom InputTypes
  /**
   * PortfolioTranslation findUnique
   */
  export type PortfolioTranslationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTranslation to fetch.
     */
    where: PortfolioTranslationWhereUniqueInput
  }

  /**
   * PortfolioTranslation findUniqueOrThrow
   */
  export type PortfolioTranslationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTranslation to fetch.
     */
    where: PortfolioTranslationWhereUniqueInput
  }

  /**
   * PortfolioTranslation findFirst
   */
  export type PortfolioTranslationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTranslation to fetch.
     */
    where?: PortfolioTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioTranslations to fetch.
     */
    orderBy?:
      | PortfolioTranslationOrderByWithRelationInput
      | PortfolioTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PortfolioTranslations.
     */
    cursor?: PortfolioTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PortfolioTranslations.
     */
    distinct?: PortfolioTranslationScalarFieldEnum | PortfolioTranslationScalarFieldEnum[]
  }

  /**
   * PortfolioTranslation findFirstOrThrow
   */
  export type PortfolioTranslationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTranslation to fetch.
     */
    where?: PortfolioTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioTranslations to fetch.
     */
    orderBy?:
      | PortfolioTranslationOrderByWithRelationInput
      | PortfolioTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PortfolioTranslations.
     */
    cursor?: PortfolioTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PortfolioTranslations.
     */
    distinct?: PortfolioTranslationScalarFieldEnum | PortfolioTranslationScalarFieldEnum[]
  }

  /**
   * PortfolioTranslation findMany
   */
  export type PortfolioTranslationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTranslations to fetch.
     */
    where?: PortfolioTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioTranslations to fetch.
     */
    orderBy?:
      | PortfolioTranslationOrderByWithRelationInput
      | PortfolioTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PortfolioTranslations.
     */
    cursor?: PortfolioTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioTranslations.
     */
    skip?: number
    distinct?: PortfolioTranslationScalarFieldEnum | PortfolioTranslationScalarFieldEnum[]
  }

  /**
   * PortfolioTranslation create
   */
  export type PortfolioTranslationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioTranslation.
     */
    data: XOR<PortfolioTranslationCreateInput, PortfolioTranslationUncheckedCreateInput>
  }

  /**
   * PortfolioTranslation createMany
   */
  export type PortfolioTranslationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many PortfolioTranslations.
     */
    data: PortfolioTranslationCreateManyInput | PortfolioTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioTranslation createManyAndReturn
   */
  export type PortfolioTranslationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioTranslations.
     */
    data: PortfolioTranslationCreateManyInput | PortfolioTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioTranslation update
   */
  export type PortfolioTranslationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioTranslation.
     */
    data: XOR<PortfolioTranslationUpdateInput, PortfolioTranslationUncheckedUpdateInput>
    /**
     * Choose, which PortfolioTranslation to update.
     */
    where: PortfolioTranslationWhereUniqueInput
  }

  /**
   * PortfolioTranslation updateMany
   */
  export type PortfolioTranslationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update PortfolioTranslations.
     */
    data: XOR<
      PortfolioTranslationUpdateManyMutationInput,
      PortfolioTranslationUncheckedUpdateManyInput
    >
    /**
     * Filter which PortfolioTranslations to update
     */
    where?: PortfolioTranslationWhereInput
    /**
     * Limit how many PortfolioTranslations to update.
     */
    limit?: number
  }

  /**
   * PortfolioTranslation updateManyAndReturn
   */
  export type PortfolioTranslationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioTranslations.
     */
    data: XOR<
      PortfolioTranslationUpdateManyMutationInput,
      PortfolioTranslationUncheckedUpdateManyInput
    >
    /**
     * Filter which PortfolioTranslations to update
     */
    where?: PortfolioTranslationWhereInput
    /**
     * Limit how many PortfolioTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioTranslation upsert
   */
  export type PortfolioTranslationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioTranslation to update in case it exists.
     */
    where: PortfolioTranslationWhereUniqueInput
    /**
     * In case the PortfolioTranslation found by the `where` argument doesn't exist, create a new PortfolioTranslation with this data.
     */
    create: XOR<PortfolioTranslationCreateInput, PortfolioTranslationUncheckedCreateInput>
    /**
     * In case the PortfolioTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioTranslationUpdateInput, PortfolioTranslationUncheckedUpdateInput>
  }

  /**
   * PortfolioTranslation delete
   */
  export type PortfolioTranslationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
    /**
     * Filter which PortfolioTranslation to delete.
     */
    where: PortfolioTranslationWhereUniqueInput
  }

  /**
   * PortfolioTranslation deleteMany
   */
  export type PortfolioTranslationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PortfolioTranslations to delete
     */
    where?: PortfolioTranslationWhereInput
    /**
     * Limit how many PortfolioTranslations to delete.
     */
    limit?: number
  }

  /**
   * PortfolioTranslation without action
   */
  export type PortfolioTranslationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioTranslation
     */
    select?: PortfolioTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTranslation
     */
    omit?: PortfolioTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTranslationInclude<ExtArgs> | null
  }

  /**
   * Model PortfolioMeta
   */

  export type AggregatePortfolioMeta = {
    _count: PortfolioMetaCountAggregateOutputType | null
    _avg: PortfolioMetaAvgAggregateOutputType | null
    _sum: PortfolioMetaSumAggregateOutputType | null
    _min: PortfolioMetaMinAggregateOutputType | null
    _max: PortfolioMetaMaxAggregateOutputType | null
  }

  export type PortfolioMetaAvgAggregateOutputType = {
    id: number | null
    portfolioId: number | null
  }

  export type PortfolioMetaSumAggregateOutputType = {
    id: number | null
    portfolioId: number | null
  }

  export type PortfolioMetaMinAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    key: string | null
  }

  export type PortfolioMetaMaxAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    key: string | null
  }

  export type PortfolioMetaCountAggregateOutputType = {
    id: number
    portfolioId: number
    key: number
    value: number
    _all: number
  }

  export type PortfolioMetaAvgAggregateInputType = {
    id?: true
    portfolioId?: true
  }

  export type PortfolioMetaSumAggregateInputType = {
    id?: true
    portfolioId?: true
  }

  export type PortfolioMetaMinAggregateInputType = {
    id?: true
    portfolioId?: true
    key?: true
  }

  export type PortfolioMetaMaxAggregateInputType = {
    id?: true
    portfolioId?: true
    key?: true
  }

  export type PortfolioMetaCountAggregateInputType = {
    id?: true
    portfolioId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type PortfolioMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PortfolioMeta to aggregate.
     */
    where?: PortfolioMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioMetas to fetch.
     */
    orderBy?: PortfolioMetaOrderByWithRelationInput | PortfolioMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PortfolioMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PortfolioMetas
     */
    _count?: true | PortfolioMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: PortfolioMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: PortfolioMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: PortfolioMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: PortfolioMetaMaxAggregateInputType
  }

  export type GetPortfolioMetaAggregateType<T extends PortfolioMetaAggregateArgs> = {
    [P in keyof T & keyof AggregatePortfolioMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioMeta[P]>
      : GetScalarType<T[P], AggregatePortfolioMeta[P]>
  }

  export type PortfolioMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: PortfolioMetaWhereInput
    orderBy?: PortfolioMetaOrderByWithAggregationInput | PortfolioMetaOrderByWithAggregationInput[]
    by: PortfolioMetaScalarFieldEnum[] | PortfolioMetaScalarFieldEnum
    having?: PortfolioMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioMetaCountAggregateInputType | true
    _avg?: PortfolioMetaAvgAggregateInputType
    _sum?: PortfolioMetaSumAggregateInputType
    _min?: PortfolioMetaMinAggregateInputType
    _max?: PortfolioMetaMaxAggregateInputType
  }

  export type PortfolioMetaGroupByOutputType = {
    id: number
    portfolioId: number
    key: string
    value: JsonValue
    _count: PortfolioMetaCountAggregateOutputType | null
    _avg: PortfolioMetaAvgAggregateOutputType | null
    _sum: PortfolioMetaSumAggregateOutputType | null
    _min: PortfolioMetaMinAggregateOutputType | null
    _max: PortfolioMetaMaxAggregateOutputType | null
  }

  type GetPortfolioMetaGroupByPayload<T extends PortfolioMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PortfolioMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PortfolioMetaGroupByOutputType[P]>
          : GetScalarType<T[P], PortfolioMetaGroupByOutputType[P]>
      }
    >
  >

  export type PortfolioMetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      key?: boolean
      value?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioMeta']
  >

  export type PortfolioMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      key?: boolean
      value?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioMeta']
  >

  export type PortfolioMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      portfolioId?: boolean
      key?: boolean
      value?: boolean
      portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['portfolioMeta']
  >

  export type PortfolioMetaSelectScalar = {
    id?: boolean
    portfolioId?: boolean
    key?: boolean
    value?: boolean
  }

  export type PortfolioMetaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'portfolioId' | 'key' | 'value',
    ExtArgs['result']['portfolioMeta']
  >
  export type PortfolioMetaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }

  export type $PortfolioMetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'PortfolioMeta'
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        portfolioId: number
        key: string
        value: Prisma.JsonValue
      },
      ExtArgs['result']['portfolioMeta']
    >
    composites: {}
  }

  type PortfolioMetaGetPayload<S extends boolean | null | undefined | PortfolioMetaDefaultArgs> =
    $Result.GetResult<Prisma.$PortfolioMetaPayload, S>

  type PortfolioMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioMetaCountAggregateInputType | true
    }

  export interface PortfolioMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PortfolioMeta']
      meta: { name: 'PortfolioMeta' }
    }
    /**
     * Find zero or one PortfolioMeta that matches the filter.
     * @param {PortfolioMetaFindUniqueArgs} args - Arguments to find a PortfolioMeta
     * @example
     * // Get one PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioMetaFindUniqueArgs>(
      args: SelectSubset<T, PortfolioMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one PortfolioMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioMetaFindUniqueOrThrowArgs} args - Arguments to find a PortfolioMeta
     * @example
     * // Get one PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PortfolioMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PortfolioMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaFindFirstArgs} args - Arguments to find a PortfolioMeta
     * @example
     * // Get one PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioMetaFindFirstArgs>(
      args?: SelectSubset<T, PortfolioMetaFindFirstArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first PortfolioMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaFindFirstOrThrowArgs} args - Arguments to find a PortfolioMeta
     * @example
     * // Get one PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PortfolioMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more PortfolioMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioMetas
     * const portfolioMetas = await prisma.portfolioMeta.findMany()
     *
     * // Get first 10 PortfolioMetas
     * const portfolioMetas = await prisma.portfolioMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const portfolioMetaWithIdOnly = await prisma.portfolioMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PortfolioMetaFindManyArgs>(
      args?: SelectSubset<T, PortfolioMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a PortfolioMeta.
     * @param {PortfolioMetaCreateArgs} args - Arguments to create a PortfolioMeta.
     * @example
     * // Create one PortfolioMeta
     * const PortfolioMeta = await prisma.portfolioMeta.create({
     *   data: {
     *     // ... data to create a PortfolioMeta
     *   }
     * })
     *
     */
    create<T extends PortfolioMetaCreateArgs>(
      args: SelectSubset<T, PortfolioMetaCreateArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many PortfolioMetas.
     * @param {PortfolioMetaCreateManyArgs} args - Arguments to create many PortfolioMetas.
     * @example
     * // Create many PortfolioMetas
     * const portfolioMeta = await prisma.portfolioMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PortfolioMetaCreateManyArgs>(
      args?: SelectSubset<T, PortfolioMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioMetas and returns the data saved in the database.
     * @param {PortfolioMetaCreateManyAndReturnArgs} args - Arguments to create many PortfolioMetas.
     * @example
     * // Create many PortfolioMetas
     * const portfolioMeta = await prisma.portfolioMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PortfolioMetas and only return the `id`
     * const portfolioMetaWithIdOnly = await prisma.portfolioMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PortfolioMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PortfolioMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a PortfolioMeta.
     * @param {PortfolioMetaDeleteArgs} args - Arguments to delete one PortfolioMeta.
     * @example
     * // Delete one PortfolioMeta
     * const PortfolioMeta = await prisma.portfolioMeta.delete({
     *   where: {
     *     // ... filter to delete one PortfolioMeta
     *   }
     * })
     *
     */
    delete<T extends PortfolioMetaDeleteArgs>(
      args: SelectSubset<T, PortfolioMetaDeleteArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one PortfolioMeta.
     * @param {PortfolioMetaUpdateArgs} args - Arguments to update one PortfolioMeta.
     * @example
     * // Update one PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PortfolioMetaUpdateArgs>(
      args: SelectSubset<T, PortfolioMetaUpdateArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more PortfolioMetas.
     * @param {PortfolioMetaDeleteManyArgs} args - Arguments to filter PortfolioMetas to delete.
     * @example
     * // Delete a few PortfolioMetas
     * const { count } = await prisma.portfolioMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PortfolioMetaDeleteManyArgs>(
      args?: SelectSubset<T, PortfolioMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioMetas
     * const portfolioMeta = await prisma.portfolioMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PortfolioMetaUpdateManyArgs>(
      args: SelectSubset<T, PortfolioMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioMetas and returns the data updated in the database.
     * @param {PortfolioMetaUpdateManyAndReturnArgs} args - Arguments to update many PortfolioMetas.
     * @example
     * // Update many PortfolioMetas
     * const portfolioMeta = await prisma.portfolioMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PortfolioMetas and only return the `id`
     * const portfolioMetaWithIdOnly = await prisma.portfolioMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PortfolioMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PortfolioMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PortfolioMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one PortfolioMeta.
     * @param {PortfolioMetaUpsertArgs} args - Arguments to update or create a PortfolioMeta.
     * @example
     * // Update or create a PortfolioMeta
     * const portfolioMeta = await prisma.portfolioMeta.upsert({
     *   create: {
     *     // ... data to create a PortfolioMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioMeta we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioMetaUpsertArgs>(
      args: SelectSubset<T, PortfolioMetaUpsertArgs<ExtArgs>>
    ): Prisma__PortfolioMetaClient<
      $Result.GetResult<Prisma.$PortfolioMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of PortfolioMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaCountArgs} args - Arguments to filter PortfolioMetas to count.
     * @example
     * // Count the number of PortfolioMetas
     * const count = await prisma.portfolioMeta.count({
     *   where: {
     *     // ... the filter for the PortfolioMetas we want to count
     *   }
     * })
     */
    count<T extends PortfolioMetaCountArgs>(
      args?: Subset<T, PortfolioMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends PortfolioMetaAggregateArgs>(
      args: Subset<T, PortfolioMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetPortfolioMetaAggregateType<T>>

    /**
     * Group by PortfolioMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends PortfolioMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioMetaGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, PortfolioMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPortfolioMetaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the PortfolioMeta model
     */
    readonly fields: PortfolioMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      | $Result.GetResult<
          Prisma.$PortfolioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the PortfolioMeta model
   */
  interface PortfolioMetaFieldRefs {
    readonly id: FieldRef<'PortfolioMeta', 'Int'>
    readonly portfolioId: FieldRef<'PortfolioMeta', 'Int'>
    readonly key: FieldRef<'PortfolioMeta', 'String'>
    readonly value: FieldRef<'PortfolioMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * PortfolioMeta findUnique
   */
  export type PortfolioMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioMeta to fetch.
     */
    where: PortfolioMetaWhereUniqueInput
  }

  /**
   * PortfolioMeta findUniqueOrThrow
   */
  export type PortfolioMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioMeta to fetch.
     */
    where: PortfolioMetaWhereUniqueInput
  }

  /**
   * PortfolioMeta findFirst
   */
  export type PortfolioMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioMeta to fetch.
     */
    where?: PortfolioMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioMetas to fetch.
     */
    orderBy?: PortfolioMetaOrderByWithRelationInput | PortfolioMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PortfolioMetas.
     */
    cursor?: PortfolioMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PortfolioMetas.
     */
    distinct?: PortfolioMetaScalarFieldEnum | PortfolioMetaScalarFieldEnum[]
  }

  /**
   * PortfolioMeta findFirstOrThrow
   */
  export type PortfolioMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioMeta to fetch.
     */
    where?: PortfolioMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioMetas to fetch.
     */
    orderBy?: PortfolioMetaOrderByWithRelationInput | PortfolioMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PortfolioMetas.
     */
    cursor?: PortfolioMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PortfolioMetas.
     */
    distinct?: PortfolioMetaScalarFieldEnum | PortfolioMetaScalarFieldEnum[]
  }

  /**
   * PortfolioMeta findMany
   */
  export type PortfolioMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioMetas to fetch.
     */
    where?: PortfolioMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PortfolioMetas to fetch.
     */
    orderBy?: PortfolioMetaOrderByWithRelationInput | PortfolioMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PortfolioMetas.
     */
    cursor?: PortfolioMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PortfolioMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PortfolioMetas.
     */
    skip?: number
    distinct?: PortfolioMetaScalarFieldEnum | PortfolioMetaScalarFieldEnum[]
  }

  /**
   * PortfolioMeta create
   */
  export type PortfolioMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioMeta.
     */
    data: XOR<PortfolioMetaCreateInput, PortfolioMetaUncheckedCreateInput>
  }

  /**
   * PortfolioMeta createMany
   */
  export type PortfolioMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many PortfolioMetas.
     */
    data: PortfolioMetaCreateManyInput | PortfolioMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioMeta createManyAndReturn
   */
  export type PortfolioMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioMetas.
     */
    data: PortfolioMetaCreateManyInput | PortfolioMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioMeta update
   */
  export type PortfolioMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioMeta.
     */
    data: XOR<PortfolioMetaUpdateInput, PortfolioMetaUncheckedUpdateInput>
    /**
     * Choose, which PortfolioMeta to update.
     */
    where: PortfolioMetaWhereUniqueInput
  }

  /**
   * PortfolioMeta updateMany
   */
  export type PortfolioMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update PortfolioMetas.
     */
    data: XOR<PortfolioMetaUpdateManyMutationInput, PortfolioMetaUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioMetas to update
     */
    where?: PortfolioMetaWhereInput
    /**
     * Limit how many PortfolioMetas to update.
     */
    limit?: number
  }

  /**
   * PortfolioMeta updateManyAndReturn
   */
  export type PortfolioMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioMetas.
     */
    data: XOR<PortfolioMetaUpdateManyMutationInput, PortfolioMetaUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioMetas to update
     */
    where?: PortfolioMetaWhereInput
    /**
     * Limit how many PortfolioMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioMeta upsert
   */
  export type PortfolioMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioMeta to update in case it exists.
     */
    where: PortfolioMetaWhereUniqueInput
    /**
     * In case the PortfolioMeta found by the `where` argument doesn't exist, create a new PortfolioMeta with this data.
     */
    create: XOR<PortfolioMetaCreateInput, PortfolioMetaUncheckedCreateInput>
    /**
     * In case the PortfolioMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioMetaUpdateInput, PortfolioMetaUncheckedUpdateInput>
  }

  /**
   * PortfolioMeta delete
   */
  export type PortfolioMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
    /**
     * Filter which PortfolioMeta to delete.
     */
    where: PortfolioMetaWhereUniqueInput
  }

  /**
   * PortfolioMeta deleteMany
   */
  export type PortfolioMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which PortfolioMetas to delete
     */
    where?: PortfolioMetaWhereInput
    /**
     * Limit how many PortfolioMetas to delete.
     */
    limit?: number
  }

  /**
   * PortfolioMeta without action
   */
  export type PortfolioMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the PortfolioMeta
     */
    select?: PortfolioMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioMeta
     */
    omit?: PortfolioMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioMetaInclude<ExtArgs> | null
  }

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
    vendorId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
    vendorId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    slug: string | null
    price: number | null
    currency: string | null
    stock: number | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    price: number | null
    currency: string | null
    stock: number | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    slug: number
    price: number
    currency: number
    stock: number
    vendorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    vendorId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    vendorId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    slug?: true
    price?: true
    currency?: true
    stock?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    slug?: true
    price?: true
    currency?: true
    stock?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    slug?: true
    price?: true
    currency?: true
    stock?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Products
     */
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
    [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }

  export type ProductGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    slug: string
    price: number
    currency: string
    stock: number
    vendorId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ProductGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
          : GetScalarType<T[P], ProductGroupByOutputType[P]>
      }
    >
  >

  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        price?: boolean
        currency?: boolean
        stock?: boolean
        vendorId?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        vendor?: boolean | UserDefaultArgs<ExtArgs>
        translations?: boolean | Product$translationsArgs<ExtArgs>
        metas?: boolean | Product$metasArgs<ExtArgs>
        comments?: boolean | Product$commentsArgs<ExtArgs>
        terms?: boolean | Product$termsArgs<ExtArgs>
        _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['product']
    >

  export type ProductSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      price?: boolean
      currency?: boolean
      stock?: boolean
      vendorId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      vendor?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['product']
  >

  export type ProductSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      price?: boolean
      currency?: boolean
      stock?: boolean
      vendorId?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      vendor?: boolean | UserDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['product']
  >

  export type ProductSelectScalar = {
    id?: boolean
    slug?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    vendorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'slug' | 'price' | 'currency' | 'stock' | 'vendorId' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['product']
    >
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    translations?: boolean | Product$translationsArgs<ExtArgs>
    metas?: boolean | Product$metasArgs<ExtArgs>
    comments?: boolean | Product$commentsArgs<ExtArgs>
    terms?: boolean | Product$termsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Product'
      objects: {
        vendor: Prisma.$UserPayload<ExtArgs>
        translations: Prisma.$ProductTranslationPayload<ExtArgs>[]
        metas: Prisma.$ProductMetaPayload<ExtArgs>[]
        comments: Prisma.$CommentPayload<ExtArgs>[]
        terms: Prisma.$TermRelationshipPayload<ExtArgs>[]
      }
      scalars: $Extensions.GetPayloadResult<
        {
          id: number
          slug: string
          price: number
          currency: string
          stock: number
          vendorId: number
          createdAt: Date
          updatedAt: Date
        },
        ExtArgs['result']['product']
      >
      composites: {}
    }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> =
    $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProductFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ProductCountAggregateInputType | true
  }

  export interface ProductDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product']; meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     *
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     *
     */
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     *
     */
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
     */
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ProductAggregateArgs>(
      args: Subset<T, ProductAggregateArgs>
    ): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Product model
     */
    readonly fields: ProductFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    translations<T extends Product$translationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$translationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ProductTranslationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    metas<T extends Product$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    comments<T extends Product$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    terms<T extends Product$termsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$termsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TermRelationshipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<'Product', 'Int'>
    readonly slug: FieldRef<'Product', 'String'>
    readonly price: FieldRef<'Product', 'Float'>
    readonly currency: FieldRef<'Product', 'String'>
    readonly stock: FieldRef<'Product', 'Int'>
    readonly vendorId: FieldRef<'Product', 'Int'>
    readonly createdAt: FieldRef<'Product', 'DateTime'>
    readonly updatedAt: FieldRef<'Product', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.translations
   */
  export type Product$translationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?:
      | ProductTranslationOrderByWithRelationInput
      | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * Product.metas
   */
  export type Product$metasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    where?: ProductMetaWhereInput
    orderBy?: ProductMetaOrderByWithRelationInput | ProductMetaOrderByWithRelationInput[]
    cursor?: ProductMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductMetaScalarFieldEnum | ProductMetaScalarFieldEnum[]
  }

  /**
   * Product.comments
   */
  export type Product$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Product.terms
   */
  export type Product$termsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    where?: TermRelationshipWhereInput
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    cursor?: TermRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }

  /**
   * Model ProductTranslation
   */

  export type AggregateProductTranslation = {
    _count: ProductTranslationCountAggregateOutputType | null
    _avg: ProductTranslationAvgAggregateOutputType | null
    _sum: ProductTranslationSumAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  export type ProductTranslationAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductTranslationSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductTranslationMinAggregateOutputType = {
    id: number | null
    productId: number | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type ProductTranslationMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type ProductTranslationCountAggregateOutputType = {
    id: number
    productId: number
    lang: number
    title: number
    description: number
    _all: number
  }

  export type ProductTranslationAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductTranslationSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductTranslationMinAggregateInputType = {
    id?: true
    productId?: true
    lang?: true
    title?: true
    description?: true
  }

  export type ProductTranslationMaxAggregateInputType = {
    id?: true
    productId?: true
    lang?: true
    title?: true
    description?: true
  }

  export type ProductTranslationCountAggregateInputType = {
    id?: true
    productId?: true
    lang?: true
    title?: true
    description?: true
    _all?: true
  }

  export type ProductTranslationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ProductTranslation to aggregate.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?:
      | ProductTranslationOrderByWithRelationInput
      | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductTranslations
     */
    _count?: true | ProductTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ProductTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ProductTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ProductTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type GetProductTranslationAggregateType<T extends ProductTranslationAggregateArgs> = {
    [P in keyof T & keyof AggregateProductTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTranslation[P]>
      : GetScalarType<T[P], AggregateProductTranslation[P]>
  }

  export type ProductTranslationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductTranslationWhereInput
    orderBy?:
      | ProductTranslationOrderByWithAggregationInput
      | ProductTranslationOrderByWithAggregationInput[]
    by: ProductTranslationScalarFieldEnum[] | ProductTranslationScalarFieldEnum
    having?: ProductTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTranslationCountAggregateInputType | true
    _avg?: ProductTranslationAvgAggregateInputType
    _sum?: ProductTranslationSumAggregateInputType
    _min?: ProductTranslationMinAggregateInputType
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type ProductTranslationGroupByOutputType = {
    id: number
    productId: number
    lang: string
    title: string
    description: string
    _count: ProductTranslationCountAggregateOutputType | null
    _avg: ProductTranslationAvgAggregateOutputType | null
    _sum: ProductTranslationSumAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  type GetProductTranslationGroupByPayload<T extends ProductTranslationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProductTranslationGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ProductTranslationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
        }
      >
    >

  export type ProductTranslationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      lang?: boolean
      title?: boolean
      description?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productTranslation']
  >

  export type ProductTranslationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      lang?: boolean
      title?: boolean
      description?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productTranslation']
  >

  export type ProductTranslationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      lang?: boolean
      title?: boolean
      description?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productTranslation']
  >

  export type ProductTranslationSelectScalar = {
    id?: boolean
    productId?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }

  export type ProductTranslationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'productId' | 'lang' | 'title' | 'description',
    ExtArgs['result']['productTranslation']
  >
  export type ProductTranslationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductTranslationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductTranslationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductTranslationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ProductTranslation'
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        productId: number
        lang: string
        title: string
        description: string
      },
      ExtArgs['result']['productTranslation']
    >
    composites: {}
  }

  type ProductTranslationGetPayload<
    S extends boolean | null | undefined | ProductTranslationDefaultArgs
  > = $Result.GetResult<Prisma.$ProductTranslationPayload, S>

  type ProductTranslationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ProductTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProductTranslationCountAggregateInputType | true
  }

  export interface ProductTranslationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ProductTranslation']
      meta: { name: 'ProductTranslation' }
    }
    /**
     * Find zero or one ProductTranslation that matches the filter.
     * @param {ProductTranslationFindUniqueArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTranslationFindUniqueArgs>(
      args: SelectSubset<T, ProductTranslationFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one ProductTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTranslationFindUniqueOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTranslationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductTranslationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ProductTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTranslationFindFirstArgs>(
      args?: SelectSubset<T, ProductTranslationFindFirstArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ProductTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTranslationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductTranslationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more ProductTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany()
     *
     * // Get first 10 ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductTranslationFindManyArgs>(
      args?: SelectSubset<T, ProductTranslationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a ProductTranslation.
     * @param {ProductTranslationCreateArgs} args - Arguments to create a ProductTranslation.
     * @example
     * // Create one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.create({
     *   data: {
     *     // ... data to create a ProductTranslation
     *   }
     * })
     *
     */
    create<T extends ProductTranslationCreateArgs>(
      args: SelectSubset<T, ProductTranslationCreateArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many ProductTranslations.
     * @param {ProductTranslationCreateManyArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductTranslationCreateManyArgs>(
      args?: SelectSubset<T, ProductTranslationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTranslations and returns the data saved in the database.
     * @param {ProductTranslationCreateManyAndReturnArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ProductTranslations and only return the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductTranslationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductTranslationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a ProductTranslation.
     * @param {ProductTranslationDeleteArgs} args - Arguments to delete one ProductTranslation.
     * @example
     * // Delete one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.delete({
     *   where: {
     *     // ... filter to delete one ProductTranslation
     *   }
     * })
     *
     */
    delete<T extends ProductTranslationDeleteArgs>(
      args: SelectSubset<T, ProductTranslationDeleteArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one ProductTranslation.
     * @param {ProductTranslationUpdateArgs} args - Arguments to update one ProductTranslation.
     * @example
     * // Update one ProductTranslation
     * const productTranslation = await prisma.productTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductTranslationUpdateArgs>(
      args: SelectSubset<T, ProductTranslationUpdateArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more ProductTranslations.
     * @param {ProductTranslationDeleteManyArgs} args - Arguments to filter ProductTranslations to delete.
     * @example
     * // Delete a few ProductTranslations
     * const { count } = await prisma.productTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductTranslationDeleteManyArgs>(
      args?: SelectSubset<T, ProductTranslationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTranslations
     * const productTranslation = await prisma.productTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductTranslationUpdateManyArgs>(
      args: SelectSubset<T, ProductTranslationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTranslations and returns the data updated in the database.
     * @param {ProductTranslationUpdateManyAndReturnArgs} args - Arguments to update many ProductTranslations.
     * @example
     * // Update many ProductTranslations
     * const productTranslation = await prisma.productTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ProductTranslations and only return the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductTranslationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductTranslationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductTranslationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one ProductTranslation.
     * @param {ProductTranslationUpsertArgs} args - Arguments to update or create a ProductTranslation.
     * @example
     * // Update or create a ProductTranslation
     * const productTranslation = await prisma.productTranslation.upsert({
     *   create: {
     *     // ... data to create a ProductTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ProductTranslationUpsertArgs>(
      args: SelectSubset<T, ProductTranslationUpsertArgs<ExtArgs>>
    ): Prisma__ProductTranslationClient<
      $Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationCountArgs} args - Arguments to filter ProductTranslations to count.
     * @example
     * // Count the number of ProductTranslations
     * const count = await prisma.productTranslation.count({
     *   where: {
     *     // ... the filter for the ProductTranslations we want to count
     *   }
     * })
     */
    count<T extends ProductTranslationCountArgs>(
      args?: Subset<T, ProductTranslationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ProductTranslationAggregateArgs>(
      args: Subset<T, ProductTranslationAggregateArgs>
    ): Prisma.PrismaPromise<GetProductTranslationAggregateType<T>>

    /**
     * Group by ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ProductTranslationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ProductTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ProductTranslationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetProductTranslationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the ProductTranslation model
     */
    readonly fields: ProductTranslationFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTranslationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      | $Result.GetResult<
          Prisma.$ProductPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the ProductTranslation model
   */
  interface ProductTranslationFieldRefs {
    readonly id: FieldRef<'ProductTranslation', 'Int'>
    readonly productId: FieldRef<'ProductTranslation', 'Int'>
    readonly lang: FieldRef<'ProductTranslation', 'String'>
    readonly title: FieldRef<'ProductTranslation', 'String'>
    readonly description: FieldRef<'ProductTranslation', 'String'>
  }

  // Custom InputTypes
  /**
   * ProductTranslation findUnique
   */
  export type ProductTranslationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findUniqueOrThrow
   */
  export type ProductTranslationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findFirst
   */
  export type ProductTranslationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?:
      | ProductTranslationOrderByWithRelationInput
      | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findFirstOrThrow
   */
  export type ProductTranslationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?:
      | ProductTranslationOrderByWithRelationInput
      | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findMany
   */
  export type ProductTranslationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslations to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?:
      | ProductTranslationOrderByWithRelationInput
      | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation create
   */
  export type ProductTranslationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTranslation.
     */
    data: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
  }

  /**
   * ProductTranslation createMany
   */
  export type ProductTranslationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTranslation createManyAndReturn
   */
  export type ProductTranslationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTranslation update
   */
  export type ProductTranslationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTranslation.
     */
    data: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
    /**
     * Choose, which ProductTranslation to update.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation updateMany
   */
  export type ProductTranslationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ProductTranslations.
     */
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductTranslations to update
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to update.
     */
    limit?: number
  }

  /**
   * ProductTranslation updateManyAndReturn
   */
  export type ProductTranslationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ProductTranslations.
     */
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductTranslations to update
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTranslation upsert
   */
  export type ProductTranslationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTranslation to update in case it exists.
     */
    where: ProductTranslationWhereUniqueInput
    /**
     * In case the ProductTranslation found by the `where` argument doesn't exist, create a new ProductTranslation with this data.
     */
    create: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
    /**
     * In case the ProductTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
  }

  /**
   * ProductTranslation delete
   */
  export type ProductTranslationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter which ProductTranslation to delete.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation deleteMany
   */
  export type ProductTranslationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ProductTranslations to delete
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to delete.
     */
    limit?: number
  }

  /**
   * ProductTranslation without action
   */
  export type ProductTranslationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
  }

  /**
   * Model ProductMeta
   */

  export type AggregateProductMeta = {
    _count: ProductMetaCountAggregateOutputType | null
    _avg: ProductMetaAvgAggregateOutputType | null
    _sum: ProductMetaSumAggregateOutputType | null
    _min: ProductMetaMinAggregateOutputType | null
    _max: ProductMetaMaxAggregateOutputType | null
  }

  export type ProductMetaAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductMetaSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductMetaMinAggregateOutputType = {
    id: number | null
    productId: number | null
    key: string | null
  }

  export type ProductMetaMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    key: string | null
  }

  export type ProductMetaCountAggregateOutputType = {
    id: number
    productId: number
    key: number
    value: number
    _all: number
  }

  export type ProductMetaAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductMetaSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductMetaMinAggregateInputType = {
    id?: true
    productId?: true
    key?: true
  }

  export type ProductMetaMaxAggregateInputType = {
    id?: true
    productId?: true
    key?: true
  }

  export type ProductMetaCountAggregateInputType = {
    id?: true
    productId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type ProductMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ProductMeta to aggregate.
     */
    where?: ProductMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductMetas to fetch.
     */
    orderBy?: ProductMetaOrderByWithRelationInput | ProductMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductMetas
     */
    _count?: true | ProductMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: ProductMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: ProductMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: ProductMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: ProductMetaMaxAggregateInputType
  }

  export type GetProductMetaAggregateType<T extends ProductMetaAggregateArgs> = {
    [P in keyof T & keyof AggregateProductMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductMeta[P]>
      : GetScalarType<T[P], AggregateProductMeta[P]>
  }

  export type ProductMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ProductMetaWhereInput
    orderBy?: ProductMetaOrderByWithAggregationInput | ProductMetaOrderByWithAggregationInput[]
    by: ProductMetaScalarFieldEnum[] | ProductMetaScalarFieldEnum
    having?: ProductMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductMetaCountAggregateInputType | true
    _avg?: ProductMetaAvgAggregateInputType
    _sum?: ProductMetaSumAggregateInputType
    _min?: ProductMetaMinAggregateInputType
    _max?: ProductMetaMaxAggregateInputType
  }

  export type ProductMetaGroupByOutputType = {
    id: number
    productId: number
    key: string
    value: JsonValue
    _count: ProductMetaCountAggregateOutputType | null
    _avg: ProductMetaAvgAggregateOutputType | null
    _sum: ProductMetaSumAggregateOutputType | null
    _min: ProductMetaMinAggregateOutputType | null
    _max: ProductMetaMaxAggregateOutputType | null
  }

  type GetProductMetaGroupByPayload<T extends ProductMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ProductMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductMetaGroupByOutputType[P]>
          : GetScalarType<T[P], ProductMetaGroupByOutputType[P]>
      }
    >
  >

  export type ProductMetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      key?: boolean
      value?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productMeta']
  >

  export type ProductMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      key?: boolean
      value?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productMeta']
  >

  export type ProductMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      productId?: boolean
      key?: boolean
      value?: boolean
      product?: boolean | ProductDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['productMeta']
  >

  export type ProductMetaSelectScalar = {
    id?: boolean
    productId?: boolean
    key?: boolean
    value?: boolean
  }

  export type ProductMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'productId' | 'key' | 'value', ExtArgs['result']['productMeta']>
  export type ProductMetaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductMetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'ProductMeta'
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        productId: number
        key: string
        value: Prisma.JsonValue
      },
      ExtArgs['result']['productMeta']
    >
    composites: {}
  }

  type ProductMetaGetPayload<S extends boolean | null | undefined | ProductMetaDefaultArgs> =
    $Result.GetResult<Prisma.$ProductMetaPayload, S>

  type ProductMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductMetaCountAggregateInputType | true
    }

  export interface ProductMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ProductMeta']
      meta: { name: 'ProductMeta' }
    }
    /**
     * Find zero or one ProductMeta that matches the filter.
     * @param {ProductMetaFindUniqueArgs} args - Arguments to find a ProductMeta
     * @example
     * // Get one ProductMeta
     * const productMeta = await prisma.productMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductMetaFindUniqueArgs>(
      args: SelectSubset<T, ProductMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one ProductMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductMetaFindUniqueOrThrowArgs} args - Arguments to find a ProductMeta
     * @example
     * // Get one ProductMeta
     * const productMeta = await prisma.productMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ProductMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaFindFirstArgs} args - Arguments to find a ProductMeta
     * @example
     * // Get one ProductMeta
     * const productMeta = await prisma.productMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductMetaFindFirstArgs>(
      args?: SelectSubset<T, ProductMetaFindFirstArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first ProductMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaFindFirstOrThrowArgs} args - Arguments to find a ProductMeta
     * @example
     * // Get one ProductMeta
     * const productMeta = await prisma.productMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more ProductMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductMetas
     * const productMetas = await prisma.productMeta.findMany()
     *
     * // Get first 10 ProductMetas
     * const productMetas = await prisma.productMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productMetaWithIdOnly = await prisma.productMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductMetaFindManyArgs>(
      args?: SelectSubset<T, ProductMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a ProductMeta.
     * @param {ProductMetaCreateArgs} args - Arguments to create a ProductMeta.
     * @example
     * // Create one ProductMeta
     * const ProductMeta = await prisma.productMeta.create({
     *   data: {
     *     // ... data to create a ProductMeta
     *   }
     * })
     *
     */
    create<T extends ProductMetaCreateArgs>(
      args: SelectSubset<T, ProductMetaCreateArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many ProductMetas.
     * @param {ProductMetaCreateManyArgs} args - Arguments to create many ProductMetas.
     * @example
     * // Create many ProductMetas
     * const productMeta = await prisma.productMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductMetaCreateManyArgs>(
      args?: SelectSubset<T, ProductMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductMetas and returns the data saved in the database.
     * @param {ProductMetaCreateManyAndReturnArgs} args - Arguments to create many ProductMetas.
     * @example
     * // Create many ProductMetas
     * const productMeta = await prisma.productMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ProductMetas and only return the `id`
     * const productMetaWithIdOnly = await prisma.productMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProductMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProductMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a ProductMeta.
     * @param {ProductMetaDeleteArgs} args - Arguments to delete one ProductMeta.
     * @example
     * // Delete one ProductMeta
     * const ProductMeta = await prisma.productMeta.delete({
     *   where: {
     *     // ... filter to delete one ProductMeta
     *   }
     * })
     *
     */
    delete<T extends ProductMetaDeleteArgs>(
      args: SelectSubset<T, ProductMetaDeleteArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one ProductMeta.
     * @param {ProductMetaUpdateArgs} args - Arguments to update one ProductMeta.
     * @example
     * // Update one ProductMeta
     * const productMeta = await prisma.productMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductMetaUpdateArgs>(
      args: SelectSubset<T, ProductMetaUpdateArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more ProductMetas.
     * @param {ProductMetaDeleteManyArgs} args - Arguments to filter ProductMetas to delete.
     * @example
     * // Delete a few ProductMetas
     * const { count } = await prisma.productMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductMetaDeleteManyArgs>(
      args?: SelectSubset<T, ProductMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductMetas
     * const productMeta = await prisma.productMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductMetaUpdateManyArgs>(
      args: SelectSubset<T, ProductMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMetas and returns the data updated in the database.
     * @param {ProductMetaUpdateManyAndReturnArgs} args - Arguments to update many ProductMetas.
     * @example
     * // Update many ProductMetas
     * const productMeta = await prisma.productMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ProductMetas and only return the `id`
     * const productMetaWithIdOnly = await prisma.productMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProductMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProductMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProductMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one ProductMeta.
     * @param {ProductMetaUpsertArgs} args - Arguments to update or create a ProductMeta.
     * @example
     * // Update or create a ProductMeta
     * const productMeta = await prisma.productMeta.upsert({
     *   create: {
     *     // ... data to create a ProductMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductMeta we want to update
     *   }
     * })
     */
    upsert<T extends ProductMetaUpsertArgs>(
      args: SelectSubset<T, ProductMetaUpsertArgs<ExtArgs>>
    ): Prisma__ProductMetaClient<
      $Result.GetResult<Prisma.$ProductMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of ProductMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaCountArgs} args - Arguments to filter ProductMetas to count.
     * @example
     * // Count the number of ProductMetas
     * const count = await prisma.productMeta.count({
     *   where: {
     *     // ... the filter for the ProductMetas we want to count
     *   }
     * })
     */
    count<T extends ProductMetaCountArgs>(
      args?: Subset<T, ProductMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends ProductMetaAggregateArgs>(
      args: Subset<T, ProductMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetProductMetaAggregateType<T>>

    /**
     * Group by ProductMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends ProductMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductMetaGroupByArgs['orderBy'] }
        : { orderBy?: ProductMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, ProductMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProductMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the ProductMeta model
     */
    readonly fields: ProductMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>
    ): Prisma__ProductClient<
      | $Result.GetResult<
          Prisma.$ProductPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the ProductMeta model
   */
  interface ProductMetaFieldRefs {
    readonly id: FieldRef<'ProductMeta', 'Int'>
    readonly productId: FieldRef<'ProductMeta', 'Int'>
    readonly key: FieldRef<'ProductMeta', 'String'>
    readonly value: FieldRef<'ProductMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * ProductMeta findUnique
   */
  export type ProductMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMeta to fetch.
     */
    where: ProductMetaWhereUniqueInput
  }

  /**
   * ProductMeta findUniqueOrThrow
   */
  export type ProductMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMeta to fetch.
     */
    where: ProductMetaWhereUniqueInput
  }

  /**
   * ProductMeta findFirst
   */
  export type ProductMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMeta to fetch.
     */
    where?: ProductMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductMetas to fetch.
     */
    orderBy?: ProductMetaOrderByWithRelationInput | ProductMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductMetas.
     */
    cursor?: ProductMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductMetas.
     */
    distinct?: ProductMetaScalarFieldEnum | ProductMetaScalarFieldEnum[]
  }

  /**
   * ProductMeta findFirstOrThrow
   */
  export type ProductMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMeta to fetch.
     */
    where?: ProductMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductMetas to fetch.
     */
    orderBy?: ProductMetaOrderByWithRelationInput | ProductMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductMetas.
     */
    cursor?: ProductMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductMetas.
     */
    distinct?: ProductMetaScalarFieldEnum | ProductMetaScalarFieldEnum[]
  }

  /**
   * ProductMeta findMany
   */
  export type ProductMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMetas to fetch.
     */
    where?: ProductMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductMetas to fetch.
     */
    orderBy?: ProductMetaOrderByWithRelationInput | ProductMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductMetas.
     */
    cursor?: ProductMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductMetas.
     */
    skip?: number
    distinct?: ProductMetaScalarFieldEnum | ProductMetaScalarFieldEnum[]
  }

  /**
   * ProductMeta create
   */
  export type ProductMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductMeta.
     */
    data: XOR<ProductMetaCreateInput, ProductMetaUncheckedCreateInput>
  }

  /**
   * ProductMeta createMany
   */
  export type ProductMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many ProductMetas.
     */
    data: ProductMetaCreateManyInput | ProductMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductMeta createManyAndReturn
   */
  export type ProductMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * The data used to create many ProductMetas.
     */
    data: ProductMetaCreateManyInput | ProductMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMeta update
   */
  export type ProductMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductMeta.
     */
    data: XOR<ProductMetaUpdateInput, ProductMetaUncheckedUpdateInput>
    /**
     * Choose, which ProductMeta to update.
     */
    where: ProductMetaWhereUniqueInput
  }

  /**
   * ProductMeta updateMany
   */
  export type ProductMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update ProductMetas.
     */
    data: XOR<ProductMetaUpdateManyMutationInput, ProductMetaUncheckedUpdateManyInput>
    /**
     * Filter which ProductMetas to update
     */
    where?: ProductMetaWhereInput
    /**
     * Limit how many ProductMetas to update.
     */
    limit?: number
  }

  /**
   * ProductMeta updateManyAndReturn
   */
  export type ProductMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * The data used to update ProductMetas.
     */
    data: XOR<ProductMetaUpdateManyMutationInput, ProductMetaUncheckedUpdateManyInput>
    /**
     * Filter which ProductMetas to update
     */
    where?: ProductMetaWhereInput
    /**
     * Limit how many ProductMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMeta upsert
   */
  export type ProductMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductMeta to update in case it exists.
     */
    where: ProductMetaWhereUniqueInput
    /**
     * In case the ProductMeta found by the `where` argument doesn't exist, create a new ProductMeta with this data.
     */
    create: XOR<ProductMetaCreateInput, ProductMetaUncheckedCreateInput>
    /**
     * In case the ProductMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductMetaUpdateInput, ProductMetaUncheckedUpdateInput>
  }

  /**
   * ProductMeta delete
   */
  export type ProductMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
    /**
     * Filter which ProductMeta to delete.
     */
    where: ProductMetaWhereUniqueInput
  }

  /**
   * ProductMeta deleteMany
   */
  export type ProductMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which ProductMetas to delete
     */
    where?: ProductMetaWhereInput
    /**
     * Limit how many ProductMetas to delete.
     */
    limit?: number
  }

  /**
   * ProductMeta without action
   */
  export type ProductMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ProductMeta
     */
    select?: ProductMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMeta
     */
    omit?: ProductMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMetaInclude<ExtArgs> | null
  }

  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    pageId: number | null
    articleId: number | null
    portfolioId: number | null
    productId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    pageId: number | null
    articleId: number | null
    portfolioId: number | null
    productId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    pageId: number | null
    articleId: number | null
    portfolioId: number | null
    productId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    pageId: number | null
    articleId: number | null
    portfolioId: number | null
    productId: number | null
    content: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    pageId: number
    articleId: number
    portfolioId: number
    productId: number
    content: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type CommentAvgAggregateInputType = {
    id?: true
    userId?: true
    pageId?: true
    articleId?: true
    portfolioId?: true
    productId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    userId?: true
    pageId?: true
    articleId?: true
    portfolioId?: true
    productId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    pageId?: true
    articleId?: true
    portfolioId?: true
    productId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    pageId?: true
    articleId?: true
    portfolioId?: true
    productId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    pageId?: true
    articleId?: true
    portfolioId?: true
    productId?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Comments
     */
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }

  export type CommentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    userId: number | null
    pageId: number | null
    articleId: number | null
    portfolioId: number | null
    productId: number | null
    content: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CommentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
          : GetScalarType<T[P], CommentGroupByOutputType[P]>
      }
    >
  >

  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        userId?: boolean
        pageId?: boolean
        articleId?: boolean
        portfolioId?: boolean
        productId?: boolean
        content?: boolean
        status?: boolean
        createdAt?: boolean
        updatedAt?: boolean
        user?: boolean | Comment$userArgs<ExtArgs>
        page?: boolean | Comment$pageArgs<ExtArgs>
        article?: boolean | Comment$articleArgs<ExtArgs>
        portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
        product?: boolean | Comment$productArgs<ExtArgs>
        metas?: boolean | Comment$metasArgs<ExtArgs>
        _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['comment']
    >

  export type CommentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      userId?: boolean
      pageId?: boolean
      articleId?: boolean
      portfolioId?: boolean
      productId?: boolean
      content?: boolean
      status?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      user?: boolean | Comment$userArgs<ExtArgs>
      page?: boolean | Comment$pageArgs<ExtArgs>
      article?: boolean | Comment$articleArgs<ExtArgs>
      portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
      product?: boolean | Comment$productArgs<ExtArgs>
    },
    ExtArgs['result']['comment']
  >

  export type CommentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      userId?: boolean
      pageId?: boolean
      articleId?: boolean
      portfolioId?: boolean
      productId?: boolean
      content?: boolean
      status?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      user?: boolean | Comment$userArgs<ExtArgs>
      page?: boolean | Comment$pageArgs<ExtArgs>
      article?: boolean | Comment$articleArgs<ExtArgs>
      portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
      product?: boolean | Comment$productArgs<ExtArgs>
    },
    ExtArgs['result']['comment']
  >

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    pageId?: boolean
    articleId?: boolean
    portfolioId?: boolean
    productId?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'userId'
      | 'pageId'
      | 'articleId'
      | 'portfolioId'
      | 'productId'
      | 'content'
      | 'status'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['comment']
    >
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Comment$userArgs<ExtArgs>
    page?: boolean | Comment$pageArgs<ExtArgs>
    article?: boolean | Comment$articleArgs<ExtArgs>
    portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
    product?: boolean | Comment$productArgs<ExtArgs>
    metas?: boolean | Comment$metasArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    user?: boolean | Comment$userArgs<ExtArgs>
    page?: boolean | Comment$pageArgs<ExtArgs>
    article?: boolean | Comment$articleArgs<ExtArgs>
    portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
    product?: boolean | Comment$productArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    user?: boolean | Comment$userArgs<ExtArgs>
    page?: boolean | Comment$pageArgs<ExtArgs>
    article?: boolean | Comment$articleArgs<ExtArgs>
    portfolio?: boolean | Comment$portfolioArgs<ExtArgs>
    product?: boolean | Comment$productArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Comment'
      objects: {
        user: Prisma.$UserPayload<ExtArgs> | null
        page: Prisma.$PagePayload<ExtArgs> | null
        article: Prisma.$ArticlePayload<ExtArgs> | null
        portfolio: Prisma.$PortfolioPayload<ExtArgs> | null
        product: Prisma.$ProductPayload<ExtArgs> | null
        metas: Prisma.$CommentMetaPayload<ExtArgs>[]
      }
      scalars: $Extensions.GetPayloadResult<
        {
          id: number
          userId: number | null
          pageId: number | null
          articleId: number | null
          portfolioId: number | null
          productId: number | null
          content: string
          status: string
          createdAt: Date
          updatedAt: Date
        },
        ExtArgs['result']['comment']
      >
      composites: {}
    }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> =
    $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CommentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CommentCountAggregateInputType | true
  }

  export interface CommentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment']; meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     *
     */
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     *
     */
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
     */
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends CommentAggregateArgs>(
      args: Subset<T, CommentAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Comment model
     */
    readonly fields: CommentFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    user<T extends Comment$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    page<T extends Comment$pageArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$pageArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<
        Prisma.$PagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    article<T extends Comment$articleArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$articleArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<
        Prisma.$ArticlePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    portfolio<T extends Comment$portfolioArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$portfolioArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    product<T extends Comment$productArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$productArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    metas<T extends Comment$metasArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$metasArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<'Comment', 'Int'>
    readonly userId: FieldRef<'Comment', 'Int'>
    readonly pageId: FieldRef<'Comment', 'Int'>
    readonly articleId: FieldRef<'Comment', 'Int'>
    readonly portfolioId: FieldRef<'Comment', 'Int'>
    readonly productId: FieldRef<'Comment', 'Int'>
    readonly content: FieldRef<'Comment', 'String'>
    readonly status: FieldRef<'Comment', 'String'>
    readonly createdAt: FieldRef<'Comment', 'DateTime'>
    readonly updatedAt: FieldRef<'Comment', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.user
   */
  export type Comment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null
      where?: UserWhereInput
    }

  /**
   * Comment.page
   */
  export type Comment$pageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Page
       */
      select?: PageSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Page
       */
      omit?: PageOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: PageInclude<ExtArgs> | null
      where?: PageWhereInput
    }

  /**
   * Comment.article
   */
  export type Comment$articleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }

  /**
   * Comment.portfolio
   */
  export type Comment$portfolioArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
  }

  /**
   * Comment.product
   */
  export type Comment$productArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Comment.metas
   */
  export type Comment$metasArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    where?: CommentMetaWhereInput
    orderBy?: CommentMetaOrderByWithRelationInput | CommentMetaOrderByWithRelationInput[]
    cursor?: CommentMetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentMetaScalarFieldEnum | CommentMetaScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }

  /**
   * Model CommentMeta
   */

  export type AggregateCommentMeta = {
    _count: CommentMetaCountAggregateOutputType | null
    _avg: CommentMetaAvgAggregateOutputType | null
    _sum: CommentMetaSumAggregateOutputType | null
    _min: CommentMetaMinAggregateOutputType | null
    _max: CommentMetaMaxAggregateOutputType | null
  }

  export type CommentMetaAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type CommentMetaSumAggregateOutputType = {
    id: number | null
    commentId: number | null
  }

  export type CommentMetaMinAggregateOutputType = {
    id: number | null
    commentId: number | null
    key: string | null
  }

  export type CommentMetaMaxAggregateOutputType = {
    id: number | null
    commentId: number | null
    key: string | null
  }

  export type CommentMetaCountAggregateOutputType = {
    id: number
    commentId: number
    key: number
    value: number
    _all: number
  }

  export type CommentMetaAvgAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type CommentMetaSumAggregateInputType = {
    id?: true
    commentId?: true
  }

  export type CommentMetaMinAggregateInputType = {
    id?: true
    commentId?: true
    key?: true
  }

  export type CommentMetaMaxAggregateInputType = {
    id?: true
    commentId?: true
    key?: true
  }

  export type CommentMetaCountAggregateInputType = {
    id?: true
    commentId?: true
    key?: true
    value?: true
    _all?: true
  }

  export type CommentMetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CommentMeta to aggregate.
     */
    where?: CommentMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentMetas to fetch.
     */
    orderBy?: CommentMetaOrderByWithRelationInput | CommentMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CommentMetas
     */
    _count?: true | CommentMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: CommentMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: CommentMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: CommentMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: CommentMetaMaxAggregateInputType
  }

  export type GetCommentMetaAggregateType<T extends CommentMetaAggregateArgs> = {
    [P in keyof T & keyof AggregateCommentMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentMeta[P]>
      : GetScalarType<T[P], AggregateCommentMeta[P]>
  }

  export type CommentMetaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: CommentMetaWhereInput
    orderBy?: CommentMetaOrderByWithAggregationInput | CommentMetaOrderByWithAggregationInput[]
    by: CommentMetaScalarFieldEnum[] | CommentMetaScalarFieldEnum
    having?: CommentMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentMetaCountAggregateInputType | true
    _avg?: CommentMetaAvgAggregateInputType
    _sum?: CommentMetaSumAggregateInputType
    _min?: CommentMetaMinAggregateInputType
    _max?: CommentMetaMaxAggregateInputType
  }

  export type CommentMetaGroupByOutputType = {
    id: number
    commentId: number
    key: string
    value: JsonValue
    _count: CommentMetaCountAggregateOutputType | null
    _avg: CommentMetaAvgAggregateOutputType | null
    _sum: CommentMetaSumAggregateOutputType | null
    _min: CommentMetaMinAggregateOutputType | null
    _max: CommentMetaMaxAggregateOutputType | null
  }

  type GetCommentMetaGroupByPayload<T extends CommentMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentMetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CommentMetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommentMetaGroupByOutputType[P]>
          : GetScalarType<T[P], CommentMetaGroupByOutputType[P]>
      }
    >
  >

  export type CommentMetaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      commentId?: boolean
      key?: boolean
      value?: boolean
      comment?: boolean | CommentDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['commentMeta']
  >

  export type CommentMetaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      commentId?: boolean
      key?: boolean
      value?: boolean
      comment?: boolean | CommentDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['commentMeta']
  >

  export type CommentMetaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      commentId?: boolean
      key?: boolean
      value?: boolean
      comment?: boolean | CommentDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['commentMeta']
  >

  export type CommentMetaSelectScalar = {
    id?: boolean
    commentId?: boolean
    key?: boolean
    value?: boolean
  }

  export type CommentMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'commentId' | 'key' | 'value', ExtArgs['result']['commentMeta']>
  export type CommentMetaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type CommentMetaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type CommentMetaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $CommentMetaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'CommentMeta'
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        commentId: number
        key: string
        value: Prisma.JsonValue
      },
      ExtArgs['result']['commentMeta']
    >
    composites: {}
  }

  type CommentMetaGetPayload<S extends boolean | null | undefined | CommentMetaDefaultArgs> =
    $Result.GetResult<Prisma.$CommentMetaPayload, S>

  type CommentMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentMetaCountAggregateInputType | true
    }

  export interface CommentMetaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CommentMeta']
      meta: { name: 'CommentMeta' }
    }
    /**
     * Find zero or one CommentMeta that matches the filter.
     * @param {CommentMetaFindUniqueArgs} args - Arguments to find a CommentMeta
     * @example
     * // Get one CommentMeta
     * const commentMeta = await prisma.commentMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentMetaFindUniqueArgs>(
      args: SelectSubset<T, CommentMetaFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one CommentMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentMetaFindUniqueOrThrowArgs} args - Arguments to find a CommentMeta
     * @example
     * // Get one CommentMeta
     * const commentMeta = await prisma.commentMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentMetaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentMetaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first CommentMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaFindFirstArgs} args - Arguments to find a CommentMeta
     * @example
     * // Get one CommentMeta
     * const commentMeta = await prisma.commentMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentMetaFindFirstArgs>(
      args?: SelectSubset<T, CommentMetaFindFirstArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first CommentMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaFindFirstOrThrowArgs} args - Arguments to find a CommentMeta
     * @example
     * // Get one CommentMeta
     * const commentMeta = await prisma.commentMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentMetaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more CommentMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentMetas
     * const commentMetas = await prisma.commentMeta.findMany()
     *
     * // Get first 10 CommentMetas
     * const commentMetas = await prisma.commentMeta.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentMetaWithIdOnly = await prisma.commentMeta.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentMetaFindManyArgs>(
      args?: SelectSubset<T, CommentMetaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a CommentMeta.
     * @param {CommentMetaCreateArgs} args - Arguments to create a CommentMeta.
     * @example
     * // Create one CommentMeta
     * const CommentMeta = await prisma.commentMeta.create({
     *   data: {
     *     // ... data to create a CommentMeta
     *   }
     * })
     *
     */
    create<T extends CommentMetaCreateArgs>(
      args: SelectSubset<T, CommentMetaCreateArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many CommentMetas.
     * @param {CommentMetaCreateManyArgs} args - Arguments to create many CommentMetas.
     * @example
     * // Create many CommentMetas
     * const commentMeta = await prisma.commentMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentMetaCreateManyArgs>(
      args?: SelectSubset<T, CommentMetaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentMetas and returns the data saved in the database.
     * @param {CommentMetaCreateManyAndReturnArgs} args - Arguments to create many CommentMetas.
     * @example
     * // Create many CommentMetas
     * const commentMeta = await prisma.commentMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CommentMetas and only return the `id`
     * const commentMetaWithIdOnly = await prisma.commentMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentMetaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CommentMetaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a CommentMeta.
     * @param {CommentMetaDeleteArgs} args - Arguments to delete one CommentMeta.
     * @example
     * // Delete one CommentMeta
     * const CommentMeta = await prisma.commentMeta.delete({
     *   where: {
     *     // ... filter to delete one CommentMeta
     *   }
     * })
     *
     */
    delete<T extends CommentMetaDeleteArgs>(
      args: SelectSubset<T, CommentMetaDeleteArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one CommentMeta.
     * @param {CommentMetaUpdateArgs} args - Arguments to update one CommentMeta.
     * @example
     * // Update one CommentMeta
     * const commentMeta = await prisma.commentMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentMetaUpdateArgs>(
      args: SelectSubset<T, CommentMetaUpdateArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more CommentMetas.
     * @param {CommentMetaDeleteManyArgs} args - Arguments to filter CommentMetas to delete.
     * @example
     * // Delete a few CommentMetas
     * const { count } = await prisma.commentMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentMetaDeleteManyArgs>(
      args?: SelectSubset<T, CommentMetaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentMetas
     * const commentMeta = await prisma.commentMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentMetaUpdateManyArgs>(
      args: SelectSubset<T, CommentMetaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentMetas and returns the data updated in the database.
     * @param {CommentMetaUpdateManyAndReturnArgs} args - Arguments to update many CommentMetas.
     * @example
     * // Update many CommentMetas
     * const commentMeta = await prisma.commentMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CommentMetas and only return the `id`
     * const commentMetaWithIdOnly = await prisma.commentMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CommentMetaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CommentMetaUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentMetaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one CommentMeta.
     * @param {CommentMetaUpsertArgs} args - Arguments to update or create a CommentMeta.
     * @example
     * // Update or create a CommentMeta
     * const commentMeta = await prisma.commentMeta.upsert({
     *   create: {
     *     // ... data to create a CommentMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentMeta we want to update
     *   }
     * })
     */
    upsert<T extends CommentMetaUpsertArgs>(
      args: SelectSubset<T, CommentMetaUpsertArgs<ExtArgs>>
    ): Prisma__CommentMetaClient<
      $Result.GetResult<Prisma.$CommentMetaPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of CommentMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaCountArgs} args - Arguments to filter CommentMetas to count.
     * @example
     * // Count the number of CommentMetas
     * const count = await prisma.commentMeta.count({
     *   where: {
     *     // ... the filter for the CommentMetas we want to count
     *   }
     * })
     */
    count<T extends CommentMetaCountArgs>(
      args?: Subset<T, CommentMetaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends CommentMetaAggregateArgs>(
      args: Subset<T, CommentMetaAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentMetaAggregateType<T>>

    /**
     * Group by CommentMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends CommentMetaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentMetaGroupByArgs['orderBy'] }
        : { orderBy?: CommentMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, CommentMetaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCommentMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the CommentMeta model
     */
    readonly fields: CommentMetaFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentMetaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CommentDefaultArgs<ExtArgs>>
    ): Prisma__CommentClient<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the CommentMeta model
   */
  interface CommentMetaFieldRefs {
    readonly id: FieldRef<'CommentMeta', 'Int'>
    readonly commentId: FieldRef<'CommentMeta', 'Int'>
    readonly key: FieldRef<'CommentMeta', 'String'>
    readonly value: FieldRef<'CommentMeta', 'Json'>
  }

  // Custom InputTypes
  /**
   * CommentMeta findUnique
   */
  export type CommentMetaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter, which CommentMeta to fetch.
     */
    where: CommentMetaWhereUniqueInput
  }

  /**
   * CommentMeta findUniqueOrThrow
   */
  export type CommentMetaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter, which CommentMeta to fetch.
     */
    where: CommentMetaWhereUniqueInput
  }

  /**
   * CommentMeta findFirst
   */
  export type CommentMetaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter, which CommentMeta to fetch.
     */
    where?: CommentMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentMetas to fetch.
     */
    orderBy?: CommentMetaOrderByWithRelationInput | CommentMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommentMetas.
     */
    cursor?: CommentMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommentMetas.
     */
    distinct?: CommentMetaScalarFieldEnum | CommentMetaScalarFieldEnum[]
  }

  /**
   * CommentMeta findFirstOrThrow
   */
  export type CommentMetaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter, which CommentMeta to fetch.
     */
    where?: CommentMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentMetas to fetch.
     */
    orderBy?: CommentMetaOrderByWithRelationInput | CommentMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommentMetas.
     */
    cursor?: CommentMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommentMetas.
     */
    distinct?: CommentMetaScalarFieldEnum | CommentMetaScalarFieldEnum[]
  }

  /**
   * CommentMeta findMany
   */
  export type CommentMetaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter, which CommentMetas to fetch.
     */
    where?: CommentMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentMetas to fetch.
     */
    orderBy?: CommentMetaOrderByWithRelationInput | CommentMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CommentMetas.
     */
    cursor?: CommentMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentMetas.
     */
    skip?: number
    distinct?: CommentMetaScalarFieldEnum | CommentMetaScalarFieldEnum[]
  }

  /**
   * CommentMeta create
   */
  export type CommentMetaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentMeta.
     */
    data: XOR<CommentMetaCreateInput, CommentMetaUncheckedCreateInput>
  }

  /**
   * CommentMeta createMany
   */
  export type CommentMetaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many CommentMetas.
     */
    data: CommentMetaCreateManyInput | CommentMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentMeta createManyAndReturn
   */
  export type CommentMetaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * The data used to create many CommentMetas.
     */
    data: CommentMetaCreateManyInput | CommentMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentMeta update
   */
  export type CommentMetaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentMeta.
     */
    data: XOR<CommentMetaUpdateInput, CommentMetaUncheckedUpdateInput>
    /**
     * Choose, which CommentMeta to update.
     */
    where: CommentMetaWhereUniqueInput
  }

  /**
   * CommentMeta updateMany
   */
  export type CommentMetaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update CommentMetas.
     */
    data: XOR<CommentMetaUpdateManyMutationInput, CommentMetaUncheckedUpdateManyInput>
    /**
     * Filter which CommentMetas to update
     */
    where?: CommentMetaWhereInput
    /**
     * Limit how many CommentMetas to update.
     */
    limit?: number
  }

  /**
   * CommentMeta updateManyAndReturn
   */
  export type CommentMetaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * The data used to update CommentMetas.
     */
    data: XOR<CommentMetaUpdateManyMutationInput, CommentMetaUncheckedUpdateManyInput>
    /**
     * Filter which CommentMetas to update
     */
    where?: CommentMetaWhereInput
    /**
     * Limit how many CommentMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentMeta upsert
   */
  export type CommentMetaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentMeta to update in case it exists.
     */
    where: CommentMetaWhereUniqueInput
    /**
     * In case the CommentMeta found by the `where` argument doesn't exist, create a new CommentMeta with this data.
     */
    create: XOR<CommentMetaCreateInput, CommentMetaUncheckedCreateInput>
    /**
     * In case the CommentMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentMetaUpdateInput, CommentMetaUncheckedUpdateInput>
  }

  /**
   * CommentMeta delete
   */
  export type CommentMetaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
    /**
     * Filter which CommentMeta to delete.
     */
    where: CommentMetaWhereUniqueInput
  }

  /**
   * CommentMeta deleteMany
   */
  export type CommentMetaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which CommentMetas to delete
     */
    where?: CommentMetaWhereInput
    /**
     * Limit how many CommentMetas to delete.
     */
    limit?: number
  }

  /**
   * CommentMeta without action
   */
  export type CommentMetaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the CommentMeta
     */
    select?: CommentMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentMeta
     */
    omit?: CommentMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMetaInclude<ExtArgs> | null
  }

  /**
   * Model Term
   */

  export type AggregateTerm = {
    _count: TermCountAggregateOutputType | null
    _avg: TermAvgAggregateOutputType | null
    _sum: TermSumAggregateOutputType | null
    _min: TermMinAggregateOutputType | null
    _max: TermMaxAggregateOutputType | null
  }

  export type TermAvgAggregateOutputType = {
    id: number | null
    group: number | null
  }

  export type TermSumAggregateOutputType = {
    id: number | null
    group: number | null
  }

  export type TermMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    group: number | null
  }

  export type TermMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    group: number | null
  }

  export type TermCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    group: number
    _all: number
  }

  export type TermAvgAggregateInputType = {
    id?: true
    group?: true
  }

  export type TermSumAggregateInputType = {
    id?: true
    group?: true
  }

  export type TermMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    group?: true
  }

  export type TermMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    group?: true
  }

  export type TermCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    group?: true
    _all?: true
  }

  export type TermAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Term to aggregate.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Terms
     */
    _count?: true | TermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: TermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: TermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: TermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: TermMaxAggregateInputType
  }

  export type GetTermAggregateType<T extends TermAggregateArgs> = {
    [P in keyof T & keyof AggregateTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerm[P]>
      : GetScalarType<T[P], AggregateTerm[P]>
  }

  export type TermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: TermWhereInput
      orderBy?: TermOrderByWithAggregationInput | TermOrderByWithAggregationInput[]
      by: TermScalarFieldEnum[] | TermScalarFieldEnum
      having?: TermScalarWhereWithAggregatesInput
      take?: number
      skip?: number
      _count?: TermCountAggregateInputType | true
      _avg?: TermAvgAggregateInputType
      _sum?: TermSumAggregateInputType
      _min?: TermMinAggregateInputType
      _max?: TermMaxAggregateInputType
    }

  export type TermGroupByOutputType = {
    id: number
    slug: string
    name: string
    group: number
    _count: TermCountAggregateOutputType | null
    _avg: TermAvgAggregateOutputType | null
    _sum: TermSumAggregateOutputType | null
    _min: TermMinAggregateOutputType | null
    _max: TermMaxAggregateOutputType | null
  }

  type GetTermGroupByPayload<T extends TermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TermGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TermGroupByOutputType[P]>
          : GetScalarType<T[P], TermGroupByOutputType[P]>
      }
    >
  >

  export type TermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        name?: boolean
        group?: boolean
        taxonomies?: boolean | Term$taxonomiesArgs<ExtArgs>
        _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>
      },
      ExtArgs['result']['term']
    >

  export type TermSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      name?: boolean
      group?: boolean
    },
    ExtArgs['result']['term']
  >

  export type TermSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      name?: boolean
      group?: boolean
    },
    ExtArgs['result']['term']
  >

  export type TermSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    group?: boolean
  }

  export type TermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'id' | 'slug' | 'name' | 'group', ExtArgs['result']['term']>
  export type TermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxonomies?: boolean | Term$taxonomiesArgs<ExtArgs>
    _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TermIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {}
  export type TermIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {}

  export type $TermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Term'
    objects: {
      taxonomies: Prisma.$TermTaxonomyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        slug: string
        name: string
        group: number
      },
      ExtArgs['result']['term']
    >
    composites: {}
  }

  type TermGetPayload<S extends boolean | null | undefined | TermDefaultArgs> = $Result.GetResult<
    Prisma.$TermPayload,
    S
  >

  type TermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    TermFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: TermCountAggregateInputType | true
  }

  export interface TermDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Term']; meta: { name: 'Term' } }
    /**
     * Find zero or one Term that matches the filter.
     * @param {TermFindUniqueArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermFindUniqueArgs>(
      args: SelectSubset<T, TermFindUniqueArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Term that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermFindUniqueOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Term that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermFindFirstArgs>(
      args?: SelectSubset<T, TermFindFirstArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Term that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.term.findMany()
     *
     * // Get first 10 Terms
     * const terms = await prisma.term.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termWithIdOnly = await prisma.term.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermFindManyArgs>(
      args?: SelectSubset<T, TermFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Term.
     * @param {TermCreateArgs} args - Arguments to create a Term.
     * @example
     * // Create one Term
     * const Term = await prisma.term.create({
     *   data: {
     *     // ... data to create a Term
     *   }
     * })
     *
     */
    create<T extends TermCreateArgs>(
      args: SelectSubset<T, TermCreateArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Terms.
     * @param {TermCreateManyArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermCreateManyArgs>(
      args?: SelectSubset<T, TermCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Terms and returns the data saved in the database.
     * @param {TermCreateManyAndReturnArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Delete a Term.
     * @param {TermDeleteArgs} args - Arguments to delete one Term.
     * @example
     * // Delete one Term
     * const Term = await prisma.term.delete({
     *   where: {
     *     // ... filter to delete one Term
     *   }
     * })
     *
     */
    delete<T extends TermDeleteArgs>(
      args: SelectSubset<T, TermDeleteArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Term.
     * @param {TermUpdateArgs} args - Arguments to update one Term.
     * @example
     * // Update one Term
     * const term = await prisma.term.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermUpdateArgs>(
      args: SelectSubset<T, TermUpdateArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Terms.
     * @param {TermDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.term.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermDeleteManyArgs>(
      args?: SelectSubset<T, TermDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermUpdateManyArgs>(
      args: SelectSubset<T, TermUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms and returns the data updated in the database.
     * @param {TermUpdateManyAndReturnArgs} args - Arguments to update many Terms.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Create or update one Term.
     * @param {TermUpsertArgs} args - Arguments to update or create a Term.
     * @example
     * // Update or create a Term
     * const term = await prisma.term.upsert({
     *   create: {
     *     // ... data to create a Term
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Term we want to update
     *   }
     * })
     */
    upsert<T extends TermUpsertArgs>(
      args: SelectSubset<T, TermUpsertArgs<ExtArgs>>
    ): Prisma__TermClient<
      $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.term.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
     */
    count<T extends TermCountArgs>(
      args?: Subset<T, TermCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends TermAggregateArgs>(
      args: Subset<T, TermAggregateArgs>
    ): Prisma.PrismaPromise<GetTermAggregateType<T>>

    /**
     * Group by Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends TermGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermGroupByArgs['orderBy'] }
        : { orderBy?: TermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, TermGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Term model
     */
    readonly fields: TermFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Term.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    taxonomies<T extends Term$taxonomiesArgs<ExtArgs> = {}>(
      args?: Subset<T, Term$taxonomiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Term model
   */
  interface TermFieldRefs {
    readonly id: FieldRef<'Term', 'Int'>
    readonly slug: FieldRef<'Term', 'String'>
    readonly name: FieldRef<'Term', 'String'>
    readonly group: FieldRef<'Term', 'Int'>
  }

  // Custom InputTypes
  /**
   * Term findUnique
   */
  export type TermFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term findUniqueOrThrow
   */
  export type TermFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term findFirst
   */
  export type TermFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * Term findFirstOrThrow
   */
  export type TermFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * Term findMany
   */
  export type TermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Term
       */
      select?: TermSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Term
       */
      omit?: TermOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TermInclude<ExtArgs> | null
      /**
       * Filter, which Terms to fetch.
       */
      where?: TermWhereInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Terms to fetch.
       */
      orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Terms.
       */
      cursor?: TermWhereUniqueInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Terms from the position of the cursor.
       */
      take?: number
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Terms.
       */
      skip?: number
      distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
    }

  /**
   * Term create
   */
  export type TermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The data needed to create a Term.
     */
    data: XOR<TermCreateInput, TermUncheckedCreateInput>
  }

  /**
   * Term createMany
   */
  export type TermCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Term createManyAndReturn
   */
  export type TermCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Term update
   */
  export type TermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The data needed to update a Term.
     */
    data: XOR<TermUpdateInput, TermUncheckedUpdateInput>
    /**
     * Choose, which Term to update.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term updateMany
   */
  export type TermUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to update.
     */
    limit?: number
  }

  /**
   * Term updateManyAndReturn
   */
  export type TermUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to update.
     */
    limit?: number
  }

  /**
   * Term upsert
   */
  export type TermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The filter to search for the Term to update in case it exists.
     */
    where: TermWhereUniqueInput
    /**
     * In case the Term found by the `where` argument doesn't exist, create a new Term with this data.
     */
    create: XOR<TermCreateInput, TermUncheckedCreateInput>
    /**
     * In case the Term was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermUpdateInput, TermUncheckedUpdateInput>
  }

  /**
   * Term delete
   */
  export type TermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter which Term to delete.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term deleteMany
   */
  export type TermDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Terms to delete
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to delete.
     */
    limit?: number
  }

  /**
   * Term.taxonomies
   */
  export type Term$taxonomiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    where?: TermTaxonomyWhereInput
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    cursor?: TermTaxonomyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermTaxonomyScalarFieldEnum | TermTaxonomyScalarFieldEnum[]
  }

  /**
   * Term without action
   */
  export type TermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Term
       */
      select?: TermSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Term
       */
      omit?: TermOmit<ExtArgs> | null
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TermInclude<ExtArgs> | null
    }

  /**
   * Model TermTaxonomy
   */

  export type AggregateTermTaxonomy = {
    _count: TermTaxonomyCountAggregateOutputType | null
    _avg: TermTaxonomyAvgAggregateOutputType | null
    _sum: TermTaxonomySumAggregateOutputType | null
    _min: TermTaxonomyMinAggregateOutputType | null
    _max: TermTaxonomyMaxAggregateOutputType | null
  }

  export type TermTaxonomyAvgAggregateOutputType = {
    id: number | null
    termId: number | null
    parentId: number | null
    count: number | null
  }

  export type TermTaxonomySumAggregateOutputType = {
    id: number | null
    termId: number | null
    parentId: number | null
    count: number | null
  }

  export type TermTaxonomyMinAggregateOutputType = {
    id: number | null
    termId: number | null
    taxonomy: string | null
    description: string | null
    parentId: number | null
    count: number | null
  }

  export type TermTaxonomyMaxAggregateOutputType = {
    id: number | null
    termId: number | null
    taxonomy: string | null
    description: string | null
    parentId: number | null
    count: number | null
  }

  export type TermTaxonomyCountAggregateOutputType = {
    id: number
    termId: number
    taxonomy: number
    description: number
    parentId: number
    count: number
    _all: number
  }

  export type TermTaxonomyAvgAggregateInputType = {
    id?: true
    termId?: true
    parentId?: true
    count?: true
  }

  export type TermTaxonomySumAggregateInputType = {
    id?: true
    termId?: true
    parentId?: true
    count?: true
  }

  export type TermTaxonomyMinAggregateInputType = {
    id?: true
    termId?: true
    taxonomy?: true
    description?: true
    parentId?: true
    count?: true
  }

  export type TermTaxonomyMaxAggregateInputType = {
    id?: true
    termId?: true
    taxonomy?: true
    description?: true
    parentId?: true
    count?: true
  }

  export type TermTaxonomyCountAggregateInputType = {
    id?: true
    termId?: true
    taxonomy?: true
    description?: true
    parentId?: true
    count?: true
    _all?: true
  }

  export type TermTaxonomyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which TermTaxonomy to aggregate.
     */
    where?: TermTaxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermTaxonomies to fetch.
     */
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermTaxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermTaxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermTaxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TermTaxonomies
     */
    _count?: true | TermTaxonomyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: TermTaxonomyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: TermTaxonomySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: TermTaxonomyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: TermTaxonomyMaxAggregateInputType
  }

  export type GetTermTaxonomyAggregateType<T extends TermTaxonomyAggregateArgs> = {
    [P in keyof T & keyof AggregateTermTaxonomy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermTaxonomy[P]>
      : GetScalarType<T[P], AggregateTermTaxonomy[P]>
  }

  export type TermTaxonomyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermTaxonomyWhereInput
    orderBy?: TermTaxonomyOrderByWithAggregationInput | TermTaxonomyOrderByWithAggregationInput[]
    by: TermTaxonomyScalarFieldEnum[] | TermTaxonomyScalarFieldEnum
    having?: TermTaxonomyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermTaxonomyCountAggregateInputType | true
    _avg?: TermTaxonomyAvgAggregateInputType
    _sum?: TermTaxonomySumAggregateInputType
    _min?: TermTaxonomyMinAggregateInputType
    _max?: TermTaxonomyMaxAggregateInputType
  }

  export type TermTaxonomyGroupByOutputType = {
    id: number
    termId: number
    taxonomy: string
    description: string | null
    parentId: number | null
    count: number
    _count: TermTaxonomyCountAggregateOutputType | null
    _avg: TermTaxonomyAvgAggregateOutputType | null
    _sum: TermTaxonomySumAggregateOutputType | null
    _min: TermTaxonomyMinAggregateOutputType | null
    _max: TermTaxonomyMaxAggregateOutputType | null
  }

  type GetTermTaxonomyGroupByPayload<T extends TermTaxonomyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermTaxonomyGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TermTaxonomyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TermTaxonomyGroupByOutputType[P]>
          : GetScalarType<T[P], TermTaxonomyGroupByOutputType[P]>
      }
    >
  >

  export type TermTaxonomySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      termId?: boolean
      taxonomy?: boolean
      description?: boolean
      parentId?: boolean
      count?: boolean
      term?: boolean | TermDefaultArgs<ExtArgs>
      parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
      children?: boolean | TermTaxonomy$childrenArgs<ExtArgs>
      relationships?: boolean | TermTaxonomy$relationshipsArgs<ExtArgs>
      _count?: boolean | TermTaxonomyCountOutputTypeDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['termTaxonomy']
  >

  export type TermTaxonomySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      termId?: boolean
      taxonomy?: boolean
      description?: boolean
      parentId?: boolean
      count?: boolean
      term?: boolean | TermDefaultArgs<ExtArgs>
      parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
    },
    ExtArgs['result']['termTaxonomy']
  >

  export type TermTaxonomySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      termId?: boolean
      taxonomy?: boolean
      description?: boolean
      parentId?: boolean
      count?: boolean
      term?: boolean | TermDefaultArgs<ExtArgs>
      parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
    },
    ExtArgs['result']['termTaxonomy']
  >

  export type TermTaxonomySelectScalar = {
    id?: boolean
    termId?: boolean
    taxonomy?: boolean
    description?: boolean
    parentId?: boolean
    count?: boolean
  }

  export type TermTaxonomyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'termId' | 'taxonomy' | 'description' | 'parentId' | 'count',
      ExtArgs['result']['termTaxonomy']
    >
  export type TermTaxonomyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    term?: boolean | TermDefaultArgs<ExtArgs>
    parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
    children?: boolean | TermTaxonomy$childrenArgs<ExtArgs>
    relationships?: boolean | TermTaxonomy$relationshipsArgs<ExtArgs>
    _count?: boolean | TermTaxonomyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TermTaxonomyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    term?: boolean | TermDefaultArgs<ExtArgs>
    parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
  }
  export type TermTaxonomyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    term?: boolean | TermDefaultArgs<ExtArgs>
    parent?: boolean | TermTaxonomy$parentArgs<ExtArgs>
  }

  export type $TermTaxonomyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'TermTaxonomy'
    objects: {
      term: Prisma.$TermPayload<ExtArgs>
      parent: Prisma.$TermTaxonomyPayload<ExtArgs> | null
      children: Prisma.$TermTaxonomyPayload<ExtArgs>[]
      relationships: Prisma.$TermRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        termId: number
        taxonomy: string
        description: string | null
        parentId: number | null
        count: number
      },
      ExtArgs['result']['termTaxonomy']
    >
    composites: {}
  }

  type TermTaxonomyGetPayload<S extends boolean | null | undefined | TermTaxonomyDefaultArgs> =
    $Result.GetResult<Prisma.$TermTaxonomyPayload, S>

  type TermTaxonomyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermTaxonomyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermTaxonomyCountAggregateInputType | true
    }

  export interface TermTaxonomyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TermTaxonomy']
      meta: { name: 'TermTaxonomy' }
    }
    /**
     * Find zero or one TermTaxonomy that matches the filter.
     * @param {TermTaxonomyFindUniqueArgs} args - Arguments to find a TermTaxonomy
     * @example
     * // Get one TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermTaxonomyFindUniqueArgs>(
      args: SelectSubset<T, TermTaxonomyFindUniqueArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one TermTaxonomy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermTaxonomyFindUniqueOrThrowArgs} args - Arguments to find a TermTaxonomy
     * @example
     * // Get one TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermTaxonomyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermTaxonomyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first TermTaxonomy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyFindFirstArgs} args - Arguments to find a TermTaxonomy
     * @example
     * // Get one TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermTaxonomyFindFirstArgs>(
      args?: SelectSubset<T, TermTaxonomyFindFirstArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first TermTaxonomy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyFindFirstOrThrowArgs} args - Arguments to find a TermTaxonomy
     * @example
     * // Get one TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermTaxonomyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermTaxonomyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more TermTaxonomies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermTaxonomies
     * const termTaxonomies = await prisma.termTaxonomy.findMany()
     *
     * // Get first 10 TermTaxonomies
     * const termTaxonomies = await prisma.termTaxonomy.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termTaxonomyWithIdOnly = await prisma.termTaxonomy.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermTaxonomyFindManyArgs>(
      args?: SelectSubset<T, TermTaxonomyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a TermTaxonomy.
     * @param {TermTaxonomyCreateArgs} args - Arguments to create a TermTaxonomy.
     * @example
     * // Create one TermTaxonomy
     * const TermTaxonomy = await prisma.termTaxonomy.create({
     *   data: {
     *     // ... data to create a TermTaxonomy
     *   }
     * })
     *
     */
    create<T extends TermTaxonomyCreateArgs>(
      args: SelectSubset<T, TermTaxonomyCreateArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many TermTaxonomies.
     * @param {TermTaxonomyCreateManyArgs} args - Arguments to create many TermTaxonomies.
     * @example
     * // Create many TermTaxonomies
     * const termTaxonomy = await prisma.termTaxonomy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermTaxonomyCreateManyArgs>(
      args?: SelectSubset<T, TermTaxonomyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TermTaxonomies and returns the data saved in the database.
     * @param {TermTaxonomyCreateManyAndReturnArgs} args - Arguments to create many TermTaxonomies.
     * @example
     * // Create many TermTaxonomies
     * const termTaxonomy = await prisma.termTaxonomy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TermTaxonomies and only return the `id`
     * const termTaxonomyWithIdOnly = await prisma.termTaxonomy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermTaxonomyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermTaxonomyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a TermTaxonomy.
     * @param {TermTaxonomyDeleteArgs} args - Arguments to delete one TermTaxonomy.
     * @example
     * // Delete one TermTaxonomy
     * const TermTaxonomy = await prisma.termTaxonomy.delete({
     *   where: {
     *     // ... filter to delete one TermTaxonomy
     *   }
     * })
     *
     */
    delete<T extends TermTaxonomyDeleteArgs>(
      args: SelectSubset<T, TermTaxonomyDeleteArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one TermTaxonomy.
     * @param {TermTaxonomyUpdateArgs} args - Arguments to update one TermTaxonomy.
     * @example
     * // Update one TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermTaxonomyUpdateArgs>(
      args: SelectSubset<T, TermTaxonomyUpdateArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more TermTaxonomies.
     * @param {TermTaxonomyDeleteManyArgs} args - Arguments to filter TermTaxonomies to delete.
     * @example
     * // Delete a few TermTaxonomies
     * const { count } = await prisma.termTaxonomy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermTaxonomyDeleteManyArgs>(
      args?: SelectSubset<T, TermTaxonomyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermTaxonomies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermTaxonomies
     * const termTaxonomy = await prisma.termTaxonomy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermTaxonomyUpdateManyArgs>(
      args: SelectSubset<T, TermTaxonomyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermTaxonomies and returns the data updated in the database.
     * @param {TermTaxonomyUpdateManyAndReturnArgs} args - Arguments to update many TermTaxonomies.
     * @example
     * // Update many TermTaxonomies
     * const termTaxonomy = await prisma.termTaxonomy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TermTaxonomies and only return the `id`
     * const termTaxonomyWithIdOnly = await prisma.termTaxonomy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermTaxonomyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermTaxonomyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one TermTaxonomy.
     * @param {TermTaxonomyUpsertArgs} args - Arguments to update or create a TermTaxonomy.
     * @example
     * // Update or create a TermTaxonomy
     * const termTaxonomy = await prisma.termTaxonomy.upsert({
     *   create: {
     *     // ... data to create a TermTaxonomy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermTaxonomy we want to update
     *   }
     * })
     */
    upsert<T extends TermTaxonomyUpsertArgs>(
      args: SelectSubset<T, TermTaxonomyUpsertArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of TermTaxonomies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyCountArgs} args - Arguments to filter TermTaxonomies to count.
     * @example
     * // Count the number of TermTaxonomies
     * const count = await prisma.termTaxonomy.count({
     *   where: {
     *     // ... the filter for the TermTaxonomies we want to count
     *   }
     * })
     */
    count<T extends TermTaxonomyCountArgs>(
      args?: Subset<T, TermTaxonomyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermTaxonomyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermTaxonomy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends TermTaxonomyAggregateArgs>(
      args: Subset<T, TermTaxonomyAggregateArgs>
    ): Prisma.PrismaPromise<GetTermTaxonomyAggregateType<T>>

    /**
     * Group by TermTaxonomy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermTaxonomyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends TermTaxonomyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermTaxonomyGroupByArgs['orderBy'] }
        : { orderBy?: TermTaxonomyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, TermTaxonomyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTermTaxonomyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the TermTaxonomy model
     */
    readonly fields: TermTaxonomyFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermTaxonomy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermTaxonomyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    term<T extends TermDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TermDefaultArgs<ExtArgs>>
    ): Prisma__TermClient<
      | $Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    parent<T extends TermTaxonomy$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, TermTaxonomy$parentArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      $Result.GetResult<
        Prisma.$TermTaxonomyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    children<T extends TermTaxonomy$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, TermTaxonomy$childrenArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TermTaxonomyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >
    relationships<T extends TermTaxonomy$relationshipsArgs<ExtArgs> = {}>(
      args?: Subset<T, TermTaxonomy$relationshipsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TermRelationshipPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the TermTaxonomy model
   */
  interface TermTaxonomyFieldRefs {
    readonly id: FieldRef<'TermTaxonomy', 'Int'>
    readonly termId: FieldRef<'TermTaxonomy', 'Int'>
    readonly taxonomy: FieldRef<'TermTaxonomy', 'String'>
    readonly description: FieldRef<'TermTaxonomy', 'String'>
    readonly parentId: FieldRef<'TermTaxonomy', 'Int'>
    readonly count: FieldRef<'TermTaxonomy', 'Int'>
  }

  // Custom InputTypes
  /**
   * TermTaxonomy findUnique
   */
  export type TermTaxonomyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter, which TermTaxonomy to fetch.
     */
    where: TermTaxonomyWhereUniqueInput
  }

  /**
   * TermTaxonomy findUniqueOrThrow
   */
  export type TermTaxonomyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter, which TermTaxonomy to fetch.
     */
    where: TermTaxonomyWhereUniqueInput
  }

  /**
   * TermTaxonomy findFirst
   */
  export type TermTaxonomyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter, which TermTaxonomy to fetch.
     */
    where?: TermTaxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermTaxonomies to fetch.
     */
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermTaxonomies.
     */
    cursor?: TermTaxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermTaxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermTaxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermTaxonomies.
     */
    distinct?: TermTaxonomyScalarFieldEnum | TermTaxonomyScalarFieldEnum[]
  }

  /**
   * TermTaxonomy findFirstOrThrow
   */
  export type TermTaxonomyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter, which TermTaxonomy to fetch.
     */
    where?: TermTaxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermTaxonomies to fetch.
     */
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermTaxonomies.
     */
    cursor?: TermTaxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermTaxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermTaxonomies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermTaxonomies.
     */
    distinct?: TermTaxonomyScalarFieldEnum | TermTaxonomyScalarFieldEnum[]
  }

  /**
   * TermTaxonomy findMany
   */
  export type TermTaxonomyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter, which TermTaxonomies to fetch.
     */
    where?: TermTaxonomyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermTaxonomies to fetch.
     */
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TermTaxonomies.
     */
    cursor?: TermTaxonomyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermTaxonomies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermTaxonomies.
     */
    skip?: number
    distinct?: TermTaxonomyScalarFieldEnum | TermTaxonomyScalarFieldEnum[]
  }

  /**
   * TermTaxonomy create
   */
  export type TermTaxonomyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * The data needed to create a TermTaxonomy.
     */
    data: XOR<TermTaxonomyCreateInput, TermTaxonomyUncheckedCreateInput>
  }

  /**
   * TermTaxonomy createMany
   */
  export type TermTaxonomyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many TermTaxonomies.
     */
    data: TermTaxonomyCreateManyInput | TermTaxonomyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermTaxonomy createManyAndReturn
   */
  export type TermTaxonomyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * The data used to create many TermTaxonomies.
     */
    data: TermTaxonomyCreateManyInput | TermTaxonomyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermTaxonomy update
   */
  export type TermTaxonomyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * The data needed to update a TermTaxonomy.
     */
    data: XOR<TermTaxonomyUpdateInput, TermTaxonomyUncheckedUpdateInput>
    /**
     * Choose, which TermTaxonomy to update.
     */
    where: TermTaxonomyWhereUniqueInput
  }

  /**
   * TermTaxonomy updateMany
   */
  export type TermTaxonomyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update TermTaxonomies.
     */
    data: XOR<TermTaxonomyUpdateManyMutationInput, TermTaxonomyUncheckedUpdateManyInput>
    /**
     * Filter which TermTaxonomies to update
     */
    where?: TermTaxonomyWhereInput
    /**
     * Limit how many TermTaxonomies to update.
     */
    limit?: number
  }

  /**
   * TermTaxonomy updateManyAndReturn
   */
  export type TermTaxonomyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * The data used to update TermTaxonomies.
     */
    data: XOR<TermTaxonomyUpdateManyMutationInput, TermTaxonomyUncheckedUpdateManyInput>
    /**
     * Filter which TermTaxonomies to update
     */
    where?: TermTaxonomyWhereInput
    /**
     * Limit how many TermTaxonomies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermTaxonomy upsert
   */
  export type TermTaxonomyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * The filter to search for the TermTaxonomy to update in case it exists.
     */
    where: TermTaxonomyWhereUniqueInput
    /**
     * In case the TermTaxonomy found by the `where` argument doesn't exist, create a new TermTaxonomy with this data.
     */
    create: XOR<TermTaxonomyCreateInput, TermTaxonomyUncheckedCreateInput>
    /**
     * In case the TermTaxonomy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermTaxonomyUpdateInput, TermTaxonomyUncheckedUpdateInput>
  }

  /**
   * TermTaxonomy delete
   */
  export type TermTaxonomyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    /**
     * Filter which TermTaxonomy to delete.
     */
    where: TermTaxonomyWhereUniqueInput
  }

  /**
   * TermTaxonomy deleteMany
   */
  export type TermTaxonomyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which TermTaxonomies to delete
     */
    where?: TermTaxonomyWhereInput
    /**
     * Limit how many TermTaxonomies to delete.
     */
    limit?: number
  }

  /**
   * TermTaxonomy.parent
   */
  export type TermTaxonomy$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    where?: TermTaxonomyWhereInput
  }

  /**
   * TermTaxonomy.children
   */
  export type TermTaxonomy$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
    where?: TermTaxonomyWhereInput
    orderBy?: TermTaxonomyOrderByWithRelationInput | TermTaxonomyOrderByWithRelationInput[]
    cursor?: TermTaxonomyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermTaxonomyScalarFieldEnum | TermTaxonomyScalarFieldEnum[]
  }

  /**
   * TermTaxonomy.relationships
   */
  export type TermTaxonomy$relationshipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    where?: TermRelationshipWhereInput
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    cursor?: TermRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * TermTaxonomy without action
   */
  export type TermTaxonomyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermTaxonomy
     */
    select?: TermTaxonomySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermTaxonomy
     */
    omit?: TermTaxonomyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermTaxonomyInclude<ExtArgs> | null
  }

  /**
   * Model TermRelationship
   */

  export type AggregateTermRelationship = {
    _count: TermRelationshipCountAggregateOutputType | null
    _avg: TermRelationshipAvgAggregateOutputType | null
    _sum: TermRelationshipSumAggregateOutputType | null
    _min: TermRelationshipMinAggregateOutputType | null
    _max: TermRelationshipMaxAggregateOutputType | null
  }

  export type TermRelationshipAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
    pageId: number | null
    portfolioId: number | null
    productId: number | null
    termTaxonomyId: number | null
  }

  export type TermRelationshipSumAggregateOutputType = {
    id: number | null
    articleId: number | null
    pageId: number | null
    portfolioId: number | null
    productId: number | null
    termTaxonomyId: number | null
  }

  export type TermRelationshipMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    pageId: number | null
    portfolioId: number | null
    productId: number | null
    termTaxonomyId: number | null
  }

  export type TermRelationshipMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    pageId: number | null
    portfolioId: number | null
    productId: number | null
    termTaxonomyId: number | null
  }

  export type TermRelationshipCountAggregateOutputType = {
    id: number
    articleId: number
    pageId: number
    portfolioId: number
    productId: number
    termTaxonomyId: number
    _all: number
  }

  export type TermRelationshipAvgAggregateInputType = {
    id?: true
    articleId?: true
    pageId?: true
    portfolioId?: true
    productId?: true
    termTaxonomyId?: true
  }

  export type TermRelationshipSumAggregateInputType = {
    id?: true
    articleId?: true
    pageId?: true
    portfolioId?: true
    productId?: true
    termTaxonomyId?: true
  }

  export type TermRelationshipMinAggregateInputType = {
    id?: true
    articleId?: true
    pageId?: true
    portfolioId?: true
    productId?: true
    termTaxonomyId?: true
  }

  export type TermRelationshipMaxAggregateInputType = {
    id?: true
    articleId?: true
    pageId?: true
    portfolioId?: true
    productId?: true
    termTaxonomyId?: true
  }

  export type TermRelationshipCountAggregateInputType = {
    id?: true
    articleId?: true
    pageId?: true
    portfolioId?: true
    productId?: true
    termTaxonomyId?: true
    _all?: true
  }

  export type TermRelationshipAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which TermRelationship to aggregate.
     */
    where?: TermRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermRelationships to fetch.
     */
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TermRelationships
     */
    _count?: true | TermRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: TermRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: TermRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: TermRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: TermRelationshipMaxAggregateInputType
  }

  export type GetTermRelationshipAggregateType<T extends TermRelationshipAggregateArgs> = {
    [P in keyof T & keyof AggregateTermRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermRelationship[P]>
      : GetScalarType<T[P], AggregateTermRelationship[P]>
  }

  export type TermRelationshipGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TermRelationshipWhereInput
    orderBy?:
      | TermRelationshipOrderByWithAggregationInput
      | TermRelationshipOrderByWithAggregationInput[]
    by: TermRelationshipScalarFieldEnum[] | TermRelationshipScalarFieldEnum
    having?: TermRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermRelationshipCountAggregateInputType | true
    _avg?: TermRelationshipAvgAggregateInputType
    _sum?: TermRelationshipSumAggregateInputType
    _min?: TermRelationshipMinAggregateInputType
    _max?: TermRelationshipMaxAggregateInputType
  }

  export type TermRelationshipGroupByOutputType = {
    id: number
    articleId: number | null
    pageId: number | null
    portfolioId: number | null
    productId: number | null
    termTaxonomyId: number
    _count: TermRelationshipCountAggregateOutputType | null
    _avg: TermRelationshipAvgAggregateOutputType | null
    _sum: TermRelationshipSumAggregateOutputType | null
    _min: TermRelationshipMinAggregateOutputType | null
    _max: TermRelationshipMaxAggregateOutputType | null
  }

  type GetTermRelationshipGroupByPayload<T extends TermRelationshipGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TermRelationshipGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TermRelationshipGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], TermRelationshipGroupByOutputType[P]>
        }
      >
    >

  export type TermRelationshipSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      pageId?: boolean
      portfolioId?: boolean
      productId?: boolean
      termTaxonomyId?: boolean
      article?: boolean | TermRelationship$articleArgs<ExtArgs>
      page?: boolean | TermRelationship$pageArgs<ExtArgs>
      portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
      product?: boolean | TermRelationship$productArgs<ExtArgs>
      termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['termRelationship']
  >

  export type TermRelationshipSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      pageId?: boolean
      portfolioId?: boolean
      productId?: boolean
      termTaxonomyId?: boolean
      article?: boolean | TermRelationship$articleArgs<ExtArgs>
      page?: boolean | TermRelationship$pageArgs<ExtArgs>
      portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
      product?: boolean | TermRelationship$productArgs<ExtArgs>
      termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['termRelationship']
  >

  export type TermRelationshipSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      articleId?: boolean
      pageId?: boolean
      portfolioId?: boolean
      productId?: boolean
      termTaxonomyId?: boolean
      article?: boolean | TermRelationship$articleArgs<ExtArgs>
      page?: boolean | TermRelationship$pageArgs<ExtArgs>
      portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
      product?: boolean | TermRelationship$productArgs<ExtArgs>
      termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['termRelationship']
  >

  export type TermRelationshipSelectScalar = {
    id?: boolean
    articleId?: boolean
    pageId?: boolean
    portfolioId?: boolean
    productId?: boolean
    termTaxonomyId?: boolean
  }

  export type TermRelationshipOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetOmit<
    'id' | 'articleId' | 'pageId' | 'portfolioId' | 'productId' | 'termTaxonomyId',
    ExtArgs['result']['termRelationship']
  >
  export type TermRelationshipInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | TermRelationship$articleArgs<ExtArgs>
    page?: boolean | TermRelationship$pageArgs<ExtArgs>
    portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
    product?: boolean | TermRelationship$productArgs<ExtArgs>
    termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
  }
  export type TermRelationshipIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | TermRelationship$articleArgs<ExtArgs>
    page?: boolean | TermRelationship$pageArgs<ExtArgs>
    portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
    product?: boolean | TermRelationship$productArgs<ExtArgs>
    termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
  }
  export type TermRelationshipIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    article?: boolean | TermRelationship$articleArgs<ExtArgs>
    page?: boolean | TermRelationship$pageArgs<ExtArgs>
    portfolio?: boolean | TermRelationship$portfolioArgs<ExtArgs>
    product?: boolean | TermRelationship$productArgs<ExtArgs>
    termTaxonomy?: boolean | TermTaxonomyDefaultArgs<ExtArgs>
  }

  export type $TermRelationshipPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: 'TermRelationship'
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs> | null
      page: Prisma.$PagePayload<ExtArgs> | null
      portfolio: Prisma.$PortfolioPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      termTaxonomy: Prisma.$TermTaxonomyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        articleId: number | null
        pageId: number | null
        portfolioId: number | null
        productId: number | null
        termTaxonomyId: number
      },
      ExtArgs['result']['termRelationship']
    >
    composites: {}
  }

  type TermRelationshipGetPayload<
    S extends boolean | null | undefined | TermRelationshipDefaultArgs
  > = $Result.GetResult<Prisma.$TermRelationshipPayload, S>

  type TermRelationshipCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<TermRelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TermRelationshipCountAggregateInputType | true
  }

  export interface TermRelationshipDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TermRelationship']
      meta: { name: 'TermRelationship' }
    }
    /**
     * Find zero or one TermRelationship that matches the filter.
     * @param {TermRelationshipFindUniqueArgs} args - Arguments to find a TermRelationship
     * @example
     * // Get one TermRelationship
     * const termRelationship = await prisma.termRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermRelationshipFindUniqueArgs>(
      args: SelectSubset<T, TermRelationshipFindUniqueArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one TermRelationship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermRelationshipFindUniqueOrThrowArgs} args - Arguments to find a TermRelationship
     * @example
     * // Get one TermRelationship
     * const termRelationship = await prisma.termRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermRelationshipFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermRelationshipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first TermRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipFindFirstArgs} args - Arguments to find a TermRelationship
     * @example
     * // Get one TermRelationship
     * const termRelationship = await prisma.termRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermRelationshipFindFirstArgs>(
      args?: SelectSubset<T, TermRelationshipFindFirstArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first TermRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipFindFirstOrThrowArgs} args - Arguments to find a TermRelationship
     * @example
     * // Get one TermRelationship
     * const termRelationship = await prisma.termRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermRelationshipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermRelationshipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more TermRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermRelationships
     * const termRelationships = await prisma.termRelationship.findMany()
     *
     * // Get first 10 TermRelationships
     * const termRelationships = await prisma.termRelationship.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termRelationshipWithIdOnly = await prisma.termRelationship.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermRelationshipFindManyArgs>(
      args?: SelectSubset<T, TermRelationshipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermRelationshipPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a TermRelationship.
     * @param {TermRelationshipCreateArgs} args - Arguments to create a TermRelationship.
     * @example
     * // Create one TermRelationship
     * const TermRelationship = await prisma.termRelationship.create({
     *   data: {
     *     // ... data to create a TermRelationship
     *   }
     * })
     *
     */
    create<T extends TermRelationshipCreateArgs>(
      args: SelectSubset<T, TermRelationshipCreateArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<Prisma.$TermRelationshipPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many TermRelationships.
     * @param {TermRelationshipCreateManyArgs} args - Arguments to create many TermRelationships.
     * @example
     * // Create many TermRelationships
     * const termRelationship = await prisma.termRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermRelationshipCreateManyArgs>(
      args?: SelectSubset<T, TermRelationshipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TermRelationships and returns the data saved in the database.
     * @param {TermRelationshipCreateManyAndReturnArgs} args - Arguments to create many TermRelationships.
     * @example
     * // Create many TermRelationships
     * const termRelationship = await prisma.termRelationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TermRelationships and only return the `id`
     * const termRelationshipWithIdOnly = await prisma.termRelationship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermRelationshipCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermRelationshipCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a TermRelationship.
     * @param {TermRelationshipDeleteArgs} args - Arguments to delete one TermRelationship.
     * @example
     * // Delete one TermRelationship
     * const TermRelationship = await prisma.termRelationship.delete({
     *   where: {
     *     // ... filter to delete one TermRelationship
     *   }
     * })
     *
     */
    delete<T extends TermRelationshipDeleteArgs>(
      args: SelectSubset<T, TermRelationshipDeleteArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<Prisma.$TermRelationshipPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one TermRelationship.
     * @param {TermRelationshipUpdateArgs} args - Arguments to update one TermRelationship.
     * @example
     * // Update one TermRelationship
     * const termRelationship = await prisma.termRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermRelationshipUpdateArgs>(
      args: SelectSubset<T, TermRelationshipUpdateArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<Prisma.$TermRelationshipPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more TermRelationships.
     * @param {TermRelationshipDeleteManyArgs} args - Arguments to filter TermRelationships to delete.
     * @example
     * // Delete a few TermRelationships
     * const { count } = await prisma.termRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermRelationshipDeleteManyArgs>(
      args?: SelectSubset<T, TermRelationshipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermRelationships
     * const termRelationship = await prisma.termRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermRelationshipUpdateManyArgs>(
      args: SelectSubset<T, TermRelationshipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermRelationships and returns the data updated in the database.
     * @param {TermRelationshipUpdateManyAndReturnArgs} args - Arguments to update many TermRelationships.
     * @example
     * // Update many TermRelationships
     * const termRelationship = await prisma.termRelationship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TermRelationships and only return the `id`
     * const termRelationshipWithIdOnly = await prisma.termRelationship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermRelationshipUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermRelationshipUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermRelationshipPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one TermRelationship.
     * @param {TermRelationshipUpsertArgs} args - Arguments to update or create a TermRelationship.
     * @example
     * // Update or create a TermRelationship
     * const termRelationship = await prisma.termRelationship.upsert({
     *   create: {
     *     // ... data to create a TermRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermRelationship we want to update
     *   }
     * })
     */
    upsert<T extends TermRelationshipUpsertArgs>(
      args: SelectSubset<T, TermRelationshipUpsertArgs<ExtArgs>>
    ): Prisma__TermRelationshipClient<
      $Result.GetResult<Prisma.$TermRelationshipPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of TermRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipCountArgs} args - Arguments to filter TermRelationships to count.
     * @example
     * // Count the number of TermRelationships
     * const count = await prisma.termRelationship.count({
     *   where: {
     *     // ... the filter for the TermRelationships we want to count
     *   }
     * })
     */
    count<T extends TermRelationshipCountArgs>(
      args?: Subset<T, TermRelationshipCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends TermRelationshipAggregateArgs>(
      args: Subset<T, TermRelationshipAggregateArgs>
    ): Prisma.PrismaPromise<GetTermRelationshipAggregateType<T>>

    /**
     * Group by TermRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends TermRelationshipGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: TermRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, TermRelationshipGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTermRelationshipGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the TermRelationship model
     */
    readonly fields: TermRelationshipFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermRelationshipClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    article<T extends TermRelationship$articleArgs<ExtArgs> = {}>(
      args?: Subset<T, TermRelationship$articleArgs<ExtArgs>>
    ): Prisma__ArticleClient<
      $Result.GetResult<
        Prisma.$ArticlePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    page<T extends TermRelationship$pageArgs<ExtArgs> = {}>(
      args?: Subset<T, TermRelationship$pageArgs<ExtArgs>>
    ): Prisma__PageClient<
      $Result.GetResult<
        Prisma.$PagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    portfolio<T extends TermRelationship$portfolioArgs<ExtArgs> = {}>(
      args?: Subset<T, TermRelationship$portfolioArgs<ExtArgs>>
    ): Prisma__PortfolioClient<
      $Result.GetResult<
        Prisma.$PortfolioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    product<T extends TermRelationship$productArgs<ExtArgs> = {}>(
      args?: Subset<T, TermRelationship$productArgs<ExtArgs>>
    ): Prisma__ProductClient<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >
    termTaxonomy<T extends TermTaxonomyDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TermTaxonomyDefaultArgs<ExtArgs>>
    ): Prisma__TermTaxonomyClient<
      | $Result.GetResult<
          Prisma.$TermTaxonomyPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the TermRelationship model
   */
  interface TermRelationshipFieldRefs {
    readonly id: FieldRef<'TermRelationship', 'Int'>
    readonly articleId: FieldRef<'TermRelationship', 'Int'>
    readonly pageId: FieldRef<'TermRelationship', 'Int'>
    readonly portfolioId: FieldRef<'TermRelationship', 'Int'>
    readonly productId: FieldRef<'TermRelationship', 'Int'>
    readonly termTaxonomyId: FieldRef<'TermRelationship', 'Int'>
  }

  // Custom InputTypes
  /**
   * TermRelationship findUnique
   */
  export type TermRelationshipFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which TermRelationship to fetch.
     */
    where: TermRelationshipWhereUniqueInput
  }

  /**
   * TermRelationship findUniqueOrThrow
   */
  export type TermRelationshipFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which TermRelationship to fetch.
     */
    where: TermRelationshipWhereUniqueInput
  }

  /**
   * TermRelationship findFirst
   */
  export type TermRelationshipFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which TermRelationship to fetch.
     */
    where?: TermRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermRelationships to fetch.
     */
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermRelationships.
     */
    cursor?: TermRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermRelationships.
     */
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * TermRelationship findFirstOrThrow
   */
  export type TermRelationshipFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which TermRelationship to fetch.
     */
    where?: TermRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermRelationships to fetch.
     */
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermRelationships.
     */
    cursor?: TermRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermRelationships.
     */
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * TermRelationship findMany
   */
  export type TermRelationshipFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which TermRelationships to fetch.
     */
    where?: TermRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermRelationships to fetch.
     */
    orderBy?: TermRelationshipOrderByWithRelationInput | TermRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TermRelationships.
     */
    cursor?: TermRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermRelationships.
     */
    skip?: number
    distinct?: TermRelationshipScalarFieldEnum | TermRelationshipScalarFieldEnum[]
  }

  /**
   * TermRelationship create
   */
  export type TermRelationshipCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a TermRelationship.
     */
    data: XOR<TermRelationshipCreateInput, TermRelationshipUncheckedCreateInput>
  }

  /**
   * TermRelationship createMany
   */
  export type TermRelationshipCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many TermRelationships.
     */
    data: TermRelationshipCreateManyInput | TermRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermRelationship createManyAndReturn
   */
  export type TermRelationshipCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * The data used to create many TermRelationships.
     */
    data: TermRelationshipCreateManyInput | TermRelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermRelationship update
   */
  export type TermRelationshipUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a TermRelationship.
     */
    data: XOR<TermRelationshipUpdateInput, TermRelationshipUncheckedUpdateInput>
    /**
     * Choose, which TermRelationship to update.
     */
    where: TermRelationshipWhereUniqueInput
  }

  /**
   * TermRelationship updateMany
   */
  export type TermRelationshipUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update TermRelationships.
     */
    data: XOR<TermRelationshipUpdateManyMutationInput, TermRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which TermRelationships to update
     */
    where?: TermRelationshipWhereInput
    /**
     * Limit how many TermRelationships to update.
     */
    limit?: number
  }

  /**
   * TermRelationship updateManyAndReturn
   */
  export type TermRelationshipUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * The data used to update TermRelationships.
     */
    data: XOR<TermRelationshipUpdateManyMutationInput, TermRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which TermRelationships to update
     */
    where?: TermRelationshipWhereInput
    /**
     * Limit how many TermRelationships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermRelationship upsert
   */
  export type TermRelationshipUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the TermRelationship to update in case it exists.
     */
    where: TermRelationshipWhereUniqueInput
    /**
     * In case the TermRelationship found by the `where` argument doesn't exist, create a new TermRelationship with this data.
     */
    create: XOR<TermRelationshipCreateInput, TermRelationshipUncheckedCreateInput>
    /**
     * In case the TermRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermRelationshipUpdateInput, TermRelationshipUncheckedUpdateInput>
  }

  /**
   * TermRelationship delete
   */
  export type TermRelationshipDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
    /**
     * Filter which TermRelationship to delete.
     */
    where: TermRelationshipWhereUniqueInput
  }

  /**
   * TermRelationship deleteMany
   */
  export type TermRelationshipDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which TermRelationships to delete
     */
    where?: TermRelationshipWhereInput
    /**
     * Limit how many TermRelationships to delete.
     */
    limit?: number
  }

  /**
   * TermRelationship.article
   */
  export type TermRelationship$articleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }

  /**
   * TermRelationship.page
   */
  export type TermRelationship$pageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }

  /**
   * TermRelationship.portfolio
   */
  export type TermRelationship$portfolioArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
  }

  /**
   * TermRelationship.product
   */
  export type TermRelationship$productArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * TermRelationship without action
   */
  export type TermRelationshipDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TermRelationship
     */
    select?: TermRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermRelationship
     */
    omit?: TermRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermRelationshipInclude<ExtArgs> | null
  }

  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    items: number
    createdAt: number
    updatedAt: number
    _all: number
  }

  export type MenuAvgAggregateInputType = {
    id?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    items?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Menus
     */
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     */
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     */
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
    [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }

  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: MenuWhereInput
      orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
      by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
      having?: MenuScalarWhereWithAggregatesInput
      take?: number
      skip?: number
      _count?: MenuCountAggregateInputType | true
      _avg?: MenuAvgAggregateInputType
      _sum?: MenuSumAggregateInputType
      _min?: MenuMinAggregateInputType
      _max?: MenuMaxAggregateInputType
    }

  export type MenuGroupByOutputType = {
    id: number
    slug: string
    name: string
    items: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> & {
        [P in keyof T & keyof MenuGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
          : GetScalarType<T[P], MenuGroupByOutputType[P]>
      }
    >
  >

  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean
        slug?: boolean
        name?: boolean
        items?: boolean
        createdAt?: boolean
        updatedAt?: boolean
      },
      ExtArgs['result']['menu']
    >

  export type MenuSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      name?: boolean
      items?: boolean
      createdAt?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['menu']
  >

  export type MenuSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean
      slug?: boolean
      name?: boolean
      items?: boolean
      createdAt?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['menu']
  >

  export type MenuSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'slug' | 'name' | 'items' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['menu']
    >

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Menu'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        slug: string
        name: string
        items: Prisma.JsonValue
        createdAt: Date
        updatedAt: Date
      },
      ExtArgs['result']['menu']
    >
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<
    Prisma.$MenuPayload,
    S
  >

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    MenuFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: MenuCountAggregateInputType | true
  }

  export interface MenuDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu']; meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(
      args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(
      args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     *
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MenuFindManyArgs>(
      args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     *
     */
    create<T extends MenuCreateArgs>(
      args: SelectSubset<T, MenuCreateArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MenuCreateManyArgs>(
      args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     *
     */
    delete<T extends MenuDeleteArgs>(
      args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MenuUpdateArgs>(
      args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MenuDeleteManyArgs>(
      args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MenuUpdateManyArgs>(
      args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(
      args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>
    ): Prisma__MenuClient<
      $Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
     */
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends MenuAggregateArgs>(
      args: Subset<T, MenuAggregateArgs>
    ): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Menu model
     */
    readonly fields: MenuFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<'Menu', 'Int'>
    readonly slug: FieldRef<'Menu', 'String'>
    readonly name: FieldRef<'Menu', 'String'>
    readonly items: FieldRef<'Menu', 'Json'>
    readonly createdAt: FieldRef<'Menu', 'DateTime'>
    readonly updatedAt: FieldRef<'Menu', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Menu
       */
      select?: MenuSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Menu
       */
      omit?: MenuOmit<ExtArgs> | null
      /**
       * Filter, which Menus to fetch.
       */
      where?: MenuWhereInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Menus to fetch.
       */
      orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Menus.
       */
      cursor?: MenuWhereUniqueInput
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Menus from the position of the cursor.
       */
      take?: number
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Menus.
       */
      skip?: number
      distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
    }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Menu
       */
      select?: MenuSelect<ExtArgs> | null
      /**
       * Omit specific fields from the Menu
       */
      omit?: MenuOmit<ExtArgs> | null
    }

  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    key: string | null
  }

  export type SettingMaxAggregateOutputType = {
    key: string | null
  }

  export type SettingCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }

  export type SettingMinAggregateInputType = {
    key?: true
  }

  export type SettingMaxAggregateInputType = {
    key?: true
  }

  export type SettingCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type SettingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Settings
     */
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     */
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     */
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
    [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }

  export type SettingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    key: string
    value: JsonValue
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SettingGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
          : GetScalarType<T[P], SettingGroupByOutputType[P]>
      }
    >
  >

  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        key?: boolean
        value?: boolean
      },
      ExtArgs['result']['setting']
    >

  export type SettingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      key?: boolean
      value?: boolean
    },
    ExtArgs['result']['setting']
  >

  export type SettingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      key?: boolean
      value?: boolean
    },
    ExtArgs['result']['setting']
  >

  export type SettingSelectScalar = {
    key?: boolean
    value?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<'key' | 'value', ExtArgs['result']['setting']>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Setting'
      objects: {}
      scalars: $Extensions.GetPayloadResult<
        {
          key: string
          value: Prisma.JsonValue
        },
        ExtArgs['result']['setting']
      >
      composites: {}
    }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> =
    $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SettingFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SettingCountAggregateInputType | true
  }

  export interface SettingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting']; meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(
      args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(
      args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     *
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     *
     * // Only select the `key`
     * const settingWithKeyOnly = await prisma.setting.findMany({ select: { key: true } })
     *
     */
    findMany<T extends SettingFindManyArgs>(
      args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     *
     */
    create<T extends SettingCreateArgs>(
      args: SelectSubset<T, SettingCreateArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SettingCreateManyArgs>(
      args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Settings and only return the `key`
     * const settingWithKeyOnly = await prisma.setting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     *
     */
    delete<T extends SettingDeleteArgs>(
      args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SettingUpdateArgs>(
      args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SettingDeleteManyArgs>(
      args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SettingUpdateManyArgs>(
      args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Settings and only return the `key`
     * const settingWithKeyOnly = await prisma.setting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(
      args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
     */
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     */
    aggregate<T extends SettingAggregateArgs>(
      args: Subset<T, SettingAggregateArgs>
    ): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     */
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? 'Error: "by" must not be empty.'
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ' in "having" needs to be provided in "by"']
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
    >(
      args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Setting model
     */
    readonly fields: SettingFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {}
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly key: FieldRef<'Setting', 'String'>
    readonly value: FieldRef<'Setting', 'Json'>
  }

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted'
    ReadCommitted: 'ReadCommitted'
    RepeatableRead: 'RepeatableRead'
    Serializable: 'Serializable'
  }

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

  export const UserScalarFieldEnum: {
    id: 'id'
    login: 'login'
    email: 'email'
    password: 'password'
    displayName: 'displayName'
    role: 'role'
    isActive: 'isActive'
    registeredAt: 'registeredAt'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]

  export const UserMetaScalarFieldEnum: {
    id: 'id'
    userId: 'userId'
    key: 'key'
    value: 'value'
  }

  export type UserMetaScalarFieldEnum =
    (typeof UserMetaScalarFieldEnum)[keyof typeof UserMetaScalarFieldEnum]

  export const PageScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    status: 'status'
    authorId: 'authorId'
    parentId: 'parentId'
    menuOrder: 'menuOrder'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]

  export const PageTranslationScalarFieldEnum: {
    id: 'id'
    pageId: 'pageId'
    lang: 'lang'
    title: 'title'
    content: 'content'
    excerpt: 'excerpt'
  }

  export type PageTranslationScalarFieldEnum =
    (typeof PageTranslationScalarFieldEnum)[keyof typeof PageTranslationScalarFieldEnum]

  export const PageMetaScalarFieldEnum: {
    id: 'id'
    pageId: 'pageId'
    key: 'key'
    value: 'value'
  }

  export type PageMetaScalarFieldEnum =
    (typeof PageMetaScalarFieldEnum)[keyof typeof PageMetaScalarFieldEnum]

  export const ArticleScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    status: 'status'
    authorId: 'authorId'
    parentId: 'parentId'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type ArticleScalarFieldEnum =
    (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]

  export const ArticleTranslationScalarFieldEnum: {
    id: 'id'
    articleId: 'articleId'
    lang: 'lang'
    title: 'title'
    content: 'content'
    excerpt: 'excerpt'
  }

  export type ArticleTranslationScalarFieldEnum =
    (typeof ArticleTranslationScalarFieldEnum)[keyof typeof ArticleTranslationScalarFieldEnum]

  export const ArticleMetaScalarFieldEnum: {
    id: 'id'
    articleId: 'articleId'
    key: 'key'
    value: 'value'
  }

  export type ArticleMetaScalarFieldEnum =
    (typeof ArticleMetaScalarFieldEnum)[keyof typeof ArticleMetaScalarFieldEnum]

  export const PortfolioScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    status: 'status'
    authorId: 'authorId'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type PortfolioScalarFieldEnum =
    (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]

  export const PortfolioTranslationScalarFieldEnum: {
    id: 'id'
    portfolioId: 'portfolioId'
    lang: 'lang'
    title: 'title'
    content: 'content'
    excerpt: 'excerpt'
  }

  export type PortfolioTranslationScalarFieldEnum =
    (typeof PortfolioTranslationScalarFieldEnum)[keyof typeof PortfolioTranslationScalarFieldEnum]

  export const PortfolioMetaScalarFieldEnum: {
    id: 'id'
    portfolioId: 'portfolioId'
    key: 'key'
    value: 'value'
  }

  export type PortfolioMetaScalarFieldEnum =
    (typeof PortfolioMetaScalarFieldEnum)[keyof typeof PortfolioMetaScalarFieldEnum]

  export const ProductScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    price: 'price'
    currency: 'currency'
    stock: 'stock'
    vendorId: 'vendorId'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type ProductScalarFieldEnum =
    (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]

  export const ProductTranslationScalarFieldEnum: {
    id: 'id'
    productId: 'productId'
    lang: 'lang'
    title: 'title'
    description: 'description'
  }

  export type ProductTranslationScalarFieldEnum =
    (typeof ProductTranslationScalarFieldEnum)[keyof typeof ProductTranslationScalarFieldEnum]

  export const ProductMetaScalarFieldEnum: {
    id: 'id'
    productId: 'productId'
    key: 'key'
    value: 'value'
  }

  export type ProductMetaScalarFieldEnum =
    (typeof ProductMetaScalarFieldEnum)[keyof typeof ProductMetaScalarFieldEnum]

  export const CommentScalarFieldEnum: {
    id: 'id'
    userId: 'userId'
    pageId: 'pageId'
    articleId: 'articleId'
    portfolioId: 'portfolioId'
    productId: 'productId'
    content: 'content'
    status: 'status'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type CommentScalarFieldEnum =
    (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]

  export const CommentMetaScalarFieldEnum: {
    id: 'id'
    commentId: 'commentId'
    key: 'key'
    value: 'value'
  }

  export type CommentMetaScalarFieldEnum =
    (typeof CommentMetaScalarFieldEnum)[keyof typeof CommentMetaScalarFieldEnum]

  export const TermScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    name: 'name'
    group: 'group'
  }

  export type TermScalarFieldEnum = (typeof TermScalarFieldEnum)[keyof typeof TermScalarFieldEnum]

  export const TermTaxonomyScalarFieldEnum: {
    id: 'id'
    termId: 'termId'
    taxonomy: 'taxonomy'
    description: 'description'
    parentId: 'parentId'
    count: 'count'
  }

  export type TermTaxonomyScalarFieldEnum =
    (typeof TermTaxonomyScalarFieldEnum)[keyof typeof TermTaxonomyScalarFieldEnum]

  export const TermRelationshipScalarFieldEnum: {
    id: 'id'
    articleId: 'articleId'
    pageId: 'pageId'
    portfolioId: 'portfolioId'
    productId: 'productId'
    termTaxonomyId: 'termTaxonomyId'
  }

  export type TermRelationshipScalarFieldEnum =
    (typeof TermRelationshipScalarFieldEnum)[keyof typeof TermRelationshipScalarFieldEnum]

  export const MenuScalarFieldEnum: {
    id: 'id'
    slug: 'slug'
    name: 'name'
    items: 'items'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
  }

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]

  export const SettingScalarFieldEnum: {
    key: 'key'
    value: 'value'
  }

  export type SettingScalarFieldEnum =
    (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]

  export const SortOrder: {
    asc: 'asc'
    desc: 'desc'
  }

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  }

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]

  export const QueryMode: {
    default: 'default'
    insensitive: 'insensitive'
  }

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull
    JsonNull: typeof JsonNull
    AnyNull: typeof AnyNull
  }

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]

  export const NullsOrder: {
    first: 'first'
    last: 'last'
  }

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>

  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>

  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >

  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>

  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Status[]'
  >

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<'User'> | number
    login?: StringFilter<'User'> | string
    email?: StringFilter<'User'> | string
    password?: StringFilter<'User'> | string
    displayName?: StringFilter<'User'> | string
    role?: EnumRoleFilter<'User'> | $Enums.Role
    isActive?: BoolFilter<'User'> | boolean
    registeredAt?: DateTimeFilter<'User'> | Date | string
    createdAt?: DateTimeFilter<'User'> | Date | string
    updatedAt?: DateTimeFilter<'User'> | Date | string
    metas?: UserMetaListRelationFilter
    articles?: ArticleListRelationFilter
    pages?: PageListRelationFilter
    portfolios?: PortfolioListRelationFilter
    products?: ProductListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    login?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metas?: UserMetaOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
    portfolios?: PortfolioOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      login?: string
      email?: string
      AND?: UserWhereInput | UserWhereInput[]
      OR?: UserWhereInput[]
      NOT?: UserWhereInput | UserWhereInput[]
      password?: StringFilter<'User'> | string
      displayName?: StringFilter<'User'> | string
      role?: EnumRoleFilter<'User'> | $Enums.Role
      isActive?: BoolFilter<'User'> | boolean
      registeredAt?: DateTimeFilter<'User'> | Date | string
      createdAt?: DateTimeFilter<'User'> | Date | string
      updatedAt?: DateTimeFilter<'User'> | Date | string
      metas?: UserMetaListRelationFilter
      articles?: ArticleListRelationFilter
      pages?: PageListRelationFilter
      portfolios?: PortfolioListRelationFilter
      products?: ProductListRelationFilter
      comments?: CommentListRelationFilter
    },
    'id' | 'login' | 'email'
  >

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    login?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'User'> | number
    login?: StringWithAggregatesFilter<'User'> | string
    email?: StringWithAggregatesFilter<'User'> | string
    password?: StringWithAggregatesFilter<'User'> | string
    displayName?: StringWithAggregatesFilter<'User'> | string
    role?: EnumRoleWithAggregatesFilter<'User'> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<'User'> | boolean
    registeredAt?: DateTimeWithAggregatesFilter<'User'> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string
  }

  export type UserMetaWhereInput = {
    AND?: UserMetaWhereInput | UserMetaWhereInput[]
    OR?: UserMetaWhereInput[]
    NOT?: UserMetaWhereInput | UserMetaWhereInput[]
    id?: IntFilter<'UserMeta'> | number
    userId?: IntFilter<'UserMeta'> | number
    key?: StringFilter<'UserMeta'> | string
    value?: JsonFilter<'UserMeta'>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserMetaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: UserMetaWhereInput | UserMetaWhereInput[]
      OR?: UserMetaWhereInput[]
      NOT?: UserMetaWhereInput | UserMetaWhereInput[]
      userId?: IntFilter<'UserMeta'> | number
      key?: StringFilter<'UserMeta'> | string
      value?: JsonFilter<'UserMeta'>
      user?: XOR<UserScalarRelationFilter, UserWhereInput>
    },
    'id'
  >

  export type UserMetaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: UserMetaCountOrderByAggregateInput
    _avg?: UserMetaAvgOrderByAggregateInput
    _max?: UserMetaMaxOrderByAggregateInput
    _min?: UserMetaMinOrderByAggregateInput
    _sum?: UserMetaSumOrderByAggregateInput
  }

  export type UserMetaScalarWhereWithAggregatesInput = {
    AND?: UserMetaScalarWhereWithAggregatesInput | UserMetaScalarWhereWithAggregatesInput[]
    OR?: UserMetaScalarWhereWithAggregatesInput[]
    NOT?: UserMetaScalarWhereWithAggregatesInput | UserMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'UserMeta'> | number
    userId?: IntWithAggregatesFilter<'UserMeta'> | number
    key?: StringWithAggregatesFilter<'UserMeta'> | string
    value?: JsonWithAggregatesFilter<'UserMeta'>
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: IntFilter<'Page'> | number
    slug?: StringFilter<'Page'> | string
    status?: EnumStatusFilter<'Page'> | $Enums.Status
    authorId?: IntFilter<'Page'> | number
    parentId?: IntNullableFilter<'Page'> | number | null
    menuOrder?: IntFilter<'Page'> | number
    createdAt?: DateTimeFilter<'Page'> | Date | string
    updatedAt?: DateTimeFilter<'Page'> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
    children?: PageListRelationFilter
    translations?: PageTranslationListRelationFilter
    metas?: PageMetaListRelationFilter
    comments?: CommentListRelationFilter
    terms?: TermRelationshipListRelationFilter
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    menuOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    parent?: PageOrderByWithRelationInput
    children?: PageOrderByRelationAggregateInput
    translations?: PageTranslationOrderByRelationAggregateInput
    metas?: PageMetaOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    terms?: TermRelationshipOrderByRelationAggregateInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: PageWhereInput | PageWhereInput[]
      OR?: PageWhereInput[]
      NOT?: PageWhereInput | PageWhereInput[]
      status?: EnumStatusFilter<'Page'> | $Enums.Status
      authorId?: IntFilter<'Page'> | number
      parentId?: IntNullableFilter<'Page'> | number | null
      menuOrder?: IntFilter<'Page'> | number
      createdAt?: DateTimeFilter<'Page'> | Date | string
      updatedAt?: DateTimeFilter<'Page'> | Date | string
      author?: XOR<UserScalarRelationFilter, UserWhereInput>
      parent?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
      children?: PageListRelationFilter
      translations?: PageTranslationListRelationFilter
      metas?: PageMetaListRelationFilter
      comments?: CommentListRelationFilter
      terms?: TermRelationshipListRelationFilter
    },
    'id' | 'slug'
  >

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    menuOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Page'> | number
    slug?: StringWithAggregatesFilter<'Page'> | string
    status?: EnumStatusWithAggregatesFilter<'Page'> | $Enums.Status
    authorId?: IntWithAggregatesFilter<'Page'> | number
    parentId?: IntNullableWithAggregatesFilter<'Page'> | number | null
    menuOrder?: IntWithAggregatesFilter<'Page'> | number
    createdAt?: DateTimeWithAggregatesFilter<'Page'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Page'> | Date | string
  }

  export type PageTranslationWhereInput = {
    AND?: PageTranslationWhereInput | PageTranslationWhereInput[]
    OR?: PageTranslationWhereInput[]
    NOT?: PageTranslationWhereInput | PageTranslationWhereInput[]
    id?: IntFilter<'PageTranslation'> | number
    pageId?: IntFilter<'PageTranslation'> | number
    lang?: StringFilter<'PageTranslation'> | string
    title?: StringFilter<'PageTranslation'> | string
    content?: StringFilter<'PageTranslation'> | string
    excerpt?: StringNullableFilter<'PageTranslation'> | string | null
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
  }

  export type PageTranslationOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    page?: PageOrderByWithRelationInput
  }

  export type PageTranslationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      pageId_lang?: PageTranslationPageIdLangCompoundUniqueInput
      AND?: PageTranslationWhereInput | PageTranslationWhereInput[]
      OR?: PageTranslationWhereInput[]
      NOT?: PageTranslationWhereInput | PageTranslationWhereInput[]
      pageId?: IntFilter<'PageTranslation'> | number
      lang?: StringFilter<'PageTranslation'> | string
      title?: StringFilter<'PageTranslation'> | string
      content?: StringFilter<'PageTranslation'> | string
      excerpt?: StringNullableFilter<'PageTranslation'> | string | null
      page?: XOR<PageScalarRelationFilter, PageWhereInput>
    },
    'id' | 'pageId_lang'
  >

  export type PageTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    _count?: PageTranslationCountOrderByAggregateInput
    _avg?: PageTranslationAvgOrderByAggregateInput
    _max?: PageTranslationMaxOrderByAggregateInput
    _min?: PageTranslationMinOrderByAggregateInput
    _sum?: PageTranslationSumOrderByAggregateInput
  }

  export type PageTranslationScalarWhereWithAggregatesInput = {
    AND?:
      | PageTranslationScalarWhereWithAggregatesInput
      | PageTranslationScalarWhereWithAggregatesInput[]
    OR?: PageTranslationScalarWhereWithAggregatesInput[]
    NOT?:
      | PageTranslationScalarWhereWithAggregatesInput
      | PageTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'PageTranslation'> | number
    pageId?: IntWithAggregatesFilter<'PageTranslation'> | number
    lang?: StringWithAggregatesFilter<'PageTranslation'> | string
    title?: StringWithAggregatesFilter<'PageTranslation'> | string
    content?: StringWithAggregatesFilter<'PageTranslation'> | string
    excerpt?: StringNullableWithAggregatesFilter<'PageTranslation'> | string | null
  }

  export type PageMetaWhereInput = {
    AND?: PageMetaWhereInput | PageMetaWhereInput[]
    OR?: PageMetaWhereInput[]
    NOT?: PageMetaWhereInput | PageMetaWhereInput[]
    id?: IntFilter<'PageMeta'> | number
    pageId?: IntFilter<'PageMeta'> | number
    key?: StringFilter<'PageMeta'> | string
    value?: JsonFilter<'PageMeta'>
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
  }

  export type PageMetaOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    page?: PageOrderByWithRelationInput
  }

  export type PageMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: PageMetaWhereInput | PageMetaWhereInput[]
      OR?: PageMetaWhereInput[]
      NOT?: PageMetaWhereInput | PageMetaWhereInput[]
      pageId?: IntFilter<'PageMeta'> | number
      key?: StringFilter<'PageMeta'> | string
      value?: JsonFilter<'PageMeta'>
      page?: XOR<PageScalarRelationFilter, PageWhereInput>
    },
    'id'
  >

  export type PageMetaOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: PageMetaCountOrderByAggregateInput
    _avg?: PageMetaAvgOrderByAggregateInput
    _max?: PageMetaMaxOrderByAggregateInput
    _min?: PageMetaMinOrderByAggregateInput
    _sum?: PageMetaSumOrderByAggregateInput
  }

  export type PageMetaScalarWhereWithAggregatesInput = {
    AND?: PageMetaScalarWhereWithAggregatesInput | PageMetaScalarWhereWithAggregatesInput[]
    OR?: PageMetaScalarWhereWithAggregatesInput[]
    NOT?: PageMetaScalarWhereWithAggregatesInput | PageMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'PageMeta'> | number
    pageId?: IntWithAggregatesFilter<'PageMeta'> | number
    key?: StringWithAggregatesFilter<'PageMeta'> | string
    value?: JsonWithAggregatesFilter<'PageMeta'>
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: IntFilter<'Article'> | number
    slug?: StringFilter<'Article'> | string
    status?: EnumStatusFilter<'Article'> | $Enums.Status
    authorId?: IntFilter<'Article'> | number
    parentId?: IntNullableFilter<'Article'> | number | null
    createdAt?: DateTimeFilter<'Article'> | Date | string
    updatedAt?: DateTimeFilter<'Article'> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
    children?: ArticleListRelationFilter
    translations?: ArticleTranslationListRelationFilter
    metas?: ArticleMetaListRelationFilter
    comments?: CommentListRelationFilter
    terms?: TermRelationshipListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    parent?: ArticleOrderByWithRelationInput
    children?: ArticleOrderByRelationAggregateInput
    translations?: ArticleTranslationOrderByRelationAggregateInput
    metas?: ArticleMetaOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    terms?: TermRelationshipOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: ArticleWhereInput | ArticleWhereInput[]
      OR?: ArticleWhereInput[]
      NOT?: ArticleWhereInput | ArticleWhereInput[]
      status?: EnumStatusFilter<'Article'> | $Enums.Status
      authorId?: IntFilter<'Article'> | number
      parentId?: IntNullableFilter<'Article'> | number | null
      createdAt?: DateTimeFilter<'Article'> | Date | string
      updatedAt?: DateTimeFilter<'Article'> | Date | string
      author?: XOR<UserScalarRelationFilter, UserWhereInput>
      parent?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
      children?: ArticleListRelationFilter
      translations?: ArticleTranslationListRelationFilter
      metas?: ArticleMetaListRelationFilter
      comments?: CommentListRelationFilter
      terms?: TermRelationshipListRelationFilter
    },
    'id' | 'slug'
  >

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Article'> | number
    slug?: StringWithAggregatesFilter<'Article'> | string
    status?: EnumStatusWithAggregatesFilter<'Article'> | $Enums.Status
    authorId?: IntWithAggregatesFilter<'Article'> | number
    parentId?: IntNullableWithAggregatesFilter<'Article'> | number | null
    createdAt?: DateTimeWithAggregatesFilter<'Article'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Article'> | Date | string
  }

  export type ArticleTranslationWhereInput = {
    AND?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    OR?: ArticleTranslationWhereInput[]
    NOT?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
    id?: IntFilter<'ArticleTranslation'> | number
    articleId?: IntFilter<'ArticleTranslation'> | number
    lang?: StringFilter<'ArticleTranslation'> | string
    title?: StringFilter<'ArticleTranslation'> | string
    content?: StringFilter<'ArticleTranslation'> | string
    excerpt?: StringNullableFilter<'ArticleTranslation'> | string | null
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
  }

  export type ArticleTranslationOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type ArticleTranslationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      articleId_lang?: ArticleTranslationArticleIdLangCompoundUniqueInput
      AND?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
      OR?: ArticleTranslationWhereInput[]
      NOT?: ArticleTranslationWhereInput | ArticleTranslationWhereInput[]
      articleId?: IntFilter<'ArticleTranslation'> | number
      lang?: StringFilter<'ArticleTranslation'> | string
      title?: StringFilter<'ArticleTranslation'> | string
      content?: StringFilter<'ArticleTranslation'> | string
      excerpt?: StringNullableFilter<'ArticleTranslation'> | string | null
      article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    },
    'id' | 'articleId_lang'
  >

  export type ArticleTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    _count?: ArticleTranslationCountOrderByAggregateInput
    _avg?: ArticleTranslationAvgOrderByAggregateInput
    _max?: ArticleTranslationMaxOrderByAggregateInput
    _min?: ArticleTranslationMinOrderByAggregateInput
    _sum?: ArticleTranslationSumOrderByAggregateInput
  }

  export type ArticleTranslationScalarWhereWithAggregatesInput = {
    AND?:
      | ArticleTranslationScalarWhereWithAggregatesInput
      | ArticleTranslationScalarWhereWithAggregatesInput[]
    OR?: ArticleTranslationScalarWhereWithAggregatesInput[]
    NOT?:
      | ArticleTranslationScalarWhereWithAggregatesInput
      | ArticleTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'ArticleTranslation'> | number
    articleId?: IntWithAggregatesFilter<'ArticleTranslation'> | number
    lang?: StringWithAggregatesFilter<'ArticleTranslation'> | string
    title?: StringWithAggregatesFilter<'ArticleTranslation'> | string
    content?: StringWithAggregatesFilter<'ArticleTranslation'> | string
    excerpt?: StringNullableWithAggregatesFilter<'ArticleTranslation'> | string | null
  }

  export type ArticleMetaWhereInput = {
    AND?: ArticleMetaWhereInput | ArticleMetaWhereInput[]
    OR?: ArticleMetaWhereInput[]
    NOT?: ArticleMetaWhereInput | ArticleMetaWhereInput[]
    id?: IntFilter<'ArticleMeta'> | number
    articleId?: IntFilter<'ArticleMeta'> | number
    key?: StringFilter<'ArticleMeta'> | string
    value?: JsonFilter<'ArticleMeta'>
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
  }

  export type ArticleMetaOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type ArticleMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: ArticleMetaWhereInput | ArticleMetaWhereInput[]
      OR?: ArticleMetaWhereInput[]
      NOT?: ArticleMetaWhereInput | ArticleMetaWhereInput[]
      articleId?: IntFilter<'ArticleMeta'> | number
      key?: StringFilter<'ArticleMeta'> | string
      value?: JsonFilter<'ArticleMeta'>
      article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    },
    'id'
  >

  export type ArticleMetaOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: ArticleMetaCountOrderByAggregateInput
    _avg?: ArticleMetaAvgOrderByAggregateInput
    _max?: ArticleMetaMaxOrderByAggregateInput
    _min?: ArticleMetaMinOrderByAggregateInput
    _sum?: ArticleMetaSumOrderByAggregateInput
  }

  export type ArticleMetaScalarWhereWithAggregatesInput = {
    AND?: ArticleMetaScalarWhereWithAggregatesInput | ArticleMetaScalarWhereWithAggregatesInput[]
    OR?: ArticleMetaScalarWhereWithAggregatesInput[]
    NOT?: ArticleMetaScalarWhereWithAggregatesInput | ArticleMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'ArticleMeta'> | number
    articleId?: IntWithAggregatesFilter<'ArticleMeta'> | number
    key?: StringWithAggregatesFilter<'ArticleMeta'> | string
    value?: JsonWithAggregatesFilter<'ArticleMeta'>
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: IntFilter<'Portfolio'> | number
    slug?: StringFilter<'Portfolio'> | string
    status?: EnumStatusFilter<'Portfolio'> | $Enums.Status
    authorId?: IntFilter<'Portfolio'> | number
    createdAt?: DateTimeFilter<'Portfolio'> | Date | string
    updatedAt?: DateTimeFilter<'Portfolio'> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    translations?: PortfolioTranslationListRelationFilter
    metas?: PortfolioMetaListRelationFilter
    comments?: CommentListRelationFilter
    terms?: TermRelationshipListRelationFilter
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    translations?: PortfolioTranslationOrderByRelationAggregateInput
    metas?: PortfolioMetaOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    terms?: TermRelationshipOrderByRelationAggregateInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: PortfolioWhereInput | PortfolioWhereInput[]
      OR?: PortfolioWhereInput[]
      NOT?: PortfolioWhereInput | PortfolioWhereInput[]
      status?: EnumStatusFilter<'Portfolio'> | $Enums.Status
      authorId?: IntFilter<'Portfolio'> | number
      createdAt?: DateTimeFilter<'Portfolio'> | Date | string
      updatedAt?: DateTimeFilter<'Portfolio'> | Date | string
      author?: XOR<UserScalarRelationFilter, UserWhereInput>
      translations?: PortfolioTranslationListRelationFilter
      metas?: PortfolioMetaListRelationFilter
      comments?: CommentListRelationFilter
      terms?: TermRelationshipListRelationFilter
    },
    'id' | 'slug'
  >

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _avg?: PortfolioAvgOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
    _sum?: PortfolioSumOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Portfolio'> | number
    slug?: StringWithAggregatesFilter<'Portfolio'> | string
    status?: EnumStatusWithAggregatesFilter<'Portfolio'> | $Enums.Status
    authorId?: IntWithAggregatesFilter<'Portfolio'> | number
    createdAt?: DateTimeWithAggregatesFilter<'Portfolio'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Portfolio'> | Date | string
  }

  export type PortfolioTranslationWhereInput = {
    AND?: PortfolioTranslationWhereInput | PortfolioTranslationWhereInput[]
    OR?: PortfolioTranslationWhereInput[]
    NOT?: PortfolioTranslationWhereInput | PortfolioTranslationWhereInput[]
    id?: IntFilter<'PortfolioTranslation'> | number
    portfolioId?: IntFilter<'PortfolioTranslation'> | number
    lang?: StringFilter<'PortfolioTranslation'> | string
    title?: StringFilter<'PortfolioTranslation'> | string
    content?: StringFilter<'PortfolioTranslation'> | string
    excerpt?: StringNullableFilter<'PortfolioTranslation'> | string | null
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
  }

  export type PortfolioTranslationOrderByWithRelationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
  }

  export type PortfolioTranslationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      portfolioId_lang?: PortfolioTranslationPortfolioIdLangCompoundUniqueInput
      AND?: PortfolioTranslationWhereInput | PortfolioTranslationWhereInput[]
      OR?: PortfolioTranslationWhereInput[]
      NOT?: PortfolioTranslationWhereInput | PortfolioTranslationWhereInput[]
      portfolioId?: IntFilter<'PortfolioTranslation'> | number
      lang?: StringFilter<'PortfolioTranslation'> | string
      title?: StringFilter<'PortfolioTranslation'> | string
      content?: StringFilter<'PortfolioTranslation'> | string
      excerpt?: StringNullableFilter<'PortfolioTranslation'> | string | null
      portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    },
    'id' | 'portfolioId_lang'
  >

  export type PortfolioTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    _count?: PortfolioTranslationCountOrderByAggregateInput
    _avg?: PortfolioTranslationAvgOrderByAggregateInput
    _max?: PortfolioTranslationMaxOrderByAggregateInput
    _min?: PortfolioTranslationMinOrderByAggregateInput
    _sum?: PortfolioTranslationSumOrderByAggregateInput
  }

  export type PortfolioTranslationScalarWhereWithAggregatesInput = {
    AND?:
      | PortfolioTranslationScalarWhereWithAggregatesInput
      | PortfolioTranslationScalarWhereWithAggregatesInput[]
    OR?: PortfolioTranslationScalarWhereWithAggregatesInput[]
    NOT?:
      | PortfolioTranslationScalarWhereWithAggregatesInput
      | PortfolioTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'PortfolioTranslation'> | number
    portfolioId?: IntWithAggregatesFilter<'PortfolioTranslation'> | number
    lang?: StringWithAggregatesFilter<'PortfolioTranslation'> | string
    title?: StringWithAggregatesFilter<'PortfolioTranslation'> | string
    content?: StringWithAggregatesFilter<'PortfolioTranslation'> | string
    excerpt?: StringNullableWithAggregatesFilter<'PortfolioTranslation'> | string | null
  }

  export type PortfolioMetaWhereInput = {
    AND?: PortfolioMetaWhereInput | PortfolioMetaWhereInput[]
    OR?: PortfolioMetaWhereInput[]
    NOT?: PortfolioMetaWhereInput | PortfolioMetaWhereInput[]
    id?: IntFilter<'PortfolioMeta'> | number
    portfolioId?: IntFilter<'PortfolioMeta'> | number
    key?: StringFilter<'PortfolioMeta'> | string
    value?: JsonFilter<'PortfolioMeta'>
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
  }

  export type PortfolioMetaOrderByWithRelationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
  }

  export type PortfolioMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: PortfolioMetaWhereInput | PortfolioMetaWhereInput[]
      OR?: PortfolioMetaWhereInput[]
      NOT?: PortfolioMetaWhereInput | PortfolioMetaWhereInput[]
      portfolioId?: IntFilter<'PortfolioMeta'> | number
      key?: StringFilter<'PortfolioMeta'> | string
      value?: JsonFilter<'PortfolioMeta'>
      portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    },
    'id'
  >

  export type PortfolioMetaOrderByWithAggregationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: PortfolioMetaCountOrderByAggregateInput
    _avg?: PortfolioMetaAvgOrderByAggregateInput
    _max?: PortfolioMetaMaxOrderByAggregateInput
    _min?: PortfolioMetaMinOrderByAggregateInput
    _sum?: PortfolioMetaSumOrderByAggregateInput
  }

  export type PortfolioMetaScalarWhereWithAggregatesInput = {
    AND?:
      | PortfolioMetaScalarWhereWithAggregatesInput
      | PortfolioMetaScalarWhereWithAggregatesInput[]
    OR?: PortfolioMetaScalarWhereWithAggregatesInput[]
    NOT?:
      | PortfolioMetaScalarWhereWithAggregatesInput
      | PortfolioMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'PortfolioMeta'> | number
    portfolioId?: IntWithAggregatesFilter<'PortfolioMeta'> | number
    key?: StringWithAggregatesFilter<'PortfolioMeta'> | string
    value?: JsonWithAggregatesFilter<'PortfolioMeta'>
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<'Product'> | number
    slug?: StringFilter<'Product'> | string
    price?: FloatFilter<'Product'> | number
    currency?: StringFilter<'Product'> | string
    stock?: IntFilter<'Product'> | number
    vendorId?: IntFilter<'Product'> | number
    createdAt?: DateTimeFilter<'Product'> | Date | string
    updatedAt?: DateTimeFilter<'Product'> | Date | string
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    translations?: ProductTranslationListRelationFilter
    metas?: ProductMetaListRelationFilter
    comments?: CommentListRelationFilter
    terms?: TermRelationshipListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: UserOrderByWithRelationInput
    translations?: ProductTranslationOrderByRelationAggregateInput
    metas?: ProductMetaOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    terms?: TermRelationshipOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: ProductWhereInput | ProductWhereInput[]
      OR?: ProductWhereInput[]
      NOT?: ProductWhereInput | ProductWhereInput[]
      price?: FloatFilter<'Product'> | number
      currency?: StringFilter<'Product'> | string
      stock?: IntFilter<'Product'> | number
      vendorId?: IntFilter<'Product'> | number
      createdAt?: DateTimeFilter<'Product'> | Date | string
      updatedAt?: DateTimeFilter<'Product'> | Date | string
      vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
      translations?: ProductTranslationListRelationFilter
      metas?: ProductMetaListRelationFilter
      comments?: CommentListRelationFilter
      terms?: TermRelationshipListRelationFilter
    },
    'id' | 'slug'
  >

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Product'> | number
    slug?: StringWithAggregatesFilter<'Product'> | string
    price?: FloatWithAggregatesFilter<'Product'> | number
    currency?: StringWithAggregatesFilter<'Product'> | string
    stock?: IntWithAggregatesFilter<'Product'> | number
    vendorId?: IntWithAggregatesFilter<'Product'> | number
    createdAt?: DateTimeWithAggregatesFilter<'Product'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Product'> | Date | string
  }

  export type ProductTranslationWhereInput = {
    AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    OR?: ProductTranslationWhereInput[]
    NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    id?: IntFilter<'ProductTranslation'> | number
    productId?: IntFilter<'ProductTranslation'> | number
    lang?: StringFilter<'ProductTranslation'> | string
    title?: StringFilter<'ProductTranslation'> | string
    description?: StringFilter<'ProductTranslation'> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductTranslationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductTranslationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      productId_lang?: ProductTranslationProductIdLangCompoundUniqueInput
      AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
      OR?: ProductTranslationWhereInput[]
      NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
      productId?: IntFilter<'ProductTranslation'> | number
      lang?: StringFilter<'ProductTranslation'> | string
      title?: StringFilter<'ProductTranslation'> | string
      description?: StringFilter<'ProductTranslation'> | string
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    },
    'id' | 'productId_lang'
  >

  export type ProductTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: ProductTranslationCountOrderByAggregateInput
    _avg?: ProductTranslationAvgOrderByAggregateInput
    _max?: ProductTranslationMaxOrderByAggregateInput
    _min?: ProductTranslationMinOrderByAggregateInput
    _sum?: ProductTranslationSumOrderByAggregateInput
  }

  export type ProductTranslationScalarWhereWithAggregatesInput = {
    AND?:
      | ProductTranslationScalarWhereWithAggregatesInput
      | ProductTranslationScalarWhereWithAggregatesInput[]
    OR?: ProductTranslationScalarWhereWithAggregatesInput[]
    NOT?:
      | ProductTranslationScalarWhereWithAggregatesInput
      | ProductTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'ProductTranslation'> | number
    productId?: IntWithAggregatesFilter<'ProductTranslation'> | number
    lang?: StringWithAggregatesFilter<'ProductTranslation'> | string
    title?: StringWithAggregatesFilter<'ProductTranslation'> | string
    description?: StringWithAggregatesFilter<'ProductTranslation'> | string
  }

  export type ProductMetaWhereInput = {
    AND?: ProductMetaWhereInput | ProductMetaWhereInput[]
    OR?: ProductMetaWhereInput[]
    NOT?: ProductMetaWhereInput | ProductMetaWhereInput[]
    id?: IntFilter<'ProductMeta'> | number
    productId?: IntFilter<'ProductMeta'> | number
    key?: StringFilter<'ProductMeta'> | string
    value?: JsonFilter<'ProductMeta'>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductMetaOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: ProductMetaWhereInput | ProductMetaWhereInput[]
      OR?: ProductMetaWhereInput[]
      NOT?: ProductMetaWhereInput | ProductMetaWhereInput[]
      productId?: IntFilter<'ProductMeta'> | number
      key?: StringFilter<'ProductMeta'> | string
      value?: JsonFilter<'ProductMeta'>
      product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    },
    'id'
  >

  export type ProductMetaOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: ProductMetaCountOrderByAggregateInput
    _avg?: ProductMetaAvgOrderByAggregateInput
    _max?: ProductMetaMaxOrderByAggregateInput
    _min?: ProductMetaMinOrderByAggregateInput
    _sum?: ProductMetaSumOrderByAggregateInput
  }

  export type ProductMetaScalarWhereWithAggregatesInput = {
    AND?: ProductMetaScalarWhereWithAggregatesInput | ProductMetaScalarWhereWithAggregatesInput[]
    OR?: ProductMetaScalarWhereWithAggregatesInput[]
    NOT?: ProductMetaScalarWhereWithAggregatesInput | ProductMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'ProductMeta'> | number
    productId?: IntWithAggregatesFilter<'ProductMeta'> | number
    key?: StringWithAggregatesFilter<'ProductMeta'> | string
    value?: JsonWithAggregatesFilter<'ProductMeta'>
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<'Comment'> | number
    userId?: IntNullableFilter<'Comment'> | number | null
    pageId?: IntNullableFilter<'Comment'> | number | null
    articleId?: IntNullableFilter<'Comment'> | number | null
    portfolioId?: IntNullableFilter<'Comment'> | number | null
    productId?: IntNullableFilter<'Comment'> | number | null
    content?: StringFilter<'Comment'> | string
    status?: StringFilter<'Comment'> | string
    createdAt?: DateTimeFilter<'Comment'> | Date | string
    updatedAt?: DateTimeFilter<'Comment'> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
    article?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
    portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    metas?: CommentMetaListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    portfolioId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    page?: PageOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
    portfolio?: PortfolioOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    metas?: CommentMetaOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: CommentWhereInput | CommentWhereInput[]
      OR?: CommentWhereInput[]
      NOT?: CommentWhereInput | CommentWhereInput[]
      userId?: IntNullableFilter<'Comment'> | number | null
      pageId?: IntNullableFilter<'Comment'> | number | null
      articleId?: IntNullableFilter<'Comment'> | number | null
      portfolioId?: IntNullableFilter<'Comment'> | number | null
      productId?: IntNullableFilter<'Comment'> | number | null
      content?: StringFilter<'Comment'> | string
      status?: StringFilter<'Comment'> | string
      createdAt?: DateTimeFilter<'Comment'> | Date | string
      updatedAt?: DateTimeFilter<'Comment'> | Date | string
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
      page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
      article?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
      portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
      product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
      metas?: CommentMetaListRelationFilter
    },
    'id'
  >

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    articleId?: SortOrderInput | SortOrder
    portfolioId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Comment'> | number
    userId?: IntNullableWithAggregatesFilter<'Comment'> | number | null
    pageId?: IntNullableWithAggregatesFilter<'Comment'> | number | null
    articleId?: IntNullableWithAggregatesFilter<'Comment'> | number | null
    portfolioId?: IntNullableWithAggregatesFilter<'Comment'> | number | null
    productId?: IntNullableWithAggregatesFilter<'Comment'> | number | null
    content?: StringWithAggregatesFilter<'Comment'> | string
    status?: StringWithAggregatesFilter<'Comment'> | string
    createdAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string
  }

  export type CommentMetaWhereInput = {
    AND?: CommentMetaWhereInput | CommentMetaWhereInput[]
    OR?: CommentMetaWhereInput[]
    NOT?: CommentMetaWhereInput | CommentMetaWhereInput[]
    id?: IntFilter<'CommentMeta'> | number
    commentId?: IntFilter<'CommentMeta'> | number
    key?: StringFilter<'CommentMeta'> | string
    value?: JsonFilter<'CommentMeta'>
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }

  export type CommentMetaOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentMetaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: CommentMetaWhereInput | CommentMetaWhereInput[]
      OR?: CommentMetaWhereInput[]
      NOT?: CommentMetaWhereInput | CommentMetaWhereInput[]
      commentId?: IntFilter<'CommentMeta'> | number
      key?: StringFilter<'CommentMeta'> | string
      value?: JsonFilter<'CommentMeta'>
      comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    },
    'id'
  >

  export type CommentMetaOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: CommentMetaCountOrderByAggregateInput
    _avg?: CommentMetaAvgOrderByAggregateInput
    _max?: CommentMetaMaxOrderByAggregateInput
    _min?: CommentMetaMinOrderByAggregateInput
    _sum?: CommentMetaSumOrderByAggregateInput
  }

  export type CommentMetaScalarWhereWithAggregatesInput = {
    AND?: CommentMetaScalarWhereWithAggregatesInput | CommentMetaScalarWhereWithAggregatesInput[]
    OR?: CommentMetaScalarWhereWithAggregatesInput[]
    NOT?: CommentMetaScalarWhereWithAggregatesInput | CommentMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'CommentMeta'> | number
    commentId?: IntWithAggregatesFilter<'CommentMeta'> | number
    key?: StringWithAggregatesFilter<'CommentMeta'> | string
    value?: JsonWithAggregatesFilter<'CommentMeta'>
  }

  export type TermWhereInput = {
    AND?: TermWhereInput | TermWhereInput[]
    OR?: TermWhereInput[]
    NOT?: TermWhereInput | TermWhereInput[]
    id?: IntFilter<'Term'> | number
    slug?: StringFilter<'Term'> | string
    name?: StringFilter<'Term'> | string
    group?: IntFilter<'Term'> | number
    taxonomies?: TermTaxonomyListRelationFilter
  }

  export type TermOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    group?: SortOrder
    taxonomies?: TermTaxonomyOrderByRelationAggregateInput
  }

  export type TermWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: TermWhereInput | TermWhereInput[]
      OR?: TermWhereInput[]
      NOT?: TermWhereInput | TermWhereInput[]
      name?: StringFilter<'Term'> | string
      group?: IntFilter<'Term'> | number
      taxonomies?: TermTaxonomyListRelationFilter
    },
    'id' | 'slug'
  >

  export type TermOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    group?: SortOrder
    _count?: TermCountOrderByAggregateInput
    _avg?: TermAvgOrderByAggregateInput
    _max?: TermMaxOrderByAggregateInput
    _min?: TermMinOrderByAggregateInput
    _sum?: TermSumOrderByAggregateInput
  }

  export type TermScalarWhereWithAggregatesInput = {
    AND?: TermScalarWhereWithAggregatesInput | TermScalarWhereWithAggregatesInput[]
    OR?: TermScalarWhereWithAggregatesInput[]
    NOT?: TermScalarWhereWithAggregatesInput | TermScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Term'> | number
    slug?: StringWithAggregatesFilter<'Term'> | string
    name?: StringWithAggregatesFilter<'Term'> | string
    group?: IntWithAggregatesFilter<'Term'> | number
  }

  export type TermTaxonomyWhereInput = {
    AND?: TermTaxonomyWhereInput | TermTaxonomyWhereInput[]
    OR?: TermTaxonomyWhereInput[]
    NOT?: TermTaxonomyWhereInput | TermTaxonomyWhereInput[]
    id?: IntFilter<'TermTaxonomy'> | number
    termId?: IntFilter<'TermTaxonomy'> | number
    taxonomy?: StringFilter<'TermTaxonomy'> | string
    description?: StringNullableFilter<'TermTaxonomy'> | string | null
    parentId?: IntNullableFilter<'TermTaxonomy'> | number | null
    count?: IntFilter<'TermTaxonomy'> | number
    term?: XOR<TermScalarRelationFilter, TermWhereInput>
    parent?: XOR<TermTaxonomyNullableScalarRelationFilter, TermTaxonomyWhereInput> | null
    children?: TermTaxonomyListRelationFilter
    relationships?: TermRelationshipListRelationFilter
  }

  export type TermTaxonomyOrderByWithRelationInput = {
    id?: SortOrder
    termId?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    count?: SortOrder
    term?: TermOrderByWithRelationInput
    parent?: TermTaxonomyOrderByWithRelationInput
    children?: TermTaxonomyOrderByRelationAggregateInput
    relationships?: TermRelationshipOrderByRelationAggregateInput
  }

  export type TermTaxonomyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: TermTaxonomyWhereInput | TermTaxonomyWhereInput[]
      OR?: TermTaxonomyWhereInput[]
      NOT?: TermTaxonomyWhereInput | TermTaxonomyWhereInput[]
      termId?: IntFilter<'TermTaxonomy'> | number
      taxonomy?: StringFilter<'TermTaxonomy'> | string
      description?: StringNullableFilter<'TermTaxonomy'> | string | null
      parentId?: IntNullableFilter<'TermTaxonomy'> | number | null
      count?: IntFilter<'TermTaxonomy'> | number
      term?: XOR<TermScalarRelationFilter, TermWhereInput>
      parent?: XOR<TermTaxonomyNullableScalarRelationFilter, TermTaxonomyWhereInput> | null
      children?: TermTaxonomyListRelationFilter
      relationships?: TermRelationshipListRelationFilter
    },
    'id'
  >

  export type TermTaxonomyOrderByWithAggregationInput = {
    id?: SortOrder
    termId?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    count?: SortOrder
    _count?: TermTaxonomyCountOrderByAggregateInput
    _avg?: TermTaxonomyAvgOrderByAggregateInput
    _max?: TermTaxonomyMaxOrderByAggregateInput
    _min?: TermTaxonomyMinOrderByAggregateInput
    _sum?: TermTaxonomySumOrderByAggregateInput
  }

  export type TermTaxonomyScalarWhereWithAggregatesInput = {
    AND?: TermTaxonomyScalarWhereWithAggregatesInput | TermTaxonomyScalarWhereWithAggregatesInput[]
    OR?: TermTaxonomyScalarWhereWithAggregatesInput[]
    NOT?: TermTaxonomyScalarWhereWithAggregatesInput | TermTaxonomyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'TermTaxonomy'> | number
    termId?: IntWithAggregatesFilter<'TermTaxonomy'> | number
    taxonomy?: StringWithAggregatesFilter<'TermTaxonomy'> | string
    description?: StringNullableWithAggregatesFilter<'TermTaxonomy'> | string | null
    parentId?: IntNullableWithAggregatesFilter<'TermTaxonomy'> | number | null
    count?: IntWithAggregatesFilter<'TermTaxonomy'> | number
  }

  export type TermRelationshipWhereInput = {
    AND?: TermRelationshipWhereInput | TermRelationshipWhereInput[]
    OR?: TermRelationshipWhereInput[]
    NOT?: TermRelationshipWhereInput | TermRelationshipWhereInput[]
    id?: IntFilter<'TermRelationship'> | number
    articleId?: IntNullableFilter<'TermRelationship'> | number | null
    pageId?: IntNullableFilter<'TermRelationship'> | number | null
    portfolioId?: IntNullableFilter<'TermRelationship'> | number | null
    productId?: IntNullableFilter<'TermRelationship'> | number | null
    termTaxonomyId?: IntFilter<'TermRelationship'> | number
    article?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
    portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    termTaxonomy?: XOR<TermTaxonomyScalarRelationFilter, TermTaxonomyWhereInput>
  }

  export type TermRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    portfolioId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    termTaxonomyId?: SortOrder
    article?: ArticleOrderByWithRelationInput
    page?: PageOrderByWithRelationInput
    portfolio?: PortfolioOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    termTaxonomy?: TermTaxonomyOrderByWithRelationInput
  }

  export type TermRelationshipWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      AND?: TermRelationshipWhereInput | TermRelationshipWhereInput[]
      OR?: TermRelationshipWhereInput[]
      NOT?: TermRelationshipWhereInput | TermRelationshipWhereInput[]
      articleId?: IntNullableFilter<'TermRelationship'> | number | null
      pageId?: IntNullableFilter<'TermRelationship'> | number | null
      portfolioId?: IntNullableFilter<'TermRelationship'> | number | null
      productId?: IntNullableFilter<'TermRelationship'> | number | null
      termTaxonomyId?: IntFilter<'TermRelationship'> | number
      article?: XOR<ArticleNullableScalarRelationFilter, ArticleWhereInput> | null
      page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
      portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
      product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
      termTaxonomy?: XOR<TermTaxonomyScalarRelationFilter, TermTaxonomyWhereInput>
    },
    'id'
  >

  export type TermRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    portfolioId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    termTaxonomyId?: SortOrder
    _count?: TermRelationshipCountOrderByAggregateInput
    _avg?: TermRelationshipAvgOrderByAggregateInput
    _max?: TermRelationshipMaxOrderByAggregateInput
    _min?: TermRelationshipMinOrderByAggregateInput
    _sum?: TermRelationshipSumOrderByAggregateInput
  }

  export type TermRelationshipScalarWhereWithAggregatesInput = {
    AND?:
      | TermRelationshipScalarWhereWithAggregatesInput
      | TermRelationshipScalarWhereWithAggregatesInput[]
    OR?: TermRelationshipScalarWhereWithAggregatesInput[]
    NOT?:
      | TermRelationshipScalarWhereWithAggregatesInput
      | TermRelationshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'TermRelationship'> | number
    articleId?: IntNullableWithAggregatesFilter<'TermRelationship'> | number | null
    pageId?: IntNullableWithAggregatesFilter<'TermRelationship'> | number | null
    portfolioId?: IntNullableWithAggregatesFilter<'TermRelationship'> | number | null
    productId?: IntNullableWithAggregatesFilter<'TermRelationship'> | number | null
    termTaxonomyId?: IntWithAggregatesFilter<'TermRelationship'> | number
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: IntFilter<'Menu'> | number
    slug?: StringFilter<'Menu'> | string
    name?: StringFilter<'Menu'> | string
    items?: JsonFilter<'Menu'>
    createdAt?: DateTimeFilter<'Menu'> | Date | string
    updatedAt?: DateTimeFilter<'Menu'> | Date | string
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      slug?: string
      AND?: MenuWhereInput | MenuWhereInput[]
      OR?: MenuWhereInput[]
      NOT?: MenuWhereInput | MenuWhereInput[]
      name?: StringFilter<'Menu'> | string
      items?: JsonFilter<'Menu'>
      createdAt?: DateTimeFilter<'Menu'> | Date | string
      updatedAt?: DateTimeFilter<'Menu'> | Date | string
    },
    'id' | 'slug'
  >

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'Menu'> | number
    slug?: StringWithAggregatesFilter<'Menu'> | string
    name?: StringWithAggregatesFilter<'Menu'> | string
    items?: JsonWithAggregatesFilter<'Menu'>
    createdAt?: DateTimeWithAggregatesFilter<'Menu'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'Menu'> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    key?: StringFilter<'Setting'> | string
    value?: JsonFilter<'Setting'>
  }

  export type SettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<
    {
      key?: string
      AND?: SettingWhereInput | SettingWhereInput[]
      OR?: SettingWhereInput[]
      NOT?: SettingWhereInput | SettingWhereInput[]
      value?: JsonFilter<'Setting'>
    },
    'key'
  >

  export type SettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<'Setting'> | string
    value?: JsonWithAggregatesFilter<'Setting'>
  }

  export type UserCreateInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutMetasInput
  }

  export type UserMetaUncheckedCreateInput = {
    id?: number
    userId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutMetasNestedInput
  }

  export type UserMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaCreateManyInput = {
    id?: number
    userId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PageCreateInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationCreateInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
    page: PageCreateNestedOneWithoutTranslationsInput
  }

  export type PageTranslationUncheckedCreateInput = {
    id?: number
    pageId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PageTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    page?: PageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTranslationCreateManyInput = {
    id?: number
    pageId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PageTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    page: PageCreateNestedOneWithoutMetasInput
  }

  export type PageMetaUncheckedCreateInput = {
    id?: number
    pageId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    page?: PageUpdateOneRequiredWithoutMetasNestedInput
  }

  export type PageMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaCreateManyInput = {
    id?: number
    pageId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleCreateInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationCreateInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
    article: ArticleCreateNestedOneWithoutTranslationsInput
  }

  export type ArticleTranslationUncheckedCreateInput = {
    id?: number
    articleId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type ArticleTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    article?: ArticleUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ArticleTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationCreateManyInput = {
    id?: number
    articleId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type ArticleTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    article: ArticleCreateNestedOneWithoutMetasInput
  }

  export type ArticleMetaUncheckedCreateInput = {
    id?: number
    articleId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    article?: ArticleUpdateOneRequiredWithoutMetasNestedInput
  }

  export type ArticleMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaCreateManyInput = {
    id?: number
    articleId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioCreateInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPortfoliosInput
    translations?: PortfolioTranslationCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaCreateNestedManyWithoutPortfolioInput
    comments?: CommentCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: CommentUncheckedCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    translations?: PortfolioTranslationUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateManyInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTranslationCreateInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
    portfolio: PortfolioCreateNestedOneWithoutTranslationsInput
  }

  export type PortfolioTranslationUncheckedCreateInput = {
    id?: number
    portfolioId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PortfolioTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: PortfolioUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PortfolioTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioTranslationCreateManyInput = {
    id?: number
    portfolioId: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PortfolioTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    portfolio: PortfolioCreateNestedOneWithoutMetasInput
  }

  export type PortfolioMetaUncheckedCreateInput = {
    id?: number
    portfolioId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    portfolio?: PortfolioUpdateOneRequiredWithoutMetasNestedInput
  }

  export type PortfolioMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaCreateManyInput = {
    id?: number
    portfolioId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductCreateInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutProductsInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
    metas?: ProductMetaCreateNestedManyWithoutProductInput
    comments?: CommentCreateNestedManyWithoutProductInput
    terms?: TermRelationshipCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
    metas?: ProductMetaUncheckedCreateNestedManyWithoutProductInput
    comments?: CommentUncheckedCreateNestedManyWithoutProductInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUpdateManyWithoutProductNestedInput
    comments?: CommentUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUncheckedUpdateManyWithoutProductNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTranslationCreateInput = {
    lang: string
    title: string
    description: string
    product: ProductCreateNestedOneWithoutTranslationsInput
  }

  export type ProductTranslationUncheckedCreateInput = {
    id?: number
    productId: number
    lang: string
    title: string
    description: string
  }

  export type ProductTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationCreateManyInput = {
    id?: number
    productId: number
    lang: string
    title: string
    description: string
  }

  export type ProductTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    product: ProductCreateNestedOneWithoutMetasInput
  }

  export type ProductMetaUncheckedCreateInput = {
    id?: number
    productId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    product?: ProductUpdateOneRequiredWithoutMetasNestedInput
  }

  export type ProductMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaCreateManyInput = {
    id?: number
    productId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    page?: PageCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    page?: PageUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentMetaCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    comment: CommentCreateNestedOneWithoutMetasInput
  }

  export type CommentMetaUncheckedCreateInput = {
    id?: number
    commentId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    comment?: CommentUpdateOneRequiredWithoutMetasNestedInput
  }

  export type CommentMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaCreateManyInput = {
    id?: number
    commentId: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type TermCreateInput = {
    slug: string
    name: string
    group?: number
    taxonomies?: TermTaxonomyCreateNestedManyWithoutTermInput
  }

  export type TermUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    group?: number
    taxonomies?: TermTaxonomyUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
    taxonomies?: TermTaxonomyUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
    taxonomies?: TermTaxonomyUncheckedUpdateManyWithoutTermNestedInput
  }

  export type TermCreateManyInput = {
    id?: number
    slug: string
    name: string
    group?: number
  }

  export type TermUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
  }

  export type TermUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
  }

  export type TermTaxonomyCreateInput = {
    taxonomy: string
    description?: string | null
    count?: number
    term: TermCreateNestedOneWithoutTaxonomiesInput
    parent?: TermTaxonomyCreateNestedOneWithoutChildrenInput
    children?: TermTaxonomyCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyUncheckedCreateInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
    children?: TermTaxonomyUncheckedCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipUncheckedCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyUpdateInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    term?: TermUpdateOneRequiredWithoutTaxonomiesNestedInput
    parent?: TermTaxonomyUpdateOneWithoutChildrenNestedInput
    children?: TermTaxonomyUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    children?: TermTaxonomyUncheckedUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyCreateManyInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
  }

  export type TermTaxonomyUpdateManyMutationInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
  }

  export type TermTaxonomyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipCreateInput = {
    article?: ArticleCreateNestedOneWithoutTermsInput
    page?: PageCreateNestedOneWithoutTermsInput
    portfolio?: PortfolioCreateNestedOneWithoutTermsInput
    product?: ProductCreateNestedOneWithoutTermsInput
    termTaxonomy: TermTaxonomyCreateNestedOneWithoutRelationshipsInput
  }

  export type TermRelationshipUncheckedCreateInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipUpdateInput = {
    article?: ArticleUpdateOneWithoutTermsNestedInput
    page?: PageUpdateOneWithoutTermsNestedInput
    portfolio?: PortfolioUpdateOneWithoutTermsNestedInput
    product?: ProductUpdateOneWithoutTermsNestedInput
    termTaxonomy?: TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type TermRelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipCreateManyInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipUpdateManyMutationInput = {}

  export type TermRelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateInput = {
    slug: string
    name: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateManyInput = {
    id?: number
    slug: string
    name: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type SettingUncheckedCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type SettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type SettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type SettingCreateManyInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type SettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type SettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserMetaListRelationFilter = {
    every?: UserMetaWhereInput
    some?: UserMetaWhereInput
    none?: UserMetaWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type UserMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserMetaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type UserMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
  }

  export type UserMetaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
  }

  export type UserMetaSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PageNullableScalarRelationFilter = {
    is?: PageWhereInput | null
    isNot?: PageWhereInput | null
  }

  export type PageTranslationListRelationFilter = {
    every?: PageTranslationWhereInput
    some?: PageTranslationWhereInput
    none?: PageTranslationWhereInput
  }

  export type PageMetaListRelationFilter = {
    every?: PageMetaWhereInput
    some?: PageMetaWhereInput
    none?: PageMetaWhereInput
  }

  export type TermRelationshipListRelationFilter = {
    every?: TermRelationshipWhereInput
    some?: TermRelationshipWhereInput
    none?: TermRelationshipWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PageTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    menuOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    menuOrder?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    menuOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    menuOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    menuOrder?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PageScalarRelationFilter = {
    is?: PageWhereInput
    isNot?: PageWhereInput
  }

  export type PageTranslationPageIdLangCompoundUniqueInput = {
    pageId: number
    lang: string
  }

  export type PageTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PageTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type PageTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PageTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PageTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PageMetaCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PageMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type PageMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    key?: SortOrder
  }

  export type PageMetaMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    key?: SortOrder
  }

  export type PageMetaSumOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type ArticleNullableScalarRelationFilter = {
    is?: ArticleWhereInput | null
    isNot?: ArticleWhereInput | null
  }

  export type ArticleTranslationListRelationFilter = {
    every?: ArticleTranslationWhereInput
    some?: ArticleTranslationWhereInput
    none?: ArticleTranslationWhereInput
  }

  export type ArticleMetaListRelationFilter = {
    every?: ArticleMetaWhereInput
    some?: ArticleMetaWhereInput
    none?: ArticleMetaWhereInput
  }

  export type ArticleTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
  }

  export type ArticleScalarRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type ArticleTranslationArticleIdLangCompoundUniqueInput = {
    articleId: number
    lang: string
  }

  export type ArticleTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type ArticleTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type ArticleTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type ArticleTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleMetaCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type ArticleMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type ArticleMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    key?: SortOrder
  }

  export type ArticleMetaMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    key?: SortOrder
  }

  export type ArticleMetaSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type PortfolioTranslationListRelationFilter = {
    every?: PortfolioTranslationWhereInput
    some?: PortfolioTranslationWhereInput
    none?: PortfolioTranslationWhereInput
  }

  export type PortfolioMetaListRelationFilter = {
    every?: PortfolioMetaWhereInput
    some?: PortfolioMetaWhereInput
    none?: PortfolioMetaWhereInput
  }

  export type PortfolioTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PortfolioScalarRelationFilter = {
    is?: PortfolioWhereInput
    isNot?: PortfolioWhereInput
  }

  export type PortfolioTranslationPortfolioIdLangCompoundUniqueInput = {
    portfolioId: number
    lang: string
  }

  export type PortfolioTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PortfolioTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
  }

  export type PortfolioTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PortfolioTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
  }

  export type PortfolioTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
  }

  export type PortfolioMetaCountOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PortfolioMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
  }

  export type PortfolioMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    key?: SortOrder
  }

  export type PortfolioMetaMinOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    key?: SortOrder
  }

  export type PortfolioMetaSumOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductTranslationListRelationFilter = {
    every?: ProductTranslationWhereInput
    some?: ProductTranslationWhereInput
    none?: ProductTranslationWhereInput
  }

  export type ProductMetaListRelationFilter = {
    every?: ProductMetaWhereInput
    some?: ProductMetaWhereInput
    none?: ProductMetaWhereInput
  }

  export type ProductTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    vendorId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductTranslationProductIdLangCompoundUniqueInput = {
    productId: number
    lang: string
  }

  export type ProductTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductMetaCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type ProductMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    key?: SortOrder
  }

  export type ProductMetaMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    key?: SortOrder
  }

  export type ProductMetaSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PortfolioNullableScalarRelationFilter = {
    is?: PortfolioWhereInput | null
    isNot?: PortfolioWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type CommentMetaListRelationFilter = {
    every?: CommentMetaWhereInput
    some?: CommentMetaWhereInput
    none?: CommentMetaWhereInput
  }

  export type CommentMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pageId?: SortOrder
    articleId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentMetaCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type CommentMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type CommentMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    key?: SortOrder
  }

  export type CommentMetaMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    key?: SortOrder
  }

  export type CommentMetaSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
  }

  export type TermTaxonomyListRelationFilter = {
    every?: TermTaxonomyWhereInput
    some?: TermTaxonomyWhereInput
    none?: TermTaxonomyWhereInput
  }

  export type TermTaxonomyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    group?: SortOrder
  }

  export type TermAvgOrderByAggregateInput = {
    id?: SortOrder
    group?: SortOrder
  }

  export type TermMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    group?: SortOrder
  }

  export type TermMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    group?: SortOrder
  }

  export type TermSumOrderByAggregateInput = {
    id?: SortOrder
    group?: SortOrder
  }

  export type TermScalarRelationFilter = {
    is?: TermWhereInput
    isNot?: TermWhereInput
  }

  export type TermTaxonomyNullableScalarRelationFilter = {
    is?: TermTaxonomyWhereInput | null
    isNot?: TermTaxonomyWhereInput | null
  }

  export type TermTaxonomyCountOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    count?: SortOrder
  }

  export type TermTaxonomyAvgOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    parentId?: SortOrder
    count?: SortOrder
  }

  export type TermTaxonomyMaxOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    count?: SortOrder
  }

  export type TermTaxonomyMinOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    taxonomy?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    count?: SortOrder
  }

  export type TermTaxonomySumOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    parentId?: SortOrder
    count?: SortOrder
  }

  export type TermTaxonomyScalarRelationFilter = {
    is?: TermTaxonomyWhereInput
    isNot?: TermTaxonomyWhereInput
  }

  export type TermRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    pageId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    termTaxonomyId?: SortOrder
  }

  export type TermRelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    pageId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    termTaxonomyId?: SortOrder
  }

  export type TermRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    pageId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    termTaxonomyId?: SortOrder
  }

  export type TermRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    pageId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    termTaxonomyId?: SortOrder
  }

  export type TermRelationshipSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    pageId?: SortOrder
    portfolioId?: SortOrder
    productId?: SortOrder
    termTaxonomyId?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    key?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    key?: SortOrder
  }

  export type UserMetaCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
      | UserMetaCreateWithoutUserInput[]
      | UserMetaUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | UserMetaCreateOrConnectWithoutUserInput
      | UserMetaCreateOrConnectWithoutUserInput[]
    createMany?: UserMetaCreateManyUserInputEnvelope
    connect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
      | ArticleCreateWithoutAuthorInput[]
      | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutAuthorInput
      | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
      | PageCreateWithoutAuthorInput[]
      | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutAuthorInput
      | PageCreateOrConnectWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PortfolioCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
      | PortfolioCreateWithoutAuthorInput[]
      | PortfolioUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PortfolioCreateOrConnectWithoutAuthorInput
      | PortfolioCreateOrConnectWithoutAuthorInput[]
    createMany?: PortfolioCreateManyAuthorInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutVendorInput = {
    create?:
      | XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
      | ProductCreateWithoutVendorInput[]
      | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?:
      | ProductCreateOrConnectWithoutVendorInput
      | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserMetaUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
      | UserMetaCreateWithoutUserInput[]
      | UserMetaUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | UserMetaCreateOrConnectWithoutUserInput
      | UserMetaCreateOrConnectWithoutUserInput[]
    createMany?: UserMetaCreateManyUserInputEnvelope
    connect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
      | ArticleCreateWithoutAuthorInput[]
      | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutAuthorInput
      | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
      | PageCreateWithoutAuthorInput[]
      | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutAuthorInput
      | PageCreateOrConnectWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
      | PortfolioCreateWithoutAuthorInput[]
      | PortfolioUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PortfolioCreateOrConnectWithoutAuthorInput
      | PortfolioCreateOrConnectWithoutAuthorInput[]
    createMany?: PortfolioCreateManyAuthorInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutVendorInput = {
    create?:
      | XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
      | ProductCreateWithoutVendorInput[]
      | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?:
      | ProductCreateOrConnectWithoutVendorInput
      | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserMetaUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
      | UserMetaCreateWithoutUserInput[]
      | UserMetaUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | UserMetaCreateOrConnectWithoutUserInput
      | UserMetaCreateOrConnectWithoutUserInput[]
    upsert?:
      | UserMetaUpsertWithWhereUniqueWithoutUserInput
      | UserMetaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetaCreateManyUserInputEnvelope
    set?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    disconnect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    delete?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    connect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    update?:
      | UserMetaUpdateWithWhereUniqueWithoutUserInput
      | UserMetaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?:
      | UserMetaUpdateManyWithWhereWithoutUserInput
      | UserMetaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetaScalarWhereInput | UserMetaScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
      | ArticleCreateWithoutAuthorInput[]
      | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutAuthorInput
      | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | ArticleUpsertWithWhereUniqueWithoutAuthorInput
      | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?:
      | ArticleUpdateWithWhereUniqueWithoutAuthorInput
      | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | ArticleUpdateManyWithWhereWithoutAuthorInput
      | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type PageUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
      | PageCreateWithoutAuthorInput[]
      | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutAuthorInput
      | PageCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | PageUpsertWithWhereUniqueWithoutAuthorInput
      | PageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?:
      | PageUpdateWithWhereUniqueWithoutAuthorInput
      | PageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | PageUpdateManyWithWhereWithoutAuthorInput
      | PageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PortfolioUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
      | PortfolioCreateWithoutAuthorInput[]
      | PortfolioUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PortfolioCreateOrConnectWithoutAuthorInput
      | PortfolioCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | PortfolioUpsertWithWhereUniqueWithoutAuthorInput
      | PortfolioUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PortfolioCreateManyAuthorInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?:
      | PortfolioUpdateWithWhereUniqueWithoutAuthorInput
      | PortfolioUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | PortfolioUpdateManyWithWhereWithoutAuthorInput
      | PortfolioUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutVendorNestedInput = {
    create?:
      | XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
      | ProductCreateWithoutVendorInput[]
      | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?:
      | ProductCreateOrConnectWithoutVendorInput
      | ProductCreateOrConnectWithoutVendorInput[]
    upsert?:
      | ProductUpsertWithWhereUniqueWithoutVendorInput
      | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?:
      | ProductUpdateWithWhereUniqueWithoutVendorInput
      | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?:
      | ProductUpdateManyWithWhereWithoutVendorInput
      | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutUserInput
      | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutUserInput
      | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutUserInput
      | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserMetaUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
      | UserMetaCreateWithoutUserInput[]
      | UserMetaUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | UserMetaCreateOrConnectWithoutUserInput
      | UserMetaCreateOrConnectWithoutUserInput[]
    upsert?:
      | UserMetaUpsertWithWhereUniqueWithoutUserInput
      | UserMetaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetaCreateManyUserInputEnvelope
    set?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    disconnect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    delete?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    connect?: UserMetaWhereUniqueInput | UserMetaWhereUniqueInput[]
    update?:
      | UserMetaUpdateWithWhereUniqueWithoutUserInput
      | UserMetaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?:
      | UserMetaUpdateManyWithWhereWithoutUserInput
      | UserMetaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetaScalarWhereInput | UserMetaScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
      | ArticleCreateWithoutAuthorInput[]
      | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutAuthorInput
      | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | ArticleUpsertWithWhereUniqueWithoutAuthorInput
      | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?:
      | ArticleUpdateWithWhereUniqueWithoutAuthorInput
      | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | ArticleUpdateManyWithWhereWithoutAuthorInput
      | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
      | PageCreateWithoutAuthorInput[]
      | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutAuthorInput
      | PageCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | PageUpsertWithWhereUniqueWithoutAuthorInput
      | PageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?:
      | PageUpdateWithWhereUniqueWithoutAuthorInput
      | PageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | PageUpdateManyWithWhereWithoutAuthorInput
      | PageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
      | PortfolioCreateWithoutAuthorInput[]
      | PortfolioUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?:
      | PortfolioCreateOrConnectWithoutAuthorInput
      | PortfolioCreateOrConnectWithoutAuthorInput[]
    upsert?:
      | PortfolioUpsertWithWhereUniqueWithoutAuthorInput
      | PortfolioUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PortfolioCreateManyAuthorInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?:
      | PortfolioUpdateWithWhereUniqueWithoutAuthorInput
      | PortfolioUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?:
      | PortfolioUpdateManyWithWhereWithoutAuthorInput
      | PortfolioUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutVendorNestedInput = {
    create?:
      | XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
      | ProductCreateWithoutVendorInput[]
      | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?:
      | ProductCreateOrConnectWithoutVendorInput
      | ProductCreateOrConnectWithoutVendorInput[]
    upsert?:
      | ProductUpsertWithWhereUniqueWithoutVendorInput
      | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?:
      | ProductUpdateWithWhereUniqueWithoutVendorInput
      | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?:
      | ProductUpdateManyWithWhereWithoutVendorInput
      | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
      | CommentCreateWithoutUserInput[]
      | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutUserInput
      | CommentCreateOrConnectWithoutUserInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutUserInput
      | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutUserInput
      | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutUserInput
      | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMetasInput = {
    create?: XOR<UserCreateWithoutMetasInput, UserUncheckedCreateWithoutMetasInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetasInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<UserCreateWithoutMetasInput, UserUncheckedCreateWithoutMetasInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetasInput
    upsert?: UserUpsertWithoutMetasInput
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutMetasInput, UserUpdateWithoutMetasInput>,
      UserUncheckedUpdateWithoutMetasInput
    >
  }

  export type UserCreateNestedOneWithoutPagesInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    connect?: UserWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PageCreateOrConnectWithoutChildrenInput
    connect?: PageWhereUniqueInput
  }

  export type PageCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
      | PageCreateWithoutParentInput[]
      | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutParentInput
      | PageCreateOrConnectWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageTranslationCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
      | PageTranslationCreateWithoutPageInput[]
      | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageTranslationCreateOrConnectWithoutPageInput
      | PageTranslationCreateOrConnectWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type PageMetaCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
      | PageMetaCreateWithoutPageInput[]
      | PageMetaUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageMetaCreateOrConnectWithoutPageInput
      | PageMetaCreateOrConnectWithoutPageInput[]
    createMany?: PageMetaCreateManyPageInputEnvelope
    connect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
      | CommentCreateWithoutPageInput[]
      | CommentUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPageInput
      | CommentCreateOrConnectWithoutPageInput[]
    createMany?: CommentCreateManyPageInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<TermRelationshipCreateWithoutPageInput, TermRelationshipUncheckedCreateWithoutPageInput>
      | TermRelationshipCreateWithoutPageInput[]
      | TermRelationshipUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPageInput
      | TermRelationshipCreateOrConnectWithoutPageInput[]
    createMany?: TermRelationshipCreateManyPageInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
      | PageCreateWithoutParentInput[]
      | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutParentInput
      | PageCreateOrConnectWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageTranslationUncheckedCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
      | PageTranslationCreateWithoutPageInput[]
      | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageTranslationCreateOrConnectWithoutPageInput
      | PageTranslationCreateOrConnectWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
  }

  export type PageMetaUncheckedCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
      | PageMetaCreateWithoutPageInput[]
      | PageMetaUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageMetaCreateOrConnectWithoutPageInput
      | PageMetaCreateOrConnectWithoutPageInput[]
    createMany?: PageMetaCreateManyPageInputEnvelope
    connect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
      | CommentCreateWithoutPageInput[]
      | CommentUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPageInput
      | CommentCreateOrConnectWithoutPageInput[]
    createMany?: CommentCreateManyPageInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipUncheckedCreateNestedManyWithoutPageInput = {
    create?:
      | XOR<TermRelationshipCreateWithoutPageInput, TermRelationshipUncheckedCreateWithoutPageInput>
      | TermRelationshipCreateWithoutPageInput[]
      | TermRelationshipUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPageInput
      | TermRelationshipCreateOrConnectWithoutPageInput[]
    createMany?: TermRelationshipCreateManyPageInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type UserUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    upsert?: UserUpsertWithoutPagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutPagesInput, UserUpdateWithoutPagesInput>,
      UserUncheckedUpdateWithoutPagesInput
    >
  }

  export type PageUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PageCreateOrConnectWithoutChildrenInput
    upsert?: PageUpsertWithoutChildrenInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<
      XOR<PageUpdateToOneWithWhereWithoutChildrenInput, PageUpdateWithoutChildrenInput>,
      PageUncheckedUpdateWithoutChildrenInput
    >
  }

  export type PageUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
      | PageCreateWithoutParentInput[]
      | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutParentInput
      | PageCreateOrConnectWithoutParentInput[]
    upsert?:
      | PageUpsertWithWhereUniqueWithoutParentInput
      | PageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?:
      | PageUpdateWithWhereUniqueWithoutParentInput
      | PageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | PageUpdateManyWithWhereWithoutParentInput
      | PageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageTranslationUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
      | PageTranslationCreateWithoutPageInput[]
      | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageTranslationCreateOrConnectWithoutPageInput
      | PageTranslationCreateOrConnectWithoutPageInput[]
    upsert?:
      | PageTranslationUpsertWithWhereUniqueWithoutPageInput
      | PageTranslationUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?:
      | PageTranslationUpdateWithWhereUniqueWithoutPageInput
      | PageTranslationUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | PageTranslationUpdateManyWithWhereWithoutPageInput
      | PageTranslationUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type PageMetaUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
      | PageMetaCreateWithoutPageInput[]
      | PageMetaUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageMetaCreateOrConnectWithoutPageInput
      | PageMetaCreateOrConnectWithoutPageInput[]
    upsert?:
      | PageMetaUpsertWithWhereUniqueWithoutPageInput
      | PageMetaUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageMetaCreateManyPageInputEnvelope
    set?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    disconnect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    delete?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    connect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    update?:
      | PageMetaUpdateWithWhereUniqueWithoutPageInput
      | PageMetaUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | PageMetaUpdateManyWithWhereWithoutPageInput
      | PageMetaUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageMetaScalarWhereInput | PageMetaScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
      | CommentCreateWithoutPageInput[]
      | CommentUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPageInput
      | CommentCreateOrConnectWithoutPageInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutPageInput
      | CommentUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: CommentCreateManyPageInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutPageInput
      | CommentUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutPageInput
      | CommentUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<TermRelationshipCreateWithoutPageInput, TermRelationshipUncheckedCreateWithoutPageInput>
      | TermRelationshipCreateWithoutPageInput[]
      | TermRelationshipUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPageInput
      | TermRelationshipCreateOrConnectWithoutPageInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutPageInput
      | TermRelationshipUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: TermRelationshipCreateManyPageInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutPageInput
      | TermRelationshipUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutPageInput
      | TermRelationshipUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PageUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
      | PageCreateWithoutParentInput[]
      | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | PageCreateOrConnectWithoutParentInput
      | PageCreateOrConnectWithoutParentInput[]
    upsert?:
      | PageUpsertWithWhereUniqueWithoutParentInput
      | PageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?:
      | PageUpdateWithWhereUniqueWithoutParentInput
      | PageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | PageUpdateManyWithWhereWithoutParentInput
      | PageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageTranslationUncheckedUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<PageTranslationCreateWithoutPageInput, PageTranslationUncheckedCreateWithoutPageInput>
      | PageTranslationCreateWithoutPageInput[]
      | PageTranslationUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageTranslationCreateOrConnectWithoutPageInput
      | PageTranslationCreateOrConnectWithoutPageInput[]
    upsert?:
      | PageTranslationUpsertWithWhereUniqueWithoutPageInput
      | PageTranslationUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTranslationCreateManyPageInputEnvelope
    set?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    disconnect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    delete?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    connect?: PageTranslationWhereUniqueInput | PageTranslationWhereUniqueInput[]
    update?:
      | PageTranslationUpdateWithWhereUniqueWithoutPageInput
      | PageTranslationUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | PageTranslationUpdateManyWithWhereWithoutPageInput
      | PageTranslationUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
  }

  export type PageMetaUncheckedUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
      | PageMetaCreateWithoutPageInput[]
      | PageMetaUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | PageMetaCreateOrConnectWithoutPageInput
      | PageMetaCreateOrConnectWithoutPageInput[]
    upsert?:
      | PageMetaUpsertWithWhereUniqueWithoutPageInput
      | PageMetaUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageMetaCreateManyPageInputEnvelope
    set?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    disconnect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    delete?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    connect?: PageMetaWhereUniqueInput | PageMetaWhereUniqueInput[]
    update?:
      | PageMetaUpdateWithWhereUniqueWithoutPageInput
      | PageMetaUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | PageMetaUpdateManyWithWhereWithoutPageInput
      | PageMetaUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageMetaScalarWhereInput | PageMetaScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
      | CommentCreateWithoutPageInput[]
      | CommentUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPageInput
      | CommentCreateOrConnectWithoutPageInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutPageInput
      | CommentUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: CommentCreateManyPageInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutPageInput
      | CommentUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutPageInput
      | CommentUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUncheckedUpdateManyWithoutPageNestedInput = {
    create?:
      | XOR<TermRelationshipCreateWithoutPageInput, TermRelationshipUncheckedCreateWithoutPageInput>
      | TermRelationshipCreateWithoutPageInput[]
      | TermRelationshipUncheckedCreateWithoutPageInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPageInput
      | TermRelationshipCreateOrConnectWithoutPageInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutPageInput
      | TermRelationshipUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: TermRelationshipCreateManyPageInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutPageInput
      | TermRelationshipUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutPageInput
      | TermRelationshipUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type PageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTranslationsInput
    connect?: PageWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTranslationsInput
    upsert?: PageUpsertWithoutTranslationsInput
    connect?: PageWhereUniqueInput
    update?: XOR<
      XOR<PageUpdateToOneWithWhereWithoutTranslationsInput, PageUpdateWithoutTranslationsInput>,
      PageUncheckedUpdateWithoutTranslationsInput
    >
  }

  export type PageCreateNestedOneWithoutMetasInput = {
    create?: XOR<PageCreateWithoutMetasInput, PageUncheckedCreateWithoutMetasInput>
    connectOrCreate?: PageCreateOrConnectWithoutMetasInput
    connect?: PageWhereUniqueInput
  }

  export type PageUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<PageCreateWithoutMetasInput, PageUncheckedCreateWithoutMetasInput>
    connectOrCreate?: PageCreateOrConnectWithoutMetasInput
    upsert?: PageUpsertWithoutMetasInput
    connect?: PageWhereUniqueInput
    update?: XOR<
      XOR<PageUpdateToOneWithWhereWithoutMetasInput, PageUpdateWithoutMetasInput>,
      PageUncheckedUpdateWithoutMetasInput
    >
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ArticleCreateWithoutChildrenInput, ArticleUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutChildrenInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
      | ArticleCreateWithoutParentInput[]
      | ArticleUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutParentInput
      | ArticleCreateOrConnectWithoutParentInput[]
    createMany?: ArticleCreateManyParentInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleTranslationCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<
          ArticleTranslationCreateWithoutArticleInput,
          ArticleTranslationUncheckedCreateWithoutArticleInput
        >
      | ArticleTranslationCreateWithoutArticleInput[]
      | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleTranslationCreateOrConnectWithoutArticleInput
      | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type ArticleMetaCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
      | ArticleMetaCreateWithoutArticleInput[]
      | ArticleMetaUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleMetaCreateOrConnectWithoutArticleInput
      | ArticleMetaCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleMetaCreateManyArticleInputEnvelope
    connect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
      | CommentCreateWithoutArticleInput[]
      | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutArticleInput
      | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutArticleInput,
          TermRelationshipUncheckedCreateWithoutArticleInput
        >
      | TermRelationshipCreateWithoutArticleInput[]
      | TermRelationshipUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutArticleInput
      | TermRelationshipCreateOrConnectWithoutArticleInput[]
    createMany?: TermRelationshipCreateManyArticleInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
      | ArticleCreateWithoutParentInput[]
      | ArticleUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutParentInput
      | ArticleCreateOrConnectWithoutParentInput[]
    createMany?: ArticleCreateManyParentInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<
          ArticleTranslationCreateWithoutArticleInput,
          ArticleTranslationUncheckedCreateWithoutArticleInput
        >
      | ArticleTranslationCreateWithoutArticleInput[]
      | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleTranslationCreateOrConnectWithoutArticleInput
      | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
  }

  export type ArticleMetaUncheckedCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
      | ArticleMetaCreateWithoutArticleInput[]
      | ArticleMetaUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleMetaCreateOrConnectWithoutArticleInput
      | ArticleMetaCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleMetaCreateManyArticleInputEnvelope
    connect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
      | CommentCreateWithoutArticleInput[]
      | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutArticleInput
      | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipUncheckedCreateNestedManyWithoutArticleInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutArticleInput,
          TermRelationshipUncheckedCreateWithoutArticleInput
        >
      | TermRelationshipCreateWithoutArticleInput[]
      | TermRelationshipUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutArticleInput
      | TermRelationshipCreateOrConnectWithoutArticleInput[]
    createMany?: TermRelationshipCreateManyArticleInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutArticlesInput, UserUpdateWithoutArticlesInput>,
      UserUncheckedUpdateWithoutArticlesInput
    >
  }

  export type ArticleUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ArticleCreateWithoutChildrenInput, ArticleUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutChildrenInput
    upsert?: ArticleUpsertWithoutChildrenInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<
      XOR<ArticleUpdateToOneWithWhereWithoutChildrenInput, ArticleUpdateWithoutChildrenInput>,
      ArticleUncheckedUpdateWithoutChildrenInput
    >
  }

  export type ArticleUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
      | ArticleCreateWithoutParentInput[]
      | ArticleUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutParentInput
      | ArticleCreateOrConnectWithoutParentInput[]
    upsert?:
      | ArticleUpsertWithWhereUniqueWithoutParentInput
      | ArticleUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ArticleCreateManyParentInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?:
      | ArticleUpdateWithWhereUniqueWithoutParentInput
      | ArticleUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | ArticleUpdateManyWithWhereWithoutParentInput
      | ArticleUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleTranslationUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<
          ArticleTranslationCreateWithoutArticleInput,
          ArticleTranslationUncheckedCreateWithoutArticleInput
        >
      | ArticleTranslationCreateWithoutArticleInput[]
      | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleTranslationCreateOrConnectWithoutArticleInput
      | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    upsert?:
      | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput
      | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?:
      | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput
      | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | ArticleTranslationUpdateManyWithWhereWithoutArticleInput
      | ArticleTranslationUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type ArticleMetaUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
      | ArticleMetaCreateWithoutArticleInput[]
      | ArticleMetaUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleMetaCreateOrConnectWithoutArticleInput
      | ArticleMetaCreateOrConnectWithoutArticleInput[]
    upsert?:
      | ArticleMetaUpsertWithWhereUniqueWithoutArticleInput
      | ArticleMetaUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleMetaCreateManyArticleInputEnvelope
    set?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    disconnect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    delete?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    connect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    update?:
      | ArticleMetaUpdateWithWhereUniqueWithoutArticleInput
      | ArticleMetaUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | ArticleMetaUpdateManyWithWhereWithoutArticleInput
      | ArticleMetaUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleMetaScalarWhereInput | ArticleMetaScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
      | CommentCreateWithoutArticleInput[]
      | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutArticleInput
      | CommentCreateOrConnectWithoutArticleInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutArticleInput
      | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutArticleInput
      | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutArticleInput
      | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutArticleInput,
          TermRelationshipUncheckedCreateWithoutArticleInput
        >
      | TermRelationshipCreateWithoutArticleInput[]
      | TermRelationshipUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutArticleInput
      | TermRelationshipCreateOrConnectWithoutArticleInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutArticleInput
      | TermRelationshipUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: TermRelationshipCreateManyArticleInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutArticleInput
      | TermRelationshipUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutArticleInput
      | TermRelationshipUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
      | ArticleCreateWithoutParentInput[]
      | ArticleUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | ArticleCreateOrConnectWithoutParentInput
      | ArticleCreateOrConnectWithoutParentInput[]
    upsert?:
      | ArticleUpsertWithWhereUniqueWithoutParentInput
      | ArticleUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ArticleCreateManyParentInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?:
      | ArticleUpdateWithWhereUniqueWithoutParentInput
      | ArticleUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | ArticleUpdateManyWithWhereWithoutParentInput
      | ArticleUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<
          ArticleTranslationCreateWithoutArticleInput,
          ArticleTranslationUncheckedCreateWithoutArticleInput
        >
      | ArticleTranslationCreateWithoutArticleInput[]
      | ArticleTranslationUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleTranslationCreateOrConnectWithoutArticleInput
      | ArticleTranslationCreateOrConnectWithoutArticleInput[]
    upsert?:
      | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput
      | ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTranslationCreateManyArticleInputEnvelope
    set?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    disconnect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    delete?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    connect?: ArticleTranslationWhereUniqueInput | ArticleTranslationWhereUniqueInput[]
    update?:
      | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput
      | ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | ArticleTranslationUpdateManyWithWhereWithoutArticleInput
      | ArticleTranslationUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
  }

  export type ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
      | ArticleMetaCreateWithoutArticleInput[]
      | ArticleMetaUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | ArticleMetaCreateOrConnectWithoutArticleInput
      | ArticleMetaCreateOrConnectWithoutArticleInput[]
    upsert?:
      | ArticleMetaUpsertWithWhereUniqueWithoutArticleInput
      | ArticleMetaUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleMetaCreateManyArticleInputEnvelope
    set?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    disconnect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    delete?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    connect?: ArticleMetaWhereUniqueInput | ArticleMetaWhereUniqueInput[]
    update?:
      | ArticleMetaUpdateWithWhereUniqueWithoutArticleInput
      | ArticleMetaUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | ArticleMetaUpdateManyWithWhereWithoutArticleInput
      | ArticleMetaUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleMetaScalarWhereInput | ArticleMetaScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
      | CommentCreateWithoutArticleInput[]
      | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutArticleInput
      | CommentCreateOrConnectWithoutArticleInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutArticleInput
      | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutArticleInput
      | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutArticleInput
      | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutArticleInput,
          TermRelationshipUncheckedCreateWithoutArticleInput
        >
      | TermRelationshipCreateWithoutArticleInput[]
      | TermRelationshipUncheckedCreateWithoutArticleInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutArticleInput
      | TermRelationshipCreateOrConnectWithoutArticleInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutArticleInput
      | TermRelationshipUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: TermRelationshipCreateManyArticleInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutArticleInput
      | TermRelationshipUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutArticleInput
      | TermRelationshipUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type ArticleCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<
      ArticleCreateWithoutTranslationsInput,
      ArticleUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: ArticleCreateOrConnectWithoutTranslationsInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<
      ArticleCreateWithoutTranslationsInput,
      ArticleUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: ArticleCreateOrConnectWithoutTranslationsInput
    upsert?: ArticleUpsertWithoutTranslationsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<
      XOR<
        ArticleUpdateToOneWithWhereWithoutTranslationsInput,
        ArticleUpdateWithoutTranslationsInput
      >,
      ArticleUncheckedUpdateWithoutTranslationsInput
    >
  }

  export type ArticleCreateNestedOneWithoutMetasInput = {
    create?: XOR<ArticleCreateWithoutMetasInput, ArticleUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutMetasInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<ArticleCreateWithoutMetasInput, ArticleUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutMetasInput
    upsert?: ArticleUpsertWithoutMetasInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<
      XOR<ArticleUpdateToOneWithWhereWithoutMetasInput, ArticleUpdateWithoutMetasInput>,
      ArticleUncheckedUpdateWithoutMetasInput
    >
  }

  export type UserCreateNestedOneWithoutPortfoliosInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioTranslationCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          PortfolioTranslationCreateWithoutPortfolioInput,
          PortfolioTranslationUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioTranslationCreateWithoutPortfolioInput[]
      | PortfolioTranslationUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioTranslationCreateManyPortfolioInputEnvelope
    connect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
  }

  export type PortfolioMetaCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          PortfolioMetaCreateWithoutPortfolioInput,
          PortfolioMetaUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioMetaCreateWithoutPortfolioInput[]
      | PortfolioMetaUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioMetaCreateManyPortfolioInputEnvelope
    connect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
      | CommentCreateWithoutPortfolioInput[]
      | CommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPortfolioInput
      | CommentCreateOrConnectWithoutPortfolioInput[]
    createMany?: CommentCreateManyPortfolioInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutPortfolioInput,
          TermRelationshipUncheckedCreateWithoutPortfolioInput
        >
      | TermRelationshipCreateWithoutPortfolioInput[]
      | TermRelationshipUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPortfolioInput
      | TermRelationshipCreateOrConnectWithoutPortfolioInput[]
    createMany?: TermRelationshipCreateManyPortfolioInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          PortfolioTranslationCreateWithoutPortfolioInput,
          PortfolioTranslationUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioTranslationCreateWithoutPortfolioInput[]
      | PortfolioTranslationUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioTranslationCreateManyPortfolioInputEnvelope
    connect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
  }

  export type PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          PortfolioMetaCreateWithoutPortfolioInput,
          PortfolioMetaUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioMetaCreateWithoutPortfolioInput[]
      | PortfolioMetaUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioMetaCreateManyPortfolioInputEnvelope
    connect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
      | CommentCreateWithoutPortfolioInput[]
      | CommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPortfolioInput
      | CommentCreateOrConnectWithoutPortfolioInput[]
    createMany?: CommentCreateManyPortfolioInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutPortfolioInput,
          TermRelationshipUncheckedCreateWithoutPortfolioInput
        >
      | TermRelationshipCreateWithoutPortfolioInput[]
      | TermRelationshipUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPortfolioInput
      | TermRelationshipCreateOrConnectWithoutPortfolioInput[]
    createMany?: TermRelationshipCreateManyPortfolioInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPortfoliosNestedInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    upsert?: UserUpsertWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutPortfoliosInput, UserUpdateWithoutPortfoliosInput>,
      UserUncheckedUpdateWithoutPortfoliosInput
    >
  }

  export type PortfolioTranslationUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          PortfolioTranslationCreateWithoutPortfolioInput,
          PortfolioTranslationUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioTranslationCreateWithoutPortfolioInput[]
      | PortfolioTranslationUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | PortfolioTranslationUpsertWithWhereUniqueWithoutPortfolioInput
      | PortfolioTranslationUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioTranslationCreateManyPortfolioInputEnvelope
    set?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    disconnect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    delete?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    connect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    update?:
      | PortfolioTranslationUpdateWithWhereUniqueWithoutPortfolioInput
      | PortfolioTranslationUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | PortfolioTranslationUpdateManyWithWhereWithoutPortfolioInput
      | PortfolioTranslationUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioTranslationScalarWhereInput | PortfolioTranslationScalarWhereInput[]
  }

  export type PortfolioMetaUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          PortfolioMetaCreateWithoutPortfolioInput,
          PortfolioMetaUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioMetaCreateWithoutPortfolioInput[]
      | PortfolioMetaUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | PortfolioMetaUpsertWithWhereUniqueWithoutPortfolioInput
      | PortfolioMetaUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioMetaCreateManyPortfolioInputEnvelope
    set?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    disconnect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    delete?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    connect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    update?:
      | PortfolioMetaUpdateWithWhereUniqueWithoutPortfolioInput
      | PortfolioMetaUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | PortfolioMetaUpdateManyWithWhereWithoutPortfolioInput
      | PortfolioMetaUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioMetaScalarWhereInput | PortfolioMetaScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
      | CommentCreateWithoutPortfolioInput[]
      | CommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPortfolioInput
      | CommentCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutPortfolioInput
      | CommentUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: CommentCreateManyPortfolioInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutPortfolioInput
      | CommentUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutPortfolioInput
      | CommentUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutPortfolioInput,
          TermRelationshipUncheckedCreateWithoutPortfolioInput
        >
      | TermRelationshipCreateWithoutPortfolioInput[]
      | TermRelationshipUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPortfolioInput
      | TermRelationshipCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutPortfolioInput
      | TermRelationshipUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: TermRelationshipCreateManyPortfolioInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutPortfolioInput
      | TermRelationshipUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutPortfolioInput
      | TermRelationshipUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          PortfolioTranslationCreateWithoutPortfolioInput,
          PortfolioTranslationUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioTranslationCreateWithoutPortfolioInput[]
      | PortfolioTranslationUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput
      | PortfolioTranslationCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | PortfolioTranslationUpsertWithWhereUniqueWithoutPortfolioInput
      | PortfolioTranslationUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioTranslationCreateManyPortfolioInputEnvelope
    set?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    disconnect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    delete?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    connect?: PortfolioTranslationWhereUniqueInput | PortfolioTranslationWhereUniqueInput[]
    update?:
      | PortfolioTranslationUpdateWithWhereUniqueWithoutPortfolioInput
      | PortfolioTranslationUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | PortfolioTranslationUpdateManyWithWhereWithoutPortfolioInput
      | PortfolioTranslationUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioTranslationScalarWhereInput | PortfolioTranslationScalarWhereInput[]
  }

  export type PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          PortfolioMetaCreateWithoutPortfolioInput,
          PortfolioMetaUncheckedCreateWithoutPortfolioInput
        >
      | PortfolioMetaCreateWithoutPortfolioInput[]
      | PortfolioMetaUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput
      | PortfolioMetaCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | PortfolioMetaUpsertWithWhereUniqueWithoutPortfolioInput
      | PortfolioMetaUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioMetaCreateManyPortfolioInputEnvelope
    set?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    disconnect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    delete?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    connect?: PortfolioMetaWhereUniqueInput | PortfolioMetaWhereUniqueInput[]
    update?:
      | PortfolioMetaUpdateWithWhereUniqueWithoutPortfolioInput
      | PortfolioMetaUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | PortfolioMetaUpdateManyWithWhereWithoutPortfolioInput
      | PortfolioMetaUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioMetaScalarWhereInput | PortfolioMetaScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
      | CommentCreateWithoutPortfolioInput[]
      | CommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutPortfolioInput
      | CommentCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutPortfolioInput
      | CommentUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: CommentCreateManyPortfolioInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutPortfolioInput
      | CommentUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutPortfolioInput
      | CommentUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutPortfolioInput,
          TermRelationshipUncheckedCreateWithoutPortfolioInput
        >
      | TermRelationshipCreateWithoutPortfolioInput[]
      | TermRelationshipUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutPortfolioInput
      | TermRelationshipCreateOrConnectWithoutPortfolioInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutPortfolioInput
      | TermRelationshipUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: TermRelationshipCreateManyPortfolioInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutPortfolioInput
      | TermRelationshipUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutPortfolioInput
      | TermRelationshipUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type PortfolioCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<
      PortfolioCreateWithoutTranslationsInput,
      PortfolioUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: PortfolioCreateOrConnectWithoutTranslationsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<
      PortfolioCreateWithoutTranslationsInput,
      PortfolioUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: PortfolioCreateOrConnectWithoutTranslationsInput
    upsert?: PortfolioUpsertWithoutTranslationsInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<
      XOR<
        PortfolioUpdateToOneWithWhereWithoutTranslationsInput,
        PortfolioUpdateWithoutTranslationsInput
      >,
      PortfolioUncheckedUpdateWithoutTranslationsInput
    >
  }

  export type PortfolioCreateNestedOneWithoutMetasInput = {
    create?: XOR<PortfolioCreateWithoutMetasInput, PortfolioUncheckedCreateWithoutMetasInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutMetasInput
    connect?: PortfolioWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<PortfolioCreateWithoutMetasInput, PortfolioUncheckedCreateWithoutMetasInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutMetasInput
    upsert?: PortfolioUpsertWithoutMetasInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<
      XOR<PortfolioUpdateToOneWithWhereWithoutMetasInput, PortfolioUpdateWithoutMetasInput>,
      PortfolioUncheckedUpdateWithoutMetasInput
    >
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductTranslationCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          ProductTranslationCreateWithoutProductInput,
          ProductTranslationUncheckedCreateWithoutProductInput
        >
      | ProductTranslationCreateWithoutProductInput[]
      | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductTranslationCreateOrConnectWithoutProductInput
      | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductMetaCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
      | ProductMetaCreateWithoutProductInput[]
      | ProductMetaUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductMetaCreateOrConnectWithoutProductInput
      | ProductMetaCreateOrConnectWithoutProductInput[]
    createMany?: ProductMetaCreateManyProductInputEnvelope
    connect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
      | CommentCreateWithoutProductInput[]
      | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutProductInput
      | CommentCreateOrConnectWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutProductInput,
          TermRelationshipUncheckedCreateWithoutProductInput
        >
      | TermRelationshipCreateWithoutProductInput[]
      | TermRelationshipUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutProductInput
      | TermRelationshipCreateOrConnectWithoutProductInput[]
    createMany?: TermRelationshipCreateManyProductInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          ProductTranslationCreateWithoutProductInput,
          ProductTranslationUncheckedCreateWithoutProductInput
        >
      | ProductTranslationCreateWithoutProductInput[]
      | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductTranslationCreateOrConnectWithoutProductInput
      | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductMetaUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
      | ProductMetaCreateWithoutProductInput[]
      | ProductMetaUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductMetaCreateOrConnectWithoutProductInput
      | ProductMetaCreateOrConnectWithoutProductInput[]
    createMany?: ProductMetaCreateManyProductInputEnvelope
    connect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
      | CommentCreateWithoutProductInput[]
      | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutProductInput
      | CommentCreateOrConnectWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TermRelationshipUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutProductInput,
          TermRelationshipUncheckedCreateWithoutProductInput
        >
      | TermRelationshipCreateWithoutProductInput[]
      | TermRelationshipUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutProductInput
      | TermRelationshipCreateOrConnectWithoutProductInput[]
    createMany?: TermRelationshipCreateManyProductInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>,
      UserUncheckedUpdateWithoutProductsInput
    >
  }

  export type ProductTranslationUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          ProductTranslationCreateWithoutProductInput,
          ProductTranslationUncheckedCreateWithoutProductInput
        >
      | ProductTranslationCreateWithoutProductInput[]
      | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductTranslationCreateOrConnectWithoutProductInput
      | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?:
      | ProductTranslationUpsertWithWhereUniqueWithoutProductInput
      | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?:
      | ProductTranslationUpdateWithWhereUniqueWithoutProductInput
      | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | ProductTranslationUpdateManyWithWhereWithoutProductInput
      | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductMetaUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
      | ProductMetaCreateWithoutProductInput[]
      | ProductMetaUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductMetaCreateOrConnectWithoutProductInput
      | ProductMetaCreateOrConnectWithoutProductInput[]
    upsert?:
      | ProductMetaUpsertWithWhereUniqueWithoutProductInput
      | ProductMetaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMetaCreateManyProductInputEnvelope
    set?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    disconnect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    delete?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    connect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    update?:
      | ProductMetaUpdateWithWhereUniqueWithoutProductInput
      | ProductMetaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | ProductMetaUpdateManyWithWhereWithoutProductInput
      | ProductMetaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMetaScalarWhereInput | ProductMetaScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
      | CommentCreateWithoutProductInput[]
      | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutProductInput
      | CommentCreateOrConnectWithoutProductInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutProductInput
      | CommentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutProductInput
      | CommentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutProductInput
      | CommentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutProductInput,
          TermRelationshipUncheckedCreateWithoutProductInput
        >
      | TermRelationshipCreateWithoutProductInput[]
      | TermRelationshipUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutProductInput
      | TermRelationshipCreateOrConnectWithoutProductInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutProductInput
      | TermRelationshipUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TermRelationshipCreateManyProductInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutProductInput
      | TermRelationshipUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutProductInput
      | TermRelationshipUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          ProductTranslationCreateWithoutProductInput,
          ProductTranslationUncheckedCreateWithoutProductInput
        >
      | ProductTranslationCreateWithoutProductInput[]
      | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductTranslationCreateOrConnectWithoutProductInput
      | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?:
      | ProductTranslationUpsertWithWhereUniqueWithoutProductInput
      | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?:
      | ProductTranslationUpdateWithWhereUniqueWithoutProductInput
      | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | ProductTranslationUpdateManyWithWhereWithoutProductInput
      | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductMetaUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
      | ProductMetaCreateWithoutProductInput[]
      | ProductMetaUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | ProductMetaCreateOrConnectWithoutProductInput
      | ProductMetaCreateOrConnectWithoutProductInput[]
    upsert?:
      | ProductMetaUpsertWithWhereUniqueWithoutProductInput
      | ProductMetaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMetaCreateManyProductInputEnvelope
    set?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    disconnect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    delete?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    connect?: ProductMetaWhereUniqueInput | ProductMetaWhereUniqueInput[]
    update?:
      | ProductMetaUpdateWithWhereUniqueWithoutProductInput
      | ProductMetaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | ProductMetaUpdateManyWithWhereWithoutProductInput
      | ProductMetaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMetaScalarWhereInput | ProductMetaScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
      | CommentCreateWithoutProductInput[]
      | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | CommentCreateOrConnectWithoutProductInput
      | CommentCreateOrConnectWithoutProductInput[]
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutProductInput
      | CommentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?:
      | CommentUpdateWithWhereUniqueWithoutProductInput
      | CommentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | CommentUpdateManyWithWhereWithoutProductInput
      | CommentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TermRelationshipUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutProductInput,
          TermRelationshipUncheckedCreateWithoutProductInput
        >
      | TermRelationshipCreateWithoutProductInput[]
      | TermRelationshipUncheckedCreateWithoutProductInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutProductInput
      | TermRelationshipCreateOrConnectWithoutProductInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutProductInput
      | TermRelationshipUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TermRelationshipCreateManyProductInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutProductInput
      | TermRelationshipUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutProductInput
      | TermRelationshipUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<
      ProductCreateWithoutTranslationsInput,
      ProductUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<
      ProductCreateWithoutTranslationsInput,
      ProductUncheckedCreateWithoutTranslationsInput
    >
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    upsert?: ProductUpsertWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<
      XOR<
        ProductUpdateToOneWithWhereWithoutTranslationsInput,
        ProductUpdateWithoutTranslationsInput
      >,
      ProductUncheckedUpdateWithoutTranslationsInput
    >
  }

  export type ProductCreateNestedOneWithoutMetasInput = {
    create?: XOR<ProductCreateWithoutMetasInput, ProductUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMetasInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<ProductCreateWithoutMetasInput, ProductUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMetasInput
    upsert?: ProductUpsertWithoutMetasInput
    connect?: ProductWhereUniqueInput
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutMetasInput, ProductUpdateWithoutMetasInput>,
      ProductUncheckedUpdateWithoutMetasInput
    >
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PageCreateWithoutCommentsInput, PageUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PageCreateOrConnectWithoutCommentsInput
    connect?: PageWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    connect?: ArticleWhereUniqueInput
  }

  export type PortfolioCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutCommentsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommentsInput
    connect?: ProductWhereUniqueInput
  }

  export type CommentMetaCreateNestedManyWithoutCommentInput = {
    create?:
      | XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
      | CommentMetaCreateWithoutCommentInput[]
      | CommentMetaUncheckedCreateWithoutCommentInput[]
    connectOrCreate?:
      | CommentMetaCreateOrConnectWithoutCommentInput
      | CommentMetaCreateOrConnectWithoutCommentInput[]
    createMany?: CommentMetaCreateManyCommentInputEnvelope
    connect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
  }

  export type CommentMetaUncheckedCreateNestedManyWithoutCommentInput = {
    create?:
      | XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
      | CommentMetaCreateWithoutCommentInput[]
      | CommentMetaUncheckedCreateWithoutCommentInput[]
    connectOrCreate?:
      | CommentMetaCreateOrConnectWithoutCommentInput
      | CommentMetaCreateOrConnectWithoutCommentInput[]
    createMany?: CommentMetaCreateManyCommentInputEnvelope
    connect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>,
      UserUncheckedUpdateWithoutCommentsInput
    >
  }

  export type PageUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PageCreateWithoutCommentsInput, PageUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PageCreateOrConnectWithoutCommentsInput
    upsert?: PageUpsertWithoutCommentsInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<
      XOR<PageUpdateToOneWithWhereWithoutCommentsInput, PageUpdateWithoutCommentsInput>,
      PageUncheckedUpdateWithoutCommentsInput
    >
  }

  export type ArticleUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    upsert?: ArticleUpsertWithoutCommentsInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<
      XOR<ArticleUpdateToOneWithWhereWithoutCommentsInput, ArticleUpdateWithoutCommentsInput>,
      ArticleUncheckedUpdateWithoutCommentsInput
    >
  }

  export type PortfolioUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutCommentsInput
    upsert?: PortfolioUpsertWithoutCommentsInput
    disconnect?: PortfolioWhereInput | boolean
    delete?: PortfolioWhereInput | boolean
    connect?: PortfolioWhereUniqueInput
    update?: XOR<
      XOR<PortfolioUpdateToOneWithWhereWithoutCommentsInput, PortfolioUpdateWithoutCommentsInput>,
      PortfolioUncheckedUpdateWithoutCommentsInput
    >
  }

  export type ProductUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommentsInput
    upsert?: ProductUpsertWithoutCommentsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutCommentsInput, ProductUpdateWithoutCommentsInput>,
      ProductUncheckedUpdateWithoutCommentsInput
    >
  }

  export type CommentMetaUpdateManyWithoutCommentNestedInput = {
    create?:
      | XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
      | CommentMetaCreateWithoutCommentInput[]
      | CommentMetaUncheckedCreateWithoutCommentInput[]
    connectOrCreate?:
      | CommentMetaCreateOrConnectWithoutCommentInput
      | CommentMetaCreateOrConnectWithoutCommentInput[]
    upsert?:
      | CommentMetaUpsertWithWhereUniqueWithoutCommentInput
      | CommentMetaUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentMetaCreateManyCommentInputEnvelope
    set?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    disconnect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    delete?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    connect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    update?:
      | CommentMetaUpdateWithWhereUniqueWithoutCommentInput
      | CommentMetaUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?:
      | CommentMetaUpdateManyWithWhereWithoutCommentInput
      | CommentMetaUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentMetaScalarWhereInput | CommentMetaScalarWhereInput[]
  }

  export type CommentMetaUncheckedUpdateManyWithoutCommentNestedInput = {
    create?:
      | XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
      | CommentMetaCreateWithoutCommentInput[]
      | CommentMetaUncheckedCreateWithoutCommentInput[]
    connectOrCreate?:
      | CommentMetaCreateOrConnectWithoutCommentInput
      | CommentMetaCreateOrConnectWithoutCommentInput[]
    upsert?:
      | CommentMetaUpsertWithWhereUniqueWithoutCommentInput
      | CommentMetaUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentMetaCreateManyCommentInputEnvelope
    set?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    disconnect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    delete?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    connect?: CommentMetaWhereUniqueInput | CommentMetaWhereUniqueInput[]
    update?:
      | CommentMetaUpdateWithWhereUniqueWithoutCommentInput
      | CommentMetaUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?:
      | CommentMetaUpdateManyWithWhereWithoutCommentInput
      | CommentMetaUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentMetaScalarWhereInput | CommentMetaScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutMetasInput = {
    create?: XOR<CommentCreateWithoutMetasInput, CommentUncheckedCreateWithoutMetasInput>
    connectOrCreate?: CommentCreateOrConnectWithoutMetasInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutMetasNestedInput = {
    create?: XOR<CommentCreateWithoutMetasInput, CommentUncheckedCreateWithoutMetasInput>
    connectOrCreate?: CommentCreateOrConnectWithoutMetasInput
    upsert?: CommentUpsertWithoutMetasInput
    connect?: CommentWhereUniqueInput
    update?: XOR<
      XOR<CommentUpdateToOneWithWhereWithoutMetasInput, CommentUpdateWithoutMetasInput>,
      CommentUncheckedUpdateWithoutMetasInput
    >
  }

  export type TermTaxonomyCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
      | TermTaxonomyCreateWithoutTermInput[]
      | TermTaxonomyUncheckedCreateWithoutTermInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutTermInput
      | TermTaxonomyCreateOrConnectWithoutTermInput[]
    createMany?: TermTaxonomyCreateManyTermInputEnvelope
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
  }

  export type TermTaxonomyUncheckedCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
      | TermTaxonomyCreateWithoutTermInput[]
      | TermTaxonomyUncheckedCreateWithoutTermInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutTermInput
      | TermTaxonomyCreateOrConnectWithoutTermInput[]
    createMany?: TermTaxonomyCreateManyTermInputEnvelope
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
  }

  export type TermTaxonomyUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
      | TermTaxonomyCreateWithoutTermInput[]
      | TermTaxonomyUncheckedCreateWithoutTermInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutTermInput
      | TermTaxonomyCreateOrConnectWithoutTermInput[]
    upsert?:
      | TermTaxonomyUpsertWithWhereUniqueWithoutTermInput
      | TermTaxonomyUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TermTaxonomyCreateManyTermInputEnvelope
    set?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    disconnect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    delete?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    update?:
      | TermTaxonomyUpdateWithWhereUniqueWithoutTermInput
      | TermTaxonomyUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?:
      | TermTaxonomyUpdateManyWithWhereWithoutTermInput
      | TermTaxonomyUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
  }

  export type TermTaxonomyUncheckedUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
      | TermTaxonomyCreateWithoutTermInput[]
      | TermTaxonomyUncheckedCreateWithoutTermInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutTermInput
      | TermTaxonomyCreateOrConnectWithoutTermInput[]
    upsert?:
      | TermTaxonomyUpsertWithWhereUniqueWithoutTermInput
      | TermTaxonomyUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TermTaxonomyCreateManyTermInputEnvelope
    set?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    disconnect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    delete?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    update?:
      | TermTaxonomyUpdateWithWhereUniqueWithoutTermInput
      | TermTaxonomyUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?:
      | TermTaxonomyUpdateManyWithWhereWithoutTermInput
      | TermTaxonomyUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
  }

  export type TermCreateNestedOneWithoutTaxonomiesInput = {
    create?: XOR<TermCreateWithoutTaxonomiesInput, TermUncheckedCreateWithoutTaxonomiesInput>
    connectOrCreate?: TermCreateOrConnectWithoutTaxonomiesInput
    connect?: TermWhereUniqueInput
  }

  export type TermTaxonomyCreateNestedOneWithoutChildrenInput = {
    create?: XOR<
      TermTaxonomyCreateWithoutChildrenInput,
      TermTaxonomyUncheckedCreateWithoutChildrenInput
    >
    connectOrCreate?: TermTaxonomyCreateOrConnectWithoutChildrenInput
    connect?: TermTaxonomyWhereUniqueInput
  }

  export type TermTaxonomyCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
      | TermTaxonomyCreateWithoutParentInput[]
      | TermTaxonomyUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutParentInput
      | TermTaxonomyCreateOrConnectWithoutParentInput[]
    createMany?: TermTaxonomyCreateManyParentInputEnvelope
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
  }

  export type TermRelationshipCreateNestedManyWithoutTermTaxonomyInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutTermTaxonomyInput,
          TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
        >
      | TermRelationshipCreateWithoutTermTaxonomyInput[]
      | TermRelationshipUncheckedCreateWithoutTermTaxonomyInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput[]
    createMany?: TermRelationshipCreateManyTermTaxonomyInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type TermTaxonomyUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
      | TermTaxonomyCreateWithoutParentInput[]
      | TermTaxonomyUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutParentInput
      | TermTaxonomyCreateOrConnectWithoutParentInput[]
    createMany?: TermTaxonomyCreateManyParentInputEnvelope
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
  }

  export type TermRelationshipUncheckedCreateNestedManyWithoutTermTaxonomyInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutTermTaxonomyInput,
          TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
        >
      | TermRelationshipCreateWithoutTermTaxonomyInput[]
      | TermRelationshipUncheckedCreateWithoutTermTaxonomyInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput[]
    createMany?: TermRelationshipCreateManyTermTaxonomyInputEnvelope
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
  }

  export type TermUpdateOneRequiredWithoutTaxonomiesNestedInput = {
    create?: XOR<TermCreateWithoutTaxonomiesInput, TermUncheckedCreateWithoutTaxonomiesInput>
    connectOrCreate?: TermCreateOrConnectWithoutTaxonomiesInput
    upsert?: TermUpsertWithoutTaxonomiesInput
    connect?: TermWhereUniqueInput
    update?: XOR<
      XOR<TermUpdateToOneWithWhereWithoutTaxonomiesInput, TermUpdateWithoutTaxonomiesInput>,
      TermUncheckedUpdateWithoutTaxonomiesInput
    >
  }

  export type TermTaxonomyUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<
      TermTaxonomyCreateWithoutChildrenInput,
      TermTaxonomyUncheckedCreateWithoutChildrenInput
    >
    connectOrCreate?: TermTaxonomyCreateOrConnectWithoutChildrenInput
    upsert?: TermTaxonomyUpsertWithoutChildrenInput
    disconnect?: TermTaxonomyWhereInput | boolean
    delete?: TermTaxonomyWhereInput | boolean
    connect?: TermTaxonomyWhereUniqueInput
    update?: XOR<
      XOR<
        TermTaxonomyUpdateToOneWithWhereWithoutChildrenInput,
        TermTaxonomyUpdateWithoutChildrenInput
      >,
      TermTaxonomyUncheckedUpdateWithoutChildrenInput
    >
  }

  export type TermTaxonomyUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
      | TermTaxonomyCreateWithoutParentInput[]
      | TermTaxonomyUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutParentInput
      | TermTaxonomyCreateOrConnectWithoutParentInput[]
    upsert?:
      | TermTaxonomyUpsertWithWhereUniqueWithoutParentInput
      | TermTaxonomyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TermTaxonomyCreateManyParentInputEnvelope
    set?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    disconnect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    delete?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    update?:
      | TermTaxonomyUpdateWithWhereUniqueWithoutParentInput
      | TermTaxonomyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | TermTaxonomyUpdateManyWithWhereWithoutParentInput
      | TermTaxonomyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
  }

  export type TermRelationshipUpdateManyWithoutTermTaxonomyNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutTermTaxonomyInput,
          TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
        >
      | TermRelationshipCreateWithoutTermTaxonomyInput[]
      | TermRelationshipUncheckedCreateWithoutTermTaxonomyInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutTermTaxonomyInput
      | TermRelationshipUpsertWithWhereUniqueWithoutTermTaxonomyInput[]
    createMany?: TermRelationshipCreateManyTermTaxonomyInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutTermTaxonomyInput
      | TermRelationshipUpdateWithWhereUniqueWithoutTermTaxonomyInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutTermTaxonomyInput
      | TermRelationshipUpdateManyWithWhereWithoutTermTaxonomyInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type TermTaxonomyUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
      | TermTaxonomyCreateWithoutParentInput[]
      | TermTaxonomyUncheckedCreateWithoutParentInput[]
    connectOrCreate?:
      | TermTaxonomyCreateOrConnectWithoutParentInput
      | TermTaxonomyCreateOrConnectWithoutParentInput[]
    upsert?:
      | TermTaxonomyUpsertWithWhereUniqueWithoutParentInput
      | TermTaxonomyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TermTaxonomyCreateManyParentInputEnvelope
    set?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    disconnect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    delete?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    connect?: TermTaxonomyWhereUniqueInput | TermTaxonomyWhereUniqueInput[]
    update?:
      | TermTaxonomyUpdateWithWhereUniqueWithoutParentInput
      | TermTaxonomyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?:
      | TermTaxonomyUpdateManyWithWhereWithoutParentInput
      | TermTaxonomyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
  }

  export type TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyNestedInput = {
    create?:
      | XOR<
          TermRelationshipCreateWithoutTermTaxonomyInput,
          TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
        >
      | TermRelationshipCreateWithoutTermTaxonomyInput[]
      | TermRelationshipUncheckedCreateWithoutTermTaxonomyInput[]
    connectOrCreate?:
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput
      | TermRelationshipCreateOrConnectWithoutTermTaxonomyInput[]
    upsert?:
      | TermRelationshipUpsertWithWhereUniqueWithoutTermTaxonomyInput
      | TermRelationshipUpsertWithWhereUniqueWithoutTermTaxonomyInput[]
    createMany?: TermRelationshipCreateManyTermTaxonomyInputEnvelope
    set?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    disconnect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    delete?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    connect?: TermRelationshipWhereUniqueInput | TermRelationshipWhereUniqueInput[]
    update?:
      | TermRelationshipUpdateWithWhereUniqueWithoutTermTaxonomyInput
      | TermRelationshipUpdateWithWhereUniqueWithoutTermTaxonomyInput[]
    updateMany?:
      | TermRelationshipUpdateManyWithWhereWithoutTermTaxonomyInput
      | TermRelationshipUpdateManyWithWhereWithoutTermTaxonomyInput[]
    deleteMany?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
  }

  export type ArticleCreateNestedOneWithoutTermsInput = {
    create?: XOR<ArticleCreateWithoutTermsInput, ArticleUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTermsInput
    connect?: ArticleWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutTermsInput = {
    create?: XOR<PageCreateWithoutTermsInput, PageUncheckedCreateWithoutTermsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTermsInput
    connect?: PageWhereUniqueInput
  }

  export type PortfolioCreateNestedOneWithoutTermsInput = {
    create?: XOR<PortfolioCreateWithoutTermsInput, PortfolioUncheckedCreateWithoutTermsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutTermsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTermsInput = {
    create?: XOR<ProductCreateWithoutTermsInput, ProductUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTermsInput
    connect?: ProductWhereUniqueInput
  }

  export type TermTaxonomyCreateNestedOneWithoutRelationshipsInput = {
    create?: XOR<
      TermTaxonomyCreateWithoutRelationshipsInput,
      TermTaxonomyUncheckedCreateWithoutRelationshipsInput
    >
    connectOrCreate?: TermTaxonomyCreateOrConnectWithoutRelationshipsInput
    connect?: TermTaxonomyWhereUniqueInput
  }

  export type ArticleUpdateOneWithoutTermsNestedInput = {
    create?: XOR<ArticleCreateWithoutTermsInput, ArticleUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTermsInput
    upsert?: ArticleUpsertWithoutTermsInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<
      XOR<ArticleUpdateToOneWithWhereWithoutTermsInput, ArticleUpdateWithoutTermsInput>,
      ArticleUncheckedUpdateWithoutTermsInput
    >
  }

  export type PageUpdateOneWithoutTermsNestedInput = {
    create?: XOR<PageCreateWithoutTermsInput, PageUncheckedCreateWithoutTermsInput>
    connectOrCreate?: PageCreateOrConnectWithoutTermsInput
    upsert?: PageUpsertWithoutTermsInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<
      XOR<PageUpdateToOneWithWhereWithoutTermsInput, PageUpdateWithoutTermsInput>,
      PageUncheckedUpdateWithoutTermsInput
    >
  }

  export type PortfolioUpdateOneWithoutTermsNestedInput = {
    create?: XOR<PortfolioCreateWithoutTermsInput, PortfolioUncheckedCreateWithoutTermsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutTermsInput
    upsert?: PortfolioUpsertWithoutTermsInput
    disconnect?: PortfolioWhereInput | boolean
    delete?: PortfolioWhereInput | boolean
    connect?: PortfolioWhereUniqueInput
    update?: XOR<
      XOR<PortfolioUpdateToOneWithWhereWithoutTermsInput, PortfolioUpdateWithoutTermsInput>,
      PortfolioUncheckedUpdateWithoutTermsInput
    >
  }

  export type ProductUpdateOneWithoutTermsNestedInput = {
    create?: XOR<ProductCreateWithoutTermsInput, ProductUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTermsInput
    upsert?: ProductUpsertWithoutTermsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<
      XOR<ProductUpdateToOneWithWhereWithoutTermsInput, ProductUpdateWithoutTermsInput>,
      ProductUncheckedUpdateWithoutTermsInput
    >
  }

  export type TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput = {
    create?: XOR<
      TermTaxonomyCreateWithoutRelationshipsInput,
      TermTaxonomyUncheckedCreateWithoutRelationshipsInput
    >
    connectOrCreate?: TermTaxonomyCreateOrConnectWithoutRelationshipsInput
    upsert?: TermTaxonomyUpsertWithoutRelationshipsInput
    connect?: TermTaxonomyWhereUniqueInput
    update?: XOR<
      XOR<
        TermTaxonomyUpdateToOneWithWhereWithoutRelationshipsInput,
        TermTaxonomyUpdateWithoutRelationshipsInput
      >,
      TermTaxonomyUncheckedUpdateWithoutRelationshipsInput
    >
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserMetaCreateWithoutUserInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUncheckedCreateWithoutUserInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaCreateOrConnectWithoutUserInput = {
    where: UserMetaWhereUniqueInput
    create: XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
  }

  export type UserMetaCreateManyUserInputEnvelope = {
    data: UserMetaCreateManyUserInput | UserMetaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutAuthorInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleCreateManyAuthorInputEnvelope = {
    data: ArticleCreateManyAuthorInput | ArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutAuthorInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutAuthorInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
  }

  export type PageCreateManyAuthorInputEnvelope = {
    data: PageCreateManyAuthorInput | PageCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCreateWithoutAuthorInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaCreateNestedManyWithoutPortfolioInput
    comments?: CommentCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: CommentUncheckedCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutAuthorInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
  }

  export type PortfolioCreateManyAuthorInputEnvelope = {
    data: PortfolioCreateManyAuthorInput | PortfolioCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutVendorInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
    metas?: ProductMetaCreateNestedManyWithoutProductInput
    comments?: CommentCreateNestedManyWithoutProductInput
    terms?: TermRelationshipCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVendorInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
    metas?: ProductMetaUncheckedCreateNestedManyWithoutProductInput
    comments?: CommentUncheckedCreateNestedManyWithoutProductInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVendorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductCreateManyVendorInputEnvelope = {
    data: ProductCreateManyVendorInput | ProductCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    page?: PageCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserMetaUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMetaWhereUniqueInput
    update: XOR<UserMetaUpdateWithoutUserInput, UserMetaUncheckedUpdateWithoutUserInput>
    create: XOR<UserMetaCreateWithoutUserInput, UserMetaUncheckedCreateWithoutUserInput>
  }

  export type UserMetaUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMetaWhereUniqueInput
    data: XOR<UserMetaUpdateWithoutUserInput, UserMetaUncheckedUpdateWithoutUserInput>
  }

  export type UserMetaUpdateManyWithWhereWithoutUserInput = {
    where: UserMetaScalarWhereInput
    data: XOR<UserMetaUpdateManyMutationInput, UserMetaUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMetaScalarWhereInput = {
    AND?: UserMetaScalarWhereInput | UserMetaScalarWhereInput[]
    OR?: UserMetaScalarWhereInput[]
    NOT?: UserMetaScalarWhereInput | UserMetaScalarWhereInput[]
    id?: IntFilter<'UserMeta'> | number
    userId?: IntFilter<'UserMeta'> | number
    key?: StringFilter<'UserMeta'> | string
    value?: JsonFilter<'UserMeta'>
  }

  export type ArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: IntFilter<'Article'> | number
    slug?: StringFilter<'Article'> | string
    status?: EnumStatusFilter<'Article'> | $Enums.Status
    authorId?: IntFilter<'Article'> | number
    parentId?: IntNullableFilter<'Article'> | number | null
    createdAt?: DateTimeFilter<'Article'> | Date | string
    updatedAt?: DateTimeFilter<'Article'> | Date | string
  }

  export type PageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutAuthorInput, PageUncheckedUpdateWithoutAuthorInput>
    create: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
  }

  export type PageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutAuthorInput, PageUncheckedUpdateWithoutAuthorInput>
  }

  export type PageUpdateManyWithWhereWithoutAuthorInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: IntFilter<'Page'> | number
    slug?: StringFilter<'Page'> | string
    status?: EnumStatusFilter<'Page'> | $Enums.Status
    authorId?: IntFilter<'Page'> | number
    parentId?: IntNullableFilter<'Page'> | number | null
    menuOrder?: IntFilter<'Page'> | number
    createdAt?: DateTimeFilter<'Page'> | Date | string
    updatedAt?: DateTimeFilter<'Page'> | Date | string
  }

  export type PortfolioUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutAuthorInput, PortfolioUncheckedUpdateWithoutAuthorInput>
    create: XOR<PortfolioCreateWithoutAuthorInput, PortfolioUncheckedCreateWithoutAuthorInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutAuthorInput, PortfolioUncheckedUpdateWithoutAuthorInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutAuthorInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: IntFilter<'Portfolio'> | number
    slug?: StringFilter<'Portfolio'> | string
    status?: EnumStatusFilter<'Portfolio'> | $Enums.Status
    authorId?: IntFilter<'Portfolio'> | number
    createdAt?: DateTimeFilter<'Portfolio'> | Date | string
    updatedAt?: DateTimeFilter<'Portfolio'> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
  }

  export type ProductUpdateManyWithWhereWithoutVendorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVendorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<'Product'> | number
    slug?: StringFilter<'Product'> | string
    price?: FloatFilter<'Product'> | number
    currency?: StringFilter<'Product'> | string
    stock?: IntFilter<'Product'> | number
    vendorId?: IntFilter<'Product'> | number
    createdAt?: DateTimeFilter<'Product'> | Date | string
    updatedAt?: DateTimeFilter<'Product'> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<'Comment'> | number
    userId?: IntNullableFilter<'Comment'> | number | null
    pageId?: IntNullableFilter<'Comment'> | number | null
    articleId?: IntNullableFilter<'Comment'> | number | null
    portfolioId?: IntNullableFilter<'Comment'> | number | null
    productId?: IntNullableFilter<'Comment'> | number | null
    content?: StringFilter<'Comment'> | string
    status?: StringFilter<'Comment'> | string
    createdAt?: DateTimeFilter<'Comment'> | Date | string
    updatedAt?: DateTimeFilter<'Comment'> | Date | string
  }

  export type UserCreateWithoutMetasInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMetasInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMetasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMetasInput, UserUncheckedCreateWithoutMetasInput>
  }

  export type UserUpsertWithoutMetasInput = {
    update: XOR<UserUpdateWithoutMetasInput, UserUncheckedUpdateWithoutMetasInput>
    create: XOR<UserCreateWithoutMetasInput, UserUncheckedCreateWithoutMetasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMetasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMetasInput, UserUncheckedUpdateWithoutMetasInput>
  }

  export type UserUpdateWithoutMetasInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPagesInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPagesInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
  }

  export type PageCreateWithoutChildrenInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutChildrenInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutChildrenInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
  }

  export type PageCreateWithoutParentInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutParentInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutParentInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
  }

  export type PageCreateManyParentInputEnvelope = {
    data: PageCreateManyParentInput | PageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PageTranslationCreateWithoutPageInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PageTranslationUncheckedCreateWithoutPageInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PageTranslationCreateOrConnectWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    create: XOR<
      PageTranslationCreateWithoutPageInput,
      PageTranslationUncheckedCreateWithoutPageInput
    >
  }

  export type PageTranslationCreateManyPageInputEnvelope = {
    data: PageTranslationCreateManyPageInput | PageTranslationCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type PageMetaCreateWithoutPageInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUncheckedCreateWithoutPageInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaCreateOrConnectWithoutPageInput = {
    where: PageMetaWhereUniqueInput
    create: XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
  }

  export type PageMetaCreateManyPageInputEnvelope = {
    data: PageMetaCreateManyPageInput | PageMetaCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPageInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPageInput = {
    id?: number
    userId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPageInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
  }

  export type CommentCreateManyPageInputEnvelope = {
    data: CommentCreateManyPageInput | CommentCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type TermRelationshipCreateWithoutPageInput = {
    article?: ArticleCreateNestedOneWithoutTermsInput
    portfolio?: PortfolioCreateNestedOneWithoutTermsInput
    product?: ProductCreateNestedOneWithoutTermsInput
    termTaxonomy: TermTaxonomyCreateNestedOneWithoutRelationshipsInput
  }

  export type TermRelationshipUncheckedCreateWithoutPageInput = {
    id?: number
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipCreateOrConnectWithoutPageInput = {
    where: TermRelationshipWhereUniqueInput
    create: XOR<
      TermRelationshipCreateWithoutPageInput,
      TermRelationshipUncheckedCreateWithoutPageInput
    >
  }

  export type TermRelationshipCreateManyPageInputEnvelope = {
    data: TermRelationshipCreateManyPageInput | TermRelationshipCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPagesInput = {
    update: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
  }

  export type UserUpdateWithoutPagesInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PageUpsertWithoutChildrenInput = {
    update: XOR<PageUpdateWithoutChildrenInput, PageUncheckedUpdateWithoutChildrenInput>
    create: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutChildrenInput, PageUncheckedUpdateWithoutChildrenInput>
  }

  export type PageUpdateWithoutChildrenInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUpsertWithWhereUniqueWithoutParentInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutParentInput, PageUncheckedUpdateWithoutParentInput>
    create: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
  }

  export type PageUpdateWithWhereUniqueWithoutParentInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutParentInput, PageUncheckedUpdateWithoutParentInput>
  }

  export type PageUpdateManyWithWhereWithoutParentInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutParentInput>
  }

  export type PageTranslationUpsertWithWhereUniqueWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    update: XOR<
      PageTranslationUpdateWithoutPageInput,
      PageTranslationUncheckedUpdateWithoutPageInput
    >
    create: XOR<
      PageTranslationCreateWithoutPageInput,
      PageTranslationUncheckedCreateWithoutPageInput
    >
  }

  export type PageTranslationUpdateWithWhereUniqueWithoutPageInput = {
    where: PageTranslationWhereUniqueInput
    data: XOR<PageTranslationUpdateWithoutPageInput, PageTranslationUncheckedUpdateWithoutPageInput>
  }

  export type PageTranslationUpdateManyWithWhereWithoutPageInput = {
    where: PageTranslationScalarWhereInput
    data: XOR<
      PageTranslationUpdateManyMutationInput,
      PageTranslationUncheckedUpdateManyWithoutPageInput
    >
  }

  export type PageTranslationScalarWhereInput = {
    AND?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
    OR?: PageTranslationScalarWhereInput[]
    NOT?: PageTranslationScalarWhereInput | PageTranslationScalarWhereInput[]
    id?: IntFilter<'PageTranslation'> | number
    pageId?: IntFilter<'PageTranslation'> | number
    lang?: StringFilter<'PageTranslation'> | string
    title?: StringFilter<'PageTranslation'> | string
    content?: StringFilter<'PageTranslation'> | string
    excerpt?: StringNullableFilter<'PageTranslation'> | string | null
  }

  export type PageMetaUpsertWithWhereUniqueWithoutPageInput = {
    where: PageMetaWhereUniqueInput
    update: XOR<PageMetaUpdateWithoutPageInput, PageMetaUncheckedUpdateWithoutPageInput>
    create: XOR<PageMetaCreateWithoutPageInput, PageMetaUncheckedCreateWithoutPageInput>
  }

  export type PageMetaUpdateWithWhereUniqueWithoutPageInput = {
    where: PageMetaWhereUniqueInput
    data: XOR<PageMetaUpdateWithoutPageInput, PageMetaUncheckedUpdateWithoutPageInput>
  }

  export type PageMetaUpdateManyWithWhereWithoutPageInput = {
    where: PageMetaScalarWhereInput
    data: XOR<PageMetaUpdateManyMutationInput, PageMetaUncheckedUpdateManyWithoutPageInput>
  }

  export type PageMetaScalarWhereInput = {
    AND?: PageMetaScalarWhereInput | PageMetaScalarWhereInput[]
    OR?: PageMetaScalarWhereInput[]
    NOT?: PageMetaScalarWhereInput | PageMetaScalarWhereInput[]
    id?: IntFilter<'PageMeta'> | number
    pageId?: IntFilter<'PageMeta'> | number
    key?: StringFilter<'PageMeta'> | string
    value?: JsonFilter<'PageMeta'>
  }

  export type CommentUpsertWithWhereUniqueWithoutPageInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPageInput, CommentUncheckedUpdateWithoutPageInput>
    create: XOR<CommentCreateWithoutPageInput, CommentUncheckedCreateWithoutPageInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPageInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPageInput, CommentUncheckedUpdateWithoutPageInput>
  }

  export type CommentUpdateManyWithWhereWithoutPageInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPageInput>
  }

  export type TermRelationshipUpsertWithWhereUniqueWithoutPageInput = {
    where: TermRelationshipWhereUniqueInput
    update: XOR<
      TermRelationshipUpdateWithoutPageInput,
      TermRelationshipUncheckedUpdateWithoutPageInput
    >
    create: XOR<
      TermRelationshipCreateWithoutPageInput,
      TermRelationshipUncheckedCreateWithoutPageInput
    >
  }

  export type TermRelationshipUpdateWithWhereUniqueWithoutPageInput = {
    where: TermRelationshipWhereUniqueInput
    data: XOR<
      TermRelationshipUpdateWithoutPageInput,
      TermRelationshipUncheckedUpdateWithoutPageInput
    >
  }

  export type TermRelationshipUpdateManyWithWhereWithoutPageInput = {
    where: TermRelationshipScalarWhereInput
    data: XOR<
      TermRelationshipUpdateManyMutationInput,
      TermRelationshipUncheckedUpdateManyWithoutPageInput
    >
  }

  export type TermRelationshipScalarWhereInput = {
    AND?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
    OR?: TermRelationshipScalarWhereInput[]
    NOT?: TermRelationshipScalarWhereInput | TermRelationshipScalarWhereInput[]
    id?: IntFilter<'TermRelationship'> | number
    articleId?: IntNullableFilter<'TermRelationship'> | number | null
    pageId?: IntNullableFilter<'TermRelationship'> | number | null
    portfolioId?: IntNullableFilter<'TermRelationship'> | number | null
    productId?: IntNullableFilter<'TermRelationship'> | number | null
    termTaxonomyId?: IntFilter<'TermRelationship'> | number
  }

  export type PageCreateWithoutTranslationsInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutTranslationsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutTranslationsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
  }

  export type PageUpsertWithoutTranslationsInput = {
    update: XOR<PageUpdateWithoutTranslationsInput, PageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<PageCreateWithoutTranslationsInput, PageUncheckedCreateWithoutTranslationsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutTranslationsInput, PageUncheckedUpdateWithoutTranslationsInput>
  }

  export type PageUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageCreateWithoutMetasInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutMetasInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutMetasInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutMetasInput, PageUncheckedCreateWithoutMetasInput>
  }

  export type PageUpsertWithoutMetasInput = {
    update: XOR<PageUpdateWithoutMetasInput, PageUncheckedUpdateWithoutMetasInput>
    create: XOR<PageCreateWithoutMetasInput, PageUncheckedCreateWithoutMetasInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutMetasInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutMetasInput, PageUncheckedUpdateWithoutMetasInput>
  }

  export type PageUpdateWithoutMetasInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type UserCreateWithoutArticlesInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCreateWithoutChildrenInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutChildrenInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutChildrenInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutChildrenInput, ArticleUncheckedCreateWithoutChildrenInput>
  }

  export type ArticleCreateWithoutParentInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutParentInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutParentInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
  }

  export type ArticleCreateManyParentInputEnvelope = {
    data: ArticleCreateManyParentInput | ArticleCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ArticleTranslationCreateWithoutArticleInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type ArticleTranslationUncheckedCreateWithoutArticleInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type ArticleTranslationCreateOrConnectWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    create: XOR<
      ArticleTranslationCreateWithoutArticleInput,
      ArticleTranslationUncheckedCreateWithoutArticleInput
    >
  }

  export type ArticleTranslationCreateManyArticleInputEnvelope = {
    data: ArticleTranslationCreateManyArticleInput | ArticleTranslationCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type ArticleMetaCreateWithoutArticleInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUncheckedCreateWithoutArticleInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaCreateOrConnectWithoutArticleInput = {
    where: ArticleMetaWhereUniqueInput
    create: XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
  }

  export type ArticleMetaCreateManyArticleInputEnvelope = {
    data: ArticleMetaCreateManyArticleInput | ArticleMetaCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutArticleInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    page?: PageCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutArticleInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutArticleInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentCreateManyArticleInputEnvelope = {
    data: CommentCreateManyArticleInput | CommentCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type TermRelationshipCreateWithoutArticleInput = {
    page?: PageCreateNestedOneWithoutTermsInput
    portfolio?: PortfolioCreateNestedOneWithoutTermsInput
    product?: ProductCreateNestedOneWithoutTermsInput
    termTaxonomy: TermTaxonomyCreateNestedOneWithoutRelationshipsInput
  }

  export type TermRelationshipUncheckedCreateWithoutArticleInput = {
    id?: number
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipCreateOrConnectWithoutArticleInput = {
    where: TermRelationshipWhereUniqueInput
    create: XOR<
      TermRelationshipCreateWithoutArticleInput,
      TermRelationshipUncheckedCreateWithoutArticleInput
    >
  }

  export type TermRelationshipCreateManyArticleInputEnvelope = {
    data: TermRelationshipCreateManyArticleInput | TermRelationshipCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleUpsertWithoutChildrenInput = {
    update: XOR<ArticleUpdateWithoutChildrenInput, ArticleUncheckedUpdateWithoutChildrenInput>
    create: XOR<ArticleCreateWithoutChildrenInput, ArticleUncheckedCreateWithoutChildrenInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutChildrenInput, ArticleUncheckedUpdateWithoutChildrenInput>
  }

  export type ArticleUpdateWithoutChildrenInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUpsertWithWhereUniqueWithoutParentInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutParentInput, ArticleUncheckedUpdateWithoutParentInput>
    create: XOR<ArticleCreateWithoutParentInput, ArticleUncheckedCreateWithoutParentInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutParentInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutParentInput, ArticleUncheckedUpdateWithoutParentInput>
  }

  export type ArticleUpdateManyWithWhereWithoutParentInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutParentInput>
  }

  export type ArticleTranslationUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    update: XOR<
      ArticleTranslationUpdateWithoutArticleInput,
      ArticleTranslationUncheckedUpdateWithoutArticleInput
    >
    create: XOR<
      ArticleTranslationCreateWithoutArticleInput,
      ArticleTranslationUncheckedCreateWithoutArticleInput
    >
  }

  export type ArticleTranslationUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleTranslationWhereUniqueInput
    data: XOR<
      ArticleTranslationUpdateWithoutArticleInput,
      ArticleTranslationUncheckedUpdateWithoutArticleInput
    >
  }

  export type ArticleTranslationUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleTranslationScalarWhereInput
    data: XOR<
      ArticleTranslationUpdateManyMutationInput,
      ArticleTranslationUncheckedUpdateManyWithoutArticleInput
    >
  }

  export type ArticleTranslationScalarWhereInput = {
    AND?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
    OR?: ArticleTranslationScalarWhereInput[]
    NOT?: ArticleTranslationScalarWhereInput | ArticleTranslationScalarWhereInput[]
    id?: IntFilter<'ArticleTranslation'> | number
    articleId?: IntFilter<'ArticleTranslation'> | number
    lang?: StringFilter<'ArticleTranslation'> | string
    title?: StringFilter<'ArticleTranslation'> | string
    content?: StringFilter<'ArticleTranslation'> | string
    excerpt?: StringNullableFilter<'ArticleTranslation'> | string | null
  }

  export type ArticleMetaUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleMetaWhereUniqueInput
    update: XOR<ArticleMetaUpdateWithoutArticleInput, ArticleMetaUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleMetaCreateWithoutArticleInput, ArticleMetaUncheckedCreateWithoutArticleInput>
  }

  export type ArticleMetaUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleMetaWhereUniqueInput
    data: XOR<ArticleMetaUpdateWithoutArticleInput, ArticleMetaUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleMetaUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleMetaScalarWhereInput
    data: XOR<ArticleMetaUpdateManyMutationInput, ArticleMetaUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleMetaScalarWhereInput = {
    AND?: ArticleMetaScalarWhereInput | ArticleMetaScalarWhereInput[]
    OR?: ArticleMetaScalarWhereInput[]
    NOT?: ArticleMetaScalarWhereInput | ArticleMetaScalarWhereInput[]
    id?: IntFilter<'ArticleMeta'> | number
    articleId?: IntFilter<'ArticleMeta'> | number
    key?: StringFilter<'ArticleMeta'> | string
    value?: JsonFilter<'ArticleMeta'>
  }

  export type CommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
  }

  export type CommentUpdateManyWithWhereWithoutArticleInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutArticleInput>
  }

  export type TermRelationshipUpsertWithWhereUniqueWithoutArticleInput = {
    where: TermRelationshipWhereUniqueInput
    update: XOR<
      TermRelationshipUpdateWithoutArticleInput,
      TermRelationshipUncheckedUpdateWithoutArticleInput
    >
    create: XOR<
      TermRelationshipCreateWithoutArticleInput,
      TermRelationshipUncheckedCreateWithoutArticleInput
    >
  }

  export type TermRelationshipUpdateWithWhereUniqueWithoutArticleInput = {
    where: TermRelationshipWhereUniqueInput
    data: XOR<
      TermRelationshipUpdateWithoutArticleInput,
      TermRelationshipUncheckedUpdateWithoutArticleInput
    >
  }

  export type TermRelationshipUpdateManyWithWhereWithoutArticleInput = {
    where: TermRelationshipScalarWhereInput
    data: XOR<
      TermRelationshipUpdateManyMutationInput,
      TermRelationshipUncheckedUpdateManyWithoutArticleInput
    >
  }

  export type ArticleCreateWithoutTranslationsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutTranslationsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutTranslationsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<
      ArticleCreateWithoutTranslationsInput,
      ArticleUncheckedCreateWithoutTranslationsInput
    >
  }

  export type ArticleUpsertWithoutTranslationsInput = {
    update: XOR<
      ArticleUpdateWithoutTranslationsInput,
      ArticleUncheckedUpdateWithoutTranslationsInput
    >
    create: XOR<
      ArticleCreateWithoutTranslationsInput,
      ArticleUncheckedCreateWithoutTranslationsInput
    >
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutTranslationsInput, ArticleUncheckedUpdateWithoutTranslationsInput>
  }

  export type ArticleUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateWithoutMetasInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutMetasInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutMetasInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutMetasInput, ArticleUncheckedCreateWithoutMetasInput>
  }

  export type ArticleUpsertWithoutMetasInput = {
    update: XOR<ArticleUpdateWithoutMetasInput, ArticleUncheckedUpdateWithoutMetasInput>
    create: XOR<ArticleCreateWithoutMetasInput, ArticleUncheckedCreateWithoutMetasInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutMetasInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutMetasInput, ArticleUncheckedUpdateWithoutMetasInput>
  }

  export type ArticleUpdateWithoutMetasInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserCreateWithoutPortfoliosInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPortfoliosInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPortfoliosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
  }

  export type PortfolioTranslationCreateWithoutPortfolioInput = {
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PortfolioTranslationUncheckedCreateWithoutPortfolioInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PortfolioTranslationCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioTranslationWhereUniqueInput
    create: XOR<
      PortfolioTranslationCreateWithoutPortfolioInput,
      PortfolioTranslationUncheckedCreateWithoutPortfolioInput
    >
  }

  export type PortfolioTranslationCreateManyPortfolioInputEnvelope = {
    data:
      | PortfolioTranslationCreateManyPortfolioInput
      | PortfolioTranslationCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioMetaCreateWithoutPortfolioInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUncheckedCreateWithoutPortfolioInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioMetaWhereUniqueInput
    create: XOR<
      PortfolioMetaCreateWithoutPortfolioInput,
      PortfolioMetaUncheckedCreateWithoutPortfolioInput
    >
  }

  export type PortfolioMetaCreateManyPortfolioInputEnvelope = {
    data: PortfolioMetaCreateManyPortfolioInput | PortfolioMetaCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPortfolioInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    page?: PageCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPortfolioInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPortfolioInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
  }

  export type CommentCreateManyPortfolioInputEnvelope = {
    data: CommentCreateManyPortfolioInput | CommentCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type TermRelationshipCreateWithoutPortfolioInput = {
    article?: ArticleCreateNestedOneWithoutTermsInput
    page?: PageCreateNestedOneWithoutTermsInput
    product?: ProductCreateNestedOneWithoutTermsInput
    termTaxonomy: TermTaxonomyCreateNestedOneWithoutRelationshipsInput
  }

  export type TermRelationshipUncheckedCreateWithoutPortfolioInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipCreateOrConnectWithoutPortfolioInput = {
    where: TermRelationshipWhereUniqueInput
    create: XOR<
      TermRelationshipCreateWithoutPortfolioInput,
      TermRelationshipUncheckedCreateWithoutPortfolioInput
    >
  }

  export type TermRelationshipCreateManyPortfolioInputEnvelope = {
    data: TermRelationshipCreateManyPortfolioInput | TermRelationshipCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPortfoliosInput = {
    update: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPortfoliosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
  }

  export type UserUpdateWithoutPortfoliosInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPortfoliosInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortfolioTranslationUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioTranslationWhereUniqueInput
    update: XOR<
      PortfolioTranslationUpdateWithoutPortfolioInput,
      PortfolioTranslationUncheckedUpdateWithoutPortfolioInput
    >
    create: XOR<
      PortfolioTranslationCreateWithoutPortfolioInput,
      PortfolioTranslationUncheckedCreateWithoutPortfolioInput
    >
  }

  export type PortfolioTranslationUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioTranslationWhereUniqueInput
    data: XOR<
      PortfolioTranslationUpdateWithoutPortfolioInput,
      PortfolioTranslationUncheckedUpdateWithoutPortfolioInput
    >
  }

  export type PortfolioTranslationUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioTranslationScalarWhereInput
    data: XOR<
      PortfolioTranslationUpdateManyMutationInput,
      PortfolioTranslationUncheckedUpdateManyWithoutPortfolioInput
    >
  }

  export type PortfolioTranslationScalarWhereInput = {
    AND?: PortfolioTranslationScalarWhereInput | PortfolioTranslationScalarWhereInput[]
    OR?: PortfolioTranslationScalarWhereInput[]
    NOT?: PortfolioTranslationScalarWhereInput | PortfolioTranslationScalarWhereInput[]
    id?: IntFilter<'PortfolioTranslation'> | number
    portfolioId?: IntFilter<'PortfolioTranslation'> | number
    lang?: StringFilter<'PortfolioTranslation'> | string
    title?: StringFilter<'PortfolioTranslation'> | string
    content?: StringFilter<'PortfolioTranslation'> | string
    excerpt?: StringNullableFilter<'PortfolioTranslation'> | string | null
  }

  export type PortfolioMetaUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioMetaWhereUniqueInput
    update: XOR<
      PortfolioMetaUpdateWithoutPortfolioInput,
      PortfolioMetaUncheckedUpdateWithoutPortfolioInput
    >
    create: XOR<
      PortfolioMetaCreateWithoutPortfolioInput,
      PortfolioMetaUncheckedCreateWithoutPortfolioInput
    >
  }

  export type PortfolioMetaUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioMetaWhereUniqueInput
    data: XOR<
      PortfolioMetaUpdateWithoutPortfolioInput,
      PortfolioMetaUncheckedUpdateWithoutPortfolioInput
    >
  }

  export type PortfolioMetaUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioMetaScalarWhereInput
    data: XOR<
      PortfolioMetaUpdateManyMutationInput,
      PortfolioMetaUncheckedUpdateManyWithoutPortfolioInput
    >
  }

  export type PortfolioMetaScalarWhereInput = {
    AND?: PortfolioMetaScalarWhereInput | PortfolioMetaScalarWhereInput[]
    OR?: PortfolioMetaScalarWhereInput[]
    NOT?: PortfolioMetaScalarWhereInput | PortfolioMetaScalarWhereInput[]
    id?: IntFilter<'PortfolioMeta'> | number
    portfolioId?: IntFilter<'PortfolioMeta'> | number
    key?: StringFilter<'PortfolioMeta'> | string
    value?: JsonFilter<'PortfolioMeta'>
  }

  export type CommentUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPortfolioInput, CommentUncheckedUpdateWithoutPortfolioInput>
    create: XOR<CommentCreateWithoutPortfolioInput, CommentUncheckedCreateWithoutPortfolioInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPortfolioInput, CommentUncheckedUpdateWithoutPortfolioInput>
  }

  export type CommentUpdateManyWithWhereWithoutPortfolioInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type TermRelationshipUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: TermRelationshipWhereUniqueInput
    update: XOR<
      TermRelationshipUpdateWithoutPortfolioInput,
      TermRelationshipUncheckedUpdateWithoutPortfolioInput
    >
    create: XOR<
      TermRelationshipCreateWithoutPortfolioInput,
      TermRelationshipUncheckedCreateWithoutPortfolioInput
    >
  }

  export type TermRelationshipUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: TermRelationshipWhereUniqueInput
    data: XOR<
      TermRelationshipUpdateWithoutPortfolioInput,
      TermRelationshipUncheckedUpdateWithoutPortfolioInput
    >
  }

  export type TermRelationshipUpdateManyWithWhereWithoutPortfolioInput = {
    where: TermRelationshipScalarWhereInput
    data: XOR<
      TermRelationshipUpdateManyMutationInput,
      TermRelationshipUncheckedUpdateManyWithoutPortfolioInput
    >
  }

  export type PortfolioCreateWithoutTranslationsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPortfoliosInput
    metas?: PortfolioMetaCreateNestedManyWithoutPortfolioInput
    comments?: CommentCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutTranslationsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: CommentUncheckedCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutTranslationsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<
      PortfolioCreateWithoutTranslationsInput,
      PortfolioUncheckedCreateWithoutTranslationsInput
    >
  }

  export type PortfolioUpsertWithoutTranslationsInput = {
    update: XOR<
      PortfolioUpdateWithoutTranslationsInput,
      PortfolioUncheckedUpdateWithoutTranslationsInput
    >
    create: XOR<
      PortfolioCreateWithoutTranslationsInput,
      PortfolioUncheckedCreateWithoutTranslationsInput
    >
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: PortfolioWhereInput
    data: XOR<
      PortfolioUpdateWithoutTranslationsInput,
      PortfolioUncheckedUpdateWithoutTranslationsInput
    >
  }

  export type PortfolioUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    metas?: PortfolioMetaUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateWithoutMetasInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPortfoliosInput
    translations?: PortfolioTranslationCreateNestedManyWithoutPortfolioInput
    comments?: CommentCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutMetasInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: CommentUncheckedCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutMetasInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutMetasInput, PortfolioUncheckedCreateWithoutMetasInput>
  }

  export type PortfolioUpsertWithoutMetasInput = {
    update: XOR<PortfolioUpdateWithoutMetasInput, PortfolioUncheckedUpdateWithoutMetasInput>
    create: XOR<PortfolioCreateWithoutMetasInput, PortfolioUncheckedCreateWithoutMetasInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutMetasInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutMetasInput, PortfolioUncheckedUpdateWithoutMetasInput>
  }

  export type PortfolioUpdateWithoutMetasInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    translations?: PortfolioTranslationUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type UserCreateWithoutProductsInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type ProductTranslationCreateWithoutProductInput = {
    lang: string
    title: string
    description: string
  }

  export type ProductTranslationUncheckedCreateWithoutProductInput = {
    id?: number
    lang: string
    title: string
    description: string
  }

  export type ProductTranslationCreateOrConnectWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<
      ProductTranslationCreateWithoutProductInput,
      ProductTranslationUncheckedCreateWithoutProductInput
    >
  }

  export type ProductTranslationCreateManyProductInputEnvelope = {
    data: ProductTranslationCreateManyProductInput | ProductTranslationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductMetaCreateWithoutProductInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUncheckedCreateWithoutProductInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaCreateOrConnectWithoutProductInput = {
    where: ProductMetaWhereUniqueInput
    create: XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
  }

  export type ProductMetaCreateManyProductInputEnvelope = {
    data: ProductMetaCreateManyProductInput | ProductMetaCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutProductInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    page?: PageCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    metas?: CommentMetaCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutProductInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: CommentMetaUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutProductInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
  }

  export type CommentCreateManyProductInputEnvelope = {
    data: CommentCreateManyProductInput | CommentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TermRelationshipCreateWithoutProductInput = {
    article?: ArticleCreateNestedOneWithoutTermsInput
    page?: PageCreateNestedOneWithoutTermsInput
    portfolio?: PortfolioCreateNestedOneWithoutTermsInput
    termTaxonomy: TermTaxonomyCreateNestedOneWithoutRelationshipsInput
  }

  export type TermRelationshipUncheckedCreateWithoutProductInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    termTaxonomyId: number
  }

  export type TermRelationshipCreateOrConnectWithoutProductInput = {
    where: TermRelationshipWhereUniqueInput
    create: XOR<
      TermRelationshipCreateWithoutProductInput,
      TermRelationshipUncheckedCreateWithoutProductInput
    >
  }

  export type TermRelationshipCreateManyProductInputEnvelope = {
    data: TermRelationshipCreateManyProductInput | TermRelationshipCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<
      ProductTranslationUpdateWithoutProductInput,
      ProductTranslationUncheckedUpdateWithoutProductInput
    >
    create: XOR<
      ProductTranslationCreateWithoutProductInput,
      ProductTranslationUncheckedCreateWithoutProductInput
    >
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<
      ProductTranslationUpdateWithoutProductInput,
      ProductTranslationUncheckedUpdateWithoutProductInput
    >
  }

  export type ProductTranslationUpdateManyWithWhereWithoutProductInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<
      ProductTranslationUpdateManyMutationInput,
      ProductTranslationUncheckedUpdateManyWithoutProductInput
    >
  }

  export type ProductTranslationScalarWhereInput = {
    AND?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    OR?: ProductTranslationScalarWhereInput[]
    NOT?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    id?: IntFilter<'ProductTranslation'> | number
    productId?: IntFilter<'ProductTranslation'> | number
    lang?: StringFilter<'ProductTranslation'> | string
    title?: StringFilter<'ProductTranslation'> | string
    description?: StringFilter<'ProductTranslation'> | string
  }

  export type ProductMetaUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductMetaWhereUniqueInput
    update: XOR<ProductMetaUpdateWithoutProductInput, ProductMetaUncheckedUpdateWithoutProductInput>
    create: XOR<ProductMetaCreateWithoutProductInput, ProductMetaUncheckedCreateWithoutProductInput>
  }

  export type ProductMetaUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductMetaWhereUniqueInput
    data: XOR<ProductMetaUpdateWithoutProductInput, ProductMetaUncheckedUpdateWithoutProductInput>
  }

  export type ProductMetaUpdateManyWithWhereWithoutProductInput = {
    where: ProductMetaScalarWhereInput
    data: XOR<ProductMetaUpdateManyMutationInput, ProductMetaUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductMetaScalarWhereInput = {
    AND?: ProductMetaScalarWhereInput | ProductMetaScalarWhereInput[]
    OR?: ProductMetaScalarWhereInput[]
    NOT?: ProductMetaScalarWhereInput | ProductMetaScalarWhereInput[]
    id?: IntFilter<'ProductMeta'> | number
    productId?: IntFilter<'ProductMeta'> | number
    key?: StringFilter<'ProductMeta'> | string
    value?: JsonFilter<'ProductMeta'>
  }

  export type CommentUpsertWithWhereUniqueWithoutProductInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProductInput, CommentUncheckedUpdateWithoutProductInput>
    create: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProductInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProductInput, CommentUncheckedUpdateWithoutProductInput>
  }

  export type CommentUpdateManyWithWhereWithoutProductInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProductInput>
  }

  export type TermRelationshipUpsertWithWhereUniqueWithoutProductInput = {
    where: TermRelationshipWhereUniqueInput
    update: XOR<
      TermRelationshipUpdateWithoutProductInput,
      TermRelationshipUncheckedUpdateWithoutProductInput
    >
    create: XOR<
      TermRelationshipCreateWithoutProductInput,
      TermRelationshipUncheckedCreateWithoutProductInput
    >
  }

  export type TermRelationshipUpdateWithWhereUniqueWithoutProductInput = {
    where: TermRelationshipWhereUniqueInput
    data: XOR<
      TermRelationshipUpdateWithoutProductInput,
      TermRelationshipUncheckedUpdateWithoutProductInput
    >
  }

  export type TermRelationshipUpdateManyWithWhereWithoutProductInput = {
    where: TermRelationshipScalarWhereInput
    data: XOR<
      TermRelationshipUpdateManyMutationInput,
      TermRelationshipUncheckedUpdateManyWithoutProductInput
    >
  }

  export type ProductCreateWithoutTranslationsInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutProductsInput
    metas?: ProductMetaCreateNestedManyWithoutProductInput
    comments?: CommentCreateNestedManyWithoutProductInput
    terms?: TermRelationshipCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTranslationsInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: ProductMetaUncheckedCreateNestedManyWithoutProductInput
    comments?: CommentUncheckedCreateNestedManyWithoutProductInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTranslationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<
      ProductCreateWithoutTranslationsInput,
      ProductUncheckedCreateWithoutTranslationsInput
    >
  }

  export type ProductUpsertWithoutTranslationsInput = {
    update: XOR<
      ProductUpdateWithoutTranslationsInput,
      ProductUncheckedUpdateWithoutTranslationsInput
    >
    create: XOR<
      ProductCreateWithoutTranslationsInput,
      ProductUncheckedCreateWithoutTranslationsInput
    >
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTranslationsInput, ProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    metas?: ProductMetaUpdateManyWithoutProductNestedInput
    comments?: CommentUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: ProductMetaUncheckedUpdateManyWithoutProductNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutMetasInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutProductsInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
    comments?: CommentCreateNestedManyWithoutProductInput
    terms?: TermRelationshipCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMetasInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
    comments?: CommentUncheckedCreateNestedManyWithoutProductInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMetasInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMetasInput, ProductUncheckedCreateWithoutMetasInput>
  }

  export type ProductUpsertWithoutMetasInput = {
    update: XOR<ProductUpdateWithoutMetasInput, ProductUncheckedUpdateWithoutMetasInput>
    create: XOR<ProductCreateWithoutMetasInput, ProductUncheckedCreateWithoutMetasInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMetasInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMetasInput, ProductUncheckedUpdateWithoutMetasInput>
  }

  export type ProductUpdateWithoutMetasInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
    comments?: CommentUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioCreateNestedManyWithoutAuthorInput
    products?: ProductCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    login: string
    email: string
    password: string
    displayName: string
    role?: $Enums.Role
    isActive?: boolean
    registeredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    metas?: UserMetaUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutAuthorInput
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PageCreateWithoutCommentsInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    terms?: TermRelationshipCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutCommentsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutCommentsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutCommentsInput, PageUncheckedCreateWithoutCommentsInput>
  }

  export type ArticleCreateWithoutCommentsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCommentsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCommentsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
  }

  export type PortfolioCreateWithoutCommentsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPortfoliosInput
    translations?: PortfolioTranslationCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutCommentsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutCommentsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
  }

  export type ProductCreateWithoutCommentsInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutProductsInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
    metas?: ProductMetaCreateNestedManyWithoutProductInput
    terms?: TermRelationshipCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCommentsInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
    metas?: ProductMetaUncheckedCreateNestedManyWithoutProductInput
    terms?: TermRelationshipUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCommentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
  }

  export type CommentMetaCreateWithoutCommentInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUncheckedCreateWithoutCommentInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaCreateOrConnectWithoutCommentInput = {
    where: CommentMetaWhereUniqueInput
    create: XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
  }

  export type CommentMetaCreateManyCommentInputEnvelope = {
    data: CommentMetaCreateManyCommentInput | CommentMetaCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUpdateManyWithoutAuthorNestedInput
    products?: ProductUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: UserMetaUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutAuthorNestedInput
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PageUpsertWithoutCommentsInput = {
    update: XOR<PageUpdateWithoutCommentsInput, PageUncheckedUpdateWithoutCommentsInput>
    create: XOR<PageCreateWithoutCommentsInput, PageUncheckedCreateWithoutCommentsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutCommentsInput, PageUncheckedUpdateWithoutCommentsInput>
  }

  export type PageUpdateWithoutCommentsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type ArticleUpsertWithoutCommentsInput = {
    update: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type ArticleUpdateWithoutCommentsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type PortfolioUpsertWithoutCommentsInput = {
    update: XOR<PortfolioUpdateWithoutCommentsInput, PortfolioUncheckedUpdateWithoutCommentsInput>
    create: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutCommentsInput, PortfolioUncheckedUpdateWithoutCommentsInput>
  }

  export type PortfolioUpdateWithoutCommentsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    translations?: PortfolioTranslationUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type ProductUpsertWithoutCommentsInput = {
    update: XOR<ProductUpdateWithoutCommentsInput, ProductUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProductCreateWithoutCommentsInput, ProductUncheckedCreateWithoutCommentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCommentsInput, ProductUncheckedUpdateWithoutCommentsInput>
  }

  export type ProductUpdateWithoutCommentsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUncheckedUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CommentMetaUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentMetaWhereUniqueInput
    update: XOR<CommentMetaUpdateWithoutCommentInput, CommentMetaUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentMetaCreateWithoutCommentInput, CommentMetaUncheckedCreateWithoutCommentInput>
  }

  export type CommentMetaUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentMetaWhereUniqueInput
    data: XOR<CommentMetaUpdateWithoutCommentInput, CommentMetaUncheckedUpdateWithoutCommentInput>
  }

  export type CommentMetaUpdateManyWithWhereWithoutCommentInput = {
    where: CommentMetaScalarWhereInput
    data: XOR<CommentMetaUpdateManyMutationInput, CommentMetaUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentMetaScalarWhereInput = {
    AND?: CommentMetaScalarWhereInput | CommentMetaScalarWhereInput[]
    OR?: CommentMetaScalarWhereInput[]
    NOT?: CommentMetaScalarWhereInput | CommentMetaScalarWhereInput[]
    id?: IntFilter<'CommentMeta'> | number
    commentId?: IntFilter<'CommentMeta'> | number
    key?: StringFilter<'CommentMeta'> | string
    value?: JsonFilter<'CommentMeta'>
  }

  export type CommentCreateWithoutMetasInput = {
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCommentsInput
    page?: PageCreateNestedOneWithoutCommentsInput
    article?: ArticleCreateNestedOneWithoutCommentsInput
    portfolio?: PortfolioCreateNestedOneWithoutCommentsInput
    product?: ProductCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutMetasInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutMetasInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutMetasInput, CommentUncheckedCreateWithoutMetasInput>
  }

  export type CommentUpsertWithoutMetasInput = {
    update: XOR<CommentUpdateWithoutMetasInput, CommentUncheckedUpdateWithoutMetasInput>
    create: XOR<CommentCreateWithoutMetasInput, CommentUncheckedCreateWithoutMetasInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutMetasInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutMetasInput, CommentUncheckedUpdateWithoutMetasInput>
  }

  export type CommentUpdateWithoutMetasInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    page?: PageUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutMetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermTaxonomyCreateWithoutTermInput = {
    taxonomy: string
    description?: string | null
    count?: number
    parent?: TermTaxonomyCreateNestedOneWithoutChildrenInput
    children?: TermTaxonomyCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyUncheckedCreateWithoutTermInput = {
    id?: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
    children?: TermTaxonomyUncheckedCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipUncheckedCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyCreateOrConnectWithoutTermInput = {
    where: TermTaxonomyWhereUniqueInput
    create: XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
  }

  export type TermTaxonomyCreateManyTermInputEnvelope = {
    data: TermTaxonomyCreateManyTermInput | TermTaxonomyCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type TermTaxonomyUpsertWithWhereUniqueWithoutTermInput = {
    where: TermTaxonomyWhereUniqueInput
    update: XOR<TermTaxonomyUpdateWithoutTermInput, TermTaxonomyUncheckedUpdateWithoutTermInput>
    create: XOR<TermTaxonomyCreateWithoutTermInput, TermTaxonomyUncheckedCreateWithoutTermInput>
  }

  export type TermTaxonomyUpdateWithWhereUniqueWithoutTermInput = {
    where: TermTaxonomyWhereUniqueInput
    data: XOR<TermTaxonomyUpdateWithoutTermInput, TermTaxonomyUncheckedUpdateWithoutTermInput>
  }

  export type TermTaxonomyUpdateManyWithWhereWithoutTermInput = {
    where: TermTaxonomyScalarWhereInput
    data: XOR<TermTaxonomyUpdateManyMutationInput, TermTaxonomyUncheckedUpdateManyWithoutTermInput>
  }

  export type TermTaxonomyScalarWhereInput = {
    AND?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
    OR?: TermTaxonomyScalarWhereInput[]
    NOT?: TermTaxonomyScalarWhereInput | TermTaxonomyScalarWhereInput[]
    id?: IntFilter<'TermTaxonomy'> | number
    termId?: IntFilter<'TermTaxonomy'> | number
    taxonomy?: StringFilter<'TermTaxonomy'> | string
    description?: StringNullableFilter<'TermTaxonomy'> | string | null
    parentId?: IntNullableFilter<'TermTaxonomy'> | number | null
    count?: IntFilter<'TermTaxonomy'> | number
  }

  export type TermCreateWithoutTaxonomiesInput = {
    slug: string
    name: string
    group?: number
  }

  export type TermUncheckedCreateWithoutTaxonomiesInput = {
    id?: number
    slug: string
    name: string
    group?: number
  }

  export type TermCreateOrConnectWithoutTaxonomiesInput = {
    where: TermWhereUniqueInput
    create: XOR<TermCreateWithoutTaxonomiesInput, TermUncheckedCreateWithoutTaxonomiesInput>
  }

  export type TermTaxonomyCreateWithoutChildrenInput = {
    taxonomy: string
    description?: string | null
    count?: number
    term: TermCreateNestedOneWithoutTaxonomiesInput
    parent?: TermTaxonomyCreateNestedOneWithoutChildrenInput
    relationships?: TermRelationshipCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyUncheckedCreateWithoutChildrenInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
    relationships?: TermRelationshipUncheckedCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyCreateOrConnectWithoutChildrenInput = {
    where: TermTaxonomyWhereUniqueInput
    create: XOR<
      TermTaxonomyCreateWithoutChildrenInput,
      TermTaxonomyUncheckedCreateWithoutChildrenInput
    >
  }

  export type TermTaxonomyCreateWithoutParentInput = {
    taxonomy: string
    description?: string | null
    count?: number
    term: TermCreateNestedOneWithoutTaxonomiesInput
    children?: TermTaxonomyCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyUncheckedCreateWithoutParentInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    count?: number
    children?: TermTaxonomyUncheckedCreateNestedManyWithoutParentInput
    relationships?: TermRelationshipUncheckedCreateNestedManyWithoutTermTaxonomyInput
  }

  export type TermTaxonomyCreateOrConnectWithoutParentInput = {
    where: TermTaxonomyWhereUniqueInput
    create: XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
  }

  export type TermTaxonomyCreateManyParentInputEnvelope = {
    data: TermTaxonomyCreateManyParentInput | TermTaxonomyCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TermRelationshipCreateWithoutTermTaxonomyInput = {
    article?: ArticleCreateNestedOneWithoutTermsInput
    page?: PageCreateNestedOneWithoutTermsInput
    portfolio?: PortfolioCreateNestedOneWithoutTermsInput
    product?: ProductCreateNestedOneWithoutTermsInput
  }

  export type TermRelationshipUncheckedCreateWithoutTermTaxonomyInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
  }

  export type TermRelationshipCreateOrConnectWithoutTermTaxonomyInput = {
    where: TermRelationshipWhereUniqueInput
    create: XOR<
      TermRelationshipCreateWithoutTermTaxonomyInput,
      TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
    >
  }

  export type TermRelationshipCreateManyTermTaxonomyInputEnvelope = {
    data:
      | TermRelationshipCreateManyTermTaxonomyInput
      | TermRelationshipCreateManyTermTaxonomyInput[]
    skipDuplicates?: boolean
  }

  export type TermUpsertWithoutTaxonomiesInput = {
    update: XOR<TermUpdateWithoutTaxonomiesInput, TermUncheckedUpdateWithoutTaxonomiesInput>
    create: XOR<TermCreateWithoutTaxonomiesInput, TermUncheckedCreateWithoutTaxonomiesInput>
    where?: TermWhereInput
  }

  export type TermUpdateToOneWithWhereWithoutTaxonomiesInput = {
    where?: TermWhereInput
    data: XOR<TermUpdateWithoutTaxonomiesInput, TermUncheckedUpdateWithoutTaxonomiesInput>
  }

  export type TermUpdateWithoutTaxonomiesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
  }

  export type TermUncheckedUpdateWithoutTaxonomiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: IntFieldUpdateOperationsInput | number
  }

  export type TermTaxonomyUpsertWithoutChildrenInput = {
    update: XOR<
      TermTaxonomyUpdateWithoutChildrenInput,
      TermTaxonomyUncheckedUpdateWithoutChildrenInput
    >
    create: XOR<
      TermTaxonomyCreateWithoutChildrenInput,
      TermTaxonomyUncheckedCreateWithoutChildrenInput
    >
    where?: TermTaxonomyWhereInput
  }

  export type TermTaxonomyUpdateToOneWithWhereWithoutChildrenInput = {
    where?: TermTaxonomyWhereInput
    data: XOR<
      TermTaxonomyUpdateWithoutChildrenInput,
      TermTaxonomyUncheckedUpdateWithoutChildrenInput
    >
  }

  export type TermTaxonomyUpdateWithoutChildrenInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    term?: TermUpdateOneRequiredWithoutTaxonomiesNestedInput
    parent?: TermTaxonomyUpdateOneWithoutChildrenNestedInput
    relationships?: TermRelationshipUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    relationships?: TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUpsertWithWhereUniqueWithoutParentInput = {
    where: TermTaxonomyWhereUniqueInput
    update: XOR<TermTaxonomyUpdateWithoutParentInput, TermTaxonomyUncheckedUpdateWithoutParentInput>
    create: XOR<TermTaxonomyCreateWithoutParentInput, TermTaxonomyUncheckedCreateWithoutParentInput>
  }

  export type TermTaxonomyUpdateWithWhereUniqueWithoutParentInput = {
    where: TermTaxonomyWhereUniqueInput
    data: XOR<TermTaxonomyUpdateWithoutParentInput, TermTaxonomyUncheckedUpdateWithoutParentInput>
  }

  export type TermTaxonomyUpdateManyWithWhereWithoutParentInput = {
    where: TermTaxonomyScalarWhereInput
    data: XOR<
      TermTaxonomyUpdateManyMutationInput,
      TermTaxonomyUncheckedUpdateManyWithoutParentInput
    >
  }

  export type TermRelationshipUpsertWithWhereUniqueWithoutTermTaxonomyInput = {
    where: TermRelationshipWhereUniqueInput
    update: XOR<
      TermRelationshipUpdateWithoutTermTaxonomyInput,
      TermRelationshipUncheckedUpdateWithoutTermTaxonomyInput
    >
    create: XOR<
      TermRelationshipCreateWithoutTermTaxonomyInput,
      TermRelationshipUncheckedCreateWithoutTermTaxonomyInput
    >
  }

  export type TermRelationshipUpdateWithWhereUniqueWithoutTermTaxonomyInput = {
    where: TermRelationshipWhereUniqueInput
    data: XOR<
      TermRelationshipUpdateWithoutTermTaxonomyInput,
      TermRelationshipUncheckedUpdateWithoutTermTaxonomyInput
    >
  }

  export type TermRelationshipUpdateManyWithWhereWithoutTermTaxonomyInput = {
    where: TermRelationshipScalarWhereInput
    data: XOR<
      TermRelationshipUpdateManyMutationInput,
      TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyInput
    >
  }

  export type ArticleCreateWithoutTermsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
    parent?: ArticleCreateNestedOneWithoutChildrenInput
    children?: ArticleCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutTermsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleUncheckedCreateNestedManyWithoutParentInput
    translations?: ArticleTranslationUncheckedCreateNestedManyWithoutArticleInput
    metas?: ArticleMetaUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutTermsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutTermsInput, ArticleUncheckedCreateWithoutTermsInput>
  }

  export type PageCreateWithoutTermsInput = {
    slug: string
    status?: $Enums.Status
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    translations?: PageTranslationCreateNestedManyWithoutPageInput
    metas?: PageMetaCreateNestedManyWithoutPageInput
    comments?: CommentCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutTermsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    translations?: PageTranslationUncheckedCreateNestedManyWithoutPageInput
    metas?: PageMetaUncheckedCreateNestedManyWithoutPageInput
    comments?: CommentUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutTermsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutTermsInput, PageUncheckedCreateWithoutTermsInput>
  }

  export type PortfolioCreateWithoutTermsInput = {
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPortfoliosInput
    translations?: PortfolioTranslationCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaCreateNestedManyWithoutPortfolioInput
    comments?: CommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutTermsInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PortfolioTranslationUncheckedCreateNestedManyWithoutPortfolioInput
    metas?: PortfolioMetaUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: CommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutTermsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutTermsInput, PortfolioUncheckedCreateWithoutTermsInput>
  }

  export type ProductCreateWithoutTermsInput = {
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutProductsInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
    metas?: ProductMetaCreateNestedManyWithoutProductInput
    comments?: CommentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTermsInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    vendorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
    metas?: ProductMetaUncheckedCreateNestedManyWithoutProductInput
    comments?: CommentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTermsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTermsInput, ProductUncheckedCreateWithoutTermsInput>
  }

  export type TermTaxonomyCreateWithoutRelationshipsInput = {
    taxonomy: string
    description?: string | null
    count?: number
    term: TermCreateNestedOneWithoutTaxonomiesInput
    parent?: TermTaxonomyCreateNestedOneWithoutChildrenInput
    children?: TermTaxonomyCreateNestedManyWithoutParentInput
  }

  export type TermTaxonomyUncheckedCreateWithoutRelationshipsInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
    children?: TermTaxonomyUncheckedCreateNestedManyWithoutParentInput
  }

  export type TermTaxonomyCreateOrConnectWithoutRelationshipsInput = {
    where: TermTaxonomyWhereUniqueInput
    create: XOR<
      TermTaxonomyCreateWithoutRelationshipsInput,
      TermTaxonomyUncheckedCreateWithoutRelationshipsInput
    >
  }

  export type ArticleUpsertWithoutTermsInput = {
    update: XOR<ArticleUpdateWithoutTermsInput, ArticleUncheckedUpdateWithoutTermsInput>
    create: XOR<ArticleCreateWithoutTermsInput, ArticleUncheckedCreateWithoutTermsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutTermsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutTermsInput, ArticleUncheckedUpdateWithoutTermsInput>
  }

  export type ArticleUpdateWithoutTermsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type PageUpsertWithoutTermsInput = {
    update: XOR<PageUpdateWithoutTermsInput, PageUncheckedUpdateWithoutTermsInput>
    create: XOR<PageCreateWithoutTermsInput, PageUncheckedCreateWithoutTermsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutTermsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutTermsInput, PageUncheckedUpdateWithoutTermsInput>
  }

  export type PageUpdateWithoutTermsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PortfolioUpsertWithoutTermsInput = {
    update: XOR<PortfolioUpdateWithoutTermsInput, PortfolioUncheckedUpdateWithoutTermsInput>
    create: XOR<PortfolioCreateWithoutTermsInput, PortfolioUncheckedCreateWithoutTermsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutTermsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutTermsInput, PortfolioUncheckedUpdateWithoutTermsInput>
  }

  export type PortfolioUpdateWithoutTermsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    translations?: PortfolioTranslationUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type ProductUpsertWithoutTermsInput = {
    update: XOR<ProductUpdateWithoutTermsInput, ProductUncheckedUpdateWithoutTermsInput>
    create: XOR<ProductCreateWithoutTermsInput, ProductUncheckedCreateWithoutTermsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTermsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTermsInput, ProductUncheckedUpdateWithoutTermsInput>
  }

  export type ProductUpdateWithoutTermsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUpdateManyWithoutProductNestedInput
    comments?: CommentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUncheckedUpdateManyWithoutProductNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TermTaxonomyUpsertWithoutRelationshipsInput = {
    update: XOR<
      TermTaxonomyUpdateWithoutRelationshipsInput,
      TermTaxonomyUncheckedUpdateWithoutRelationshipsInput
    >
    create: XOR<
      TermTaxonomyCreateWithoutRelationshipsInput,
      TermTaxonomyUncheckedCreateWithoutRelationshipsInput
    >
    where?: TermTaxonomyWhereInput
  }

  export type TermTaxonomyUpdateToOneWithWhereWithoutRelationshipsInput = {
    where?: TermTaxonomyWhereInput
    data: XOR<
      TermTaxonomyUpdateWithoutRelationshipsInput,
      TermTaxonomyUncheckedUpdateWithoutRelationshipsInput
    >
  }

  export type TermTaxonomyUpdateWithoutRelationshipsInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    term?: TermUpdateOneRequiredWithoutTaxonomiesNestedInput
    parent?: TermTaxonomyUpdateOneWithoutChildrenNestedInput
    children?: TermTaxonomyUpdateManyWithoutParentNestedInput
  }

  export type TermTaxonomyUncheckedUpdateWithoutRelationshipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    children?: TermTaxonomyUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserMetaCreateManyUserInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ArticleCreateManyAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateManyAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    parentId?: number | null
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCreateManyAuthorInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyVendorInput = {
    id?: number
    slug: string
    price: number
    currency?: string
    stock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: number
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMetaUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type UserMetaUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleUpdateWithoutAuthorInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ArticleUpdateOneWithoutChildrenNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutAuthorInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutAuthorInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PortfolioTranslationUncheckedUpdateManyWithoutPortfolioNestedInput
    metas?: PortfolioMetaUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPortfolioNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutVendorInput = {
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUpdateManyWithoutProductNestedInput
    comments?: CommentUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
    metas?: ProductMetaUncheckedUpdateManyWithoutProductNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProductNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: PageUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyParentInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    menuOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTranslationCreateManyPageInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PageMetaCreateManyPageInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyPageInput = {
    id?: number
    userId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermRelationshipCreateManyPageInput = {
    id?: number
    articleId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type PageUpdateWithoutParentInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPagesNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUpdateManyWithoutPageNestedInput
    metas?: PageMetaUpdateManyWithoutPageNestedInput
    comments?: CommentUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    translations?: PageTranslationUncheckedUpdateManyWithoutPageNestedInput
    metas?: PageMetaUncheckedUpdateManyWithoutPageNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPageNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    menuOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTranslationUpdateWithoutPageInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTranslationUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTranslationUncheckedUpdateManyWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageMetaUpdateWithoutPageInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PageMetaUncheckedUpdateManyWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutPageInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermRelationshipUpdateWithoutPageInput = {
    article?: ArticleUpdateOneWithoutTermsNestedInput
    portfolio?: PortfolioUpdateOneWithoutTermsNestedInput
    product?: ProductUpdateOneWithoutTermsNestedInput
    termTaxonomy?: TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type TermRelationshipUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipUncheckedUpdateManyWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleCreateManyParentInput = {
    id?: number
    slug: string
    status?: $Enums.Status
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleTranslationCreateManyArticleInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type ArticleMetaCreateManyArticleInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyArticleInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermRelationshipCreateManyArticleInput = {
    id?: number
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type ArticleUpdateWithoutParentInput = {
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
    children?: ArticleUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleUncheckedUpdateManyWithoutParentNestedInput
    translations?: ArticleTranslationUncheckedUpdateManyWithoutArticleNestedInput
    metas?: ArticleMetaUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    terms?: TermRelationshipUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleTranslationUpdateWithoutArticleInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleTranslationUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleMetaUpdateWithoutArticleInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ArticleMetaUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    page?: PageUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermRelationshipUpdateWithoutArticleInput = {
    page?: PageUpdateOneWithoutTermsNestedInput
    portfolio?: PortfolioUpdateOneWithoutTermsNestedInput
    product?: ProductUpdateOneWithoutTermsNestedInput
    termTaxonomy?: TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type TermRelationshipUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type PortfolioTranslationCreateManyPortfolioInput = {
    id?: number
    lang: string
    title: string
    content: string
    excerpt?: string | null
  }

  export type PortfolioMetaCreateManyPortfolioInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyPortfolioInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    productId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermRelationshipCreateManyPortfolioInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    productId?: number | null
    termTaxonomyId: number
  }

  export type PortfolioTranslationUpdateWithoutPortfolioInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioTranslationUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioTranslationUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioMetaUpdateWithoutPortfolioInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type PortfolioMetaUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutPortfolioInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    page?: PageUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    product?: ProductUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermRelationshipUpdateWithoutPortfolioInput = {
    article?: ArticleUpdateOneWithoutTermsNestedInput
    page?: PageUpdateOneWithoutTermsNestedInput
    product?: ProductUpdateOneWithoutTermsNestedInput
    termTaxonomy?: TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type TermRelationshipUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTranslationCreateManyProductInput = {
    id?: number
    lang: string
    title: string
    description: string
  }

  export type ProductMetaCreateManyProductInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyProductInput = {
    id?: number
    userId?: number | null
    pageId?: number | null
    articleId?: number | null
    portfolioId?: number | null
    content: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermRelationshipCreateManyProductInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    termTaxonomyId: number
  }

  export type ProductTranslationUpdateWithoutProductInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductMetaUpdateWithoutProductInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductMetaUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutProductInput = {
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCommentsNestedInput
    page?: PageUpdateOneWithoutCommentsNestedInput
    article?: ArticleUpdateOneWithoutCommentsNestedInput
    portfolio?: PortfolioUpdateOneWithoutCommentsNestedInput
    metas?: CommentMetaUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metas?: CommentMetaUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermRelationshipUpdateWithoutProductInput = {
    article?: ArticleUpdateOneWithoutTermsNestedInput
    page?: PageUpdateOneWithoutTermsNestedInput
    portfolio?: PortfolioUpdateOneWithoutTermsNestedInput
    termTaxonomy?: TermTaxonomyUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type TermRelationshipUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    termTaxonomyId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentMetaCreateManyCommentInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUpdateWithoutCommentInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type CommentMetaUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type TermTaxonomyCreateManyTermInput = {
    id?: number
    taxonomy: string
    description?: string | null
    parentId?: number | null
    count?: number
  }

  export type TermTaxonomyUpdateWithoutTermInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    parent?: TermTaxonomyUpdateOneWithoutChildrenNestedInput
    children?: TermTaxonomyUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateWithoutTermInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    children?: TermTaxonomyUncheckedUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateManyWithoutTermInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
  }

  export type TermTaxonomyCreateManyParentInput = {
    id?: number
    termId: number
    taxonomy: string
    description?: string | null
    count?: number
  }

  export type TermRelationshipCreateManyTermTaxonomyInput = {
    id?: number
    articleId?: number | null
    pageId?: number | null
    portfolioId?: number | null
    productId?: number | null
  }

  export type TermTaxonomyUpdateWithoutParentInput = {
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    term?: TermUpdateOneRequiredWithoutTaxonomiesNestedInput
    children?: TermTaxonomyUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    children?: TermTaxonomyUncheckedUpdateManyWithoutParentNestedInput
    relationships?: TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyNestedInput
  }

  export type TermTaxonomyUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    termId?: IntFieldUpdateOperationsInput | number
    taxonomy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
  }

  export type TermRelationshipUpdateWithoutTermTaxonomyInput = {
    article?: ArticleUpdateOneWithoutTermsNestedInput
    page?: PageUpdateOneWithoutTermsNestedInput
    portfolio?: PortfolioUpdateOneWithoutTermsNestedInput
    product?: ProductUpdateOneWithoutTermsNestedInput
  }

  export type TermRelationshipUncheckedUpdateWithoutTermTaxonomyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TermRelationshipUncheckedUpdateManyWithoutTermTaxonomyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: NullableIntFieldUpdateOperationsInput | number | null
    pageId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolioId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
